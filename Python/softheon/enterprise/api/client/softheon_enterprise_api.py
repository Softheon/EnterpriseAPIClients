# coding=utf-8
# --------------------------------------------------------------------------
# Code generated by Microsoft (R) AutoRest Code Generator.
# Changes may cause incorrect behavior and will be lost if the code is
# regenerated.
# --------------------------------------------------------------------------

from msrest.service_client import ServiceClient
from msrest import Configuration, Serializer, Deserializer
from .version import VERSION
from msrest.pipeline import ClientRawResponse
from msrest.exceptions import HttpOperationError
from . import models


class SoftheonEnterpriseAPIConfiguration(Configuration):
    """Configuration for SoftheonEnterpriseAPI
    Note that all parameters used to create this instance are saved as instance
    attributes.

    :param credentials: Subscription credentials which uniquely identify
     client subscription.
    :type credentials: None
    :param str base_url: Service URL
    """

    def __init__(
            self, credentials, base_url=None):

        if credentials is None:
            raise ValueError("Parameter 'credentials' must not be None.")
        if not base_url:
            base_url = 'http://localhost:54963'

        super(SoftheonEnterpriseAPIConfiguration, self).__init__(base_url)

        self.add_user_agent('Softheon.Enterprise.Api.Client/{}'.format(VERSION))

        self.credentials = credentials


class SoftheonEnterpriseAPI(object):
    """SoftheonEnterpriseAPI

    :ivar config: Configuration for client.
    :vartype config: SoftheonEnterpriseAPIConfiguration

    :param credentials: Subscription credentials which uniquely identify
     client subscription.
    :type credentials: None
    :param str base_url: Service URL
    """

    def __init__(
            self, credentials, base_url=None):

        self.config = SoftheonEnterpriseAPIConfiguration(credentials, base_url)
        self._client = ServiceClient(self.config.credentials, self.config)

        client_models = {k: v for k, v in models.__dict__.items() if isinstance(v, type)}
        self.api_version = 'v1'
        self._serialize = Serializer(client_models)
        self._deserialize = Deserializer(client_models)


    def accept_task(
            self, model, custom_headers=None, raw=False, **operation_config):
        """Accepts the task.

        :param model: The model.
        :type model:
         ~softheon.enterprise.api.client.models.WorkflowActionModel
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: object or ClientRawResponse if raw=true
        :rtype: object or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/v1/workflow/actions/accept'

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        body_content = self._serialize.body(model, 'WorkflowActionModel')

        # Construct and send request
        request = self._client.post(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, stream=False, **operation_config)

        if response.status_code not in [204, 403, 404]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 204:
            deserialized = self._deserialize('object', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def reject_task(
            self, model, custom_headers=None, raw=False, **operation_config):
        """Rejects the task.

        :param model: The model.
        :type model:
         ~softheon.enterprise.api.client.models.WorkflowActionModel
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: object or ClientRawResponse if raw=true
        :rtype: object or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/v1/workflow/actions/reject'

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        body_content = self._serialize.body(model, 'WorkflowActionModel')

        # Construct and send request
        request = self._client.post(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, stream=False, **operation_config)

        if response.status_code not in [204, 403, 404]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 204:
            deserialized = self._deserialize('object', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def suspend_task(
            self, model, custom_headers=None, raw=False, **operation_config):
        """Suspends the task.

        :param model: The model.
        :type model:
         ~softheon.enterprise.api.client.models.WorkflowActionModel
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: object or ClientRawResponse if raw=true
        :rtype: object or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/v1/workflow/actions/suspend'

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        body_content = self._serialize.body(model, 'WorkflowActionModel')

        # Construct and send request
        request = self._client.post(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, stream=False, **operation_config)

        if response.status_code not in [204, 403, 404]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 204:
            deserialized = self._deserialize('object', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def route_task(
            self, model, custom_headers=None, raw=False, **operation_config):
        """Routes the task.

        :param model: The model.
        :type model:
         ~softheon.enterprise.api.client.models.WorkflowActionRouteModel
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: object or ClientRawResponse if raw=true
        :rtype: object or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/v1/workflow/actions/route'

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        body_content = self._serialize.body(model, 'WorkflowActionRouteModel')

        # Construct and send request
        request = self._client.post(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, stream=False, **operation_config)

        if response.status_code not in [204, 403, 404]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 204:
            deserialized = self._deserialize('object', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def override_task(
            self, model, custom_headers=None, raw=False, **operation_config):
        """Overrides the task.

        :param model: The model.
        :type model:
         ~softheon.enterprise.api.client.models.WorkflowActionModel
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: object or ClientRawResponse if raw=true
        :rtype: object or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/v1/workflow/actions/override'

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        body_content = self._serialize.body(model, 'WorkflowActionModel')

        # Construct and send request
        request = self._client.post(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, stream=False, **operation_config)

        if response.status_code not in [204, 403, 404]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 204:
            deserialized = self._deserialize('object', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def reset_task(
            self, model, custom_headers=None, raw=False, **operation_config):
        """Resets the task.

        :param model: The model.
        :type model:
         ~softheon.enterprise.api.client.models.WorkflowActionModel
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: object or ClientRawResponse if raw=true
        :rtype: object or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/v1/workflow/actions/reset'

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        body_content = self._serialize.body(model, 'WorkflowActionModel')

        # Construct and send request
        request = self._client.post(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, stream=False, **operation_config)

        if response.status_code not in [204, 403, 404]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 204:
            deserialized = self._deserialize('object', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def initialize_entity_workflow(
            self, model, custom_headers=None, raw=False, **operation_config):
        """Initializes the Workflow.

        :param model: The model.
        :type model:
         ~softheon.enterprise.api.client.models.WorkflowActionInitializeModel
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: object or ClientRawResponse if raw=true
        :rtype: object or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/v1/workflow/actions/initialize'

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        body_content = self._serialize.body(model, 'WorkflowActionInitializeModel')

        # Construct and send request
        request = self._client.post(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, stream=False, **operation_config)

        if response.status_code not in [204, 403, 404]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 204:
            deserialized = self._deserialize('object', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def get_all_applications(
            self, custom_headers=None, raw=False, **operation_config):
        """Gets a list of all available applications.

        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: list or ClientRawResponse if raw=true
        :rtype: list[~softheon.enterprise.api.client.models.ApplicationModel]
         or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/v1/directory/applications'

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('[ApplicationModel]', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def get_application_by_id(
            self, id, custom_headers=None, raw=False, **operation_config):
        """Gets a single application by its unique identifier.

        :param id: The unique application identifier.
        :type id: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: ApplicationModel or ClientRawResponse if raw=true
        :rtype: ~softheon.enterprise.api.client.models.ApplicationModel or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/v1/directory/applications/{id}'
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200, 404]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('ApplicationModel', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def get_application_by_name(
            self, name, custom_headers=None, raw=False, **operation_config):
        """Gets a single application by its name.

        :param name: The unique application name.
        :type name: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: ApplicationModel or ClientRawResponse if raw=true
        :rtype: ~softheon.enterprise.api.client.models.ApplicationModel or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/v1/directory/applications/{name}'
        path_format_arguments = {
            'name': self._serialize.url("name", name, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200, 404]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('ApplicationModel', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def get_drawer_group_associations(
            self, drawer_id, group_id=None, acl=None, page=None, page_size=None, sort_order=None, sort_by=None, custom_headers=None, raw=False, **operation_config):
        """Gets a list of drawer group associations.

        :param drawer_id: The drawer identifier.
        :type drawer_id: int
        :param group_id: The group identifier.
        :type group_id: int
        :param acl: Gets or sets the access control level permissions.
        :type acl: int
        :param page: Gets or sets the page number.
        :type page: int
        :param page_size: Gets or sets the size of the page.
        :type page_size: int
        :param sort_order: Gets or sets the order. Possible values include:
         'Unspecified', 'Ascending', 'Descending'
        :type sort_order: str
        :param sort_by: Gets or sets the column to order by. Possible values
         include: 'Unspecified', 'DrawerID', 'ApplicationID', 'GroupID',
         'UserID', 'QueueID', 'Acl'
        :type sort_by: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: list or ClientRawResponse if raw=true
        :rtype: list[~softheon.enterprise.api.client.models.GroupDrawerModel]
         or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/v1/directory/drawers/{drawerID}/groups'
        path_format_arguments = {
            'drawerID': self._serialize.url("drawer_id", drawer_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}
        if group_id is not None:
            query_parameters['groupID'] = self._serialize.query("group_id", group_id, 'int')
        if acl is not None:
            query_parameters['acl'] = self._serialize.query("acl", acl, 'int')
        if page is not None:
            query_parameters['page'] = self._serialize.query("page", page, 'int', maximum=2147483647, minimum=1)
        if page_size is not None:
            query_parameters['pageSize'] = self._serialize.query("page_size", page_size, 'int', maximum=1000, minimum=1)
        if sort_order is not None:
            query_parameters['sortOrder'] = self._serialize.query("sort_order", sort_order, 'str')
        if sort_by is not None:
            query_parameters['sortBy'] = self._serialize.query("sort_by", sort_by, 'str')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200, 403]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('[GroupDrawerModel]', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def get_group_drawer_associations(
            self, group_id, drawer_id=None, acl=None, page=None, page_size=None, sort_order=None, sort_by=None, custom_headers=None, raw=False, **operation_config):
        """Gets a list of group drawer associations.

        :param group_id: The group identifier.
        :type group_id: int
        :param drawer_id: The drawer identifier.
        :type drawer_id: int
        :param acl: Gets or sets the access control level permissions.
        :type acl: int
        :param page: Gets or sets the page number.
        :type page: int
        :param page_size: Gets or sets the size of the page.
        :type page_size: int
        :param sort_order: Gets or sets the order. Possible values include:
         'Unspecified', 'Ascending', 'Descending'
        :type sort_order: str
        :param sort_by: Gets or sets the column to order by. Possible values
         include: 'Unspecified', 'DrawerID', 'ApplicationID', 'GroupID',
         'UserID', 'QueueID', 'Acl'
        :type sort_by: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: list or ClientRawResponse if raw=true
        :rtype: list[~softheon.enterprise.api.client.models.GroupDrawerModel]
         or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/v1/directory/groups/{groupID}/drawers'
        path_format_arguments = {
            'groupID': self._serialize.url("group_id", group_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}
        if drawer_id is not None:
            query_parameters['drawerID'] = self._serialize.query("drawer_id", drawer_id, 'int')
        if acl is not None:
            query_parameters['acl'] = self._serialize.query("acl", acl, 'int')
        if page is not None:
            query_parameters['page'] = self._serialize.query("page", page, 'int', maximum=2147483647, minimum=1)
        if page_size is not None:
            query_parameters['pageSize'] = self._serialize.query("page_size", page_size, 'int', maximum=1000, minimum=1)
        if sort_order is not None:
            query_parameters['sortOrder'] = self._serialize.query("sort_order", sort_order, 'str')
        if sort_by is not None:
            query_parameters['sortBy'] = self._serialize.query("sort_by", sort_by, 'str')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200, 403]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('[GroupDrawerModel]', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def create_or_update_drawer_group_association(
            self, group_id, drawer_id, model, custom_headers=None, raw=False, **operation_config):
        """Inserts/Updates the drawer group association.

        :param group_id: The group identifier.
        :type group_id: int
        :param drawer_id: The drawer identifier.
        :type drawer_id: int
        :param model: The model.
        :type model: ~softheon.enterprise.api.client.models.GroupDrawerModel
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: object or ClientRawResponse if raw=true
        :rtype: object or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/v1/directory/drawers/{drawerID}/groups/{groupID}'
        path_format_arguments = {
            'groupID': self._serialize.url("group_id", group_id, 'int'),
            'drawerID': self._serialize.url("drawer_id", drawer_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        body_content = self._serialize.body(model, 'GroupDrawerModel')

        # Construct and send request
        request = self._client.put(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, stream=False, **operation_config)

        if response.status_code not in [204, 403]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 204:
            deserialized = self._deserialize('object', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def delete_drawer_group_association(
            self, group_id, drawer_id, custom_headers=None, raw=False, **operation_config):
        """Deletes a drawer group association;.

        :param group_id: The group identifier.
        :type group_id: int
        :param drawer_id: The drawer identifier.
        :type drawer_id: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: object or ClientRawResponse if raw=true
        :rtype: object or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/v1/directory/drawers/{drawerID}/groups/{groupID}'
        path_format_arguments = {
            'groupID': self._serialize.url("group_id", group_id, 'int'),
            'drawerID': self._serialize.url("drawer_id", drawer_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.delete(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [204, 403, 404]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 204:
            deserialized = self._deserialize('object', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def create_or_update_group_drawer_association(
            self, group_id, drawer_id, model, custom_headers=None, raw=False, **operation_config):
        """Inserts/Updates the group drawer association.

        :param group_id: The group identifier.
        :type group_id: int
        :param drawer_id: The drawer identifier.
        :type drawer_id: int
        :param model: The model.
        :type model: ~softheon.enterprise.api.client.models.GroupDrawerModel
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: object or ClientRawResponse if raw=true
        :rtype: object or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/v1/directory/groups/{groupID}/drawers/{drawerID}'
        path_format_arguments = {
            'groupID': self._serialize.url("group_id", group_id, 'int'),
            'drawerID': self._serialize.url("drawer_id", drawer_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        body_content = self._serialize.body(model, 'GroupDrawerModel')

        # Construct and send request
        request = self._client.put(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, stream=False, **operation_config)

        if response.status_code not in [204, 403]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 204:
            deserialized = self._deserialize('object', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def delete_group_drawer_association(
            self, group_id, drawer_id, custom_headers=None, raw=False, **operation_config):
        """Deletes a group drawer association;.

        :param group_id: The group identifier.
        :type group_id: int
        :param drawer_id: The drawer identifier.
        :type drawer_id: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: object or ClientRawResponse if raw=true
        :rtype: object or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/v1/directory/groups/{groupID}/drawers/{drawerID}'
        path_format_arguments = {
            'groupID': self._serialize.url("group_id", group_id, 'int'),
            'drawerID': self._serialize.url("drawer_id", drawer_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.delete(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [204, 403, 404]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 204:
            deserialized = self._deserialize('object', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def get_user_group_associations(
            self, user_id, group_id=None, acl=None, page=None, page_size=None, sort_order=None, sort_by=None, custom_headers=None, raw=False, **operation_config):
        """Gets a list of user group associations.

        :param user_id: The user identifier.
        :type user_id: int
        :param group_id: The group identifier.
        :type group_id: int
        :param acl: Gets or sets the access control level permissions.
        :type acl: int
        :param page: Gets or sets the page number.
        :type page: int
        :param page_size: Gets or sets the size of the page.
        :type page_size: int
        :param sort_order: Gets or sets the order. Possible values include:
         'Unspecified', 'Ascending', 'Descending'
        :type sort_order: str
        :param sort_by: Gets or sets the column to order by. Possible values
         include: 'Unspecified', 'DrawerID', 'ApplicationID', 'GroupID',
         'UserID', 'QueueID', 'Acl'
        :type sort_by: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: list or ClientRawResponse if raw=true
        :rtype: list[~softheon.enterprise.api.client.models.GroupUserModel] or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/v1/directory/users/{userID}/groups'
        path_format_arguments = {
            'userID': self._serialize.url("user_id", user_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}
        if group_id is not None:
            query_parameters['groupID'] = self._serialize.query("group_id", group_id, 'int')
        if acl is not None:
            query_parameters['acl'] = self._serialize.query("acl", acl, 'int')
        if page is not None:
            query_parameters['page'] = self._serialize.query("page", page, 'int', maximum=2147483647, minimum=1)
        if page_size is not None:
            query_parameters['pageSize'] = self._serialize.query("page_size", page_size, 'int', maximum=1000, minimum=1)
        if sort_order is not None:
            query_parameters['sortOrder'] = self._serialize.query("sort_order", sort_order, 'str')
        if sort_by is not None:
            query_parameters['sortBy'] = self._serialize.query("sort_by", sort_by, 'str')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200, 403]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('[GroupUserModel]', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def get_group_user_associations(
            self, group_id, user_id=None, acl=None, page=None, page_size=None, sort_order=None, sort_by=None, custom_headers=None, raw=False, **operation_config):
        """Gets a list of group user associations.

        :param group_id: The group identifier.
        :type group_id: int
        :param user_id: The user identifier.
        :type user_id: int
        :param acl: Gets or sets the access control level permissions.
        :type acl: int
        :param page: Gets or sets the page number.
        :type page: int
        :param page_size: Gets or sets the size of the page.
        :type page_size: int
        :param sort_order: Gets or sets the order. Possible values include:
         'Unspecified', 'Ascending', 'Descending'
        :type sort_order: str
        :param sort_by: Gets or sets the column to order by. Possible values
         include: 'Unspecified', 'DrawerID', 'ApplicationID', 'GroupID',
         'UserID', 'QueueID', 'Acl'
        :type sort_by: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: list or ClientRawResponse if raw=true
        :rtype: list[~softheon.enterprise.api.client.models.GroupUserModel] or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/v1/directory/groups/{groupID}/users'
        path_format_arguments = {
            'groupID': self._serialize.url("group_id", group_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}
        if user_id is not None:
            query_parameters['userID'] = self._serialize.query("user_id", user_id, 'int')
        if acl is not None:
            query_parameters['acl'] = self._serialize.query("acl", acl, 'int')
        if page is not None:
            query_parameters['page'] = self._serialize.query("page", page, 'int', maximum=2147483647, minimum=1)
        if page_size is not None:
            query_parameters['pageSize'] = self._serialize.query("page_size", page_size, 'int', maximum=1000, minimum=1)
        if sort_order is not None:
            query_parameters['sortOrder'] = self._serialize.query("sort_order", sort_order, 'str')
        if sort_by is not None:
            query_parameters['sortBy'] = self._serialize.query("sort_by", sort_by, 'str')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200, 403]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('[GroupUserModel]', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def create_user_group_association(
            self, group_id, user_id, model, custom_headers=None, raw=False, **operation_config):
        """Inserts the user group association.

        :param group_id: The group identifier.
        :type group_id: int
        :param user_id: The user identifier.
        :type user_id: int
        :param model: The model.
        :type model: ~softheon.enterprise.api.client.models.GroupUserModel
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: object or ClientRawResponse if raw=true
        :rtype: object or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/v1/directory/users/{userID}/groups/{groupID}'
        path_format_arguments = {
            'groupID': self._serialize.url("group_id", group_id, 'int'),
            'userID': self._serialize.url("user_id", user_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        body_content = self._serialize.body(model, 'GroupUserModel')

        # Construct and send request
        request = self._client.post(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, stream=False, **operation_config)

        if response.status_code not in [200, 403, 409]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('object', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def delete_user_group_association(
            self, group_id, user_id, custom_headers=None, raw=False, **operation_config):
        """Deletes a user group association;.

        :param group_id: The group identifier.
        :type group_id: int
        :param user_id: The user identifier.
        :type user_id: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: object or ClientRawResponse if raw=true
        :rtype: object or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/v1/directory/users/{userID}/groups/{groupID}'
        path_format_arguments = {
            'groupID': self._serialize.url("group_id", group_id, 'int'),
            'userID': self._serialize.url("user_id", user_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.delete(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [204, 403, 404]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 204:
            deserialized = self._deserialize('object', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def create_group_user_association(
            self, group_id, user_id, model, custom_headers=None, raw=False, **operation_config):
        """Inserts the group user association.

        :param group_id: The group identifier.
        :type group_id: int
        :param user_id: The user identifier.
        :type user_id: int
        :param model: The model.
        :type model: ~softheon.enterprise.api.client.models.GroupUserModel
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: object or ClientRawResponse if raw=true
        :rtype: object or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/v1/directory/groups/{groupID}/users/{userID}'
        path_format_arguments = {
            'groupID': self._serialize.url("group_id", group_id, 'int'),
            'userID': self._serialize.url("user_id", user_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        body_content = self._serialize.body(model, 'GroupUserModel')

        # Construct and send request
        request = self._client.post(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, stream=False, **operation_config)

        if response.status_code not in [200, 403, 409]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('object', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def delete_group_user_association(
            self, group_id, user_id, custom_headers=None, raw=False, **operation_config):
        """Deletes a group user association;.

        :param group_id: The group identifier.
        :type group_id: int
        :param user_id: The user identifier.
        :type user_id: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: object or ClientRawResponse if raw=true
        :rtype: object or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/v1/directory/groups/{groupID}/users/{userID}'
        path_format_arguments = {
            'groupID': self._serialize.url("group_id", group_id, 'int'),
            'userID': self._serialize.url("user_id", user_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.delete(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [204, 403, 404]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 204:
            deserialized = self._deserialize('object', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def get_queue_group_associations(
            self, queue_id, group_id=None, acl=None, page=None, page_size=None, sort_order=None, sort_by=None, custom_headers=None, raw=False, **operation_config):
        """Gets a list of queue group associations.

        :param queue_id: The queue identifier.
        :type queue_id: int
        :param group_id: The group identifier.
        :type group_id: int
        :param acl: Gets or sets the access control level permissions.
        :type acl: int
        :param page: Gets or sets the page number.
        :type page: int
        :param page_size: Gets or sets the size of the page.
        :type page_size: int
        :param sort_order: Gets or sets the order. Possible values include:
         'Unspecified', 'Ascending', 'Descending'
        :type sort_order: str
        :param sort_by: Gets or sets the column to order by. Possible values
         include: 'Unspecified', 'DrawerID', 'ApplicationID', 'GroupID',
         'UserID', 'QueueID', 'Acl'
        :type sort_by: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: list or ClientRawResponse if raw=true
        :rtype: list[~softheon.enterprise.api.client.models.GroupQueueModel]
         or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/v1/workflow/queues/{queueID}/groups'
        path_format_arguments = {
            'queueID': self._serialize.url("queue_id", queue_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}
        if group_id is not None:
            query_parameters['groupID'] = self._serialize.query("group_id", group_id, 'int')
        if acl is not None:
            query_parameters['acl'] = self._serialize.query("acl", acl, 'int')
        if page is not None:
            query_parameters['page'] = self._serialize.query("page", page, 'int', maximum=2147483647, minimum=1)
        if page_size is not None:
            query_parameters['pageSize'] = self._serialize.query("page_size", page_size, 'int', maximum=1000, minimum=1)
        if sort_order is not None:
            query_parameters['sortOrder'] = self._serialize.query("sort_order", sort_order, 'str')
        if sort_by is not None:
            query_parameters['sortBy'] = self._serialize.query("sort_by", sort_by, 'str')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200, 403]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('[GroupQueueModel]', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def get_group_queue_associations(
            self, group_id, queue_id=None, acl=None, page=None, page_size=None, sort_order=None, sort_by=None, custom_headers=None, raw=False, **operation_config):
        """Gets a list of group queue associations.

        :param group_id: The group identifier.
        :type group_id: int
        :param queue_id: The queue identifier.
        :type queue_id: int
        :param acl: Gets or sets the access control level permissions.
        :type acl: int
        :param page: Gets or sets the page number.
        :type page: int
        :param page_size: Gets or sets the size of the page.
        :type page_size: int
        :param sort_order: Gets or sets the order. Possible values include:
         'Unspecified', 'Ascending', 'Descending'
        :type sort_order: str
        :param sort_by: Gets or sets the column to order by. Possible values
         include: 'Unspecified', 'DrawerID', 'ApplicationID', 'GroupID',
         'UserID', 'QueueID', 'Acl'
        :type sort_by: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: list or ClientRawResponse if raw=true
        :rtype: list[~softheon.enterprise.api.client.models.GroupQueueModel]
         or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/v1/directory/groups/{groupID}/queues'
        path_format_arguments = {
            'groupID': self._serialize.url("group_id", group_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}
        if queue_id is not None:
            query_parameters['queueID'] = self._serialize.query("queue_id", queue_id, 'int')
        if acl is not None:
            query_parameters['acl'] = self._serialize.query("acl", acl, 'int')
        if page is not None:
            query_parameters['page'] = self._serialize.query("page", page, 'int', maximum=2147483647, minimum=1)
        if page_size is not None:
            query_parameters['pageSize'] = self._serialize.query("page_size", page_size, 'int', maximum=1000, minimum=1)
        if sort_order is not None:
            query_parameters['sortOrder'] = self._serialize.query("sort_order", sort_order, 'str')
        if sort_by is not None:
            query_parameters['sortBy'] = self._serialize.query("sort_by", sort_by, 'str')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200, 403]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('[GroupQueueModel]', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def create_or_update_queue_group_association(
            self, group_id, queue_id, model, custom_headers=None, raw=False, **operation_config):
        """Inserts/Updates the queue group association.

        :param group_id: The group identifier.
        :type group_id: int
        :param queue_id: The queue identifier.
        :type queue_id: int
        :param model: The model.
        :type model: ~softheon.enterprise.api.client.models.GroupQueueModel
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: object or ClientRawResponse if raw=true
        :rtype: object or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/v1/workflow/queues/{queueID}/groups/{groupID}'
        path_format_arguments = {
            'groupID': self._serialize.url("group_id", group_id, 'int'),
            'queueID': self._serialize.url("queue_id", queue_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        body_content = self._serialize.body(model, 'GroupQueueModel')

        # Construct and send request
        request = self._client.put(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, stream=False, **operation_config)

        if response.status_code not in [204, 403]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 204:
            deserialized = self._deserialize('object', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def delete_queue_group_association(
            self, group_id, queue_id, custom_headers=None, raw=False, **operation_config):
        """Deletes a queue group association;.

        :param group_id: The group identifier.
        :type group_id: int
        :param queue_id: The queue identifier.
        :type queue_id: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: object or ClientRawResponse if raw=true
        :rtype: object or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/v1/workflow/queues/{queueID}/groups/{groupID}'
        path_format_arguments = {
            'groupID': self._serialize.url("group_id", group_id, 'int'),
            'queueID': self._serialize.url("queue_id", queue_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.delete(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [204, 403, 404]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 204:
            deserialized = self._deserialize('object', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def create_or_update_group_queue_association(
            self, group_id, queue_id, model, custom_headers=None, raw=False, **operation_config):
        """Inserts/Updates the group queue association.

        :param group_id: The group identifier.
        :type group_id: int
        :param queue_id: The queue identifier.
        :type queue_id: int
        :param model: The model.
        :type model: ~softheon.enterprise.api.client.models.GroupQueueModel
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: object or ClientRawResponse if raw=true
        :rtype: object or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/v1/directory/groups/{groupID}/queues/{queueID}'
        path_format_arguments = {
            'groupID': self._serialize.url("group_id", group_id, 'int'),
            'queueID': self._serialize.url("queue_id", queue_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        body_content = self._serialize.body(model, 'GroupQueueModel')

        # Construct and send request
        request = self._client.put(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, stream=False, **operation_config)

        if response.status_code not in [204, 403]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 204:
            deserialized = self._deserialize('object', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def delete_group_queue_association(
            self, group_id, queue_id, custom_headers=None, raw=False, **operation_config):
        """Deletes a group queue association;.

        :param group_id: The group identifier.
        :type group_id: int
        :param queue_id: The queue identifier.
        :type queue_id: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: object or ClientRawResponse if raw=true
        :rtype: object or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/v1/directory/groups/{groupID}/queues/{queueID}'
        path_format_arguments = {
            'groupID': self._serialize.url("group_id", group_id, 'int'),
            'queueID': self._serialize.url("queue_id", queue_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.delete(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [204, 403, 404]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 204:
            deserialized = self._deserialize('object', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def get_application_group_associations(
            self, application_id, group_id=None, acl=None, page=None, page_size=None, sort_order=None, sort_by=None, custom_headers=None, raw=False, **operation_config):
        """Gets a list of application group associations.

        :param application_id: The application identifier.
        :type application_id: int
        :param group_id: The group identifier.
        :type group_id: int
        :param acl: Gets or sets the access control level permissions.
        :type acl: int
        :param page: Gets or sets the page number.
        :type page: int
        :param page_size: Gets or sets the size of the page.
        :type page_size: int
        :param sort_order: Gets or sets the order. Possible values include:
         'Unspecified', 'Ascending', 'Descending'
        :type sort_order: str
        :param sort_by: Gets or sets the column to order by. Possible values
         include: 'Unspecified', 'DrawerID', 'ApplicationID', 'GroupID',
         'UserID', 'QueueID', 'Acl'
        :type sort_by: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: list or ClientRawResponse if raw=true
        :rtype:
         list[~softheon.enterprise.api.client.models.GroupApplicationModel] or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/v1/directory/applications/{applicationID}/groups'
        path_format_arguments = {
            'applicationID': self._serialize.url("application_id", application_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}
        if group_id is not None:
            query_parameters['groupID'] = self._serialize.query("group_id", group_id, 'int')
        if acl is not None:
            query_parameters['acl'] = self._serialize.query("acl", acl, 'int')
        if page is not None:
            query_parameters['page'] = self._serialize.query("page", page, 'int', maximum=2147483647, minimum=1)
        if page_size is not None:
            query_parameters['pageSize'] = self._serialize.query("page_size", page_size, 'int', maximum=1000, minimum=1)
        if sort_order is not None:
            query_parameters['sortOrder'] = self._serialize.query("sort_order", sort_order, 'str')
        if sort_by is not None:
            query_parameters['sortBy'] = self._serialize.query("sort_by", sort_by, 'str')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200, 403]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('[GroupApplicationModel]', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def get_group_application_associations(
            self, group_id, application_id=None, acl=None, page=None, page_size=None, sort_order=None, sort_by=None, custom_headers=None, raw=False, **operation_config):
        """Gets a list of group application associations.

        :param group_id: The group identifier.
        :type group_id: int
        :param application_id: The application identifier.
        :type application_id: int
        :param acl: Gets or sets the access control level permissions.
        :type acl: int
        :param page: Gets or sets the page number.
        :type page: int
        :param page_size: Gets or sets the size of the page.
        :type page_size: int
        :param sort_order: Gets or sets the order. Possible values include:
         'Unspecified', 'Ascending', 'Descending'
        :type sort_order: str
        :param sort_by: Gets or sets the column to order by. Possible values
         include: 'Unspecified', 'DrawerID', 'ApplicationID', 'GroupID',
         'UserID', 'QueueID', 'Acl'
        :type sort_by: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: list or ClientRawResponse if raw=true
        :rtype:
         list[~softheon.enterprise.api.client.models.GroupApplicationModel] or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/v1/directory/groups/{groupID}/applications'
        path_format_arguments = {
            'groupID': self._serialize.url("group_id", group_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}
        if application_id is not None:
            query_parameters['applicationID'] = self._serialize.query("application_id", application_id, 'int')
        if acl is not None:
            query_parameters['acl'] = self._serialize.query("acl", acl, 'int')
        if page is not None:
            query_parameters['page'] = self._serialize.query("page", page, 'int', maximum=2147483647, minimum=1)
        if page_size is not None:
            query_parameters['pageSize'] = self._serialize.query("page_size", page_size, 'int', maximum=1000, minimum=1)
        if sort_order is not None:
            query_parameters['sortOrder'] = self._serialize.query("sort_order", sort_order, 'str')
        if sort_by is not None:
            query_parameters['sortBy'] = self._serialize.query("sort_by", sort_by, 'str')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200, 403]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('[GroupApplicationModel]', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def create_or_update_application_group_association(
            self, group_id, application_id, model, custom_headers=None, raw=False, **operation_config):
        """Inserts/Updates the application group association.

        :param group_id: The group identifier.
        :type group_id: int
        :param application_id: The application identifier.
        :type application_id: int
        :param model: The model.
        :type model:
         ~softheon.enterprise.api.client.models.GroupApplicationModel
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: object or ClientRawResponse if raw=true
        :rtype: object or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/v1/directory/applications/{applicationID}/groups/{groupID}'
        path_format_arguments = {
            'groupID': self._serialize.url("group_id", group_id, 'int'),
            'applicationID': self._serialize.url("application_id", application_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        body_content = self._serialize.body(model, 'GroupApplicationModel')

        # Construct and send request
        request = self._client.put(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, stream=False, **operation_config)

        if response.status_code not in [204, 403]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 204:
            deserialized = self._deserialize('object', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def delete_application_group_association(
            self, group_id, application_id, custom_headers=None, raw=False, **operation_config):
        """Deletes a application group association;.

        :param group_id: The group identifier.
        :type group_id: int
        :param application_id: The application identifier.
        :type application_id: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: object or ClientRawResponse if raw=true
        :rtype: object or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/v1/directory/applications/{applicationID}/groups/{groupID}'
        path_format_arguments = {
            'groupID': self._serialize.url("group_id", group_id, 'int'),
            'applicationID': self._serialize.url("application_id", application_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.delete(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [204, 403, 404, 500]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 204:
            deserialized = self._deserialize('object', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def create_or_update_group_application_association(
            self, group_id, application_id, model, custom_headers=None, raw=False, **operation_config):
        """Inserts/Updates the group application association.

        :param group_id: The group identifier.
        :type group_id: int
        :param application_id: The application identifier.
        :type application_id: int
        :param model: The model.
        :type model:
         ~softheon.enterprise.api.client.models.GroupApplicationModel
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: object or ClientRawResponse if raw=true
        :rtype: object or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/v1/directory/groups/{groupID}/applications/{applicationID}'
        path_format_arguments = {
            'groupID': self._serialize.url("group_id", group_id, 'int'),
            'applicationID': self._serialize.url("application_id", application_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        body_content = self._serialize.body(model, 'GroupApplicationModel')

        # Construct and send request
        request = self._client.put(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, stream=False, **operation_config)

        if response.status_code not in [204, 403]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 204:
            deserialized = self._deserialize('object', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def delete_group_application_association(
            self, group_id, application_id, custom_headers=None, raw=False, **operation_config):
        """Deletes a group application association;.

        :param group_id: The group identifier.
        :type group_id: int
        :param application_id: The application identifier.
        :type application_id: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: object or ClientRawResponse if raw=true
        :rtype: object or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/v1/directory/groups/{groupID}/applications/{applicationID}'
        path_format_arguments = {
            'groupID': self._serialize.url("group_id", group_id, 'int'),
            'applicationID': self._serialize.url("application_id", application_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.delete(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [204, 403, 404, 500]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 204:
            deserialized = self._deserialize('object', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def get_drawer_user_associations(
            self, drawer_id, user_id=None, acl=None, page=None, page_size=None, sort_order=None, sort_by=None, custom_headers=None, raw=False, **operation_config):
        """Gets a list of drawer user associations.

        :param drawer_id: The drawer identifier.
        :type drawer_id: int
        :param user_id: The user identifier.
        :type user_id: int
        :param acl: Gets or sets the access control level permissions.
        :type acl: int
        :param page: Gets or sets the page number.
        :type page: int
        :param page_size: Gets or sets the size of the page.
        :type page_size: int
        :param sort_order: Gets or sets the order. Possible values include:
         'Unspecified', 'Ascending', 'Descending'
        :type sort_order: str
        :param sort_by: Gets or sets the column to order by. Possible values
         include: 'Unspecified', 'DrawerID', 'ApplicationID', 'GroupID',
         'UserID', 'QueueID', 'Acl'
        :type sort_by: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: list or ClientRawResponse if raw=true
        :rtype: list[~softheon.enterprise.api.client.models.UserDrawerModel]
         or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/v1/directory/drawers/{drawerID}/users'
        path_format_arguments = {
            'drawerID': self._serialize.url("drawer_id", drawer_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}
        if user_id is not None:
            query_parameters['userID'] = self._serialize.query("user_id", user_id, 'int')
        if acl is not None:
            query_parameters['acl'] = self._serialize.query("acl", acl, 'int')
        if page is not None:
            query_parameters['page'] = self._serialize.query("page", page, 'int', maximum=2147483647, minimum=1)
        if page_size is not None:
            query_parameters['pageSize'] = self._serialize.query("page_size", page_size, 'int', maximum=1000, minimum=1)
        if sort_order is not None:
            query_parameters['sortOrder'] = self._serialize.query("sort_order", sort_order, 'str')
        if sort_by is not None:
            query_parameters['sortBy'] = self._serialize.query("sort_by", sort_by, 'str')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200, 403]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('[UserDrawerModel]', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def get_user_drawer_associations(
            self, user_id, drawer_id=None, acl=None, page=None, page_size=None, sort_order=None, sort_by=None, custom_headers=None, raw=False, **operation_config):
        """Gets a list of user drawer associations.

        :param user_id: The user identifier.
        :type user_id: int
        :param drawer_id: The drawer identifier.
        :type drawer_id: int
        :param acl: Gets or sets the access control level permissions.
        :type acl: int
        :param page: Gets or sets the page number.
        :type page: int
        :param page_size: Gets or sets the size of the page.
        :type page_size: int
        :param sort_order: Gets or sets the order. Possible values include:
         'Unspecified', 'Ascending', 'Descending'
        :type sort_order: str
        :param sort_by: Gets or sets the column to order by. Possible values
         include: 'Unspecified', 'DrawerID', 'ApplicationID', 'GroupID',
         'UserID', 'QueueID', 'Acl'
        :type sort_by: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: list or ClientRawResponse if raw=true
        :rtype: list[~softheon.enterprise.api.client.models.UserDrawerModel]
         or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/v1/directory/users/{userID}/drawers'
        path_format_arguments = {
            'userID': self._serialize.url("user_id", user_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}
        if drawer_id is not None:
            query_parameters['drawerID'] = self._serialize.query("drawer_id", drawer_id, 'int')
        if acl is not None:
            query_parameters['acl'] = self._serialize.query("acl", acl, 'int')
        if page is not None:
            query_parameters['page'] = self._serialize.query("page", page, 'int', maximum=2147483647, minimum=1)
        if page_size is not None:
            query_parameters['pageSize'] = self._serialize.query("page_size", page_size, 'int', maximum=1000, minimum=1)
        if sort_order is not None:
            query_parameters['sortOrder'] = self._serialize.query("sort_order", sort_order, 'str')
        if sort_by is not None:
            query_parameters['sortBy'] = self._serialize.query("sort_by", sort_by, 'str')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200, 403]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('[UserDrawerModel]', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def create_or_update_drawer_user_association(
            self, user_id, drawer_id, model, custom_headers=None, raw=False, **operation_config):
        """Inserts/Updates the drawer user association.

        :param user_id: The user identifier.
        :type user_id: int
        :param drawer_id: The drawer identifier.
        :type drawer_id: int
        :param model: The model.
        :type model: ~softheon.enterprise.api.client.models.UserDrawerModel
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: object or ClientRawResponse if raw=true
        :rtype: object or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/v1/directory/drawers/{drawerID}/users/{userID}'
        path_format_arguments = {
            'userID': self._serialize.url("user_id", user_id, 'int'),
            'drawerID': self._serialize.url("drawer_id", drawer_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        body_content = self._serialize.body(model, 'UserDrawerModel')

        # Construct and send request
        request = self._client.put(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, stream=False, **operation_config)

        if response.status_code not in [204, 403]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 204:
            deserialized = self._deserialize('object', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def delete_drawer_user_association(
            self, user_id, drawer_id, custom_headers=None, raw=False, **operation_config):
        """Deletes a drawer user association;.

        :param user_id: The user identifier.
        :type user_id: int
        :param drawer_id: The drawer identifier.
        :type drawer_id: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: object or ClientRawResponse if raw=true
        :rtype: object or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/v1/directory/drawers/{drawerID}/users/{userID}'
        path_format_arguments = {
            'userID': self._serialize.url("user_id", user_id, 'int'),
            'drawerID': self._serialize.url("drawer_id", drawer_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.delete(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [204, 403, 404]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 204:
            deserialized = self._deserialize('object', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def create_or_update_user_drawer_association(
            self, user_id, drawer_id, model, custom_headers=None, raw=False, **operation_config):
        """Inserts/Updates the user drawer association.

        :param user_id: The user identifier.
        :type user_id: int
        :param drawer_id: The drawer identifier.
        :type drawer_id: int
        :param model: The model.
        :type model: ~softheon.enterprise.api.client.models.UserDrawerModel
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: object or ClientRawResponse if raw=true
        :rtype: object or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/v1/directory/users/{userID}/drawers/{drawerID}'
        path_format_arguments = {
            'userID': self._serialize.url("user_id", user_id, 'int'),
            'drawerID': self._serialize.url("drawer_id", drawer_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        body_content = self._serialize.body(model, 'UserDrawerModel')

        # Construct and send request
        request = self._client.put(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, stream=False, **operation_config)

        if response.status_code not in [204, 403]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 204:
            deserialized = self._deserialize('object', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def delete_user_drawer_association(
            self, user_id, drawer_id, custom_headers=None, raw=False, **operation_config):
        """Deletes a user drawer association;.

        :param user_id: The user identifier.
        :type user_id: int
        :param drawer_id: The drawer identifier.
        :type drawer_id: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: object or ClientRawResponse if raw=true
        :rtype: object or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/v1/directory/users/{userID}/drawers/{drawerID}'
        path_format_arguments = {
            'userID': self._serialize.url("user_id", user_id, 'int'),
            'drawerID': self._serialize.url("drawer_id", drawer_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.delete(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [204, 403, 404]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 204:
            deserialized = self._deserialize('object', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def get_queue_user_associations(
            self, queue_id, user_id=None, acl=None, page=None, page_size=None, sort_order=None, sort_by=None, custom_headers=None, raw=False, **operation_config):
        """Gets a list of queue user associations.

        :param queue_id: The queue identifier.
        :type queue_id: int
        :param user_id: The user identifier.
        :type user_id: int
        :param acl: Gets or sets the access control level permissions.
        :type acl: int
        :param page: Gets or sets the page number.
        :type page: int
        :param page_size: Gets or sets the size of the page.
        :type page_size: int
        :param sort_order: Gets or sets the order. Possible values include:
         'Unspecified', 'Ascending', 'Descending'
        :type sort_order: str
        :param sort_by: Gets or sets the column to order by. Possible values
         include: 'Unspecified', 'DrawerID', 'ApplicationID', 'GroupID',
         'UserID', 'QueueID', 'Acl'
        :type sort_by: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: list or ClientRawResponse if raw=true
        :rtype: list[~softheon.enterprise.api.client.models.UserQueueModel] or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/v1/workflow/queues/{queueID}/users'
        path_format_arguments = {
            'queueID': self._serialize.url("queue_id", queue_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}
        if user_id is not None:
            query_parameters['userID'] = self._serialize.query("user_id", user_id, 'int')
        if acl is not None:
            query_parameters['acl'] = self._serialize.query("acl", acl, 'int')
        if page is not None:
            query_parameters['page'] = self._serialize.query("page", page, 'int', maximum=2147483647, minimum=1)
        if page_size is not None:
            query_parameters['pageSize'] = self._serialize.query("page_size", page_size, 'int', maximum=1000, minimum=1)
        if sort_order is not None:
            query_parameters['sortOrder'] = self._serialize.query("sort_order", sort_order, 'str')
        if sort_by is not None:
            query_parameters['sortBy'] = self._serialize.query("sort_by", sort_by, 'str')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200, 403]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('[UserQueueModel]', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def get_user_queue_associations(
            self, user_id, queue_id=None, acl=None, page=None, page_size=None, sort_order=None, sort_by=None, custom_headers=None, raw=False, **operation_config):
        """Gets a list of user queue associations.

        :param user_id: The user identifier.
        :type user_id: int
        :param queue_id: The queue identifier.
        :type queue_id: int
        :param acl: Gets or sets the access control level permissions.
        :type acl: int
        :param page: Gets or sets the page number.
        :type page: int
        :param page_size: Gets or sets the size of the page.
        :type page_size: int
        :param sort_order: Gets or sets the order. Possible values include:
         'Unspecified', 'Ascending', 'Descending'
        :type sort_order: str
        :param sort_by: Gets or sets the column to order by. Possible values
         include: 'Unspecified', 'DrawerID', 'ApplicationID', 'GroupID',
         'UserID', 'QueueID', 'Acl'
        :type sort_by: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: list or ClientRawResponse if raw=true
        :rtype: list[~softheon.enterprise.api.client.models.UserQueueModel] or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/v1/directory/users/{userID}/queues'
        path_format_arguments = {
            'userID': self._serialize.url("user_id", user_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}
        if queue_id is not None:
            query_parameters['queueID'] = self._serialize.query("queue_id", queue_id, 'int')
        if acl is not None:
            query_parameters['acl'] = self._serialize.query("acl", acl, 'int')
        if page is not None:
            query_parameters['page'] = self._serialize.query("page", page, 'int', maximum=2147483647, minimum=1)
        if page_size is not None:
            query_parameters['pageSize'] = self._serialize.query("page_size", page_size, 'int', maximum=1000, minimum=1)
        if sort_order is not None:
            query_parameters['sortOrder'] = self._serialize.query("sort_order", sort_order, 'str')
        if sort_by is not None:
            query_parameters['sortBy'] = self._serialize.query("sort_by", sort_by, 'str')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200, 403]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('[UserQueueModel]', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def create_or_update_queue_user_association(
            self, user_id, queue_id, model, custom_headers=None, raw=False, **operation_config):
        """Inserts/Updates the queue user association.

        :param user_id: The user identifier.
        :type user_id: int
        :param queue_id: The queue identifier.
        :type queue_id: int
        :param model: The model.
        :type model: ~softheon.enterprise.api.client.models.UserQueueModel
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: object or ClientRawResponse if raw=true
        :rtype: object or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/v1/workflow/queues/{queueID}/users/{userID}'
        path_format_arguments = {
            'userID': self._serialize.url("user_id", user_id, 'int'),
            'queueID': self._serialize.url("queue_id", queue_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        body_content = self._serialize.body(model, 'UserQueueModel')

        # Construct and send request
        request = self._client.put(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, stream=False, **operation_config)

        if response.status_code not in [204, 403]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 204:
            deserialized = self._deserialize('object', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def delete_queue_user_association(
            self, user_id, queue_id, custom_headers=None, raw=False, **operation_config):
        """Deletes a queue user association;.

        :param user_id: The user identifier.
        :type user_id: int
        :param queue_id: The queue identifier.
        :type queue_id: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: object or ClientRawResponse if raw=true
        :rtype: object or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/v1/workflow/queues/{queueID}/users/{userID}'
        path_format_arguments = {
            'userID': self._serialize.url("user_id", user_id, 'int'),
            'queueID': self._serialize.url("queue_id", queue_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.delete(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [204, 403, 404]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 204:
            deserialized = self._deserialize('object', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def create_or_update_user_queue_association(
            self, user_id, queue_id, model, custom_headers=None, raw=False, **operation_config):
        """Inserts/Updates the user queue association.

        :param user_id: The user identifier.
        :type user_id: int
        :param queue_id: The queue identifier.
        :type queue_id: int
        :param model: The model.
        :type model: ~softheon.enterprise.api.client.models.UserQueueModel
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: object or ClientRawResponse if raw=true
        :rtype: object or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/v1/directory/users/{userID}/queues/{queueID}'
        path_format_arguments = {
            'userID': self._serialize.url("user_id", user_id, 'int'),
            'queueID': self._serialize.url("queue_id", queue_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        body_content = self._serialize.body(model, 'UserQueueModel')

        # Construct and send request
        request = self._client.put(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, stream=False, **operation_config)

        if response.status_code not in [204, 403]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 204:
            deserialized = self._deserialize('object', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def delete_user_queue_association(
            self, user_id, queue_id, custom_headers=None, raw=False, **operation_config):
        """Deletes a user queue association;.

        :param user_id: The user identifier.
        :type user_id: int
        :param queue_id: The queue identifier.
        :type queue_id: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: object or ClientRawResponse if raw=true
        :rtype: object or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/v1/directory/users/{userID}/queues/{queueID}'
        path_format_arguments = {
            'userID': self._serialize.url("user_id", user_id, 'int'),
            'queueID': self._serialize.url("queue_id", queue_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.delete(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [204, 403, 404]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 204:
            deserialized = self._deserialize('object', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def get_application_user_associations(
            self, application_id, user_id=None, acl=None, page=None, page_size=None, sort_order=None, sort_by=None, custom_headers=None, raw=False, **operation_config):
        """Gets a list of application user associations.

        :param application_id: The application identifier.
        :type application_id: int
        :param user_id: The user identifier.
        :type user_id: int
        :param acl: Gets or sets the access control level permissions.
        :type acl: int
        :param page: Gets or sets the page number.
        :type page: int
        :param page_size: Gets or sets the size of the page.
        :type page_size: int
        :param sort_order: Gets or sets the order. Possible values include:
         'Unspecified', 'Ascending', 'Descending'
        :type sort_order: str
        :param sort_by: Gets or sets the column to order by. Possible values
         include: 'Unspecified', 'DrawerID', 'ApplicationID', 'GroupID',
         'UserID', 'QueueID', 'Acl'
        :type sort_by: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: list or ClientRawResponse if raw=true
        :rtype:
         list[~softheon.enterprise.api.client.models.UserApplicationModel] or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/v1/directory/applications/{applicationID}/users'
        path_format_arguments = {
            'applicationID': self._serialize.url("application_id", application_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}
        if user_id is not None:
            query_parameters['userID'] = self._serialize.query("user_id", user_id, 'int')
        if acl is not None:
            query_parameters['acl'] = self._serialize.query("acl", acl, 'int')
        if page is not None:
            query_parameters['page'] = self._serialize.query("page", page, 'int', maximum=2147483647, minimum=1)
        if page_size is not None:
            query_parameters['pageSize'] = self._serialize.query("page_size", page_size, 'int', maximum=1000, minimum=1)
        if sort_order is not None:
            query_parameters['sortOrder'] = self._serialize.query("sort_order", sort_order, 'str')
        if sort_by is not None:
            query_parameters['sortBy'] = self._serialize.query("sort_by", sort_by, 'str')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200, 403]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('[UserApplicationModel]', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def get_user_application_associations(
            self, user_id, application_id=None, acl=None, page=None, page_size=None, sort_order=None, sort_by=None, custom_headers=None, raw=False, **operation_config):
        """Gets a list of user application associations.

        :param user_id: The user identifier.
        :type user_id: int
        :param application_id: The application identifier.
        :type application_id: int
        :param acl: Gets or sets the access control level permissions.
        :type acl: int
        :param page: Gets or sets the page number.
        :type page: int
        :param page_size: Gets or sets the size of the page.
        :type page_size: int
        :param sort_order: Gets or sets the order. Possible values include:
         'Unspecified', 'Ascending', 'Descending'
        :type sort_order: str
        :param sort_by: Gets or sets the column to order by. Possible values
         include: 'Unspecified', 'DrawerID', 'ApplicationID', 'GroupID',
         'UserID', 'QueueID', 'Acl'
        :type sort_by: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: list or ClientRawResponse if raw=true
        :rtype:
         list[~softheon.enterprise.api.client.models.UserApplicationModel] or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/v1/directory/users/{userID}/applications'
        path_format_arguments = {
            'userID': self._serialize.url("user_id", user_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}
        if application_id is not None:
            query_parameters['applicationID'] = self._serialize.query("application_id", application_id, 'int')
        if acl is not None:
            query_parameters['acl'] = self._serialize.query("acl", acl, 'int')
        if page is not None:
            query_parameters['page'] = self._serialize.query("page", page, 'int', maximum=2147483647, minimum=1)
        if page_size is not None:
            query_parameters['pageSize'] = self._serialize.query("page_size", page_size, 'int', maximum=1000, minimum=1)
        if sort_order is not None:
            query_parameters['sortOrder'] = self._serialize.query("sort_order", sort_order, 'str')
        if sort_by is not None:
            query_parameters['sortBy'] = self._serialize.query("sort_by", sort_by, 'str')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200, 403]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('[UserApplicationModel]', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def create_or_update_application_user_association(
            self, user_id, application_id, model, custom_headers=None, raw=False, **operation_config):
        """Inserts/Updates the application user association.

        :param user_id: The user identifier.
        :type user_id: int
        :param application_id: The application identifier.
        :type application_id: int
        :param model: The model.
        :type model:
         ~softheon.enterprise.api.client.models.UserApplicationModel
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: object or ClientRawResponse if raw=true
        :rtype: object or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/v1/directory/applications/{applicationID}/users/{userID}'
        path_format_arguments = {
            'userID': self._serialize.url("user_id", user_id, 'int'),
            'applicationID': self._serialize.url("application_id", application_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        body_content = self._serialize.body(model, 'UserApplicationModel')

        # Construct and send request
        request = self._client.put(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, stream=False, **operation_config)

        if response.status_code not in [204, 403]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 204:
            deserialized = self._deserialize('object', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def delete_application_user_association(
            self, user_id, application_id, custom_headers=None, raw=False, **operation_config):
        """Deletes an application user association;.

        :param user_id: The user identifier.
        :type user_id: int
        :param application_id: The application identifier.
        :type application_id: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: object or ClientRawResponse if raw=true
        :rtype: object or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/v1/directory/applications/{applicationID}/users/{userID}'
        path_format_arguments = {
            'userID': self._serialize.url("user_id", user_id, 'int'),
            'applicationID': self._serialize.url("application_id", application_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.delete(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [204, 403, 404]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 204:
            deserialized = self._deserialize('object', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def create_or_update_user_application_association(
            self, user_id, application_id, model, custom_headers=None, raw=False, **operation_config):
        """Inserts/Updates the user application association.

        :param user_id: The user identifier.
        :type user_id: int
        :param application_id: The application identifier.
        :type application_id: int
        :param model: The model.
        :type model:
         ~softheon.enterprise.api.client.models.UserApplicationModel
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: object or ClientRawResponse if raw=true
        :rtype: object or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/v1/directory/users/{userID}/applications/{applicationID}'
        path_format_arguments = {
            'userID': self._serialize.url("user_id", user_id, 'int'),
            'applicationID': self._serialize.url("application_id", application_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        body_content = self._serialize.body(model, 'UserApplicationModel')

        # Construct and send request
        request = self._client.put(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, stream=False, **operation_config)

        if response.status_code not in [204, 403]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 204:
            deserialized = self._deserialize('object', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def delete_user_application_association(
            self, user_id, application_id, custom_headers=None, raw=False, **operation_config):
        """Deletes a user application association;.

        :param user_id: The user identifier.
        :type user_id: int
        :param application_id: The application identifier.
        :type application_id: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: object or ClientRawResponse if raw=true
        :rtype: object or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/v1/directory/users/{userID}/applications/{applicationID}'
        path_format_arguments = {
            'userID': self._serialize.url("user_id", user_id, 'int'),
            'applicationID': self._serialize.url("application_id", application_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.delete(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [204, 403, 404]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 204:
            deserialized = self._deserialize('object', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def get_attachments_by_filter(
            self, type=None, extension=None, min_size=None, max_size=None, acl=None, entity_id=None, drawer_id=None, name=None, creator_user_id=None, modifier_user_id=None, min_insertion_time=None, max_insertion_time=None, min_modification_time=None, max_modification_time=None, page=None, page_size=None, sort_order=None, sort_by=None, custom_headers=None, raw=False, **operation_config):
        """Gets a paged list of attachment metadata.

        :param type: Gets or sets the type. Possible values include:
         'Standard', 'EntityLink', 'WebLink'
        :type type: str
        :param extension: Gets or sets the extension.
        :type extension: str
        :param min_size: Gets or sets the minimum size.
        :type min_size: long
        :param max_size: Gets or sets the maximum size.
        :type max_size: long
        :param acl: Gets or sets the access control list.
        :type acl: int
        :param entity_id: Gets or sets the entity identifier.
        :type entity_id: int
        :param drawer_id: Gets or sets the drawer identifier.
        :type drawer_id: int
        :param name: Gets or sets the name.
        :type name: str
        :param creator_user_id: Gets or sets the creator user identifier.
        :type creator_user_id: int
        :param modifier_user_id: Gets or sets the modifier user identifier.
        :type modifier_user_id: int
        :param min_insertion_time: Gets or sets the minimum insertion time.
        :type min_insertion_time: datetime
        :param max_insertion_time: Gets or sets the maximum insertion time.
        :type max_insertion_time: datetime
        :param min_modification_time: Gets or sets the minimum modification
         time.
        :type min_modification_time: datetime
        :param max_modification_time: Gets or sets the maximum modification
         time.
        :type max_modification_time: datetime
        :param page: Gets or sets the page number.
        :type page: int
        :param page_size: Gets or sets the size of the page.
        :type page_size: int
        :param sort_order: Gets or sets the order. Possible values include:
         'Unspecified', 'Ascending', 'Descending'
        :type sort_order: str
        :param sort_by: Gets or sets the column to order by. Possible values
         include: 'PageNumber', 'ID', 'Type', 'InsertionTime',
         'ModificationTime', 'CrossReferenceID', 'SubType', 'Extension', 'Name'
        :type sort_by: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: list or ClientRawResponse if raw=true
        :rtype: list[~softheon.enterprise.api.client.models.AttachmentModel]
         or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/v1/content/attachments'

        # Construct parameters
        query_parameters = {}
        if type is not None:
            query_parameters['type'] = self._serialize.query("type", type, 'str')
        if extension is not None:
            query_parameters['extension'] = self._serialize.query("extension", extension, 'str', max_length=255, min_length=0)
        if min_size is not None:
            query_parameters['minSize'] = self._serialize.query("min_size", min_size, 'long', minimum=0)
        if max_size is not None:
            query_parameters['maxSize'] = self._serialize.query("max_size", max_size, 'long', minimum=1)
        if acl is not None:
            query_parameters['acl'] = self._serialize.query("acl", acl, 'int')
        if entity_id is not None:
            query_parameters['entityID'] = self._serialize.query("entity_id", entity_id, 'int', maximum=2147483647, minimum=1)
        if drawer_id is not None:
            query_parameters['drawerID'] = self._serialize.query("drawer_id", drawer_id, 'int', maximum=2147483647, minimum=1)
        if name is not None:
            query_parameters['name'] = self._serialize.query("name", name, 'str', max_length=255, min_length=0)
        if creator_user_id is not None:
            query_parameters['creatorUserID'] = self._serialize.query("creator_user_id", creator_user_id, 'int', maximum=2147483647, minimum=1)
        if modifier_user_id is not None:
            query_parameters['modifierUserID'] = self._serialize.query("modifier_user_id", modifier_user_id, 'int', maximum=2147483647, minimum=1)
        if min_insertion_time is not None:
            query_parameters['minInsertionTime'] = self._serialize.query("min_insertion_time", min_insertion_time, 'iso-8601')
        if max_insertion_time is not None:
            query_parameters['maxInsertionTime'] = self._serialize.query("max_insertion_time", max_insertion_time, 'iso-8601')
        if min_modification_time is not None:
            query_parameters['minModificationTime'] = self._serialize.query("min_modification_time", min_modification_time, 'iso-8601')
        if max_modification_time is not None:
            query_parameters['maxModificationTime'] = self._serialize.query("max_modification_time", max_modification_time, 'iso-8601')
        if page is not None:
            query_parameters['page'] = self._serialize.query("page", page, 'int', maximum=2147483647, minimum=1)
        if page_size is not None:
            query_parameters['pageSize'] = self._serialize.query("page_size", page_size, 'int', maximum=1000, minimum=1)
        if sort_order is not None:
            query_parameters['sortOrder'] = self._serialize.query("sort_order", sort_order, 'str')
        if sort_by is not None:
            query_parameters['sortBy'] = self._serialize.query("sort_by", sort_by, 'str')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('[AttachmentModel]', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def get_attachment_by_id(
            self, drawer, id, custom_headers=None, raw=False, **operation_config):
        """Gets a single attachment metadata based on its unique identifier.

        :param drawer: The drawer identifier.
        :type drawer: int
        :param id: The attachment identifier.
        :type id: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: AttachmentModel or ClientRawResponse if raw=true
        :rtype: ~softheon.enterprise.api.client.models.AttachmentModel or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/v1/content/attachments/{drawer}/{id}'
        path_format_arguments = {
            'drawer': self._serialize.url("drawer", drawer, 'int'),
            'id': self._serialize.url("id", id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200, 404]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('AttachmentModel', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def update_attachment(
            self, drawer, id, model, custom_headers=None, raw=False, **operation_config):
        """Updates a specified attachment's metadata..

        :param drawer: The drawer identifier.
        :type drawer: int
        :param id: The attachment identifier.
        :type id: int
        :param model: The model.
        :type model:
         ~softheon.enterprise.api.client.models.UpdateAttachmentRequestModel
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: object or ClientRawResponse if raw=true
        :rtype: object or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/v1/content/attachments/{drawer}/{id}'
        path_format_arguments = {
            'drawer': self._serialize.url("drawer", drawer, 'int'),
            'id': self._serialize.url("id", id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        body_content = self._serialize.body(model, 'UpdateAttachmentRequestModel')

        # Construct and send request
        request = self._client.put(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, stream=False, **operation_config)

        if response.status_code not in [204, 403, 404]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 204:
            deserialized = self._deserialize('object', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def delete_attachment(
            self, drawer, id, custom_headers=None, raw=False, **operation_config):
        """Deletes an attachment.

        :param drawer: The drawer identifier.
        :type drawer: int
        :param id: The attachment identifier.
        :type id: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: object or ClientRawResponse if raw=true
        :rtype: object or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/v1/content/attachments/{drawer}/{id}'
        path_format_arguments = {
            'drawer': self._serialize.url("drawer", drawer, 'int'),
            'id': self._serialize.url("id", id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.delete(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [204, 403, 404]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 204:
            deserialized = self._deserialize('object', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def get_attachment_file_content(
            self, drawer, id, custom_headers=None, raw=False, **operation_config):
        """Gets an attachment's file content.

        :param drawer: The drawer identifier.
        :type drawer: int
        :param id: The attachment identifier.
        :type id: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: object or ClientRawResponse if raw=true
        :rtype: object or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/v1/content/attachments/{drawer}/{id}/file'
        path_format_arguments = {
            'drawer': self._serialize.url("drawer", drawer, 'int'),
            'id': self._serialize.url("id", id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200, 403, 404]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('object', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def create_attachment(
            self, drawer, custom_headers=None, raw=False, **operation_config):
        """Inserts a new file attachment.

        :param drawer: The drawer identifier.
        :type drawer: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: AttachmentModel or ClientRawResponse if raw=true
        :rtype: ~softheon.enterprise.api.client.models.AttachmentModel or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/v1/content/attachments/{drawer}'
        path_format_arguments = {
            'drawer': self._serialize.url("drawer", drawer, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.post(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [201, 400, 403, 404]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 201:
            deserialized = self._deserialize('AttachmentModel', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def archive_attachment(
            self, drawer, id, custom_headers=None, raw=False, **operation_config):
        """Archives an attachment.

        :param drawer: The drawer identifier.
        :type drawer: int
        :param id: The attachment identifier.
        :type id: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: object or ClientRawResponse if raw=true
        :rtype: object or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/v1/content/attachments/{drawer}/{id}/archive'
        path_format_arguments = {
            'drawer': self._serialize.url("drawer", drawer, 'int'),
            'id': self._serialize.url("id", id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.put(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [204, 400, 403, 404]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 204:
            deserialized = self._deserialize('object', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def get_attachment_versions_by_filter(
            self, drawer, id, version=None, creator_user_id=None, accessor_user_id=None, min_access_time=None, max_access_time=None, min_creation_time=None, max_creation_time=None, min_modification_time=None, max_modification_time=None, page=None, page_size=None, sort_order=None, sort_by=None, custom_headers=None, raw=False, **operation_config):
        """Gets the paged list of attachment versions.

        :param drawer: The drawer identifier.
        :type drawer: int
        :param id: The attachment identifier.
        :type id: int
        :param version: Gets or sets the indexed version value.
        :type version: int
        :param creator_user_id: Gets or sets the creator identifier.
        :type creator_user_id: int
        :param accessor_user_id: Gets or sets the identifier of the user who
         accessed the attachment version.
        :type accessor_user_id: int
        :param min_access_time: Gets or sets the min time the version was last
         accessed.
        :type min_access_time: datetime
        :param max_access_time: Gets or sets the max time the version was last
         accessed.
        :type max_access_time: datetime
        :param min_creation_time: Gets or sets the min creation time of the
         attachment version.
        :type min_creation_time: datetime
        :param max_creation_time: Gets or sets the max creation time of the
         attachment version.
        :type max_creation_time: datetime
        :param min_modification_time: Gets or sets the min modification time
         of the attachment version.
        :type min_modification_time: datetime
        :param max_modification_time: Gets or sets the max modification time
         of the attachment version.
        :type max_modification_time: datetime
        :param page: Gets or sets the page number.
        :type page: int
        :param page_size: Gets or sets the size of the page.
        :type page_size: int
        :param sort_order: Gets or sets the order. Possible values include:
         'Unspecified', 'Ascending', 'Descending'
        :type sort_order: str
        :param sort_by: Gets or sets the column to order by. Possible values
         include: 'Version', 'CreatorUserID', 'AccessorUserID', 'AccessTime',
         'CreationTime', 'ModificationTime'
        :type sort_by: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: list or ClientRawResponse if raw=true
        :rtype:
         list[~softheon.enterprise.api.client.models.AttachmentVersionModel] or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/v1/content/attachments/{drawer}/{id}/versions'
        path_format_arguments = {
            'drawer': self._serialize.url("drawer", drawer, 'int'),
            'id': self._serialize.url("id", id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}
        if version is not None:
            query_parameters['version'] = self._serialize.query("version", version, 'int', maximum=2147483647, minimum=1)
        if creator_user_id is not None:
            query_parameters['creatorUserID'] = self._serialize.query("creator_user_id", creator_user_id, 'int', maximum=2147483647, minimum=1)
        if accessor_user_id is not None:
            query_parameters['accessorUserID'] = self._serialize.query("accessor_user_id", accessor_user_id, 'int', maximum=2147483647, minimum=1)
        if min_access_time is not None:
            query_parameters['minAccessTime'] = self._serialize.query("min_access_time", min_access_time, 'iso-8601')
        if max_access_time is not None:
            query_parameters['maxAccessTime'] = self._serialize.query("max_access_time", max_access_time, 'iso-8601')
        if min_creation_time is not None:
            query_parameters['minCreationTime'] = self._serialize.query("min_creation_time", min_creation_time, 'iso-8601')
        if max_creation_time is not None:
            query_parameters['maxCreationTime'] = self._serialize.query("max_creation_time", max_creation_time, 'iso-8601')
        if min_modification_time is not None:
            query_parameters['minModificationTime'] = self._serialize.query("min_modification_time", min_modification_time, 'iso-8601')
        if max_modification_time is not None:
            query_parameters['maxModificationTime'] = self._serialize.query("max_modification_time", max_modification_time, 'iso-8601')
        if page is not None:
            query_parameters['page'] = self._serialize.query("page", page, 'int', maximum=2147483647, minimum=1)
        if page_size is not None:
            query_parameters['pageSize'] = self._serialize.query("page_size", page_size, 'int', maximum=1000, minimum=1)
        if sort_order is not None:
            query_parameters['sortOrder'] = self._serialize.query("sort_order", sort_order, 'str')
        if sort_by is not None:
            query_parameters['sortBy'] = self._serialize.query("sort_by", sort_by, 'str')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200, 404]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('[AttachmentVersionModel]', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def get_attachment_version_file_content(
            self, drawer, id, version_id, custom_headers=None, raw=False, **operation_config):
        """Gets a file for a specified attachment version.

        :param drawer: The drawer identifier.
        :type drawer: int
        :param id: The attachment identifier.
        :type id: int
        :param version_id: The version identifier.
        :type version_id: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: object or ClientRawResponse if raw=true
        :rtype: object or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/v1/content/attachments/{drawer}/{id}/versions/{versionID}'
        path_format_arguments = {
            'drawer': self._serialize.url("drawer", drawer, 'int'),
            'id': self._serialize.url("id", id, 'int'),
            'versionID': self._serialize.url("version_id", version_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200, 403, 404]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('object', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def check_out_attachment(
            self, drawer, id, custom_headers=None, raw=False, **operation_config):
        """Checks out the attachment file.

        :param drawer: The drawer identifier.
        :type drawer: int
        :param id: The attachment identifier.
        :type id: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: object or ClientRawResponse if raw=true
        :rtype: object or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/v1/content/attachments/{drawer}/{id}/checkout'
        path_format_arguments = {
            'drawer': self._serialize.url("drawer", drawer, 'int'),
            'id': self._serialize.url("id", id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.put(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [204, 400, 403, 404]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 204:
            deserialized = self._deserialize('object', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def undo_check_out_attachment(
            self, drawer, id, custom_headers=None, raw=False, **operation_config):
        """Undoes the attachment check out of the attachment file.

        :param drawer: The drawer identifier.
        :type drawer: int
        :param id: The attachment identifier.
        :type id: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: object or ClientRawResponse if raw=true
        :rtype: object or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/v1/content/attachments/{drawer}/{id}/checkout'
        path_format_arguments = {
            'drawer': self._serialize.url("drawer", drawer, 'int'),
            'id': self._serialize.url("id", id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.delete(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [204, 400, 403, 404]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 204:
            deserialized = self._deserialize('object', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def check_in_attachment(
            self, drawer, id, custom_headers=None, raw=False, **operation_config):
        """Checks in the new version of attachment file.

        :param drawer: The drawer identifier.
        :type drawer: int
        :param id: The attachment identifier.
        :type id: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: object or ClientRawResponse if raw=true
        :rtype: object or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/v1/content/attachments/{drawer}/{id}/checkin'
        path_format_arguments = {
            'drawer': self._serialize.url("drawer", drawer, 'int'),
            'id': self._serialize.url("id", id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.put(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [204, 400, 403, 404]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 204:
            deserialized = self._deserialize('object', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def rollback_attachment_version(
            self, drawer, id, version_id, custom_headers=None, raw=False, **operation_config):
        """Rolls back to a specified version the attachment file.

        :param drawer: The drawer identifier.
        :type drawer: int
        :param id: The attachment identifier.
        :type id: int
        :param version_id: The version identifier.
        :type version_id: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: object or ClientRawResponse if raw=true
        :rtype: object or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/v1/content/attachments/{drawer}/{id}/rollback/{versionID}'
        path_format_arguments = {
            'drawer': self._serialize.url("drawer", drawer, 'int'),
            'id': self._serialize.url("id", id, 'int'),
            'versionID': self._serialize.url("version_id", version_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.put(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [204, 400, 403, 404]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 204:
            deserialized = self._deserialize('object', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def get_all_drawers(
            self, custom_headers=None, raw=False, **operation_config):
        """Gets a list of all available drawers.

        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: list or ClientRawResponse if raw=true
        :rtype: list[~softheon.enterprise.api.client.models.DrawerModel] or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/v1/directory/drawers'

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('[DrawerModel]', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def get_drawer_by_id(
            self, id, custom_headers=None, raw=False, **operation_config):
        """Gets a single drawer by its unique identifier.

        :param id: The drawer identifier.
        :type id: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: DrawerModel or ClientRawResponse if raw=true
        :rtype: ~softheon.enterprise.api.client.models.DrawerModel or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/v1/directory/drawers/{id}'
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200, 404]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('DrawerModel', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def update_drawer(
            self, id, model, custom_headers=None, raw=False, **operation_config):
        """Updates a specified drawer.

        :param id: The drawer identifier.
        :type id: int
        :param model: The model.
        :type model: ~softheon.enterprise.api.client.models.DrawerBase
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: object or ClientRawResponse if raw=true
        :rtype: object or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/v1/directory/drawers/{id}'
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        body_content = self._serialize.body(model, 'DrawerBase')

        # Construct and send request
        request = self._client.put(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, stream=False, **operation_config)

        if response.status_code not in [204, 403, 404]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 204:
            deserialized = self._deserialize('object', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def get_drawer_by_name(
            self, name, custom_headers=None, raw=False, **operation_config):
        """Gets a single drawer by its name.

        :param name: The drawer name.
        :type name: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: DrawerModel or ClientRawResponse if raw=true
        :rtype: ~softheon.enterprise.api.client.models.DrawerModel or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/v1/directory/drawers/{name}'
        path_format_arguments = {
            'name': self._serialize.url("name", name, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200, 404]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('DrawerModel', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def get_entities_by_filter(
            self, drawer_id, acl=None, type=None, name=None, state=None, reference_count=None, attach_count=None, note_count=None, owner_user_id=None, owner_group_id=None, creator_user_id=None, creator_group_id=None, modifier_user_id=None, modifier_group_id=None, min_creation_time=None, max_creation_time=None, min_modification_time=None, max_modification_time=None, metadata=None, page=None, page_size=None, sort_order=None, sort_by=None, custom_headers=None, raw=False, **operation_config):
        """Gets a paged list of entity summaries.

        :param drawer_id: Gets or sets the drawer identifier.
        :type drawer_id: int
        :param acl: Gets or sets the access control list.
        :type acl: int
        :param type: Gets or sets the type of the entity.
        :type type: int
        :param name: Gets or sets the name.
        :type name: str
        :param state: Gets or sets the state. Possible values include:
         'Undefined', 'Available', 'Locked', 'Suspended', 'Archived',
         'Deleted', 'Canceled', 'Complete', 'Reviewed', 'ReviewedSuspended',
         'ReviewedComplete', 'Rejected', 'RoutingSlipOpen',
         'ReviewedRoutingSlipOpen'
        :type state: str
        :param reference_count: Gets or sets the reference count.
        :type reference_count: int
        :param attach_count: Gets or sets the attach count.
        :type attach_count: int
        :param note_count: Gets or sets the note count.
        :type note_count: int
        :param owner_user_id: Gets or sets the owner user identifier.
        :type owner_user_id: int
        :param owner_group_id: Gets or sets the owner group identifier.
        :type owner_group_id: int
        :param creator_user_id: Gets or sets the creator user identifier.
        :type creator_user_id: int
        :param creator_group_id: Gets or sets the creator group identifier.
        :type creator_group_id: int
        :param modifier_user_id: Gets or sets the modifier user identifier.
        :type modifier_user_id: int
        :param modifier_group_id: Gets or sets the modifier group identifier.
        :type modifier_group_id: int
        :param min_creation_time: Gets or sets the minimum creation time.
        :type min_creation_time: datetime
        :param max_creation_time: Gets or sets the maximum creation time.
        :type max_creation_time: datetime
        :param min_modification_time: Gets or sets the minimum modification
         time.
        :type min_modification_time: datetime
        :param max_modification_time: Gets or sets the maximum modification
         time.
        :type max_modification_time: datetime
        :param metadata: Gets or sets the metadata.
        :type metadata: list[object]
        :param page: Gets or sets the page number.
        :type page: int
        :param page_size: Gets or sets the size of the page.
        :type page_size: int
        :param sort_order: Gets or sets the order. Possible values include:
         'Unspecified', 'Ascending', 'Descending'
        :type sort_order: str
        :param sort_by: Gets or sets the column to order by. Possible values
         include: 'ID', 'Type', 'CreationTime', 'ModificationTime', 'State',
         'Name'
        :type sort_by: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: list or ClientRawResponse if raw=true
        :rtype:
         list[~softheon.enterprise.api.client.models.GetEntityBaseResponse] or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/v1/content/entities'

        # Construct parameters
        query_parameters = {}
        query_parameters['drawerID'] = self._serialize.query("drawer_id", drawer_id, 'int', maximum=2147483647, minimum=1)
        if acl is not None:
            query_parameters['acl'] = self._serialize.query("acl", acl, 'int')
        if type is not None:
            query_parameters['type'] = self._serialize.query("type", type, 'int', maximum=2147483647, minimum=1)
        if name is not None:
            query_parameters['name'] = self._serialize.query("name", name, 'str', max_length=255, min_length=0)
        if state is not None:
            query_parameters['state'] = self._serialize.query("state", state, 'str')
        if reference_count is not None:
            query_parameters['referenceCount'] = self._serialize.query("reference_count", reference_count, 'int', maximum=2147483647, minimum=0)
        if attach_count is not None:
            query_parameters['attachCount'] = self._serialize.query("attach_count", attach_count, 'int', maximum=2147483647, minimum=0)
        if note_count is not None:
            query_parameters['noteCount'] = self._serialize.query("note_count", note_count, 'int', maximum=2147483647, minimum=0)
        if owner_user_id is not None:
            query_parameters['ownerUserID'] = self._serialize.query("owner_user_id", owner_user_id, 'int', maximum=2147483647, minimum=1)
        if owner_group_id is not None:
            query_parameters['ownerGroupID'] = self._serialize.query("owner_group_id", owner_group_id, 'int', maximum=2147483647, minimum=0)
        if creator_user_id is not None:
            query_parameters['creatorUserID'] = self._serialize.query("creator_user_id", creator_user_id, 'int', maximum=2147483647, minimum=1)
        if creator_group_id is not None:
            query_parameters['creatorGroupID'] = self._serialize.query("creator_group_id", creator_group_id, 'int', maximum=2147483647, minimum=0)
        if modifier_user_id is not None:
            query_parameters['modifierUserID'] = self._serialize.query("modifier_user_id", modifier_user_id, 'int', maximum=2147483647, minimum=1)
        if modifier_group_id is not None:
            query_parameters['modifierGroupID'] = self._serialize.query("modifier_group_id", modifier_group_id, 'int', maximum=2147483647, minimum=0)
        if min_creation_time is not None:
            query_parameters['minCreationTime'] = self._serialize.query("min_creation_time", min_creation_time, 'iso-8601')
        if max_creation_time is not None:
            query_parameters['maxCreationTime'] = self._serialize.query("max_creation_time", max_creation_time, 'iso-8601')
        if min_modification_time is not None:
            query_parameters['minModificationTime'] = self._serialize.query("min_modification_time", min_modification_time, 'iso-8601')
        if max_modification_time is not None:
            query_parameters['maxModificationTime'] = self._serialize.query("max_modification_time", max_modification_time, 'iso-8601')
        if metadata is not None:
            query_parameters['metadata'] = self._serialize.query("metadata", metadata, '[object]', div=',')
        if page is not None:
            query_parameters['page'] = self._serialize.query("page", page, 'int', maximum=2147483647, minimum=1)
        if page_size is not None:
            query_parameters['pageSize'] = self._serialize.query("page_size", page_size, 'int', maximum=1000, minimum=1)
        if sort_order is not None:
            query_parameters['sortOrder'] = self._serialize.query("sort_order", sort_order, 'str')
        if sort_by is not None:
            query_parameters['sortBy'] = self._serialize.query("sort_by", sort_by, 'str')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('[GetEntityBaseResponse]', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def get_entity_by_id(
            self, drawer, id, custom_headers=None, raw=False, **operation_config):
        """Gets a single entity complete with all profile metadata.

        :param drawer: The drawer identifier.
        :type drawer: int
        :param id: The entity identifier.
        :type id: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: EntityModel or ClientRawResponse if raw=true
        :rtype: ~softheon.enterprise.api.client.models.EntityModel or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/v1/content/entities/{drawer}/{id}'
        path_format_arguments = {
            'drawer': self._serialize.url("drawer", drawer, 'int'),
            'id': self._serialize.url("id", id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200, 403, 404]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('EntityModel', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def update_entity(
            self, drawer, id, model, custom_headers=None, raw=False, **operation_config):
        """Updates a specified entity.

        :param drawer: The drawer identifier.
        :type drawer: int
        :param id: The entity identifier.
        :type id: int
        :param model: The entity model.
        :type model:
         ~softheon.enterprise.api.client.models.UpdateEntityRequestModel
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: object or ClientRawResponse if raw=true
        :rtype: object or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/v1/content/entities/{drawer}/{id}'
        path_format_arguments = {
            'drawer': self._serialize.url("drawer", drawer, 'int'),
            'id': self._serialize.url("id", id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        body_content = self._serialize.body(model, 'UpdateEntityRequestModel')

        # Construct and send request
        request = self._client.put(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, stream=False, **operation_config)

        if response.status_code not in [204, 403, 404]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 204:
            deserialized = self._deserialize('object', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def delete_entity(
            self, drawer, id, custom_headers=None, raw=False, **operation_config):
        """Deletes a specified entity.

        :param drawer: The drawer identifier.
        :type drawer: int
        :param id: The entity identifier.
        :type id: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: object or ClientRawResponse if raw=true
        :rtype: object or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/v1/content/entities/{drawer}/{id}'
        path_format_arguments = {
            'drawer': self._serialize.url("drawer", drawer, 'int'),
            'id': self._serialize.url("id", id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.delete(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [204, 403, 404]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 204:
            deserialized = self._deserialize('object', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def create_entity(
            self, drawer, model, custom_headers=None, raw=False, **operation_config):
        """Creates a new entity.

        :param drawer: The drawer identifier.
        :type drawer: int
        :param model: The entity model.
        :type model:
         ~softheon.enterprise.api.client.models.InsertEntityRequestModel
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: EntityModel or ClientRawResponse if raw=true
        :rtype: ~softheon.enterprise.api.client.models.EntityModel or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/v1/content/entities/{drawer}'
        path_format_arguments = {
            'drawer': self._serialize.url("drawer", drawer, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        body_content = self._serialize.body(model, 'InsertEntityRequestModel')

        # Construct and send request
        request = self._client.post(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, stream=False, **operation_config)

        if response.status_code not in [201, 404]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 201:
            deserialized = self._deserialize('EntityModel', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def copy_entity(
            self, drawer, id, model, custom_headers=None, raw=False, **operation_config):
        """Copies the contents of an entity.

        :param drawer: The drawer.
        :type drawer: int
        :param id: The entity identifier.
        :type id: int
        :param model: The model.
        :type model: ~softheon.enterprise.api.client.models.EntityContentModel
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: EntityModel or ClientRawResponse if raw=true
        :rtype: ~softheon.enterprise.api.client.models.EntityModel or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/v1/content/entities/{drawer}/{id}/copy'
        path_format_arguments = {
            'drawer': self._serialize.url("drawer", drawer, 'int'),
            'id': self._serialize.url("id", id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        body_content = self._serialize.body(model, 'EntityContentModel')

        # Construct and send request
        request = self._client.post(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, stream=False, **operation_config)

        if response.status_code not in [201, 404]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 201:
            deserialized = self._deserialize('EntityModel', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def get_events_by_filter(
            self, drawer_id, entity_id, type=None, min_event_time=None, max_event_time=None, event_user_id=None, event_group_id=None, category=None, class_parameter=None, operation=None, min_processing_time=None, max_processing_time=None, page=None, page_size=None, sort_order=None, sort_by=None, custom_headers=None, raw=False, **operation_config):
        """Gets a paged list of events.

        :param drawer_id: Gets or sets the drawer identifier.
        :type drawer_id: int
        :param entity_id: Gets or sets the entity identifier.
        :type entity_id: int
        :param type: Gets or sets the type. Possible values include:
         'Undefined', 'Fatal', 'Warning', 'Info', 'Debug', 'Process', 'RPC',
         'SQL', 'DDE'
        :type type: str
        :param min_event_time: Gets or sets the minimum event time.
        :type min_event_time: datetime
        :param max_event_time: Gets or sets the maximum event time.
        :type max_event_time: datetime
        :param event_user_id: Gets or sets the event user identifier.
        :type event_user_id: int
        :param event_group_id: Gets or sets the event group identifier.
        :type event_group_id: int
        :param category: Gets or sets the category. Possible values include:
         'Undefined', 'Entity', 'Profile', 'Attachment', 'Discussion', 'Field',
         'Workflow'
        :type category: str
        :param class_parameter: Gets or sets the class. Possible values
         include: 'Undefined', 'Application', 'Security', 'System'
        :type class_parameter: str
        :param operation: Gets or sets the operation. Possible values include:
         'Undefined', 'Insert', 'Update', 'Delete', 'Copy', 'Lock', 'Unlock',
         'Open', 'Close', 'Checkout', 'Checkin', 'View', 'Merge', 'Split',
         'Classify', 'Null', 'OpenWF', 'Remove', 'ReturnToTop',
         'ReturnToBottom', 'Accept', 'Suspend', 'Reject', 'Route', 'Forward',
         'Reply', 'Reassign', 'Reset', 'Override', 'Rollback', 'Archive'
        :type operation: str
        :param min_processing_time: Gets or sets the minimum processing time.
        :type min_processing_time: int
        :param max_processing_time: Gets or sets the maximum processing time.
        :type max_processing_time: int
        :param page: Gets or sets the page number.
        :type page: int
        :param page_size: Gets or sets the size of the page.
        :type page_size: int
        :param sort_order: Gets or sets the order. Possible values include:
         'Unspecified', 'Ascending', 'Descending'
        :type sort_order: str
        :param sort_by: Gets or sets the column to order by. Possible values
         include: 'ID', 'Type', 'EventTime'
        :type sort_by: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: list or ClientRawResponse if raw=true
        :rtype: list[~softheon.enterprise.api.client.models.EventModel] or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/v1/content/events'

        # Construct parameters
        query_parameters = {}
        query_parameters['drawerID'] = self._serialize.query("drawer_id", drawer_id, 'int', maximum=2147483647, minimum=1)
        query_parameters['entityID'] = self._serialize.query("entity_id", entity_id, 'int', maximum=2147483647, minimum=1)
        if type is not None:
            query_parameters['type'] = self._serialize.query("type", type, 'str')
        if min_event_time is not None:
            query_parameters['minEventTime'] = self._serialize.query("min_event_time", min_event_time, 'iso-8601')
        if max_event_time is not None:
            query_parameters['maxEventTime'] = self._serialize.query("max_event_time", max_event_time, 'iso-8601')
        if event_user_id is not None:
            query_parameters['eventUserID'] = self._serialize.query("event_user_id", event_user_id, 'int', maximum=2147483647, minimum=1)
        if event_group_id is not None:
            query_parameters['eventGroupID'] = self._serialize.query("event_group_id", event_group_id, 'int', maximum=2147483647, minimum=1)
        if category is not None:
            query_parameters['category'] = self._serialize.query("category", category, 'str')
        if class_parameter is not None:
            query_parameters['class'] = self._serialize.query("class_parameter", class_parameter, 'str')
        if operation is not None:
            query_parameters['operation'] = self._serialize.query("operation", operation, 'str')
        if min_processing_time is not None:
            query_parameters['minProcessingTime'] = self._serialize.query("min_processing_time", min_processing_time, 'int')
        if max_processing_time is not None:
            query_parameters['maxProcessingTime'] = self._serialize.query("max_processing_time", max_processing_time, 'int')
        if page is not None:
            query_parameters['page'] = self._serialize.query("page", page, 'int', maximum=2147483647, minimum=1)
        if page_size is not None:
            query_parameters['pageSize'] = self._serialize.query("page_size", page_size, 'int', maximum=1000, minimum=1)
        if sort_order is not None:
            query_parameters['sortOrder'] = self._serialize.query("sort_order", sort_order, 'str')
        if sort_by is not None:
            query_parameters['sortBy'] = self._serialize.query("sort_by", sort_by, 'str')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('[EventModel]', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def get_event_by_id(
            self, drawer, id, custom_headers=None, raw=False, **operation_config):
        """Retrieves a single event based on its unique identifier.

        :param drawer: The drawer identifier.
        :type drawer: int
        :param id: The event identifier.
        :type id: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: EventModel or ClientRawResponse if raw=true
        :rtype: ~softheon.enterprise.api.client.models.EventModel or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/v1/content/events/{drawer}/{id}'
        path_format_arguments = {
            'drawer': self._serialize.url("drawer", drawer, 'int'),
            'id': self._serialize.url("id", id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200, 404]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('EventModel', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def create_event(
            self, drawer, model, custom_headers=None, raw=False, **operation_config):
        """Creates a new event.

        :param drawer: The drawer identifier.
        :type drawer: int
        :param model: The event model.
        :type model: ~softheon.enterprise.api.client.models.EventModel
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: EventModel or ClientRawResponse if raw=true
        :rtype: ~softheon.enterprise.api.client.models.EventModel or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/v1/content/events/{drawer}'
        path_format_arguments = {
            'drawer': self._serialize.url("drawer", drawer, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        body_content = self._serialize.body(model, 'EventModel')

        # Construct and send request
        request = self._client.post(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, stream=False, **operation_config)

        if response.status_code not in [201, 404]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 201:
            deserialized = self._deserialize('EventModel', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def get_extensions_by_filter(
            self, drawer_id, entity_id, profile_id, i_d=None, type=None, page=None, page_size=None, sort_order=None, sort_by=None, custom_headers=None, raw=False, **operation_config):
        """Gets a paged list of extension rows.

        :param drawer_id: Gets or sets the drawer identifier.
        :type drawer_id: int
        :param entity_id: Gets or sets the entity identifier.
        :type entity_id: int
        :param profile_id: Gets or sets the profile identifier.
        :type profile_id: int
        :param i_d: Gets or sets the extension identifier.
        :type i_d: int
        :param type: Gets or sets the type of the extension.
        :type type: int
        :param page: Gets or sets the page number.
        :type page: int
        :param page_size: Gets or sets the size of the page.
        :type page_size: int
        :param sort_order: Gets or sets the order. Possible values include:
         'Unspecified', 'Ascending', 'Descending'
        :type sort_order: str
        :param sort_by: Gets or sets the column to order by. Possible values
         include: 'RowNumber', 'ID', 'Type', 'String', 'Integer', 'Double',
         'Date'
        :type sort_by: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: list or ClientRawResponse if raw=true
        :rtype: list[~softheon.enterprise.api.client.models.ExtensionModel] or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/v1/content/extensions'

        # Construct parameters
        query_parameters = {}
        query_parameters['drawerID'] = self._serialize.query("drawer_id", drawer_id, 'int', maximum=2147483647, minimum=1)
        query_parameters['entityID'] = self._serialize.query("entity_id", entity_id, 'int', maximum=2147483647, minimum=1)
        query_parameters['profileID'] = self._serialize.query("profile_id", profile_id, 'int', maximum=2147483647, minimum=1)
        if i_d is not None:
            query_parameters['iD'] = self._serialize.query("i_d", i_d, 'int', maximum=2147483647, minimum=1)
        if type is not None:
            query_parameters['type'] = self._serialize.query("type", type, 'int', maximum=2147483647, minimum=0)
        if page is not None:
            query_parameters['page'] = self._serialize.query("page", page, 'int', maximum=2147483647, minimum=1)
        if page_size is not None:
            query_parameters['pageSize'] = self._serialize.query("page_size", page_size, 'int', maximum=1000, minimum=1)
        if sort_order is not None:
            query_parameters['sortOrder'] = self._serialize.query("sort_order", sort_order, 'str')
        if sort_by is not None:
            query_parameters['sortBy'] = self._serialize.query("sort_by", sort_by, 'str')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('[ExtensionModel]', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def get_flows_by_filter(
            self, drawer_id, entity_id, type=None, queue_id=None, min_workflow_time=None, max_workflow_time=None, min_insertion_time=None, max_insertion_time=None, workflow_user_id=None, workflow_group_id=None, operation=None, category=None, status=None, state=None, min_index1=None, max_index1=None, min_index2=None, max_index2=None, page=None, page_size=None, sort_order=None, sort_by=None, custom_headers=None, raw=False, **operation_config):
        """Gets a paged list of flows.

        :param drawer_id: Gets or sets the drawer identifier.
        :type drawer_id: int
        :param entity_id: Gets or sets the entity identifier.
        :type entity_id: int
        :param type: Gets or sets the type. Possible values include: 'None',
         'Workflow', 'Fatal', 'Warning', 'Info', 'Debug', 'Process', 'Rpc',
         'Sql', 'Dde'
        :type type: str
        :param queue_id: Gets or sets the queue identifier.
        :type queue_id: int
        :param min_workflow_time: Gets or sets the minimum workflow time.
        :type min_workflow_time: datetime
        :param max_workflow_time: Gets or sets the maximum workflow time.
        :type max_workflow_time: datetime
        :param min_insertion_time: Gets or sets the minimum insertion time.
        :type min_insertion_time: datetime
        :param max_insertion_time: Gets or sets the maximum insertion time.
        :type max_insertion_time: datetime
        :param workflow_user_id: Gets or sets the workflow user identifier.
        :type workflow_user_id: int
        :param workflow_group_id: Gets or sets the workflow group identifier.
        :type workflow_group_id: int
        :param operation: Gets or sets the operation. Possible values include:
         'None', 'Update', 'Reset', 'Override', 'Null'
        :type operation: str
        :param category: Gets or sets the category. Possible values include:
         'None', 'Direct', 'AdHoc', 'Production', 'Review', 'Reset',
         'RoutingSlip', 'ReviewRoutingSlip', 'Override'
        :type category: str
        :param status: Gets or sets the status. Possible values include:
         'None', 'Approved', 'Rejected', 'Suspended', 'ApprovedR', 'NoneR'
        :type status: str
        :param state: Gets or sets the state. Possible values include: 'None',
         'Processed', 'Pending', 'Waiting', 'ProcessedR', 'Override',
         'OverrideR', 'WaitingR'
        :type state: str
        :param min_index1: Gets or sets the minimum index 1.
        :type min_index1: int
        :param max_index1: Gets or sets the maximum index 1.
        :type max_index1: int
        :param min_index2: Gets or sets the minimum index 2.
        :type min_index2: int
        :param max_index2: Gets or sets the maximum index 2.
        :type max_index2: int
        :param page: Gets or sets the page number.
        :type page: int
        :param page_size: Gets or sets the size of the page.
        :type page_size: int
        :param sort_order: Gets or sets the order. Possible values include:
         'Unspecified', 'Ascending', 'Descending'
        :type sort_order: str
        :param sort_by: Gets or sets the column to order by. Possible values
         include: 'ID', 'Type', 'QueueID', 'WorkflowTime', 'InsertionTime',
         'Index'
        :type sort_by: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: list or ClientRawResponse if raw=true
        :rtype: list[~softheon.enterprise.api.client.models.FlowModel] or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/v1/content/flows'

        # Construct parameters
        query_parameters = {}
        query_parameters['drawerID'] = self._serialize.query("drawer_id", drawer_id, 'int', maximum=2147483647, minimum=1)
        query_parameters['entityID'] = self._serialize.query("entity_id", entity_id, 'int', maximum=2147483647, minimum=1)
        if type is not None:
            query_parameters['type'] = self._serialize.query("type", type, 'str')
        if queue_id is not None:
            query_parameters['queueID'] = self._serialize.query("queue_id", queue_id, 'int', maximum=2147483647, minimum=1)
        if min_workflow_time is not None:
            query_parameters['minWorkflowTime'] = self._serialize.query("min_workflow_time", min_workflow_time, 'iso-8601')
        if max_workflow_time is not None:
            query_parameters['maxWorkflowTime'] = self._serialize.query("max_workflow_time", max_workflow_time, 'iso-8601')
        if min_insertion_time is not None:
            query_parameters['minInsertionTime'] = self._serialize.query("min_insertion_time", min_insertion_time, 'iso-8601')
        if max_insertion_time is not None:
            query_parameters['maxInsertionTime'] = self._serialize.query("max_insertion_time", max_insertion_time, 'iso-8601')
        if workflow_user_id is not None:
            query_parameters['workflowUserID'] = self._serialize.query("workflow_user_id", workflow_user_id, 'int', maximum=2147483647, minimum=1)
        if workflow_group_id is not None:
            query_parameters['workflowGroupID'] = self._serialize.query("workflow_group_id", workflow_group_id, 'int', maximum=2147483647, minimum=1)
        if operation is not None:
            query_parameters['operation'] = self._serialize.query("operation", operation, 'str')
        if category is not None:
            query_parameters['category'] = self._serialize.query("category", category, 'str')
        if status is not None:
            query_parameters['status'] = self._serialize.query("status", status, 'str')
        if state is not None:
            query_parameters['state'] = self._serialize.query("state", state, 'str')
        if min_index1 is not None:
            query_parameters['minIndex1'] = self._serialize.query("min_index1", min_index1, 'int')
        if max_index1 is not None:
            query_parameters['maxIndex1'] = self._serialize.query("max_index1", max_index1, 'int')
        if min_index2 is not None:
            query_parameters['minIndex2'] = self._serialize.query("min_index2", min_index2, 'int')
        if max_index2 is not None:
            query_parameters['maxIndex2'] = self._serialize.query("max_index2", max_index2, 'int')
        if page is not None:
            query_parameters['page'] = self._serialize.query("page", page, 'int', maximum=2147483647, minimum=1)
        if page_size is not None:
            query_parameters['pageSize'] = self._serialize.query("page_size", page_size, 'int', maximum=1000, minimum=1)
        if sort_order is not None:
            query_parameters['sortOrder'] = self._serialize.query("sort_order", sort_order, 'str')
        if sort_by is not None:
            query_parameters['sortBy'] = self._serialize.query("sort_by", sort_by, 'str')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('[FlowModel]', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def get_flow_by_id(
            self, drawer, id, custom_headers=None, raw=False, **operation_config):
        """Gets a single flow based on its unique identifier.

        :param drawer: The drawer identifier.
        :type drawer: int
        :param id: The flow identifier.
        :type id: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: FlowModel or ClientRawResponse if raw=true
        :rtype: ~softheon.enterprise.api.client.models.FlowModel or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/v1/content/flows/{drawer}/{id}'
        path_format_arguments = {
            'drawer': self._serialize.url("drawer", drawer, 'int'),
            'id': self._serialize.url("id", id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200, 404]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('FlowModel', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def get_templates_by_filter(
            self, drawer_id=None, name=None, category=None, page=None, page_size=None, sort_order=None, sort_by=None, custom_headers=None, raw=False, **operation_config):
        """Gets a paged list of entity template definitions.

        :param drawer_id: Gets or sets the drawer identifier.
        :type drawer_id: int
        :param name: Gets or sets the name.
        :type name: str
        :param category: Gets or sets the category.
        :type category: str
        :param page: Gets or sets the page number.
        :type page: int
        :param page_size: Gets or sets the size of the page.
        :type page_size: int
        :param sort_order: Gets or sets the order. Possible values include:
         'Unspecified', 'Ascending', 'Descending'
        :type sort_order: str
        :param sort_by: Gets or sets the column to order by.
        :type sort_by: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: list or ClientRawResponse if raw=true
        :rtype:
         list[~softheon.enterprise.api.client.models.EntityDefinitionModel] or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/v1/template/ftl'

        # Construct parameters
        query_parameters = {}
        if drawer_id is not None:
            query_parameters['drawerID'] = self._serialize.query("drawer_id", drawer_id, 'int', maximum=2147483647, minimum=1)
        if name is not None:
            query_parameters['name'] = self._serialize.query("name", name, 'str', max_length=255, min_length=0)
        if category is not None:
            query_parameters['category'] = self._serialize.query("category", category, 'str', max_length=255, min_length=0)
        if page is not None:
            query_parameters['page'] = self._serialize.query("page", page, 'int', maximum=2147483647, minimum=1)
        if page_size is not None:
            query_parameters['pageSize'] = self._serialize.query("page_size", page_size, 'int', maximum=1000, minimum=1)
        if sort_order is not None:
            query_parameters['sortOrder'] = self._serialize.query("sort_order", sort_order, 'str')
        if sort_by is not None:
            query_parameters['sortBy'] = self._serialize.query("sort_by", sort_by, 'int')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('[EntityDefinitionModel]', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def create_template(
            self, model, custom_headers=None, raw=False, **operation_config):
        """Creates a new entity template definition.

        :param model: The entity template model.
        :type model:
         ~softheon.enterprise.api.client.models.EntityDefinitionBase
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: EntityDefinitionModel or ClientRawResponse if raw=true
        :rtype: ~softheon.enterprise.api.client.models.EntityDefinitionModel
         or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/v1/template/ftl'

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        body_content = self._serialize.body(model, 'EntityDefinitionBase')

        # Construct and send request
        request = self._client.post(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, stream=False, **operation_config)

        if response.status_code not in [201, 403, 404, 409]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 201:
            deserialized = self._deserialize('EntityDefinitionModel', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def get_template_by_type(
            self, type, custom_headers=None, raw=False, **operation_config):
        """Gets a single entity template definition by its type.

        :param type: The unique template type.
        :type type: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: EntityDefinitionModel or ClientRawResponse if raw=true
        :rtype: ~softheon.enterprise.api.client.models.EntityDefinitionModel
         or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/v1/template/ftl/{type}'
        path_format_arguments = {
            'type': self._serialize.url("type", type, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200, 404]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('EntityDefinitionModel', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def update_template_by_type(
            self, type, model, custom_headers=None, raw=False, **operation_config):
        """Updates a specified entity template definition by type.

        :param type: The unique template type.
        :type type: int
        :param model: The entity template model.
        :type model:
         ~softheon.enterprise.api.client.models.UpdateEntityDefinitionRequestModel
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: object or ClientRawResponse if raw=true
        :rtype: object or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/v1/template/ftl/{type}'
        path_format_arguments = {
            'type': self._serialize.url("type", type, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        body_content = self._serialize.body(model, 'UpdateEntityDefinitionRequestModel')

        # Construct and send request
        request = self._client.put(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, stream=False, **operation_config)

        if response.status_code not in [204, 403, 404]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 204:
            deserialized = self._deserialize('object', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def delete_template_by_type(
            self, type, custom_headers=None, raw=False, **operation_config):
        """Deletes a specified entity template definition by type.

        :param type: The unique template type.
        :type type: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: object or ClientRawResponse if raw=true
        :rtype: object or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/v1/template/ftl/{type}'
        path_format_arguments = {
            'type': self._serialize.url("type", type, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.delete(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [204, 403, 404]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 204:
            deserialized = self._deserialize('object', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def get_template_by_id(
            self, id, custom_headers=None, raw=False, **operation_config):
        """Gets a single entity template definition by its unique identifier.

        :param id: The template identifier.
        :type id: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: EntityDefinitionModel or ClientRawResponse if raw=true
        :rtype: ~softheon.enterprise.api.client.models.EntityDefinitionModel
         or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/v1/template/ftl/{id}'
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200, 404]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('EntityDefinitionModel', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def update_template_by_id(
            self, id, model, custom_headers=None, raw=False, **operation_config):
        """Updates a specified entity template definition by identifier.

        :param id: The unique template identifier.
        :type id: str
        :param model: The entity template model.
        :type model:
         ~softheon.enterprise.api.client.models.UpdateEntityDefinitionRequestModel
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: object or ClientRawResponse if raw=true
        :rtype: object or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/v1/template/ftl/{id}'
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        body_content = self._serialize.body(model, 'UpdateEntityDefinitionRequestModel')

        # Construct and send request
        request = self._client.put(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, stream=False, **operation_config)

        if response.status_code not in [204, 403, 404]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 204:
            deserialized = self._deserialize('object', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def delete_template_by_id(
            self, id, custom_headers=None, raw=False, **operation_config):
        """Deletes a specified entity template definition by identifier.

        :param id: The unique template identifier.
        :type id: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: object or ClientRawResponse if raw=true
        :rtype: object or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/v1/template/ftl/{id}'
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.delete(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [204, 403, 404]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 204:
            deserialized = self._deserialize('object', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def validate_template_field(
            self, type, field_id, sort_column=None, metadata=None, page=None, page_size=None, sort_order=None, sort_by=None, custom_headers=None, raw=False, **operation_config):
        """Validates the specified template field.

        :param type: The template type.
        :type type: int
        :param field_id: The field name.
        :type field_id: str
        :param sort_column: Gets or sets the sort column.
        :type sort_column: str
        :param metadata: Gets or sets the metadata search options.
        :type metadata: list[object]
        :param page: Gets or sets the page number.
        :type page: int
        :param page_size: Gets or sets the size of the page.
        :type page_size: int
        :param sort_order: Gets or sets the order. Possible values include:
         'Unspecified', 'Ascending', 'Descending'
        :type sort_order: str
        :param sort_by: Gets or sets the column to order by.
        :type sort_by: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: FieldValidationModel or ClientRawResponse if raw=true
        :rtype: ~softheon.enterprise.api.client.models.FieldValidationModel or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/v1/template/ftl/{type}/validate/{fieldID}'
        path_format_arguments = {
            'type': self._serialize.url("type", type, 'int'),
            'fieldID': self._serialize.url("field_id", field_id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}
        if sort_column is not None:
            query_parameters['sortColumn'] = self._serialize.query("sort_column", sort_column, 'str')
        if metadata is not None:
            query_parameters['metadata'] = self._serialize.query("metadata", metadata, '[object]', div=',')
        if page is not None:
            query_parameters['page'] = self._serialize.query("page", page, 'int', maximum=2147483647, minimum=1)
        if page_size is not None:
            query_parameters['pageSize'] = self._serialize.query("page_size", page_size, 'int', maximum=1000, minimum=1)
        if sort_order is not None:
            query_parameters['sortOrder'] = self._serialize.query("sort_order", sort_order, 'str')
        if sort_by is not None:
            query_parameters['sortBy'] = self._serialize.query("sort_by", sort_by, 'int')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200, 404]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('FieldValidationModel', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def get_groups_by_filter(
            self, i_d=None, user_id=None, name=None, type=None, state=None, page=None, page_size=None, sort_order=None, sort_by=None, custom_headers=None, raw=False, **operation_config):
        """Gets a paged list of groups.

        :param i_d: Gets or sets the group identifier.
        :type i_d: int
        :param user_id: Gets or sets the user identifier.
        :type user_id: int
        :param name: Gets or sets the name.
        :type name: str
        :param type: Gets or sets the type. Possible values include:
         'Generic', 'Access', 'Role'
        :type type: str
        :param state: Gets or sets the state. Possible values include:
         'Inactive', 'Active'
        :type state: str
        :param page: Gets or sets the page number.
        :type page: int
        :param page_size: Gets or sets the size of the page.
        :type page_size: int
        :param sort_order: Gets or sets the order. Possible values include:
         'Unspecified', 'Ascending', 'Descending'
        :type sort_order: str
        :param sort_by: Gets or sets the column to order by. Possible values
         include: 'ID', 'Name', 'Type', 'State'
        :type sort_by: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: list or ClientRawResponse if raw=true
        :rtype: list[~softheon.enterprise.api.client.models.GroupModel] or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/v1/directory/groups'

        # Construct parameters
        query_parameters = {}
        if i_d is not None:
            query_parameters['iD'] = self._serialize.query("i_d", i_d, 'int', maximum=2147483647, minimum=1)
        if user_id is not None:
            query_parameters['userID'] = self._serialize.query("user_id", user_id, 'int', maximum=2147483647, minimum=1)
        if name is not None:
            query_parameters['name'] = self._serialize.query("name", name, 'str', max_length=255, min_length=0)
        if type is not None:
            query_parameters['type'] = self._serialize.query("type", type, 'str')
        if state is not None:
            query_parameters['state'] = self._serialize.query("state", state, 'str')
        if page is not None:
            query_parameters['page'] = self._serialize.query("page", page, 'int', maximum=2147483647, minimum=1)
        if page_size is not None:
            query_parameters['pageSize'] = self._serialize.query("page_size", page_size, 'int', maximum=1000, minimum=1)
        if sort_order is not None:
            query_parameters['sortOrder'] = self._serialize.query("sort_order", sort_order, 'str')
        if sort_by is not None:
            query_parameters['sortBy'] = self._serialize.query("sort_by", sort_by, 'str')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200, 403]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('[GroupModel]', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def create_group(
            self, model, custom_headers=None, raw=False, **operation_config):
        """Creates a new group.

        :param model: The group model.
        :type model:
         ~softheon.enterprise.api.client.models.InsertGroupRequestModel
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: GroupModel or ClientRawResponse if raw=true
        :rtype: ~softheon.enterprise.api.client.models.GroupModel or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/v1/directory/groups'

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        body_content = self._serialize.body(model, 'InsertGroupRequestModel')

        # Construct and send request
        request = self._client.post(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, stream=False, **operation_config)

        if response.status_code not in [201, 403, 409]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 201:
            deserialized = self._deserialize('GroupModel', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def get_group_by_id(
            self, id, custom_headers=None, raw=False, **operation_config):
        """Gets a single group by its unique identifier.

        :param id: The group identifier.
        :type id: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: GroupModel or ClientRawResponse if raw=true
        :rtype: ~softheon.enterprise.api.client.models.GroupModel or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/v1/directory/groups/{id}'
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200, 403, 404]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('GroupModel', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def update_group(
            self, id, model, custom_headers=None, raw=False, **operation_config):
        """Updates a specified group.

        :param id: The group identifier.
        :type id: int
        :param model: The group model.
        :type model: ~softheon.enterprise.api.client.models.GroupBase
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: object or ClientRawResponse if raw=true
        :rtype: object or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/v1/directory/groups/{id}'
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        body_content = self._serialize.body(model, 'GroupBase')

        # Construct and send request
        request = self._client.put(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, stream=False, **operation_config)

        if response.status_code not in [204, 403, 404, 500]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 204:
            deserialized = self._deserialize('object', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def delete_group(
            self, id, custom_headers=None, raw=False, **operation_config):
        """Deactivates a group and removes all group associations.

        :param id: The group identifier.
        :type id: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: object or ClientRawResponse if raw=true
        :rtype: object or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/v1/directory/groups/{id}'
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.delete(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [204, 403, 404, 500]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 204:
            deserialized = self._deserialize('object', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def get_links_by_filter(
            self, child_entity_id=None, child_drawer_id=None, child_type=None, acl=None, entity_id=None, drawer_id=None, name=None, creator_user_id=None, modifier_user_id=None, min_insertion_time=None, max_insertion_time=None, min_modification_time=None, max_modification_time=None, page=None, page_size=None, sort_order=None, sort_by=None, custom_headers=None, raw=False, **operation_config):
        """Gets a paged list of entity links.

        :param child_entity_id: Gets or sets the child entity identifier.
        :type child_entity_id: int
        :param child_drawer_id: Gets or sets the child drawer identifier.
        :type child_drawer_id: int
        :param child_type: Gets or sets the type of the child.
        :type child_type: int
        :param acl: Gets or sets the access control list.
        :type acl: int
        :param entity_id: Gets or sets the entity identifier.
        :type entity_id: int
        :param drawer_id: Gets or sets the drawer identifier.
        :type drawer_id: int
        :param name: Gets or sets the name.
        :type name: str
        :param creator_user_id: Gets or sets the creator user identifier.
        :type creator_user_id: int
        :param modifier_user_id: Gets or sets the modifier user identifier.
        :type modifier_user_id: int
        :param min_insertion_time: Gets or sets the minimum insertion time.
        :type min_insertion_time: datetime
        :param max_insertion_time: Gets or sets the maximum insertion time.
        :type max_insertion_time: datetime
        :param min_modification_time: Gets or sets the minimum modification
         time.
        :type min_modification_time: datetime
        :param max_modification_time: Gets or sets the maximum modification
         time.
        :type max_modification_time: datetime
        :param page: Gets or sets the page number.
        :type page: int
        :param page_size: Gets or sets the size of the page.
        :type page_size: int
        :param sort_order: Gets or sets the order. Possible values include:
         'Unspecified', 'Ascending', 'Descending'
        :type sort_order: str
        :param sort_by: Gets or sets the column to order by. Possible values
         include: 'PageNumber', 'ID', 'Type', 'InsertionTime',
         'ModificationTime', 'CrossReferenceID', 'SubType', 'Extension', 'Name'
        :type sort_by: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: list or ClientRawResponse if raw=true
        :rtype: list[~softheon.enterprise.api.client.models.EntityLinkModel]
         or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/v1/content/links'

        # Construct parameters
        query_parameters = {}
        if child_entity_id is not None:
            query_parameters['childEntityID'] = self._serialize.query("child_entity_id", child_entity_id, 'int', maximum=2147483647, minimum=1)
        if child_drawer_id is not None:
            query_parameters['childDrawerID'] = self._serialize.query("child_drawer_id", child_drawer_id, 'int', maximum=2147483647, minimum=1)
        if child_type is not None:
            query_parameters['childType'] = self._serialize.query("child_type", child_type, 'int', maximum=2147483647, minimum=1)
        if acl is not None:
            query_parameters['acl'] = self._serialize.query("acl", acl, 'int')
        if entity_id is not None:
            query_parameters['entityID'] = self._serialize.query("entity_id", entity_id, 'int', maximum=2147483647, minimum=1)
        if drawer_id is not None:
            query_parameters['drawerID'] = self._serialize.query("drawer_id", drawer_id, 'int', maximum=2147483647, minimum=1)
        if name is not None:
            query_parameters['name'] = self._serialize.query("name", name, 'str', max_length=255, min_length=0)
        if creator_user_id is not None:
            query_parameters['creatorUserID'] = self._serialize.query("creator_user_id", creator_user_id, 'int', maximum=2147483647, minimum=1)
        if modifier_user_id is not None:
            query_parameters['modifierUserID'] = self._serialize.query("modifier_user_id", modifier_user_id, 'int', maximum=2147483647, minimum=1)
        if min_insertion_time is not None:
            query_parameters['minInsertionTime'] = self._serialize.query("min_insertion_time", min_insertion_time, 'iso-8601')
        if max_insertion_time is not None:
            query_parameters['maxInsertionTime'] = self._serialize.query("max_insertion_time", max_insertion_time, 'iso-8601')
        if min_modification_time is not None:
            query_parameters['minModificationTime'] = self._serialize.query("min_modification_time", min_modification_time, 'iso-8601')
        if max_modification_time is not None:
            query_parameters['maxModificationTime'] = self._serialize.query("max_modification_time", max_modification_time, 'iso-8601')
        if page is not None:
            query_parameters['page'] = self._serialize.query("page", page, 'int', maximum=2147483647, minimum=1)
        if page_size is not None:
            query_parameters['pageSize'] = self._serialize.query("page_size", page_size, 'int', maximum=1000, minimum=1)
        if sort_order is not None:
            query_parameters['sortOrder'] = self._serialize.query("sort_order", sort_order, 'str')
        if sort_by is not None:
            query_parameters['sortBy'] = self._serialize.query("sort_by", sort_by, 'str')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('[EntityLinkModel]', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def get_link_by_id(
            self, drawer, id, custom_headers=None, raw=False, **operation_config):
        """Gets a link based on its unique identifier.

        :param drawer: The drawer identifier.
        :type drawer: int
        :param id: The link identifier.
        :type id: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: EntityLinkModel or ClientRawResponse if raw=true
        :rtype: ~softheon.enterprise.api.client.models.EntityLinkModel or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/v1/content/links/{drawer}/{id}'
        path_format_arguments = {
            'drawer': self._serialize.url("drawer", drawer, 'int'),
            'id': self._serialize.url("id", id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200, 403, 404]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('EntityLinkModel', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def update_link(
            self, drawer, id, model, custom_headers=None, raw=False, **operation_config):
        """Updates a specified link.

        :param drawer: The drawer identifier.
        :type drawer: int
        :param id: The link identifier.
        :type id: int
        :param model: The model.
        :type model:
         ~softheon.enterprise.api.client.models.UpdateEntityLinkRequestModel
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: object or ClientRawResponse if raw=true
        :rtype: object or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/v1/content/links/{drawer}/{id}'
        path_format_arguments = {
            'drawer': self._serialize.url("drawer", drawer, 'int'),
            'id': self._serialize.url("id", id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        body_content = self._serialize.body(model, 'UpdateEntityLinkRequestModel')

        # Construct and send request
        request = self._client.put(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, stream=False, **operation_config)

        if response.status_code not in [204, 403, 404]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 204:
            deserialized = self._deserialize('object', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def delete_link(
            self, drawer, id, custom_headers=None, raw=False, **operation_config):
        """Deletes a specified link.

        :param drawer: The drawer identifier.
        :type drawer: int
        :param id: The link identifier.
        :type id: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: object or ClientRawResponse if raw=true
        :rtype: object or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/v1/content/links/{drawer}/{id}'
        path_format_arguments = {
            'drawer': self._serialize.url("drawer", drawer, 'int'),
            'id': self._serialize.url("id", id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.delete(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [204, 403, 404]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 204:
            deserialized = self._deserialize('object', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def create_link(
            self, drawer, model, custom_headers=None, raw=False, **operation_config):
        """Creates a new link.

        :param drawer: The drawer identifier.
        :type drawer: int
        :param model: The link model.
        :type model:
         ~softheon.enterprise.api.client.models.InsertEntityLinkRequestModel
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: EntityLinkModel or ClientRawResponse if raw=true
        :rtype: ~softheon.enterprise.api.client.models.EntityLinkModel or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/v1/content/links/{drawer}'
        path_format_arguments = {
            'drawer': self._serialize.url("drawer", drawer, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        body_content = self._serialize.body(model, 'InsertEntityLinkRequestModel')

        # Construct and send request
        request = self._client.post(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, stream=False, **operation_config)

        if response.status_code not in [201, 403, 404, 409]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 201:
            deserialized = self._deserialize('EntityLinkModel', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def get_locks_by_filter(
            self, drawer, id, custom_headers=None, raw=False, **operation_config):
        """Gets a lock for a single entity based on its unique identifier.

        :param drawer: The drawer identifier.
        :type drawer: int
        :param id: The entity identifier.
        :type id: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: LockModel or ClientRawResponse if raw=true
        :rtype: ~softheon.enterprise.api.client.models.LockModel or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/v1/content/entities/{drawer}/{id}/locks'
        path_format_arguments = {
            'drawer': self._serialize.url("drawer", drawer, 'int'),
            'id': self._serialize.url("id", id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200, 404]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('LockModel', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def create_or_update_lock(
            self, drawer, id, model, custom_headers=None, raw=False, **operation_config):
        """Inserts or updates lock on a specified entity.

        :param drawer: The drawer identifier.
        :type drawer: int
        :param id: The entity identifier.
        :type id: int
        :param model: The lock model.
        :type model:
         ~softheon.enterprise.api.client.models.UpdateLockRequestModel
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: object or ClientRawResponse if raw=true
        :rtype: object or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/v1/content/entities/{drawer}/{id}/locks'
        path_format_arguments = {
            'drawer': self._serialize.url("drawer", drawer, 'int'),
            'id': self._serialize.url("id", id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        body_content = self._serialize.body(model, 'UpdateLockRequestModel')

        # Construct and send request
        request = self._client.put(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, stream=False, **operation_config)

        if response.status_code not in [201, 403, 404]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 201:
            deserialized = self._deserialize('object', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def delete_lock(
            self, drawer, id, custom_headers=None, raw=False, **operation_config):
        """Deletes a lock on a specified entity.

        :param drawer: The drawer identifier.
        :type drawer: int
        :param id: The entity identifier.
        :type id: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: object or ClientRawResponse if raw=true
        :rtype: object or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/v1/content/entities/{drawer}/{id}/locks'
        path_format_arguments = {
            'drawer': self._serialize.url("drawer", drawer, 'int'),
            'id': self._serialize.url("id", id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.delete(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [204, 403, 404]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 204:
            deserialized = self._deserialize('object', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def get_notes_by_filter(
            self, drawer_id, entity_id=None, name=None, creator_user_id=None, modifier_user_id=None, min_creation_time=None, max_creation_time=None, min_modification_time=None, max_modification_time=None, parent_id=None, page=None, page_size=None, sort_order=None, sort_by=None, custom_headers=None, raw=False, **operation_config):
        """Gets a paged list of notes.

        :param drawer_id: Gets or sets the drawer identifier.
        :type drawer_id: int
        :param entity_id: Gets or sets the entity identifier.
        :type entity_id: int
        :param name: Gets or sets the name.
        :type name: str
        :param creator_user_id: Gets or sets the creator user identifier.
        :type creator_user_id: int
        :param modifier_user_id: Gets or sets the modifier user identifier.
        :type modifier_user_id: int
        :param min_creation_time: Gets or sets the minimum creation time.
        :type min_creation_time: datetime
        :param max_creation_time: Gets or sets the maximum creation time.
        :type max_creation_time: datetime
        :param min_modification_time: Gets or sets the minimum modification
         time.
        :type min_modification_time: datetime
        :param max_modification_time: Gets or sets the maximum modification
         time.
        :type max_modification_time: datetime
        :param parent_id: Gets or sets the parent note identifier.
        :type parent_id: int
        :param page: Gets or sets the page number.
        :type page: int
        :param page_size: Gets or sets the size of the page.
        :type page_size: int
        :param sort_order: Gets or sets the order. Possible values include:
         'Unspecified', 'Ascending', 'Descending'
        :type sort_order: str
        :param sort_by: Gets or sets the column to order by. Possible values
         include: 'ID', 'EntityID', 'Name', 'CreationTime', 'ModificationTime'
        :type sort_by: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: list or ClientRawResponse if raw=true
        :rtype: list[~softheon.enterprise.api.client.models.NoteModel] or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/v1/content/notes'

        # Construct parameters
        query_parameters = {}
        query_parameters['drawerID'] = self._serialize.query("drawer_id", drawer_id, 'int', maximum=2147483647, minimum=1)
        if entity_id is not None:
            query_parameters['entityID'] = self._serialize.query("entity_id", entity_id, 'int', maximum=2147483647, minimum=1)
        if name is not None:
            query_parameters['name'] = self._serialize.query("name", name, 'str', max_length=255, min_length=0)
        if creator_user_id is not None:
            query_parameters['creatorUserID'] = self._serialize.query("creator_user_id", creator_user_id, 'int', maximum=2147483647, minimum=1)
        if modifier_user_id is not None:
            query_parameters['modifierUserID'] = self._serialize.query("modifier_user_id", modifier_user_id, 'int', maximum=2147483647, minimum=1)
        if min_creation_time is not None:
            query_parameters['minCreationTime'] = self._serialize.query("min_creation_time", min_creation_time, 'iso-8601')
        if max_creation_time is not None:
            query_parameters['maxCreationTime'] = self._serialize.query("max_creation_time", max_creation_time, 'iso-8601')
        if min_modification_time is not None:
            query_parameters['minModificationTime'] = self._serialize.query("min_modification_time", min_modification_time, 'iso-8601')
        if max_modification_time is not None:
            query_parameters['maxModificationTime'] = self._serialize.query("max_modification_time", max_modification_time, 'iso-8601')
        if parent_id is not None:
            query_parameters['parentID'] = self._serialize.query("parent_id", parent_id, 'int', maximum=2147483647, minimum=1)
        if page is not None:
            query_parameters['page'] = self._serialize.query("page", page, 'int', maximum=2147483647, minimum=1)
        if page_size is not None:
            query_parameters['pageSize'] = self._serialize.query("page_size", page_size, 'int', maximum=1000, minimum=1)
        if sort_order is not None:
            query_parameters['sortOrder'] = self._serialize.query("sort_order", sort_order, 'str')
        if sort_by is not None:
            query_parameters['sortBy'] = self._serialize.query("sort_by", sort_by, 'str')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('[NoteModel]', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def get_note_by_id(
            self, drawer, id, custom_headers=None, raw=False, **operation_config):
        """Gets a note by its unique identifier.

        :param drawer: The drawer identifier.
        :type drawer: int
        :param id: The note identifier.
        :type id: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: NoteModel or ClientRawResponse if raw=true
        :rtype: ~softheon.enterprise.api.client.models.NoteModel or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/v1/content/notes/{drawer}/{id}'
        path_format_arguments = {
            'drawer': self._serialize.url("drawer", drawer, 'int'),
            'id': self._serialize.url("id", id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200, 403, 404]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('NoteModel', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def update_note(
            self, drawer, id, model, custom_headers=None, raw=False, **operation_config):
        """Updates a specified note.

        :param drawer: The drawer identifier.
        :type drawer: int
        :param id: The note identifier.
        :type id: int
        :param model: The note model.
        :type model: ~softheon.enterprise.api.client.models.NoteBase
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: object or ClientRawResponse if raw=true
        :rtype: object or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/v1/content/notes/{drawer}/{id}'
        path_format_arguments = {
            'drawer': self._serialize.url("drawer", drawer, 'int'),
            'id': self._serialize.url("id", id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        body_content = self._serialize.body(model, 'NoteBase')

        # Construct and send request
        request = self._client.put(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, stream=False, **operation_config)

        if response.status_code not in [204, 403, 404]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 204:
            deserialized = self._deserialize('object', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def delete_note(
            self, drawer, id, custom_headers=None, raw=False, **operation_config):
        """Deletes a specified note.

        :param drawer: The drawer identifier.
        :type drawer: int
        :param id: The note identifier.
        :type id: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: object or ClientRawResponse if raw=true
        :rtype: object or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/v1/content/notes/{drawer}/{id}'
        path_format_arguments = {
            'drawer': self._serialize.url("drawer", drawer, 'int'),
            'id': self._serialize.url("id", id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.delete(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [204, 403, 404]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 204:
            deserialized = self._deserialize('object', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def create_note(
            self, drawer, model, custom_headers=None, raw=False, **operation_config):
        """Creates a new note.

        :param drawer: The drawer identifier.
        :type drawer: int
        :param model: The note model.
        :type model:
         ~softheon.enterprise.api.client.models.InsertNoteRequestModel
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: NoteModel or ClientRawResponse if raw=true
        :rtype: ~softheon.enterprise.api.client.models.NoteModel or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/v1/content/notes/{drawer}'
        path_format_arguments = {
            'drawer': self._serialize.url("drawer", drawer, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        body_content = self._serialize.body(model, 'InsertNoteRequestModel')

        # Construct and send request
        request = self._client.post(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, stream=False, **operation_config)

        if response.status_code not in [201, 403, 404]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 201:
            deserialized = self._deserialize('NoteModel', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def get_queue_assignments_by_filter(
            self, queue_id=None, user_id=None, group_id=None, type=None, order=None, task_sort_column=None, state=None, fetch_type=None, page=None, page_size=None, sort_order=None, sort_by=None, custom_headers=None, raw=False, **operation_config):
        """Gets a paged list of queue assignments.

        :param queue_id: Gets or sets the unique queue identifier.
        :type queue_id: int
        :param user_id: Gets or sets the user identifier.
        :type user_id: int
        :param group_id: Gets or sets the group identifier.
        :type group_id: int
        :param type: Gets or sets the queue assignment type. Possible values
         include: 'Unspecified', 'Primary', 'Secondary'
        :type type: str
        :param order: Gets or sets the sort order.
        :type order: int
        :param task_sort_column: Gets or sets the task sort column. Possible
         values include: 'TaskID', 'QueueID', 'DrawerID', 'AddressID',
         'ObjectID', 'ObjectType', 'State', 'Priority', 'Description',
         'Message1', 'Message2', 'Message3', 'Message4', 'Message5',
         'OwnerUserID', 'OwnerGroupID', 'EffectiveUserID', 'EffectiveGroupID',
         'PreviousQueueID', 'NextQueueID', 'InsertionTime', 'ResolutionTime',
         'TaskFileAttachment', 'ReservedInt1', 'ReservedString1'
        :type task_sort_column: str
        :param state: Gets or sets the state. Possible values include:
         'Unspecified', 'Inactive', 'Active'
        :type state: str
        :param fetch_type: Gets or sets the type of the fetch. Possible values
         include: 'Unspecified', 'Manual', 'Push'
        :type fetch_type: str
        :param page: Gets or sets the page number.
        :type page: int
        :param page_size: Gets or sets the size of the page.
        :type page_size: int
        :param sort_order: Gets or sets the order. Possible values include:
         'Unspecified', 'Ascending', 'Descending'
        :type sort_order: str
        :param sort_by: Gets or sets the column to order by. Possible values
         include: 'QueueID', 'UserID', 'GroupID', 'Type', 'State', 'Order',
         'FetchType'
        :type sort_by: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: list or ClientRawResponse if raw=true
        :rtype:
         list[~softheon.enterprise.api.client.models.QueueAssignmentModel] or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/v1/workflow/assignments'

        # Construct parameters
        query_parameters = {}
        if queue_id is not None:
            query_parameters['queueID'] = self._serialize.query("queue_id", queue_id, 'int', maximum=2147483647, minimum=1)
        if user_id is not None:
            query_parameters['userID'] = self._serialize.query("user_id", user_id, 'int', maximum=2147483647, minimum=1)
        if group_id is not None:
            query_parameters['groupID'] = self._serialize.query("group_id", group_id, 'int', maximum=2147483647, minimum=1)
        if type is not None:
            query_parameters['type'] = self._serialize.query("type", type, 'str')
        if order is not None:
            query_parameters['order'] = self._serialize.query("order", order, 'int', maximum=2147483647, minimum=1)
        if task_sort_column is not None:
            query_parameters['taskSortColumn'] = self._serialize.query("task_sort_column", task_sort_column, 'str')
        if state is not None:
            query_parameters['state'] = self._serialize.query("state", state, 'str')
        if fetch_type is not None:
            query_parameters['fetchType'] = self._serialize.query("fetch_type", fetch_type, 'str')
        if page is not None:
            query_parameters['page'] = self._serialize.query("page", page, 'int', maximum=2147483647, minimum=1)
        if page_size is not None:
            query_parameters['pageSize'] = self._serialize.query("page_size", page_size, 'int', maximum=1000, minimum=1)
        if sort_order is not None:
            query_parameters['sortOrder'] = self._serialize.query("sort_order", sort_order, 'str')
        if sort_by is not None:
            query_parameters['sortBy'] = self._serialize.query("sort_by", sort_by, 'str')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200, 403]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('[QueueAssignmentModel]', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def update_queue_assignemnt(
            self, model, custom_headers=None, raw=False, **operation_config):
        """Updates the specified queue assignment.

        :param model: The model.
        :type model:
         ~softheon.enterprise.api.client.models.QueueAssignmentModel
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: object or ClientRawResponse if raw=true
        :rtype: object or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/v1/workflow/assignments'

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        body_content = self._serialize.body(model, 'QueueAssignmentModel')

        # Construct and send request
        request = self._client.put(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, stream=False, **operation_config)

        if response.status_code not in [204, 403, 404]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 204:
            deserialized = self._deserialize('object', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def create_queue_assignment(
            self, model, custom_headers=None, raw=False, **operation_config):
        """Creates a new queue assignment.

        :param model: The model.
        :type model:
         ~softheon.enterprise.api.client.models.InsertQueueAssignmentRequestModel
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: QueueAssignmentModel or ClientRawResponse if raw=true
        :rtype: ~softheon.enterprise.api.client.models.QueueAssignmentModel or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/v1/workflow/assignments'

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        body_content = self._serialize.body(model, 'InsertQueueAssignmentRequestModel')

        # Construct and send request
        request = self._client.post(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, stream=False, **operation_config)

        if response.status_code not in [201, 403, 404, 409]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 201:
            deserialized = self._deserialize('QueueAssignmentModel', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def get_queue_assignments_by_id(
            self, user_id, queue_id, custom_headers=None, raw=False, **operation_config):
        """Gets a single queue assignment based on user and queue identifiers.

        :param user_id: The user identifier.
        :type user_id: int
        :param queue_id: The queue identifier.
        :type queue_id: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: QueueAssignmentModel or ClientRawResponse if raw=true
        :rtype: ~softheon.enterprise.api.client.models.QueueAssignmentModel or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/v1/workflow/assignments/users/{userId}/queues/{queueId}'
        path_format_arguments = {
            'userId': self._serialize.url("user_id", user_id, 'int'),
            'queueId': self._serialize.url("queue_id", queue_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200, 403, 404]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('QueueAssignmentModel', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def delete_queue_assignment(
            self, user_id, queue_id, custom_headers=None, raw=False, **operation_config):
        """Deletes the specified queue assignment.

        :param user_id: The user identifier.
        :type user_id: int
        :param queue_id: The queue identifier.
        :type queue_id: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: object or ClientRawResponse if raw=true
        :rtype: object or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/v1/workflow/assignments/users/{userId}/queues/{queueId}'
        path_format_arguments = {
            'userId': self._serialize.url("user_id", user_id, 'int'),
            'queueId': self._serialize.url("queue_id", queue_id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.delete(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [204, 403, 404]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 204:
            deserialized = self._deserialize('object', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def get_queues_by_filter(
            self, i_d=None, name=None, alias=None, type=None, access=None, bypass_security=None, page=None, page_size=None, sort_order=None, sort_by=None, custom_headers=None, raw=False, **operation_config):
        """Gets a paged list of queues.

        :param i_d: Gets or sets the queue identifier.
        :type i_d: int
        :param name: Gets or sets the name.
        :type name: str
        :param alias: Gets or sets the alias.
        :type alias: str
        :param type: Gets or sets the type. Possible values include:
         'Inbound', 'Outbound', 'Access', 'Any', 'Shared', 'Public', 'Recycle',
         'Fax', 'Print', 'Scan', 'Ocr', 'Workflow', 'Schedule', 'System',
         'Other', 'CdoInfostore', 'CdoFolder'
        :type type: str
        :param access: Gets or sets the access level.
        :type access: int
        :param bypass_security: Gets or sets a value indicating whether to
         bypass security checks.
        :type bypass_security: bool
        :param page: Gets or sets the page number.
        :type page: int
        :param page_size: Gets or sets the size of the page.
        :type page_size: int
        :param sort_order: Gets or sets the order. Possible values include:
         'Unspecified', 'Ascending', 'Descending'
        :type sort_order: str
        :param sort_by: Gets or sets the column to order by. Possible values
         include: 'ID', 'Type', 'Name', 'Alias'
        :type sort_by: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: list or ClientRawResponse if raw=true
        :rtype: list[~softheon.enterprise.api.client.models.QueueModel] or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/v1/workflow/queues'

        # Construct parameters
        query_parameters = {}
        if i_d is not None:
            query_parameters['iD'] = self._serialize.query("i_d", i_d, 'int', maximum=2147483647, minimum=1)
        if name is not None:
            query_parameters['name'] = self._serialize.query("name", name, 'str', max_length=255, min_length=0)
        if alias is not None:
            query_parameters['alias'] = self._serialize.query("alias", alias, 'str', max_length=255, min_length=0)
        if type is not None:
            query_parameters['type'] = self._serialize.query("type", type, 'str')
        if access is not None:
            query_parameters['access'] = self._serialize.query("access", access, 'int')
        if bypass_security is not None:
            query_parameters['bypassSecurity'] = self._serialize.query("bypass_security", bypass_security, 'bool')
        if page is not None:
            query_parameters['page'] = self._serialize.query("page", page, 'int', maximum=2147483647, minimum=1)
        if page_size is not None:
            query_parameters['pageSize'] = self._serialize.query("page_size", page_size, 'int', maximum=1000, minimum=1)
        if sort_order is not None:
            query_parameters['sortOrder'] = self._serialize.query("sort_order", sort_order, 'str')
        if sort_by is not None:
            query_parameters['sortBy'] = self._serialize.query("sort_by", sort_by, 'str')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('[QueueModel]', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def create_queue(
            self, model, custom_headers=None, raw=False, **operation_config):
        """Creates a new queue.

        :param model: The queue model.
        :type model:
         ~softheon.enterprise.api.client.models.InsertQueueRequestModel
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: QueueModel or ClientRawResponse if raw=true
        :rtype: ~softheon.enterprise.api.client.models.QueueModel or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/v1/workflow/queues'

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        body_content = self._serialize.body(model, 'InsertQueueRequestModel')

        # Construct and send request
        request = self._client.post(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, stream=False, **operation_config)

        if response.status_code not in [201, 403]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 201:
            deserialized = self._deserialize('QueueModel', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def get_queue_by_id(
            self, id, custom_headers=None, raw=False, **operation_config):
        """Gets a single queue by its unique identifier.

        :param id: The queue identifier.
        :type id: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: QueueModel or ClientRawResponse if raw=true
        :rtype: ~softheon.enterprise.api.client.models.QueueModel or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/v1/workflow/queues/{id}'
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200, 404]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('QueueModel', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def update_queue(
            self, id, model, custom_headers=None, raw=False, **operation_config):
        """Updates a specified queue.

        :param id: The unique queue identifier.
        :type id: int
        :param model: The queue model.
        :type model: ~softheon.enterprise.api.client.models.QueueBase
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: object or ClientRawResponse if raw=true
        :rtype: object or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/v1/workflow/queues/{id}'
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        body_content = self._serialize.body(model, 'QueueBase')

        # Construct and send request
        request = self._client.put(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, stream=False, **operation_config)

        if response.status_code not in [200, 403, 404]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('object', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def delete_queue(
            self, id, custom_headers=None, raw=False, **operation_config):
        """Deletes a specified queue.

        :param id: The queue identifier.
        :type id: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: object or ClientRawResponse if raw=true
        :rtype: object or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/v1/workflow/queues/{id}'
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.delete(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [204, 403, 404]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 204:
            deserialized = self._deserialize('object', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def get_queue_by_name(
            self, name, custom_headers=None, raw=False, **operation_config):
        """Gets a single queue by its name.

        :param name: The queue name.
        :type name: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: QueueModel or ClientRawResponse if raw=true
        :rtype: ~softheon.enterprise.api.client.models.QueueModel or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/v1/workflow/queues/{name}'
        path_format_arguments = {
            'name': self._serialize.url("name", name, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200, 404]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('QueueModel', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def get_tasks_by_filter(
            self, last_task_id=None, i_d=None, type=None, queue_id=None, queue_type=None, drawer_id=None, description=None, task_id=None, page=None, page_size=None, sort_order=None, sort_by=None, custom_headers=None, raw=False, **operation_config):
        """Gets a paged list of tasks.

        :param last_task_id: Gets or sets the last task identifier.
        :type last_task_id: int
        :param i_d: Gets or sets the entity identifier.
        :type i_d: int
        :param type: Gets or sets the type of the entity.
        :type type: int
        :param queue_id: Gets or sets the queue identifier.
        :type queue_id: int
        :param queue_type: Gets or sets the type of the queue.
        :type queue_type: int
        :param drawer_id: Gets or sets the drawer identifier.
        :type drawer_id: int
        :param description: Gets or sets the task description.
        :type description: str
        :param task_id: Gets or sets the task identifier.
        :type task_id: int
        :param page: Gets or sets the page number.
        :type page: int
        :param page_size: Gets or sets the size of the page.
        :type page_size: int
        :param sort_order: Gets or sets the order. Possible values include:
         'Unspecified', 'Ascending', 'Descending'
        :type sort_order: str
        :param sort_by: Gets or sets the column to order by. Possible values
         include: 'TaskID', 'QueueID', 'ObjectID', 'Priority', 'Description',
         'InsertionTime', 'ResolutionTime', 'ReservedInt1'
        :type sort_by: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: list or ClientRawResponse if raw=true
        :rtype: list[~softheon.enterprise.api.client.models.TaskModel] or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/v1/workflow/tasks'

        # Construct parameters
        query_parameters = {}
        if last_task_id is not None:
            query_parameters['lastTaskID'] = self._serialize.query("last_task_id", last_task_id, 'int', maximum=2147483647, minimum=0)
        if i_d is not None:
            query_parameters['iD'] = self._serialize.query("i_d", i_d, 'int', maximum=2147483647, minimum=1)
        if type is not None:
            query_parameters['type'] = self._serialize.query("type", type, 'int')
        if queue_id is not None:
            query_parameters['queueID'] = self._serialize.query("queue_id", queue_id, 'int')
        if queue_type is not None:
            query_parameters['queueType'] = self._serialize.query("queue_type", queue_type, 'int', maximum=2147483647, minimum=1)
        if drawer_id is not None:
            query_parameters['drawerID'] = self._serialize.query("drawer_id", drawer_id, 'int', maximum=2147483647, minimum=1)
        if description is not None:
            query_parameters['description'] = self._serialize.query("description", description, 'str', max_length=255, min_length=0)
        if task_id is not None:
            query_parameters['taskID'] = self._serialize.query("task_id", task_id, 'int')
        if page is not None:
            query_parameters['page'] = self._serialize.query("page", page, 'int', maximum=2147483647, minimum=1)
        if page_size is not None:
            query_parameters['pageSize'] = self._serialize.query("page_size", page_size, 'int', maximum=1000, minimum=1)
        if sort_order is not None:
            query_parameters['sortOrder'] = self._serialize.query("sort_order", sort_order, 'str')
        if sort_by is not None:
            query_parameters['sortBy'] = self._serialize.query("sort_by", sort_by, 'str')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('[TaskModel]', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def create_task(
            self, model, custom_headers=None, raw=False, **operation_config):
        """Creates a new task.

        :param model: The task model.
        :type model:
         ~softheon.enterprise.api.client.models.InsertTaskRequestModel
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: object or ClientRawResponse if raw=true
        :rtype: object or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/v1/workflow/tasks'

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        body_content = self._serialize.body(model, 'InsertTaskRequestModel')

        # Construct and send request
        request = self._client.post(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, stream=False, **operation_config)

        if response.status_code not in [201, 403, 404, 409]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 201:
            deserialized = self._deserialize('object', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def get_task_by_id(
            self, id, custom_headers=None, raw=False, **operation_config):
        """Gets a single task based on its unique identifier.

        :param id: The identifier.
        :type id: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: TaskModel or ClientRawResponse if raw=true
        :rtype: ~softheon.enterprise.api.client.models.TaskModel or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/v1/workflow/tasks/{id}'
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200, 404]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('TaskModel', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def update_task(
            self, id, model, custom_headers=None, raw=False, **operation_config):
        """Updates a specified task.

        :param id: The identifier.
        :type id: int
        :param model: The task model.
        :type model: ~softheon.enterprise.api.client.models.TaskBase
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: object or ClientRawResponse if raw=true
        :rtype: object or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/v1/workflow/tasks/{id}'
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        body_content = self._serialize.body(model, 'TaskBase')

        # Construct and send request
        request = self._client.put(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, stream=False, **operation_config)

        if response.status_code not in [204, 403, 404]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 204:
            deserialized = self._deserialize('object', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def delete_task(
            self, id, custom_headers=None, raw=False, **operation_config):
        """Deletes a specified task.

        :param id: The identifier.
        :type id: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: object or ClientRawResponse if raw=true
        :rtype: object or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/v1/workflow/tasks/{id}'
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.delete(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [204, 403, 404]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 204:
            deserialized = self._deserialize('object', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def fetch_task_from_queue_assignment(
            self, custom_headers=None, raw=False, **operation_config):
        """Gets a single task based on user predefined queue assignment criteria.

        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: TaskModel or ClientRawResponse if raw=true
        :rtype: ~softheon.enterprise.api.client.models.TaskModel or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/v1/workflow/tasks/fetch'

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200, 404]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('TaskModel', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def get_users_by_filter(
            self, i_d=None, primary_group_id=None, group_id=None, group_name=None, username=None, type=None, state=None, full_name=None, page=None, page_size=None, sort_order=None, sort_by=None, custom_headers=None, raw=False, **operation_config):
        """Gets a paged list of users.Gets a paged list of users.

        :param i_d: Gets or sets the identifier.
        :type i_d: int
        :param primary_group_id: Gets or sets the primary group identifier.
        :type primary_group_id: int
        :param group_id: Gets or sets the group identifier.
        :type group_id: int
        :param group_name: Gets or sets the name of the group.
        :type group_name: str
        :param username: Gets or sets the username.
        :type username: str
        :param type: Gets or sets the type. Possible values include:
         'ImageDesk', 'PublishDesk', 'FaxDesk', 'CaptureDesk',
         'RecognitionDesk', 'PortalUser', 'AdminDesk', 'WorkflowDesk',
         'Benchmark', 'ReportDesk', 'ColdDesk', 'PortalDesk',
         'WorkflowArchitect', 'DocumentDesk', 'Poweruser'
        :type type: str
        :param state: Gets or sets the state. Possible values include:
         'Active', 'Inactive'
        :type state: str
        :param full_name: Gets or sets the full name.
        :type full_name: str
        :param page: Gets or sets the page number.
        :type page: int
        :param page_size: Gets or sets the size of the page.
        :type page_size: int
        :param sort_order: Gets or sets the order. Possible values include:
         'Unspecified', 'Ascending', 'Descending'
        :type sort_order: str
        :param sort_by: Gets or sets the column to order by. Possible values
         include: 'ID', 'PrimaryGroupID', 'Username', 'UserFullName', 'Type',
         'State'
        :type sort_by: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: list or ClientRawResponse if raw=true
        :rtype: list[~softheon.enterprise.api.client.models.UserModel] or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/v1/directory/users'

        # Construct parameters
        query_parameters = {}
        if i_d is not None:
            query_parameters['iD'] = self._serialize.query("i_d", i_d, 'int')
        if primary_group_id is not None:
            query_parameters['primaryGroupID'] = self._serialize.query("primary_group_id", primary_group_id, 'int')
        if group_id is not None:
            query_parameters['groupID'] = self._serialize.query("group_id", group_id, 'int')
        if group_name is not None:
            query_parameters['groupName'] = self._serialize.query("group_name", group_name, 'str')
        if username is not None:
            query_parameters['username'] = self._serialize.query("username", username, 'str')
        if type is not None:
            query_parameters['type'] = self._serialize.query("type", type, 'str')
        if state is not None:
            query_parameters['state'] = self._serialize.query("state", state, 'str')
        if full_name is not None:
            query_parameters['fullName'] = self._serialize.query("full_name", full_name, 'str')
        if page is not None:
            query_parameters['page'] = self._serialize.query("page", page, 'int', maximum=2147483647, minimum=1)
        if page_size is not None:
            query_parameters['pageSize'] = self._serialize.query("page_size", page_size, 'int', maximum=1000, minimum=1)
        if sort_order is not None:
            query_parameters['sortOrder'] = self._serialize.query("sort_order", sort_order, 'str')
        if sort_by is not None:
            query_parameters['sortBy'] = self._serialize.query("sort_by", sort_by, 'str')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200, 403]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('[UserModel]', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def create_user(
            self, model, custom_headers=None, raw=False, **operation_config):
        """Creates a new user.

        :param model: The user model.
        :type model:
         ~softheon.enterprise.api.client.models.InsertUserRequestModel
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: UserModel or ClientRawResponse if raw=true
        :rtype: ~softheon.enterprise.api.client.models.UserModel or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/v1/directory/users'

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        body_content = self._serialize.body(model, 'InsertUserRequestModel')

        # Construct and send request
        request = self._client.post(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, stream=False, **operation_config)

        if response.status_code not in [201, 403, 409]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 201:
            deserialized = self._deserialize('UserModel', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def get_user_by_id(
            self, id, custom_headers=None, raw=False, **operation_config):
        """Gets a single user by its unique identifier.

        :param id: The user identifier.
        :type id: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: UserModel or ClientRawResponse if raw=true
        :rtype: ~softheon.enterprise.api.client.models.UserModel or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/v1/directory/users/{id}'
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200, 403, 404]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('UserModel', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def update_user(
            self, id, model, custom_headers=None, raw=False, **operation_config):
        """Updates a specified user.

        :param id: The user identifier.
        :type id: int
        :param model: The user model.
        :type model: ~softheon.enterprise.api.client.models.UserBase
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: object or ClientRawResponse if raw=true
        :rtype: object or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/v1/directory/users/{id}'
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        body_content = self._serialize.body(model, 'UserBase')

        # Construct and send request
        request = self._client.put(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, stream=False, **operation_config)

        if response.status_code not in [204, 403, 404]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 204:
            deserialized = self._deserialize('object', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def delete_user(
            self, id, custom_headers=None, raw=False, **operation_config):
        """Deactivates a specified user and removes all user associations.

        :param id: The user identifier.
        :type id: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: object or ClientRawResponse if raw=true
        :rtype: object or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/v1/directory/users/{id}'
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.delete(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [204, 403, 404]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 204:
            deserialized = self._deserialize('object', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def get_workflows_by_filter(
            self, application_id=None, entity_type=None, name=None, page=None, page_size=None, sort_order=None, sort_by=None, custom_headers=None, raw=False, **operation_config):
        """Gets a paged list of workflows.

        :param application_id: Gets or sets the application identifier.
        :type application_id: int
        :param entity_type: Gets or sets the type of the entity.
        :type entity_type: int
        :param name: Gets or sets the name.
        :type name: str
        :param page: Gets or sets the page number.
        :type page: int
        :param page_size: Gets or sets the size of the page.
        :type page_size: int
        :param sort_order: Gets or sets the order. Possible values include:
         'Unspecified', 'Ascending', 'Descending'
        :type sort_order: str
        :param sort_by: Gets or sets the column to order by.
        :type sort_by: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: list or ClientRawResponse if raw=true
        :rtype: list[~softheon.enterprise.api.client.models.WorkflowModel] or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/v1/workflow/workflows'

        # Construct parameters
        query_parameters = {}
        if application_id is not None:
            query_parameters['applicationID'] = self._serialize.query("application_id", application_id, 'int', maximum=2147483647, minimum=1)
        if entity_type is not None:
            query_parameters['entityType'] = self._serialize.query("entity_type", entity_type, 'int', maximum=2147483647, minimum=1)
        if name is not None:
            query_parameters['name'] = self._serialize.query("name", name, 'str', max_length=255, min_length=0)
        if page is not None:
            query_parameters['page'] = self._serialize.query("page", page, 'int', maximum=2147483647, minimum=1)
        if page_size is not None:
            query_parameters['pageSize'] = self._serialize.query("page_size", page_size, 'int', maximum=1000, minimum=1)
        if sort_order is not None:
            query_parameters['sortOrder'] = self._serialize.query("sort_order", sort_order, 'str')
        if sort_by is not None:
            query_parameters['sortBy'] = self._serialize.query("sort_by", sort_by, 'int')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('[WorkflowModel]', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def get_workflow_by_id(
            self, id, custom_headers=None, raw=False, **operation_config):
        """Gets a single workflow based on its unique identifier.

        :param id: The workflow identifier.
        :type id: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: WorkflowModel or ClientRawResponse if raw=true
        :rtype: ~softheon.enterprise.api.client.models.WorkflowModel or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/v1/workflow/workflows/{id}'
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200, 404]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('WorkflowModel', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def get_workflow_queues_by_id(
            self, id, custom_headers=None, raw=False, **operation_config):
        """Gets queues for a specific workflow.

        :param id: The workflow identifier.
        :type id: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: list or ClientRawResponse if raw=true
        :rtype:
         list[~softheon.enterprise.api.client.models.WorkflowQueueModel] or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/v1/workflow/workflows/{id}/queue'
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200, 404]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('[WorkflowQueueModel]', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def get_xml_template_by_type(
            self, type, custom_headers=None, raw=False, **operation_config):
        """Gets a single entity template definition completed with all profiles
        definitions as XML entity definition.

        :param type: The unique template type.
        :type type: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: str or ClientRawResponse if raw=true
        :rtype: str or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/v1/template/xml/{type}'
        path_format_arguments = {
            'type': self._serialize.url("type", type, 'int')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200, 404]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('str', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def create_xml_template(
            self, custom_headers=None, raw=False, **operation_config):
        """Creates a new entity template definition.

        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: str or ClientRawResponse if raw=true
        :rtype: str or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/v1/template/xml'

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.post(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [201, 400, 403, 409]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 201:
            deserialized = self._deserialize('str', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
