/*
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is
 * regenerated.
 */

/* jshint latedef:false */
/* jshint forin:false */
/* jshint noempty:false */

'use strict';

const msRest = require('ms-rest');
const ServiceClient = msRest.ServiceClient;
const WebResource = msRest.WebResource;

const models = require('./models');


/**
 * @summary Accepts the task.
 *
 * @param {object} model The model.
 *
 * @param {number} [model.taskID] Gets or sets the task identifier.
 *
 * @param {number} [model.targetID] Gets or sets the target id.
 *
 * @param {string} [model.queueName] Gets or sets the name of the queue.
 *
 * @param {string} [model.source] Gets or sets the source.
 *
 * @param {string} [model.computer] Gets or sets the name of the computer.
 *
 * @param {string} [model.iPAddress] Gets or sets the IP address.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _acceptTask(model, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (model === null || model === undefined) {
      throw new Error('model cannot be null or undefined.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'v1/workflow/actions/accept';

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (model !== null && model !== undefined) {
      let requestModelMapper = new client.models['WorkflowActionModel']().mapper();
      requestModel = client.serialize(requestModelMapper, model, 'model');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(model, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 204 && statusCode !== 403 && statusCode !== 404) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 204) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = {
            required: false,
            serializedName: 'parsedResponse',
            type: {
              name: 'Object'
            }
          };
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Rejects the task.
 *
 * @param {object} model The model.
 *
 * @param {number} [model.taskID] Gets or sets the task identifier.
 *
 * @param {number} [model.targetID] Gets or sets the target id.
 *
 * @param {string} [model.queueName] Gets or sets the name of the queue.
 *
 * @param {string} [model.source] Gets or sets the source.
 *
 * @param {string} [model.computer] Gets or sets the name of the computer.
 *
 * @param {string} [model.iPAddress] Gets or sets the IP address.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _rejectTask(model, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (model === null || model === undefined) {
      throw new Error('model cannot be null or undefined.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'v1/workflow/actions/reject';

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (model !== null && model !== undefined) {
      let requestModelMapper = new client.models['WorkflowActionModel']().mapper();
      requestModel = client.serialize(requestModelMapper, model, 'model');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(model, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 204 && statusCode !== 403 && statusCode !== 404) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 204) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = {
            required: false,
            serializedName: 'parsedResponse',
            type: {
              name: 'Object'
            }
          };
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Suspends the task.
 *
 * @param {object} model The model.
 *
 * @param {number} [model.taskID] Gets or sets the task identifier.
 *
 * @param {number} [model.targetID] Gets or sets the target id.
 *
 * @param {string} [model.queueName] Gets or sets the name of the queue.
 *
 * @param {string} [model.source] Gets or sets the source.
 *
 * @param {string} [model.computer] Gets or sets the name of the computer.
 *
 * @param {string} [model.iPAddress] Gets or sets the IP address.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _suspendTask(model, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (model === null || model === undefined) {
      throw new Error('model cannot be null or undefined.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'v1/workflow/actions/suspend';

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (model !== null && model !== undefined) {
      let requestModelMapper = new client.models['WorkflowActionModel']().mapper();
      requestModel = client.serialize(requestModelMapper, model, 'model');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(model, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 204 && statusCode !== 403 && statusCode !== 404) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 204) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = {
            required: false,
            serializedName: 'parsedResponse',
            type: {
              name: 'Object'
            }
          };
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Routes the task.
 *
 * @param {object} model The model.
 *
 * @param {number} [model.drawerID] Gets or sets the drawer identifier.
 *
 * @param {number} [model.entityID] Gets or sets the entity identifier.
 *
 * @param {boolean} [model.keepOriginalTask] Gets or sets a value indicating
 * whether [keep original task].
 *
 * @param {number} [model.taskID] Gets or sets the task identifier.
 *
 * @param {number} [model.targetID] Gets or sets the target id.
 *
 * @param {string} [model.queueName] Gets or sets the name of the queue.
 *
 * @param {string} [model.source] Gets or sets the source.
 *
 * @param {string} [model.computer] Gets or sets the name of the computer.
 *
 * @param {string} [model.iPAddress] Gets or sets the IP address.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _routeTask(model, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (model === null || model === undefined) {
      throw new Error('model cannot be null or undefined.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'v1/workflow/actions/route';

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (model !== null && model !== undefined) {
      let requestModelMapper = new client.models['WorkflowActionRouteModel']().mapper();
      requestModel = client.serialize(requestModelMapper, model, 'model');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(model, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 204 && statusCode !== 403 && statusCode !== 404) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 204) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = {
            required: false,
            serializedName: 'parsedResponse',
            type: {
              name: 'Object'
            }
          };
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Overrides the task.
 *
 * @param {object} model The model.
 *
 * @param {number} [model.taskID] Gets or sets the task identifier.
 *
 * @param {number} [model.targetID] Gets or sets the target id.
 *
 * @param {string} [model.queueName] Gets or sets the name of the queue.
 *
 * @param {string} [model.source] Gets or sets the source.
 *
 * @param {string} [model.computer] Gets or sets the name of the computer.
 *
 * @param {string} [model.iPAddress] Gets or sets the IP address.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _overrideTask(model, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (model === null || model === undefined) {
      throw new Error('model cannot be null or undefined.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'v1/workflow/actions/override';

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (model !== null && model !== undefined) {
      let requestModelMapper = new client.models['WorkflowActionModel']().mapper();
      requestModel = client.serialize(requestModelMapper, model, 'model');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(model, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 204 && statusCode !== 403 && statusCode !== 404) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 204) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = {
            required: false,
            serializedName: 'parsedResponse',
            type: {
              name: 'Object'
            }
          };
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Resets the task.
 *
 * @param {object} model The model.
 *
 * @param {number} [model.taskID] Gets or sets the task identifier.
 *
 * @param {number} [model.targetID] Gets or sets the target id.
 *
 * @param {string} [model.queueName] Gets or sets the name of the queue.
 *
 * @param {string} [model.source] Gets or sets the source.
 *
 * @param {string} [model.computer] Gets or sets the name of the computer.
 *
 * @param {string} [model.iPAddress] Gets or sets the IP address.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _resetTask(model, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (model === null || model === undefined) {
      throw new Error('model cannot be null or undefined.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'v1/workflow/actions/reset';

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (model !== null && model !== undefined) {
      let requestModelMapper = new client.models['WorkflowActionModel']().mapper();
      requestModel = client.serialize(requestModelMapper, model, 'model');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(model, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 204 && statusCode !== 403 && statusCode !== 404) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 204) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = {
            required: false,
            serializedName: 'parsedResponse',
            type: {
              name: 'Object'
            }
          };
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Initializes the Workflow.
 *
 * @param {object} model The model.
 *
 * @param {number} [model.drawerID] Gets or sets the drawer identifier.
 *
 * @param {number} [model.entityID] Gets or sets the entity identifier.
 *
 * @param {array} [model.queueID] Gets or sets the queue identifier.
 *
 * @param {array} [model.queueName] Gets or sets the name of the queue.
 *
 * @param {string} [model.source] Gets or sets the source.
 *
 * @param {string} [model.computer] Gets or sets the name of the computer.
 *
 * @param {string} [model.iPAddress] Gets or sets the IP address.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _initializeEntityWorkflow(model, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (model === null || model === undefined) {
      throw new Error('model cannot be null or undefined.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'v1/workflow/actions/initialize';

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (model !== null && model !== undefined) {
      let requestModelMapper = new client.models['WorkflowActionInitializeModel']().mapper();
      requestModel = client.serialize(requestModelMapper, model, 'model');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(model, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 204 && statusCode !== 403 && statusCode !== 404) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 204) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = {
            required: false,
            serializedName: 'parsedResponse',
            type: {
              name: 'Object'
            }
          };
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets a list of all available applications.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {array} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getAllApplications(options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'v1/directory/applications';

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = {
            required: false,
            serializedName: 'parsedResponse',
            type: {
              name: 'Sequence',
              element: {
                  required: false,
                  serializedName: 'ApplicationModelElementType',
                  type: {
                    name: 'Composite',
                    className: 'ApplicationModel'
                  }
              }
            }
          };
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets a single application by its unique identifier.
 *
 * @param {number} id The unique application identifier.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link ApplicationModel} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getApplicationById(id, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (id === null || id === undefined || typeof id !== 'number') {
      throw new Error('id cannot be null or undefined and it must be of type number.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'v1/directory/applications/{id}';
  requestUrl = requestUrl.replace('{id}', encodeURIComponent(id.toString()));

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200 && statusCode !== 404) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['ApplicationModel']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets a single application by its name.
 *
 * @param {string} name The unique application name.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link ApplicationModel} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getApplicationByName(name, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'v1/directory/applications/{name}';
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200 && statusCode !== 404) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['ApplicationModel']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets a list of drawer group associations.
 *
 * @param {number} drawerID The drawer identifier.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {number} [options.groupID] The group identifier.
 *
 * @param {number} [options.acl] Gets or sets the access control level
 * permissions.
 *
 * @param {number} [options.page] Gets or sets the page number.
 *
 * @param {number} [options.pageSize] Gets or sets the size of the page.
 *
 * @param {string} [options.sortOrder] Gets or sets the order. Possible values
 * include: 'Unspecified', 'Ascending', 'Descending'
 *
 * @param {string} [options.sortBy] Gets or sets the column to order by.
 * Possible values include: 'Unspecified', 'DrawerID', 'ApplicationID',
 * 'GroupID', 'UserID', 'QueueID', 'Acl'
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {array} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getDrawerGroupAssociations(drawerID, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let groupID = (options && options.groupID !== undefined) ? options.groupID : undefined;
  let acl = (options && options.acl !== undefined) ? options.acl : undefined;
  let page = (options && options.page !== undefined) ? options.page : undefined;
  let pageSize = (options && options.pageSize !== undefined) ? options.pageSize : undefined;
  let sortOrder = (options && options.sortOrder !== undefined) ? options.sortOrder : undefined;
  let sortBy = (options && options.sortBy !== undefined) ? options.sortBy : undefined;
  // Validate
  try {
    if (groupID !== null && groupID !== undefined && typeof groupID !== 'number') {
      throw new Error('groupID must be of type number.');
    }
    if (drawerID === null || drawerID === undefined || typeof drawerID !== 'number') {
      throw new Error('drawerID cannot be null or undefined and it must be of type number.');
    }
    if (acl !== null && acl !== undefined && typeof acl !== 'number') {
      throw new Error('acl must be of type number.');
    }
    if (page !== null && page !== undefined && typeof page !== 'number') {
      throw new Error('page must be of type number.');
    }
    if (page !== null && page !== undefined) {
      if (page > 2147483647)
      {
        throw new Error('"page" should satisfy the constraint - "InclusiveMaximum": 2147483647');
      }
      if (page < 1)
      {
        throw new Error('"page" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
    if (pageSize !== null && pageSize !== undefined && typeof pageSize !== 'number') {
      throw new Error('pageSize must be of type number.');
    }
    if (pageSize !== null && pageSize !== undefined) {
      if (pageSize > 1000)
      {
        throw new Error('"pageSize" should satisfy the constraint - "InclusiveMaximum": 1000');
      }
      if (pageSize < 1)
      {
        throw new Error('"pageSize" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
    if (sortOrder !== null && sortOrder !== undefined && typeof sortOrder.valueOf() !== 'string') {
      throw new Error('sortOrder must be of type string.');
    }
    if (sortBy !== null && sortBy !== undefined && typeof sortBy.valueOf() !== 'string') {
      throw new Error('sortBy must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'v1/directory/drawers/{drawerID}/groups';
  requestUrl = requestUrl.replace('{drawerID}', encodeURIComponent(drawerID.toString()));
  let queryParameters = [];
  if (groupID !== null && groupID !== undefined) {
    queryParameters.push('groupID=' + encodeURIComponent(groupID.toString()));
  }
  if (acl !== null && acl !== undefined) {
    queryParameters.push('acl=' + encodeURIComponent(acl.toString()));
  }
  if (page !== null && page !== undefined) {
    queryParameters.push('page=' + encodeURIComponent(page.toString()));
  }
  if (pageSize !== null && pageSize !== undefined) {
    queryParameters.push('pageSize=' + encodeURIComponent(pageSize.toString()));
  }
  if (sortOrder !== null && sortOrder !== undefined) {
    queryParameters.push('sortOrder=' + encodeURIComponent(sortOrder));
  }
  if (sortBy !== null && sortBy !== undefined) {
    queryParameters.push('sortBy=' + encodeURIComponent(sortBy));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200 && statusCode !== 403) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = {
            required: false,
            serializedName: 'parsedResponse',
            type: {
              name: 'Sequence',
              element: {
                  required: false,
                  serializedName: 'GroupDrawerModelElementType',
                  type: {
                    name: 'Composite',
                    className: 'GroupDrawerModel'
                  }
              }
            }
          };
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets a list of group drawer associations.
 *
 * @param {number} groupID The group identifier.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {number} [options.drawerID] The drawer identifier.
 *
 * @param {number} [options.acl] Gets or sets the access control level
 * permissions.
 *
 * @param {number} [options.page] Gets or sets the page number.
 *
 * @param {number} [options.pageSize] Gets or sets the size of the page.
 *
 * @param {string} [options.sortOrder] Gets or sets the order. Possible values
 * include: 'Unspecified', 'Ascending', 'Descending'
 *
 * @param {string} [options.sortBy] Gets or sets the column to order by.
 * Possible values include: 'Unspecified', 'DrawerID', 'ApplicationID',
 * 'GroupID', 'UserID', 'QueueID', 'Acl'
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {array} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getGroupDrawerAssociations(groupID, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let drawerID = (options && options.drawerID !== undefined) ? options.drawerID : undefined;
  let acl = (options && options.acl !== undefined) ? options.acl : undefined;
  let page = (options && options.page !== undefined) ? options.page : undefined;
  let pageSize = (options && options.pageSize !== undefined) ? options.pageSize : undefined;
  let sortOrder = (options && options.sortOrder !== undefined) ? options.sortOrder : undefined;
  let sortBy = (options && options.sortBy !== undefined) ? options.sortBy : undefined;
  // Validate
  try {
    if (groupID === null || groupID === undefined || typeof groupID !== 'number') {
      throw new Error('groupID cannot be null or undefined and it must be of type number.');
    }
    if (drawerID !== null && drawerID !== undefined && typeof drawerID !== 'number') {
      throw new Error('drawerID must be of type number.');
    }
    if (acl !== null && acl !== undefined && typeof acl !== 'number') {
      throw new Error('acl must be of type number.');
    }
    if (page !== null && page !== undefined && typeof page !== 'number') {
      throw new Error('page must be of type number.');
    }
    if (page !== null && page !== undefined) {
      if (page > 2147483647)
      {
        throw new Error('"page" should satisfy the constraint - "InclusiveMaximum": 2147483647');
      }
      if (page < 1)
      {
        throw new Error('"page" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
    if (pageSize !== null && pageSize !== undefined && typeof pageSize !== 'number') {
      throw new Error('pageSize must be of type number.');
    }
    if (pageSize !== null && pageSize !== undefined) {
      if (pageSize > 1000)
      {
        throw new Error('"pageSize" should satisfy the constraint - "InclusiveMaximum": 1000');
      }
      if (pageSize < 1)
      {
        throw new Error('"pageSize" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
    if (sortOrder !== null && sortOrder !== undefined && typeof sortOrder.valueOf() !== 'string') {
      throw new Error('sortOrder must be of type string.');
    }
    if (sortBy !== null && sortBy !== undefined && typeof sortBy.valueOf() !== 'string') {
      throw new Error('sortBy must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'v1/directory/groups/{groupID}/drawers';
  requestUrl = requestUrl.replace('{groupID}', encodeURIComponent(groupID.toString()));
  let queryParameters = [];
  if (drawerID !== null && drawerID !== undefined) {
    queryParameters.push('drawerID=' + encodeURIComponent(drawerID.toString()));
  }
  if (acl !== null && acl !== undefined) {
    queryParameters.push('acl=' + encodeURIComponent(acl.toString()));
  }
  if (page !== null && page !== undefined) {
    queryParameters.push('page=' + encodeURIComponent(page.toString()));
  }
  if (pageSize !== null && pageSize !== undefined) {
    queryParameters.push('pageSize=' + encodeURIComponent(pageSize.toString()));
  }
  if (sortOrder !== null && sortOrder !== undefined) {
    queryParameters.push('sortOrder=' + encodeURIComponent(sortOrder));
  }
  if (sortBy !== null && sortBy !== undefined) {
    queryParameters.push('sortBy=' + encodeURIComponent(sortBy));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200 && statusCode !== 403) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = {
            required: false,
            serializedName: 'parsedResponse',
            type: {
              name: 'Sequence',
              element: {
                  required: false,
                  serializedName: 'GroupDrawerModelElementType',
                  type: {
                    name: 'Composite',
                    className: 'GroupDrawerModel'
                  }
              }
            }
          };
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Inserts/Updates the drawer group association.
 *
 * @param {number} groupID The group identifier.
 *
 * @param {number} drawerID The drawer identifier.
 *
 * @param {object} model The model.
 *
 * @param {number} [model.groupID] Gets or sets the group identifier.
 *
 * @param {string} [model.groupName] Gets or sets the name of the group.
 *
 * @param {number} [model.drawerID] Gets or sets the drawer identifier.
 *
 * @param {string} [model.drawerName] Gets or sets the name of the drawer.
 *
 * @param {number} [model.acl] Gets or sets the access control level
 * permissions.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _createOrUpdateDrawerGroupAssociation(groupID, drawerID, model, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (groupID === null || groupID === undefined || typeof groupID !== 'number') {
      throw new Error('groupID cannot be null or undefined and it must be of type number.');
    }
    if (drawerID === null || drawerID === undefined || typeof drawerID !== 'number') {
      throw new Error('drawerID cannot be null or undefined and it must be of type number.');
    }
    if (model === null || model === undefined) {
      throw new Error('model cannot be null or undefined.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'v1/directory/drawers/{drawerID}/groups/{groupID}';
  requestUrl = requestUrl.replace('{groupID}', encodeURIComponent(groupID.toString()));
  requestUrl = requestUrl.replace('{drawerID}', encodeURIComponent(drawerID.toString()));

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'PUT';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (model !== null && model !== undefined) {
      let requestModelMapper = new client.models['GroupDrawerModel']().mapper();
      requestModel = client.serialize(requestModelMapper, model, 'model');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(model, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 204 && statusCode !== 403) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 204) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = {
            required: false,
            serializedName: 'parsedResponse',
            type: {
              name: 'Object'
            }
          };
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Deletes a drawer group association;
 *
 * @param {number} groupID The group identifier.
 *
 * @param {number} drawerID The drawer identifier.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _deleteDrawerGroupAssociation(groupID, drawerID, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (groupID === null || groupID === undefined || typeof groupID !== 'number') {
      throw new Error('groupID cannot be null or undefined and it must be of type number.');
    }
    if (drawerID === null || drawerID === undefined || typeof drawerID !== 'number') {
      throw new Error('drawerID cannot be null or undefined and it must be of type number.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'v1/directory/drawers/{drawerID}/groups/{groupID}';
  requestUrl = requestUrl.replace('{groupID}', encodeURIComponent(groupID.toString()));
  requestUrl = requestUrl.replace('{drawerID}', encodeURIComponent(drawerID.toString()));

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'DELETE';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 204 && statusCode !== 403 && statusCode !== 404) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 204) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = {
            required: false,
            serializedName: 'parsedResponse',
            type: {
              name: 'Object'
            }
          };
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Inserts/Updates the group drawer association.
 *
 * @param {number} groupID The group identifier.
 *
 * @param {number} drawerID The drawer identifier.
 *
 * @param {object} model The model.
 *
 * @param {number} [model.groupID] Gets or sets the group identifier.
 *
 * @param {string} [model.groupName] Gets or sets the name of the group.
 *
 * @param {number} [model.drawerID] Gets or sets the drawer identifier.
 *
 * @param {string} [model.drawerName] Gets or sets the name of the drawer.
 *
 * @param {number} [model.acl] Gets or sets the access control level
 * permissions.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _createOrUpdateGroupDrawerAssociation(groupID, drawerID, model, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (groupID === null || groupID === undefined || typeof groupID !== 'number') {
      throw new Error('groupID cannot be null or undefined and it must be of type number.');
    }
    if (drawerID === null || drawerID === undefined || typeof drawerID !== 'number') {
      throw new Error('drawerID cannot be null or undefined and it must be of type number.');
    }
    if (model === null || model === undefined) {
      throw new Error('model cannot be null or undefined.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'v1/directory/groups/{groupID}/drawers/{drawerID}';
  requestUrl = requestUrl.replace('{groupID}', encodeURIComponent(groupID.toString()));
  requestUrl = requestUrl.replace('{drawerID}', encodeURIComponent(drawerID.toString()));

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'PUT';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (model !== null && model !== undefined) {
      let requestModelMapper = new client.models['GroupDrawerModel']().mapper();
      requestModel = client.serialize(requestModelMapper, model, 'model');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(model, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 204 && statusCode !== 403) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 204) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = {
            required: false,
            serializedName: 'parsedResponse',
            type: {
              name: 'Object'
            }
          };
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Deletes a group drawer association;
 *
 * @param {number} groupID The group identifier.
 *
 * @param {number} drawerID The drawer identifier.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _deleteGroupDrawerAssociation(groupID, drawerID, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (groupID === null || groupID === undefined || typeof groupID !== 'number') {
      throw new Error('groupID cannot be null or undefined and it must be of type number.');
    }
    if (drawerID === null || drawerID === undefined || typeof drawerID !== 'number') {
      throw new Error('drawerID cannot be null or undefined and it must be of type number.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'v1/directory/groups/{groupID}/drawers/{drawerID}';
  requestUrl = requestUrl.replace('{groupID}', encodeURIComponent(groupID.toString()));
  requestUrl = requestUrl.replace('{drawerID}', encodeURIComponent(drawerID.toString()));

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'DELETE';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 204 && statusCode !== 403 && statusCode !== 404) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 204) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = {
            required: false,
            serializedName: 'parsedResponse',
            type: {
              name: 'Object'
            }
          };
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets a list of user group associations.
 *
 * @param {number} userID The user identifier.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {number} [options.groupID] The group identifier.
 *
 * @param {number} [options.acl] Gets or sets the access control level
 * permissions.
 *
 * @param {number} [options.page] Gets or sets the page number.
 *
 * @param {number} [options.pageSize] Gets or sets the size of the page.
 *
 * @param {string} [options.sortOrder] Gets or sets the order. Possible values
 * include: 'Unspecified', 'Ascending', 'Descending'
 *
 * @param {string} [options.sortBy] Gets or sets the column to order by.
 * Possible values include: 'Unspecified', 'DrawerID', 'ApplicationID',
 * 'GroupID', 'UserID', 'QueueID', 'Acl'
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {array} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getUserGroupAssociations(userID, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let groupID = (options && options.groupID !== undefined) ? options.groupID : undefined;
  let acl = (options && options.acl !== undefined) ? options.acl : undefined;
  let page = (options && options.page !== undefined) ? options.page : undefined;
  let pageSize = (options && options.pageSize !== undefined) ? options.pageSize : undefined;
  let sortOrder = (options && options.sortOrder !== undefined) ? options.sortOrder : undefined;
  let sortBy = (options && options.sortBy !== undefined) ? options.sortBy : undefined;
  // Validate
  try {
    if (groupID !== null && groupID !== undefined && typeof groupID !== 'number') {
      throw new Error('groupID must be of type number.');
    }
    if (userID === null || userID === undefined || typeof userID !== 'number') {
      throw new Error('userID cannot be null or undefined and it must be of type number.');
    }
    if (acl !== null && acl !== undefined && typeof acl !== 'number') {
      throw new Error('acl must be of type number.');
    }
    if (page !== null && page !== undefined && typeof page !== 'number') {
      throw new Error('page must be of type number.');
    }
    if (page !== null && page !== undefined) {
      if (page > 2147483647)
      {
        throw new Error('"page" should satisfy the constraint - "InclusiveMaximum": 2147483647');
      }
      if (page < 1)
      {
        throw new Error('"page" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
    if (pageSize !== null && pageSize !== undefined && typeof pageSize !== 'number') {
      throw new Error('pageSize must be of type number.');
    }
    if (pageSize !== null && pageSize !== undefined) {
      if (pageSize > 1000)
      {
        throw new Error('"pageSize" should satisfy the constraint - "InclusiveMaximum": 1000');
      }
      if (pageSize < 1)
      {
        throw new Error('"pageSize" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
    if (sortOrder !== null && sortOrder !== undefined && typeof sortOrder.valueOf() !== 'string') {
      throw new Error('sortOrder must be of type string.');
    }
    if (sortBy !== null && sortBy !== undefined && typeof sortBy.valueOf() !== 'string') {
      throw new Error('sortBy must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'v1/directory/users/{userID}/groups';
  requestUrl = requestUrl.replace('{userID}', encodeURIComponent(userID.toString()));
  let queryParameters = [];
  if (groupID !== null && groupID !== undefined) {
    queryParameters.push('groupID=' + encodeURIComponent(groupID.toString()));
  }
  if (acl !== null && acl !== undefined) {
    queryParameters.push('acl=' + encodeURIComponent(acl.toString()));
  }
  if (page !== null && page !== undefined) {
    queryParameters.push('page=' + encodeURIComponent(page.toString()));
  }
  if (pageSize !== null && pageSize !== undefined) {
    queryParameters.push('pageSize=' + encodeURIComponent(pageSize.toString()));
  }
  if (sortOrder !== null && sortOrder !== undefined) {
    queryParameters.push('sortOrder=' + encodeURIComponent(sortOrder));
  }
  if (sortBy !== null && sortBy !== undefined) {
    queryParameters.push('sortBy=' + encodeURIComponent(sortBy));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200 && statusCode !== 403) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = {
            required: false,
            serializedName: 'parsedResponse',
            type: {
              name: 'Sequence',
              element: {
                  required: false,
                  serializedName: 'GroupUserModelElementType',
                  type: {
                    name: 'Composite',
                    className: 'GroupUserModel'
                  }
              }
            }
          };
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets a list of group user associations.
 *
 * @param {number} groupID The group identifier.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {number} [options.userID] The user identifier.
 *
 * @param {number} [options.acl] Gets or sets the access control level
 * permissions.
 *
 * @param {number} [options.page] Gets or sets the page number.
 *
 * @param {number} [options.pageSize] Gets or sets the size of the page.
 *
 * @param {string} [options.sortOrder] Gets or sets the order. Possible values
 * include: 'Unspecified', 'Ascending', 'Descending'
 *
 * @param {string} [options.sortBy] Gets or sets the column to order by.
 * Possible values include: 'Unspecified', 'DrawerID', 'ApplicationID',
 * 'GroupID', 'UserID', 'QueueID', 'Acl'
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {array} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getGroupUserAssociations(groupID, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let userID = (options && options.userID !== undefined) ? options.userID : undefined;
  let acl = (options && options.acl !== undefined) ? options.acl : undefined;
  let page = (options && options.page !== undefined) ? options.page : undefined;
  let pageSize = (options && options.pageSize !== undefined) ? options.pageSize : undefined;
  let sortOrder = (options && options.sortOrder !== undefined) ? options.sortOrder : undefined;
  let sortBy = (options && options.sortBy !== undefined) ? options.sortBy : undefined;
  // Validate
  try {
    if (groupID === null || groupID === undefined || typeof groupID !== 'number') {
      throw new Error('groupID cannot be null or undefined and it must be of type number.');
    }
    if (userID !== null && userID !== undefined && typeof userID !== 'number') {
      throw new Error('userID must be of type number.');
    }
    if (acl !== null && acl !== undefined && typeof acl !== 'number') {
      throw new Error('acl must be of type number.');
    }
    if (page !== null && page !== undefined && typeof page !== 'number') {
      throw new Error('page must be of type number.');
    }
    if (page !== null && page !== undefined) {
      if (page > 2147483647)
      {
        throw new Error('"page" should satisfy the constraint - "InclusiveMaximum": 2147483647');
      }
      if (page < 1)
      {
        throw new Error('"page" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
    if (pageSize !== null && pageSize !== undefined && typeof pageSize !== 'number') {
      throw new Error('pageSize must be of type number.');
    }
    if (pageSize !== null && pageSize !== undefined) {
      if (pageSize > 1000)
      {
        throw new Error('"pageSize" should satisfy the constraint - "InclusiveMaximum": 1000');
      }
      if (pageSize < 1)
      {
        throw new Error('"pageSize" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
    if (sortOrder !== null && sortOrder !== undefined && typeof sortOrder.valueOf() !== 'string') {
      throw new Error('sortOrder must be of type string.');
    }
    if (sortBy !== null && sortBy !== undefined && typeof sortBy.valueOf() !== 'string') {
      throw new Error('sortBy must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'v1/directory/groups/{groupID}/users';
  requestUrl = requestUrl.replace('{groupID}', encodeURIComponent(groupID.toString()));
  let queryParameters = [];
  if (userID !== null && userID !== undefined) {
    queryParameters.push('userID=' + encodeURIComponent(userID.toString()));
  }
  if (acl !== null && acl !== undefined) {
    queryParameters.push('acl=' + encodeURIComponent(acl.toString()));
  }
  if (page !== null && page !== undefined) {
    queryParameters.push('page=' + encodeURIComponent(page.toString()));
  }
  if (pageSize !== null && pageSize !== undefined) {
    queryParameters.push('pageSize=' + encodeURIComponent(pageSize.toString()));
  }
  if (sortOrder !== null && sortOrder !== undefined) {
    queryParameters.push('sortOrder=' + encodeURIComponent(sortOrder));
  }
  if (sortBy !== null && sortBy !== undefined) {
    queryParameters.push('sortBy=' + encodeURIComponent(sortBy));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200 && statusCode !== 403) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = {
            required: false,
            serializedName: 'parsedResponse',
            type: {
              name: 'Sequence',
              element: {
                  required: false,
                  serializedName: 'GroupUserModelElementType',
                  type: {
                    name: 'Composite',
                    className: 'GroupUserModel'
                  }
              }
            }
          };
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Inserts the user group association.
 *
 * @param {number} groupID The group identifier.
 *
 * @param {number} userID The user identifier.
 *
 * @param {object} model The model.
 *
 * @param {number} [model.groupID] Gets or sets the group identifier.
 *
 * @param {string} [model.groupName] Gets or sets the name of the group.
 *
 * @param {number} [model.userID] Gets or sets the user identifier.
 *
 * @param {string} [model.userFullName] Gets or sets the full name of the user.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _createUserGroupAssociation(groupID, userID, model, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (groupID === null || groupID === undefined || typeof groupID !== 'number') {
      throw new Error('groupID cannot be null or undefined and it must be of type number.');
    }
    if (userID === null || userID === undefined || typeof userID !== 'number') {
      throw new Error('userID cannot be null or undefined and it must be of type number.');
    }
    if (model === null || model === undefined) {
      throw new Error('model cannot be null or undefined.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'v1/directory/users/{userID}/groups/{groupID}';
  requestUrl = requestUrl.replace('{groupID}', encodeURIComponent(groupID.toString()));
  requestUrl = requestUrl.replace('{userID}', encodeURIComponent(userID.toString()));

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (model !== null && model !== undefined) {
      let requestModelMapper = new client.models['GroupUserModel']().mapper();
      requestModel = client.serialize(requestModelMapper, model, 'model');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(model, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200 && statusCode !== 403 && statusCode !== 409) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = {
            required: false,
            serializedName: 'parsedResponse',
            type: {
              name: 'Object'
            }
          };
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Deletes a user group association;
 *
 * @param {number} groupID The group identifier.
 *
 * @param {number} userID The user identifier.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _deleteUserGroupAssociation(groupID, userID, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (groupID === null || groupID === undefined || typeof groupID !== 'number') {
      throw new Error('groupID cannot be null or undefined and it must be of type number.');
    }
    if (userID === null || userID === undefined || typeof userID !== 'number') {
      throw new Error('userID cannot be null or undefined and it must be of type number.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'v1/directory/users/{userID}/groups/{groupID}';
  requestUrl = requestUrl.replace('{groupID}', encodeURIComponent(groupID.toString()));
  requestUrl = requestUrl.replace('{userID}', encodeURIComponent(userID.toString()));

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'DELETE';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 204 && statusCode !== 403 && statusCode !== 404) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 204) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = {
            required: false,
            serializedName: 'parsedResponse',
            type: {
              name: 'Object'
            }
          };
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Inserts the group user association.
 *
 * @param {number} groupID The group identifier.
 *
 * @param {number} userID The user identifier.
 *
 * @param {object} model The model.
 *
 * @param {number} [model.groupID] Gets or sets the group identifier.
 *
 * @param {string} [model.groupName] Gets or sets the name of the group.
 *
 * @param {number} [model.userID] Gets or sets the user identifier.
 *
 * @param {string} [model.userFullName] Gets or sets the full name of the user.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _createGroupUserAssociation(groupID, userID, model, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (groupID === null || groupID === undefined || typeof groupID !== 'number') {
      throw new Error('groupID cannot be null or undefined and it must be of type number.');
    }
    if (userID === null || userID === undefined || typeof userID !== 'number') {
      throw new Error('userID cannot be null or undefined and it must be of type number.');
    }
    if (model === null || model === undefined) {
      throw new Error('model cannot be null or undefined.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'v1/directory/groups/{groupID}/users/{userID}';
  requestUrl = requestUrl.replace('{groupID}', encodeURIComponent(groupID.toString()));
  requestUrl = requestUrl.replace('{userID}', encodeURIComponent(userID.toString()));

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (model !== null && model !== undefined) {
      let requestModelMapper = new client.models['GroupUserModel']().mapper();
      requestModel = client.serialize(requestModelMapper, model, 'model');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(model, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200 && statusCode !== 403 && statusCode !== 409) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = {
            required: false,
            serializedName: 'parsedResponse',
            type: {
              name: 'Object'
            }
          };
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Deletes a group user association;
 *
 * @param {number} groupID The group identifier.
 *
 * @param {number} userID The user identifier.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _deleteGroupUserAssociation(groupID, userID, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (groupID === null || groupID === undefined || typeof groupID !== 'number') {
      throw new Error('groupID cannot be null or undefined and it must be of type number.');
    }
    if (userID === null || userID === undefined || typeof userID !== 'number') {
      throw new Error('userID cannot be null or undefined and it must be of type number.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'v1/directory/groups/{groupID}/users/{userID}';
  requestUrl = requestUrl.replace('{groupID}', encodeURIComponent(groupID.toString()));
  requestUrl = requestUrl.replace('{userID}', encodeURIComponent(userID.toString()));

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'DELETE';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 204 && statusCode !== 403 && statusCode !== 404) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 204) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = {
            required: false,
            serializedName: 'parsedResponse',
            type: {
              name: 'Object'
            }
          };
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets a list of queue group associations.
 *
 * @param {number} queueID The queue identifier.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {number} [options.groupID] The group identifier.
 *
 * @param {number} [options.acl] Gets or sets the access control level
 * permissions.
 *
 * @param {number} [options.page] Gets or sets the page number.
 *
 * @param {number} [options.pageSize] Gets or sets the size of the page.
 *
 * @param {string} [options.sortOrder] Gets or sets the order. Possible values
 * include: 'Unspecified', 'Ascending', 'Descending'
 *
 * @param {string} [options.sortBy] Gets or sets the column to order by.
 * Possible values include: 'Unspecified', 'DrawerID', 'ApplicationID',
 * 'GroupID', 'UserID', 'QueueID', 'Acl'
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {array} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getQueueGroupAssociations(queueID, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let groupID = (options && options.groupID !== undefined) ? options.groupID : undefined;
  let acl = (options && options.acl !== undefined) ? options.acl : undefined;
  let page = (options && options.page !== undefined) ? options.page : undefined;
  let pageSize = (options && options.pageSize !== undefined) ? options.pageSize : undefined;
  let sortOrder = (options && options.sortOrder !== undefined) ? options.sortOrder : undefined;
  let sortBy = (options && options.sortBy !== undefined) ? options.sortBy : undefined;
  // Validate
  try {
    if (groupID !== null && groupID !== undefined && typeof groupID !== 'number') {
      throw new Error('groupID must be of type number.');
    }
    if (queueID === null || queueID === undefined || typeof queueID !== 'number') {
      throw new Error('queueID cannot be null or undefined and it must be of type number.');
    }
    if (acl !== null && acl !== undefined && typeof acl !== 'number') {
      throw new Error('acl must be of type number.');
    }
    if (page !== null && page !== undefined && typeof page !== 'number') {
      throw new Error('page must be of type number.');
    }
    if (page !== null && page !== undefined) {
      if (page > 2147483647)
      {
        throw new Error('"page" should satisfy the constraint - "InclusiveMaximum": 2147483647');
      }
      if (page < 1)
      {
        throw new Error('"page" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
    if (pageSize !== null && pageSize !== undefined && typeof pageSize !== 'number') {
      throw new Error('pageSize must be of type number.');
    }
    if (pageSize !== null && pageSize !== undefined) {
      if (pageSize > 1000)
      {
        throw new Error('"pageSize" should satisfy the constraint - "InclusiveMaximum": 1000');
      }
      if (pageSize < 1)
      {
        throw new Error('"pageSize" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
    if (sortOrder !== null && sortOrder !== undefined && typeof sortOrder.valueOf() !== 'string') {
      throw new Error('sortOrder must be of type string.');
    }
    if (sortBy !== null && sortBy !== undefined && typeof sortBy.valueOf() !== 'string') {
      throw new Error('sortBy must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'v1/workflow/queues/{queueID}/groups';
  requestUrl = requestUrl.replace('{queueID}', encodeURIComponent(queueID.toString()));
  let queryParameters = [];
  if (groupID !== null && groupID !== undefined) {
    queryParameters.push('groupID=' + encodeURIComponent(groupID.toString()));
  }
  if (acl !== null && acl !== undefined) {
    queryParameters.push('acl=' + encodeURIComponent(acl.toString()));
  }
  if (page !== null && page !== undefined) {
    queryParameters.push('page=' + encodeURIComponent(page.toString()));
  }
  if (pageSize !== null && pageSize !== undefined) {
    queryParameters.push('pageSize=' + encodeURIComponent(pageSize.toString()));
  }
  if (sortOrder !== null && sortOrder !== undefined) {
    queryParameters.push('sortOrder=' + encodeURIComponent(sortOrder));
  }
  if (sortBy !== null && sortBy !== undefined) {
    queryParameters.push('sortBy=' + encodeURIComponent(sortBy));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200 && statusCode !== 403) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = {
            required: false,
            serializedName: 'parsedResponse',
            type: {
              name: 'Sequence',
              element: {
                  required: false,
                  serializedName: 'GroupQueueModelElementType',
                  type: {
                    name: 'Composite',
                    className: 'GroupQueueModel'
                  }
              }
            }
          };
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets a list of group queue associations.
 *
 * @param {number} groupID The group identifier.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {number} [options.queueID] The queue identifier.
 *
 * @param {number} [options.acl] Gets or sets the access control level
 * permissions.
 *
 * @param {number} [options.page] Gets or sets the page number.
 *
 * @param {number} [options.pageSize] Gets or sets the size of the page.
 *
 * @param {string} [options.sortOrder] Gets or sets the order. Possible values
 * include: 'Unspecified', 'Ascending', 'Descending'
 *
 * @param {string} [options.sortBy] Gets or sets the column to order by.
 * Possible values include: 'Unspecified', 'DrawerID', 'ApplicationID',
 * 'GroupID', 'UserID', 'QueueID', 'Acl'
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {array} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getGroupQueueAssociations(groupID, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let queueID = (options && options.queueID !== undefined) ? options.queueID : undefined;
  let acl = (options && options.acl !== undefined) ? options.acl : undefined;
  let page = (options && options.page !== undefined) ? options.page : undefined;
  let pageSize = (options && options.pageSize !== undefined) ? options.pageSize : undefined;
  let sortOrder = (options && options.sortOrder !== undefined) ? options.sortOrder : undefined;
  let sortBy = (options && options.sortBy !== undefined) ? options.sortBy : undefined;
  // Validate
  try {
    if (groupID === null || groupID === undefined || typeof groupID !== 'number') {
      throw new Error('groupID cannot be null or undefined and it must be of type number.');
    }
    if (queueID !== null && queueID !== undefined && typeof queueID !== 'number') {
      throw new Error('queueID must be of type number.');
    }
    if (acl !== null && acl !== undefined && typeof acl !== 'number') {
      throw new Error('acl must be of type number.');
    }
    if (page !== null && page !== undefined && typeof page !== 'number') {
      throw new Error('page must be of type number.');
    }
    if (page !== null && page !== undefined) {
      if (page > 2147483647)
      {
        throw new Error('"page" should satisfy the constraint - "InclusiveMaximum": 2147483647');
      }
      if (page < 1)
      {
        throw new Error('"page" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
    if (pageSize !== null && pageSize !== undefined && typeof pageSize !== 'number') {
      throw new Error('pageSize must be of type number.');
    }
    if (pageSize !== null && pageSize !== undefined) {
      if (pageSize > 1000)
      {
        throw new Error('"pageSize" should satisfy the constraint - "InclusiveMaximum": 1000');
      }
      if (pageSize < 1)
      {
        throw new Error('"pageSize" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
    if (sortOrder !== null && sortOrder !== undefined && typeof sortOrder.valueOf() !== 'string') {
      throw new Error('sortOrder must be of type string.');
    }
    if (sortBy !== null && sortBy !== undefined && typeof sortBy.valueOf() !== 'string') {
      throw new Error('sortBy must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'v1/directory/groups/{groupID}/queues';
  requestUrl = requestUrl.replace('{groupID}', encodeURIComponent(groupID.toString()));
  let queryParameters = [];
  if (queueID !== null && queueID !== undefined) {
    queryParameters.push('queueID=' + encodeURIComponent(queueID.toString()));
  }
  if (acl !== null && acl !== undefined) {
    queryParameters.push('acl=' + encodeURIComponent(acl.toString()));
  }
  if (page !== null && page !== undefined) {
    queryParameters.push('page=' + encodeURIComponent(page.toString()));
  }
  if (pageSize !== null && pageSize !== undefined) {
    queryParameters.push('pageSize=' + encodeURIComponent(pageSize.toString()));
  }
  if (sortOrder !== null && sortOrder !== undefined) {
    queryParameters.push('sortOrder=' + encodeURIComponent(sortOrder));
  }
  if (sortBy !== null && sortBy !== undefined) {
    queryParameters.push('sortBy=' + encodeURIComponent(sortBy));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200 && statusCode !== 403) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = {
            required: false,
            serializedName: 'parsedResponse',
            type: {
              name: 'Sequence',
              element: {
                  required: false,
                  serializedName: 'GroupQueueModelElementType',
                  type: {
                    name: 'Composite',
                    className: 'GroupQueueModel'
                  }
              }
            }
          };
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Inserts/Updates the queue group association.
 *
 * @param {number} groupID The group identifier.
 *
 * @param {number} queueID The queue identifier.
 *
 * @param {object} model The model.
 *
 * @param {number} [model.groupID] Gets or sets the group identifier.
 *
 * @param {string} [model.groupName] Gets or sets the name of the group.
 *
 * @param {number} [model.queueID] Gets or sets the queue identifier.
 *
 * @param {string} [model.queueName] Gets or sets the name of the queue.
 *
 * @param {number} [model.acl] Gets or sets the access control level
 * permissions.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _createOrUpdateQueueGroupAssociation(groupID, queueID, model, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (groupID === null || groupID === undefined || typeof groupID !== 'number') {
      throw new Error('groupID cannot be null or undefined and it must be of type number.');
    }
    if (queueID === null || queueID === undefined || typeof queueID !== 'number') {
      throw new Error('queueID cannot be null or undefined and it must be of type number.');
    }
    if (model === null || model === undefined) {
      throw new Error('model cannot be null or undefined.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'v1/workflow/queues/{queueID}/groups/{groupID}';
  requestUrl = requestUrl.replace('{groupID}', encodeURIComponent(groupID.toString()));
  requestUrl = requestUrl.replace('{queueID}', encodeURIComponent(queueID.toString()));

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'PUT';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (model !== null && model !== undefined) {
      let requestModelMapper = new client.models['GroupQueueModel']().mapper();
      requestModel = client.serialize(requestModelMapper, model, 'model');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(model, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 204 && statusCode !== 403) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 204) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = {
            required: false,
            serializedName: 'parsedResponse',
            type: {
              name: 'Object'
            }
          };
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Deletes a queue group association;
 *
 * @param {number} groupID The group identifier.
 *
 * @param {number} queueID The queue identifier.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _deleteQueueGroupAssociation(groupID, queueID, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (groupID === null || groupID === undefined || typeof groupID !== 'number') {
      throw new Error('groupID cannot be null or undefined and it must be of type number.');
    }
    if (queueID === null || queueID === undefined || typeof queueID !== 'number') {
      throw new Error('queueID cannot be null or undefined and it must be of type number.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'v1/workflow/queues/{queueID}/groups/{groupID}';
  requestUrl = requestUrl.replace('{groupID}', encodeURIComponent(groupID.toString()));
  requestUrl = requestUrl.replace('{queueID}', encodeURIComponent(queueID.toString()));

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'DELETE';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 204 && statusCode !== 403 && statusCode !== 404) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 204) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = {
            required: false,
            serializedName: 'parsedResponse',
            type: {
              name: 'Object'
            }
          };
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Inserts/Updates the group queue association.
 *
 * @param {number} groupID The group identifier.
 *
 * @param {number} queueID The queue identifier.
 *
 * @param {object} model The model.
 *
 * @param {number} [model.groupID] Gets or sets the group identifier.
 *
 * @param {string} [model.groupName] Gets or sets the name of the group.
 *
 * @param {number} [model.queueID] Gets or sets the queue identifier.
 *
 * @param {string} [model.queueName] Gets or sets the name of the queue.
 *
 * @param {number} [model.acl] Gets or sets the access control level
 * permissions.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _createOrUpdateGroupQueueAssociation(groupID, queueID, model, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (groupID === null || groupID === undefined || typeof groupID !== 'number') {
      throw new Error('groupID cannot be null or undefined and it must be of type number.');
    }
    if (queueID === null || queueID === undefined || typeof queueID !== 'number') {
      throw new Error('queueID cannot be null or undefined and it must be of type number.');
    }
    if (model === null || model === undefined) {
      throw new Error('model cannot be null or undefined.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'v1/directory/groups/{groupID}/queues/{queueID}';
  requestUrl = requestUrl.replace('{groupID}', encodeURIComponent(groupID.toString()));
  requestUrl = requestUrl.replace('{queueID}', encodeURIComponent(queueID.toString()));

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'PUT';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (model !== null && model !== undefined) {
      let requestModelMapper = new client.models['GroupQueueModel']().mapper();
      requestModel = client.serialize(requestModelMapper, model, 'model');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(model, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 204 && statusCode !== 403) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 204) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = {
            required: false,
            serializedName: 'parsedResponse',
            type: {
              name: 'Object'
            }
          };
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Deletes a group queue association;
 *
 * @param {number} groupID The group identifier.
 *
 * @param {number} queueID The queue identifier.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _deleteGroupQueueAssociation(groupID, queueID, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (groupID === null || groupID === undefined || typeof groupID !== 'number') {
      throw new Error('groupID cannot be null or undefined and it must be of type number.');
    }
    if (queueID === null || queueID === undefined || typeof queueID !== 'number') {
      throw new Error('queueID cannot be null or undefined and it must be of type number.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'v1/directory/groups/{groupID}/queues/{queueID}';
  requestUrl = requestUrl.replace('{groupID}', encodeURIComponent(groupID.toString()));
  requestUrl = requestUrl.replace('{queueID}', encodeURIComponent(queueID.toString()));

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'DELETE';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 204 && statusCode !== 403 && statusCode !== 404) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 204) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = {
            required: false,
            serializedName: 'parsedResponse',
            type: {
              name: 'Object'
            }
          };
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets a list of application group associations.
 *
 * @param {number} applicationID The application identifier.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {number} [options.groupID] The group identifier.
 *
 * @param {number} [options.acl] Gets or sets the access control level
 * permissions.
 *
 * @param {number} [options.page] Gets or sets the page number.
 *
 * @param {number} [options.pageSize] Gets or sets the size of the page.
 *
 * @param {string} [options.sortOrder] Gets or sets the order. Possible values
 * include: 'Unspecified', 'Ascending', 'Descending'
 *
 * @param {string} [options.sortBy] Gets or sets the column to order by.
 * Possible values include: 'Unspecified', 'DrawerID', 'ApplicationID',
 * 'GroupID', 'UserID', 'QueueID', 'Acl'
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {array} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getApplicationGroupAssociations(applicationID, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let groupID = (options && options.groupID !== undefined) ? options.groupID : undefined;
  let acl = (options && options.acl !== undefined) ? options.acl : undefined;
  let page = (options && options.page !== undefined) ? options.page : undefined;
  let pageSize = (options && options.pageSize !== undefined) ? options.pageSize : undefined;
  let sortOrder = (options && options.sortOrder !== undefined) ? options.sortOrder : undefined;
  let sortBy = (options && options.sortBy !== undefined) ? options.sortBy : undefined;
  // Validate
  try {
    if (groupID !== null && groupID !== undefined && typeof groupID !== 'number') {
      throw new Error('groupID must be of type number.');
    }
    if (applicationID === null || applicationID === undefined || typeof applicationID !== 'number') {
      throw new Error('applicationID cannot be null or undefined and it must be of type number.');
    }
    if (acl !== null && acl !== undefined && typeof acl !== 'number') {
      throw new Error('acl must be of type number.');
    }
    if (page !== null && page !== undefined && typeof page !== 'number') {
      throw new Error('page must be of type number.');
    }
    if (page !== null && page !== undefined) {
      if (page > 2147483647)
      {
        throw new Error('"page" should satisfy the constraint - "InclusiveMaximum": 2147483647');
      }
      if (page < 1)
      {
        throw new Error('"page" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
    if (pageSize !== null && pageSize !== undefined && typeof pageSize !== 'number') {
      throw new Error('pageSize must be of type number.');
    }
    if (pageSize !== null && pageSize !== undefined) {
      if (pageSize > 1000)
      {
        throw new Error('"pageSize" should satisfy the constraint - "InclusiveMaximum": 1000');
      }
      if (pageSize < 1)
      {
        throw new Error('"pageSize" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
    if (sortOrder !== null && sortOrder !== undefined && typeof sortOrder.valueOf() !== 'string') {
      throw new Error('sortOrder must be of type string.');
    }
    if (sortBy !== null && sortBy !== undefined && typeof sortBy.valueOf() !== 'string') {
      throw new Error('sortBy must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'v1/directory/applications/{applicationID}/groups';
  requestUrl = requestUrl.replace('{applicationID}', encodeURIComponent(applicationID.toString()));
  let queryParameters = [];
  if (groupID !== null && groupID !== undefined) {
    queryParameters.push('groupID=' + encodeURIComponent(groupID.toString()));
  }
  if (acl !== null && acl !== undefined) {
    queryParameters.push('acl=' + encodeURIComponent(acl.toString()));
  }
  if (page !== null && page !== undefined) {
    queryParameters.push('page=' + encodeURIComponent(page.toString()));
  }
  if (pageSize !== null && pageSize !== undefined) {
    queryParameters.push('pageSize=' + encodeURIComponent(pageSize.toString()));
  }
  if (sortOrder !== null && sortOrder !== undefined) {
    queryParameters.push('sortOrder=' + encodeURIComponent(sortOrder));
  }
  if (sortBy !== null && sortBy !== undefined) {
    queryParameters.push('sortBy=' + encodeURIComponent(sortBy));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200 && statusCode !== 403) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = {
            required: false,
            serializedName: 'parsedResponse',
            type: {
              name: 'Sequence',
              element: {
                  required: false,
                  serializedName: 'GroupApplicationModelElementType',
                  type: {
                    name: 'Composite',
                    className: 'GroupApplicationModel'
                  }
              }
            }
          };
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets a list of group application associations.
 *
 * @param {number} groupID The group identifier.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {number} [options.applicationID] The application identifier.
 *
 * @param {number} [options.acl] Gets or sets the access control level
 * permissions.
 *
 * @param {number} [options.page] Gets or sets the page number.
 *
 * @param {number} [options.pageSize] Gets or sets the size of the page.
 *
 * @param {string} [options.sortOrder] Gets or sets the order. Possible values
 * include: 'Unspecified', 'Ascending', 'Descending'
 *
 * @param {string} [options.sortBy] Gets or sets the column to order by.
 * Possible values include: 'Unspecified', 'DrawerID', 'ApplicationID',
 * 'GroupID', 'UserID', 'QueueID', 'Acl'
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {array} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getGroupApplicationAssociations(groupID, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let applicationID = (options && options.applicationID !== undefined) ? options.applicationID : undefined;
  let acl = (options && options.acl !== undefined) ? options.acl : undefined;
  let page = (options && options.page !== undefined) ? options.page : undefined;
  let pageSize = (options && options.pageSize !== undefined) ? options.pageSize : undefined;
  let sortOrder = (options && options.sortOrder !== undefined) ? options.sortOrder : undefined;
  let sortBy = (options && options.sortBy !== undefined) ? options.sortBy : undefined;
  // Validate
  try {
    if (groupID === null || groupID === undefined || typeof groupID !== 'number') {
      throw new Error('groupID cannot be null or undefined and it must be of type number.');
    }
    if (applicationID !== null && applicationID !== undefined && typeof applicationID !== 'number') {
      throw new Error('applicationID must be of type number.');
    }
    if (acl !== null && acl !== undefined && typeof acl !== 'number') {
      throw new Error('acl must be of type number.');
    }
    if (page !== null && page !== undefined && typeof page !== 'number') {
      throw new Error('page must be of type number.');
    }
    if (page !== null && page !== undefined) {
      if (page > 2147483647)
      {
        throw new Error('"page" should satisfy the constraint - "InclusiveMaximum": 2147483647');
      }
      if (page < 1)
      {
        throw new Error('"page" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
    if (pageSize !== null && pageSize !== undefined && typeof pageSize !== 'number') {
      throw new Error('pageSize must be of type number.');
    }
    if (pageSize !== null && pageSize !== undefined) {
      if (pageSize > 1000)
      {
        throw new Error('"pageSize" should satisfy the constraint - "InclusiveMaximum": 1000');
      }
      if (pageSize < 1)
      {
        throw new Error('"pageSize" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
    if (sortOrder !== null && sortOrder !== undefined && typeof sortOrder.valueOf() !== 'string') {
      throw new Error('sortOrder must be of type string.');
    }
    if (sortBy !== null && sortBy !== undefined && typeof sortBy.valueOf() !== 'string') {
      throw new Error('sortBy must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'v1/directory/groups/{groupID}/applications';
  requestUrl = requestUrl.replace('{groupID}', encodeURIComponent(groupID.toString()));
  let queryParameters = [];
  if (applicationID !== null && applicationID !== undefined) {
    queryParameters.push('applicationID=' + encodeURIComponent(applicationID.toString()));
  }
  if (acl !== null && acl !== undefined) {
    queryParameters.push('acl=' + encodeURIComponent(acl.toString()));
  }
  if (page !== null && page !== undefined) {
    queryParameters.push('page=' + encodeURIComponent(page.toString()));
  }
  if (pageSize !== null && pageSize !== undefined) {
    queryParameters.push('pageSize=' + encodeURIComponent(pageSize.toString()));
  }
  if (sortOrder !== null && sortOrder !== undefined) {
    queryParameters.push('sortOrder=' + encodeURIComponent(sortOrder));
  }
  if (sortBy !== null && sortBy !== undefined) {
    queryParameters.push('sortBy=' + encodeURIComponent(sortBy));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200 && statusCode !== 403) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = {
            required: false,
            serializedName: 'parsedResponse',
            type: {
              name: 'Sequence',
              element: {
                  required: false,
                  serializedName: 'GroupApplicationModelElementType',
                  type: {
                    name: 'Composite',
                    className: 'GroupApplicationModel'
                  }
              }
            }
          };
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Inserts/Updates the application group association.
 *
 * @param {number} groupID The group identifier.
 *
 * @param {number} applicationID The application identifier.
 *
 * @param {object} model The model.
 *
 * @param {number} [model.groupID] Gets or sets the group identifier.
 *
 * @param {string} [model.groupName] Gets or sets the name of the group.
 *
 * @param {number} [model.applicationID] Gets or sets the application
 * identifier.
 *
 * @param {string} [model.applicationName] Gets or sets the name of the
 * application.
 *
 * @param {number} [model.acl] Gets or sets the acl.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _createOrUpdateApplicationGroupAssociation(groupID, applicationID, model, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (groupID === null || groupID === undefined || typeof groupID !== 'number') {
      throw new Error('groupID cannot be null or undefined and it must be of type number.');
    }
    if (applicationID === null || applicationID === undefined || typeof applicationID !== 'number') {
      throw new Error('applicationID cannot be null or undefined and it must be of type number.');
    }
    if (model === null || model === undefined) {
      throw new Error('model cannot be null or undefined.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'v1/directory/applications/{applicationID}/groups/{groupID}';
  requestUrl = requestUrl.replace('{groupID}', encodeURIComponent(groupID.toString()));
  requestUrl = requestUrl.replace('{applicationID}', encodeURIComponent(applicationID.toString()));

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'PUT';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (model !== null && model !== undefined) {
      let requestModelMapper = new client.models['GroupApplicationModel']().mapper();
      requestModel = client.serialize(requestModelMapper, model, 'model');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(model, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 204 && statusCode !== 403) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 204) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = {
            required: false,
            serializedName: 'parsedResponse',
            type: {
              name: 'Object'
            }
          };
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Deletes a application group association;
 *
 * @param {number} groupID The group identifier.
 *
 * @param {number} applicationID The application identifier.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _deleteApplicationGroupAssociation(groupID, applicationID, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (groupID === null || groupID === undefined || typeof groupID !== 'number') {
      throw new Error('groupID cannot be null or undefined and it must be of type number.');
    }
    if (applicationID === null || applicationID === undefined || typeof applicationID !== 'number') {
      throw new Error('applicationID cannot be null or undefined and it must be of type number.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'v1/directory/applications/{applicationID}/groups/{groupID}';
  requestUrl = requestUrl.replace('{groupID}', encodeURIComponent(groupID.toString()));
  requestUrl = requestUrl.replace('{applicationID}', encodeURIComponent(applicationID.toString()));

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'DELETE';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 204 && statusCode !== 403 && statusCode !== 404 && statusCode !== 500) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 204) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = {
            required: false,
            serializedName: 'parsedResponse',
            type: {
              name: 'Object'
            }
          };
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Inserts/Updates the group application association.
 *
 * @param {number} groupID The group identifier.
 *
 * @param {number} applicationID The application identifier.
 *
 * @param {object} model The model.
 *
 * @param {number} [model.groupID] Gets or sets the group identifier.
 *
 * @param {string} [model.groupName] Gets or sets the name of the group.
 *
 * @param {number} [model.applicationID] Gets or sets the application
 * identifier.
 *
 * @param {string} [model.applicationName] Gets or sets the name of the
 * application.
 *
 * @param {number} [model.acl] Gets or sets the acl.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _createOrUpdateGroupApplicationAssociation(groupID, applicationID, model, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (groupID === null || groupID === undefined || typeof groupID !== 'number') {
      throw new Error('groupID cannot be null or undefined and it must be of type number.');
    }
    if (applicationID === null || applicationID === undefined || typeof applicationID !== 'number') {
      throw new Error('applicationID cannot be null or undefined and it must be of type number.');
    }
    if (model === null || model === undefined) {
      throw new Error('model cannot be null or undefined.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'v1/directory/groups/{groupID}/applications/{applicationID}';
  requestUrl = requestUrl.replace('{groupID}', encodeURIComponent(groupID.toString()));
  requestUrl = requestUrl.replace('{applicationID}', encodeURIComponent(applicationID.toString()));

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'PUT';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (model !== null && model !== undefined) {
      let requestModelMapper = new client.models['GroupApplicationModel']().mapper();
      requestModel = client.serialize(requestModelMapper, model, 'model');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(model, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 204 && statusCode !== 403) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 204) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = {
            required: false,
            serializedName: 'parsedResponse',
            type: {
              name: 'Object'
            }
          };
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Deletes a group application association;
 *
 * @param {number} groupID The group identifier.
 *
 * @param {number} applicationID The application identifier.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _deleteGroupApplicationAssociation(groupID, applicationID, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (groupID === null || groupID === undefined || typeof groupID !== 'number') {
      throw new Error('groupID cannot be null or undefined and it must be of type number.');
    }
    if (applicationID === null || applicationID === undefined || typeof applicationID !== 'number') {
      throw new Error('applicationID cannot be null or undefined and it must be of type number.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'v1/directory/groups/{groupID}/applications/{applicationID}';
  requestUrl = requestUrl.replace('{groupID}', encodeURIComponent(groupID.toString()));
  requestUrl = requestUrl.replace('{applicationID}', encodeURIComponent(applicationID.toString()));

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'DELETE';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 204 && statusCode !== 403 && statusCode !== 404 && statusCode !== 500) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 204) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = {
            required: false,
            serializedName: 'parsedResponse',
            type: {
              name: 'Object'
            }
          };
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets a list of drawer user associations.
 *
 * @param {number} drawerID The drawer identifier.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {number} [options.userID] The user identifier.
 *
 * @param {number} [options.acl] Gets or sets the access control level
 * permissions.
 *
 * @param {number} [options.page] Gets or sets the page number.
 *
 * @param {number} [options.pageSize] Gets or sets the size of the page.
 *
 * @param {string} [options.sortOrder] Gets or sets the order. Possible values
 * include: 'Unspecified', 'Ascending', 'Descending'
 *
 * @param {string} [options.sortBy] Gets or sets the column to order by.
 * Possible values include: 'Unspecified', 'DrawerID', 'ApplicationID',
 * 'GroupID', 'UserID', 'QueueID', 'Acl'
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {array} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getDrawerUserAssociations(drawerID, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let userID = (options && options.userID !== undefined) ? options.userID : undefined;
  let acl = (options && options.acl !== undefined) ? options.acl : undefined;
  let page = (options && options.page !== undefined) ? options.page : undefined;
  let pageSize = (options && options.pageSize !== undefined) ? options.pageSize : undefined;
  let sortOrder = (options && options.sortOrder !== undefined) ? options.sortOrder : undefined;
  let sortBy = (options && options.sortBy !== undefined) ? options.sortBy : undefined;
  // Validate
  try {
    if (userID !== null && userID !== undefined && typeof userID !== 'number') {
      throw new Error('userID must be of type number.');
    }
    if (drawerID === null || drawerID === undefined || typeof drawerID !== 'number') {
      throw new Error('drawerID cannot be null or undefined and it must be of type number.');
    }
    if (acl !== null && acl !== undefined && typeof acl !== 'number') {
      throw new Error('acl must be of type number.');
    }
    if (page !== null && page !== undefined && typeof page !== 'number') {
      throw new Error('page must be of type number.');
    }
    if (page !== null && page !== undefined) {
      if (page > 2147483647)
      {
        throw new Error('"page" should satisfy the constraint - "InclusiveMaximum": 2147483647');
      }
      if (page < 1)
      {
        throw new Error('"page" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
    if (pageSize !== null && pageSize !== undefined && typeof pageSize !== 'number') {
      throw new Error('pageSize must be of type number.');
    }
    if (pageSize !== null && pageSize !== undefined) {
      if (pageSize > 1000)
      {
        throw new Error('"pageSize" should satisfy the constraint - "InclusiveMaximum": 1000');
      }
      if (pageSize < 1)
      {
        throw new Error('"pageSize" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
    if (sortOrder !== null && sortOrder !== undefined && typeof sortOrder.valueOf() !== 'string') {
      throw new Error('sortOrder must be of type string.');
    }
    if (sortBy !== null && sortBy !== undefined && typeof sortBy.valueOf() !== 'string') {
      throw new Error('sortBy must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'v1/directory/drawers/{drawerID}/users';
  requestUrl = requestUrl.replace('{drawerID}', encodeURIComponent(drawerID.toString()));
  let queryParameters = [];
  if (userID !== null && userID !== undefined) {
    queryParameters.push('userID=' + encodeURIComponent(userID.toString()));
  }
  if (acl !== null && acl !== undefined) {
    queryParameters.push('acl=' + encodeURIComponent(acl.toString()));
  }
  if (page !== null && page !== undefined) {
    queryParameters.push('page=' + encodeURIComponent(page.toString()));
  }
  if (pageSize !== null && pageSize !== undefined) {
    queryParameters.push('pageSize=' + encodeURIComponent(pageSize.toString()));
  }
  if (sortOrder !== null && sortOrder !== undefined) {
    queryParameters.push('sortOrder=' + encodeURIComponent(sortOrder));
  }
  if (sortBy !== null && sortBy !== undefined) {
    queryParameters.push('sortBy=' + encodeURIComponent(sortBy));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200 && statusCode !== 403) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = {
            required: false,
            serializedName: 'parsedResponse',
            type: {
              name: 'Sequence',
              element: {
                  required: false,
                  serializedName: 'UserDrawerModelElementType',
                  type: {
                    name: 'Composite',
                    className: 'UserDrawerModel'
                  }
              }
            }
          };
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets a list of user drawer associations.
 *
 * @param {number} userID The user identifier.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {number} [options.drawerID] The drawer identifier.
 *
 * @param {number} [options.acl] Gets or sets the access control level
 * permissions.
 *
 * @param {number} [options.page] Gets or sets the page number.
 *
 * @param {number} [options.pageSize] Gets or sets the size of the page.
 *
 * @param {string} [options.sortOrder] Gets or sets the order. Possible values
 * include: 'Unspecified', 'Ascending', 'Descending'
 *
 * @param {string} [options.sortBy] Gets or sets the column to order by.
 * Possible values include: 'Unspecified', 'DrawerID', 'ApplicationID',
 * 'GroupID', 'UserID', 'QueueID', 'Acl'
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {array} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getUserDrawerAssociations(userID, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let drawerID = (options && options.drawerID !== undefined) ? options.drawerID : undefined;
  let acl = (options && options.acl !== undefined) ? options.acl : undefined;
  let page = (options && options.page !== undefined) ? options.page : undefined;
  let pageSize = (options && options.pageSize !== undefined) ? options.pageSize : undefined;
  let sortOrder = (options && options.sortOrder !== undefined) ? options.sortOrder : undefined;
  let sortBy = (options && options.sortBy !== undefined) ? options.sortBy : undefined;
  // Validate
  try {
    if (userID === null || userID === undefined || typeof userID !== 'number') {
      throw new Error('userID cannot be null or undefined and it must be of type number.');
    }
    if (drawerID !== null && drawerID !== undefined && typeof drawerID !== 'number') {
      throw new Error('drawerID must be of type number.');
    }
    if (acl !== null && acl !== undefined && typeof acl !== 'number') {
      throw new Error('acl must be of type number.');
    }
    if (page !== null && page !== undefined && typeof page !== 'number') {
      throw new Error('page must be of type number.');
    }
    if (page !== null && page !== undefined) {
      if (page > 2147483647)
      {
        throw new Error('"page" should satisfy the constraint - "InclusiveMaximum": 2147483647');
      }
      if (page < 1)
      {
        throw new Error('"page" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
    if (pageSize !== null && pageSize !== undefined && typeof pageSize !== 'number') {
      throw new Error('pageSize must be of type number.');
    }
    if (pageSize !== null && pageSize !== undefined) {
      if (pageSize > 1000)
      {
        throw new Error('"pageSize" should satisfy the constraint - "InclusiveMaximum": 1000');
      }
      if (pageSize < 1)
      {
        throw new Error('"pageSize" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
    if (sortOrder !== null && sortOrder !== undefined && typeof sortOrder.valueOf() !== 'string') {
      throw new Error('sortOrder must be of type string.');
    }
    if (sortBy !== null && sortBy !== undefined && typeof sortBy.valueOf() !== 'string') {
      throw new Error('sortBy must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'v1/directory/users/{userID}/drawers';
  requestUrl = requestUrl.replace('{userID}', encodeURIComponent(userID.toString()));
  let queryParameters = [];
  if (drawerID !== null && drawerID !== undefined) {
    queryParameters.push('drawerID=' + encodeURIComponent(drawerID.toString()));
  }
  if (acl !== null && acl !== undefined) {
    queryParameters.push('acl=' + encodeURIComponent(acl.toString()));
  }
  if (page !== null && page !== undefined) {
    queryParameters.push('page=' + encodeURIComponent(page.toString()));
  }
  if (pageSize !== null && pageSize !== undefined) {
    queryParameters.push('pageSize=' + encodeURIComponent(pageSize.toString()));
  }
  if (sortOrder !== null && sortOrder !== undefined) {
    queryParameters.push('sortOrder=' + encodeURIComponent(sortOrder));
  }
  if (sortBy !== null && sortBy !== undefined) {
    queryParameters.push('sortBy=' + encodeURIComponent(sortBy));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200 && statusCode !== 403) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = {
            required: false,
            serializedName: 'parsedResponse',
            type: {
              name: 'Sequence',
              element: {
                  required: false,
                  serializedName: 'UserDrawerModelElementType',
                  type: {
                    name: 'Composite',
                    className: 'UserDrawerModel'
                  }
              }
            }
          };
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Inserts/Updates the drawer user association.
 *
 * @param {number} userID The user identifier.
 *
 * @param {number} drawerID The drawer identifier.
 *
 * @param {object} model The model.
 *
 * @param {number} [model.userID] Gets or sets the user identifier.
 *
 * @param {string} [model.userFullName] Gets or sets the full name of the user.
 *
 * @param {number} [model.drawerID] Gets or sets the drawer identifier.
 *
 * @param {string} [model.drawerName] Gets or sets the name of the drawer.
 *
 * @param {number} [model.acl] Gets or sets the access control level
 * permissions.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _createOrUpdateDrawerUserAssociation(userID, drawerID, model, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (userID === null || userID === undefined || typeof userID !== 'number') {
      throw new Error('userID cannot be null or undefined and it must be of type number.');
    }
    if (drawerID === null || drawerID === undefined || typeof drawerID !== 'number') {
      throw new Error('drawerID cannot be null or undefined and it must be of type number.');
    }
    if (model === null || model === undefined) {
      throw new Error('model cannot be null or undefined.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'v1/directory/drawers/{drawerID}/users/{userID}';
  requestUrl = requestUrl.replace('{userID}', encodeURIComponent(userID.toString()));
  requestUrl = requestUrl.replace('{drawerID}', encodeURIComponent(drawerID.toString()));

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'PUT';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (model !== null && model !== undefined) {
      let requestModelMapper = new client.models['UserDrawerModel']().mapper();
      requestModel = client.serialize(requestModelMapper, model, 'model');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(model, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 204 && statusCode !== 403) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 204) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = {
            required: false,
            serializedName: 'parsedResponse',
            type: {
              name: 'Object'
            }
          };
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Deletes a drawer user association;
 *
 * @param {number} userID The user identifier.
 *
 * @param {number} drawerID The drawer identifier.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _deleteDrawerUserAssociation(userID, drawerID, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (userID === null || userID === undefined || typeof userID !== 'number') {
      throw new Error('userID cannot be null or undefined and it must be of type number.');
    }
    if (drawerID === null || drawerID === undefined || typeof drawerID !== 'number') {
      throw new Error('drawerID cannot be null or undefined and it must be of type number.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'v1/directory/drawers/{drawerID}/users/{userID}';
  requestUrl = requestUrl.replace('{userID}', encodeURIComponent(userID.toString()));
  requestUrl = requestUrl.replace('{drawerID}', encodeURIComponent(drawerID.toString()));

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'DELETE';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 204 && statusCode !== 403 && statusCode !== 404) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 204) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = {
            required: false,
            serializedName: 'parsedResponse',
            type: {
              name: 'Object'
            }
          };
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Inserts/Updates the user drawer association.
 *
 * @param {number} userID The user identifier.
 *
 * @param {number} drawerID The drawer identifier.
 *
 * @param {object} model The model.
 *
 * @param {number} [model.userID] Gets or sets the user identifier.
 *
 * @param {string} [model.userFullName] Gets or sets the full name of the user.
 *
 * @param {number} [model.drawerID] Gets or sets the drawer identifier.
 *
 * @param {string} [model.drawerName] Gets or sets the name of the drawer.
 *
 * @param {number} [model.acl] Gets or sets the access control level
 * permissions.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _createOrUpdateUserDrawerAssociation(userID, drawerID, model, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (userID === null || userID === undefined || typeof userID !== 'number') {
      throw new Error('userID cannot be null or undefined and it must be of type number.');
    }
    if (drawerID === null || drawerID === undefined || typeof drawerID !== 'number') {
      throw new Error('drawerID cannot be null or undefined and it must be of type number.');
    }
    if (model === null || model === undefined) {
      throw new Error('model cannot be null or undefined.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'v1/directory/users/{userID}/drawers/{drawerID}';
  requestUrl = requestUrl.replace('{userID}', encodeURIComponent(userID.toString()));
  requestUrl = requestUrl.replace('{drawerID}', encodeURIComponent(drawerID.toString()));

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'PUT';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (model !== null && model !== undefined) {
      let requestModelMapper = new client.models['UserDrawerModel']().mapper();
      requestModel = client.serialize(requestModelMapper, model, 'model');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(model, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 204 && statusCode !== 403) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 204) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = {
            required: false,
            serializedName: 'parsedResponse',
            type: {
              name: 'Object'
            }
          };
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Deletes a user drawer association;
 *
 * @param {number} userID The user identifier.
 *
 * @param {number} drawerID The drawer identifier.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _deleteUserDrawerAssociation(userID, drawerID, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (userID === null || userID === undefined || typeof userID !== 'number') {
      throw new Error('userID cannot be null or undefined and it must be of type number.');
    }
    if (drawerID === null || drawerID === undefined || typeof drawerID !== 'number') {
      throw new Error('drawerID cannot be null or undefined and it must be of type number.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'v1/directory/users/{userID}/drawers/{drawerID}';
  requestUrl = requestUrl.replace('{userID}', encodeURIComponent(userID.toString()));
  requestUrl = requestUrl.replace('{drawerID}', encodeURIComponent(drawerID.toString()));

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'DELETE';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 204 && statusCode !== 403 && statusCode !== 404) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 204) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = {
            required: false,
            serializedName: 'parsedResponse',
            type: {
              name: 'Object'
            }
          };
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets a list of queue user associations.
 *
 * @param {number} queueID The queue identifier.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {number} [options.userID] The user identifier.
 *
 * @param {number} [options.acl] Gets or sets the access control level
 * permissions.
 *
 * @param {number} [options.page] Gets or sets the page number.
 *
 * @param {number} [options.pageSize] Gets or sets the size of the page.
 *
 * @param {string} [options.sortOrder] Gets or sets the order. Possible values
 * include: 'Unspecified', 'Ascending', 'Descending'
 *
 * @param {string} [options.sortBy] Gets or sets the column to order by.
 * Possible values include: 'Unspecified', 'DrawerID', 'ApplicationID',
 * 'GroupID', 'UserID', 'QueueID', 'Acl'
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {array} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getQueueUserAssociations(queueID, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let userID = (options && options.userID !== undefined) ? options.userID : undefined;
  let acl = (options && options.acl !== undefined) ? options.acl : undefined;
  let page = (options && options.page !== undefined) ? options.page : undefined;
  let pageSize = (options && options.pageSize !== undefined) ? options.pageSize : undefined;
  let sortOrder = (options && options.sortOrder !== undefined) ? options.sortOrder : undefined;
  let sortBy = (options && options.sortBy !== undefined) ? options.sortBy : undefined;
  // Validate
  try {
    if (userID !== null && userID !== undefined && typeof userID !== 'number') {
      throw new Error('userID must be of type number.');
    }
    if (queueID === null || queueID === undefined || typeof queueID !== 'number') {
      throw new Error('queueID cannot be null or undefined and it must be of type number.');
    }
    if (acl !== null && acl !== undefined && typeof acl !== 'number') {
      throw new Error('acl must be of type number.');
    }
    if (page !== null && page !== undefined && typeof page !== 'number') {
      throw new Error('page must be of type number.');
    }
    if (page !== null && page !== undefined) {
      if (page > 2147483647)
      {
        throw new Error('"page" should satisfy the constraint - "InclusiveMaximum": 2147483647');
      }
      if (page < 1)
      {
        throw new Error('"page" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
    if (pageSize !== null && pageSize !== undefined && typeof pageSize !== 'number') {
      throw new Error('pageSize must be of type number.');
    }
    if (pageSize !== null && pageSize !== undefined) {
      if (pageSize > 1000)
      {
        throw new Error('"pageSize" should satisfy the constraint - "InclusiveMaximum": 1000');
      }
      if (pageSize < 1)
      {
        throw new Error('"pageSize" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
    if (sortOrder !== null && sortOrder !== undefined && typeof sortOrder.valueOf() !== 'string') {
      throw new Error('sortOrder must be of type string.');
    }
    if (sortBy !== null && sortBy !== undefined && typeof sortBy.valueOf() !== 'string') {
      throw new Error('sortBy must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'v1/workflow/queues/{queueID}/users';
  requestUrl = requestUrl.replace('{queueID}', encodeURIComponent(queueID.toString()));
  let queryParameters = [];
  if (userID !== null && userID !== undefined) {
    queryParameters.push('userID=' + encodeURIComponent(userID.toString()));
  }
  if (acl !== null && acl !== undefined) {
    queryParameters.push('acl=' + encodeURIComponent(acl.toString()));
  }
  if (page !== null && page !== undefined) {
    queryParameters.push('page=' + encodeURIComponent(page.toString()));
  }
  if (pageSize !== null && pageSize !== undefined) {
    queryParameters.push('pageSize=' + encodeURIComponent(pageSize.toString()));
  }
  if (sortOrder !== null && sortOrder !== undefined) {
    queryParameters.push('sortOrder=' + encodeURIComponent(sortOrder));
  }
  if (sortBy !== null && sortBy !== undefined) {
    queryParameters.push('sortBy=' + encodeURIComponent(sortBy));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200 && statusCode !== 403) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = {
            required: false,
            serializedName: 'parsedResponse',
            type: {
              name: 'Sequence',
              element: {
                  required: false,
                  serializedName: 'UserQueueModelElementType',
                  type: {
                    name: 'Composite',
                    className: 'UserQueueModel'
                  }
              }
            }
          };
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets a list of user queue associations.
 *
 * @param {number} userID The user identifier.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {number} [options.queueID] The queue identifier.
 *
 * @param {number} [options.acl] Gets or sets the access control level
 * permissions.
 *
 * @param {number} [options.page] Gets or sets the page number.
 *
 * @param {number} [options.pageSize] Gets or sets the size of the page.
 *
 * @param {string} [options.sortOrder] Gets or sets the order. Possible values
 * include: 'Unspecified', 'Ascending', 'Descending'
 *
 * @param {string} [options.sortBy] Gets or sets the column to order by.
 * Possible values include: 'Unspecified', 'DrawerID', 'ApplicationID',
 * 'GroupID', 'UserID', 'QueueID', 'Acl'
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {array} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getUserQueueAssociations(userID, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let queueID = (options && options.queueID !== undefined) ? options.queueID : undefined;
  let acl = (options && options.acl !== undefined) ? options.acl : undefined;
  let page = (options && options.page !== undefined) ? options.page : undefined;
  let pageSize = (options && options.pageSize !== undefined) ? options.pageSize : undefined;
  let sortOrder = (options && options.sortOrder !== undefined) ? options.sortOrder : undefined;
  let sortBy = (options && options.sortBy !== undefined) ? options.sortBy : undefined;
  // Validate
  try {
    if (userID === null || userID === undefined || typeof userID !== 'number') {
      throw new Error('userID cannot be null or undefined and it must be of type number.');
    }
    if (queueID !== null && queueID !== undefined && typeof queueID !== 'number') {
      throw new Error('queueID must be of type number.');
    }
    if (acl !== null && acl !== undefined && typeof acl !== 'number') {
      throw new Error('acl must be of type number.');
    }
    if (page !== null && page !== undefined && typeof page !== 'number') {
      throw new Error('page must be of type number.');
    }
    if (page !== null && page !== undefined) {
      if (page > 2147483647)
      {
        throw new Error('"page" should satisfy the constraint - "InclusiveMaximum": 2147483647');
      }
      if (page < 1)
      {
        throw new Error('"page" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
    if (pageSize !== null && pageSize !== undefined && typeof pageSize !== 'number') {
      throw new Error('pageSize must be of type number.');
    }
    if (pageSize !== null && pageSize !== undefined) {
      if (pageSize > 1000)
      {
        throw new Error('"pageSize" should satisfy the constraint - "InclusiveMaximum": 1000');
      }
      if (pageSize < 1)
      {
        throw new Error('"pageSize" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
    if (sortOrder !== null && sortOrder !== undefined && typeof sortOrder.valueOf() !== 'string') {
      throw new Error('sortOrder must be of type string.');
    }
    if (sortBy !== null && sortBy !== undefined && typeof sortBy.valueOf() !== 'string') {
      throw new Error('sortBy must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'v1/directory/users/{userID}/queues';
  requestUrl = requestUrl.replace('{userID}', encodeURIComponent(userID.toString()));
  let queryParameters = [];
  if (queueID !== null && queueID !== undefined) {
    queryParameters.push('queueID=' + encodeURIComponent(queueID.toString()));
  }
  if (acl !== null && acl !== undefined) {
    queryParameters.push('acl=' + encodeURIComponent(acl.toString()));
  }
  if (page !== null && page !== undefined) {
    queryParameters.push('page=' + encodeURIComponent(page.toString()));
  }
  if (pageSize !== null && pageSize !== undefined) {
    queryParameters.push('pageSize=' + encodeURIComponent(pageSize.toString()));
  }
  if (sortOrder !== null && sortOrder !== undefined) {
    queryParameters.push('sortOrder=' + encodeURIComponent(sortOrder));
  }
  if (sortBy !== null && sortBy !== undefined) {
    queryParameters.push('sortBy=' + encodeURIComponent(sortBy));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200 && statusCode !== 403) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = {
            required: false,
            serializedName: 'parsedResponse',
            type: {
              name: 'Sequence',
              element: {
                  required: false,
                  serializedName: 'UserQueueModelElementType',
                  type: {
                    name: 'Composite',
                    className: 'UserQueueModel'
                  }
              }
            }
          };
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Inserts/Updates the queue user association.
 *
 * @param {number} userID The user identifier.
 *
 * @param {number} queueID The queue identifier.
 *
 * @param {object} model The model.
 *
 * @param {number} [model.userID] Gets or sets the user identifier.
 *
 * @param {string} [model.userFullName] Gets or sets the full name of the user.
 *
 * @param {number} [model.queueID] Gets or sets the queue identifier.
 *
 * @param {string} [model.queueName] Gets or sets the name of the queue.
 *
 * @param {number} [model.acl] Gets or sets the access control level
 * permissions.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _createOrUpdateQueueUserAssociation(userID, queueID, model, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (userID === null || userID === undefined || typeof userID !== 'number') {
      throw new Error('userID cannot be null or undefined and it must be of type number.');
    }
    if (queueID === null || queueID === undefined || typeof queueID !== 'number') {
      throw new Error('queueID cannot be null or undefined and it must be of type number.');
    }
    if (model === null || model === undefined) {
      throw new Error('model cannot be null or undefined.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'v1/workflow/queues/{queueID}/users/{userID}';
  requestUrl = requestUrl.replace('{userID}', encodeURIComponent(userID.toString()));
  requestUrl = requestUrl.replace('{queueID}', encodeURIComponent(queueID.toString()));

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'PUT';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (model !== null && model !== undefined) {
      let requestModelMapper = new client.models['UserQueueModel']().mapper();
      requestModel = client.serialize(requestModelMapper, model, 'model');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(model, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 204 && statusCode !== 403) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 204) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = {
            required: false,
            serializedName: 'parsedResponse',
            type: {
              name: 'Object'
            }
          };
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Deletes a queue user association;
 *
 * @param {number} userID The user identifier.
 *
 * @param {number} queueID The queue identifier.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _deleteQueueUserAssociation(userID, queueID, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (userID === null || userID === undefined || typeof userID !== 'number') {
      throw new Error('userID cannot be null or undefined and it must be of type number.');
    }
    if (queueID === null || queueID === undefined || typeof queueID !== 'number') {
      throw new Error('queueID cannot be null or undefined and it must be of type number.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'v1/workflow/queues/{queueID}/users/{userID}';
  requestUrl = requestUrl.replace('{userID}', encodeURIComponent(userID.toString()));
  requestUrl = requestUrl.replace('{queueID}', encodeURIComponent(queueID.toString()));

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'DELETE';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 204 && statusCode !== 403 && statusCode !== 404) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 204) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = {
            required: false,
            serializedName: 'parsedResponse',
            type: {
              name: 'Object'
            }
          };
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Inserts/Updates the user queue association.
 *
 * @param {number} userID The user identifier.
 *
 * @param {number} queueID The queue identifier.
 *
 * @param {object} model The model.
 *
 * @param {number} [model.userID] Gets or sets the user identifier.
 *
 * @param {string} [model.userFullName] Gets or sets the full name of the user.
 *
 * @param {number} [model.queueID] Gets or sets the queue identifier.
 *
 * @param {string} [model.queueName] Gets or sets the name of the queue.
 *
 * @param {number} [model.acl] Gets or sets the access control level
 * permissions.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _createOrUpdateUserQueueAssociation(userID, queueID, model, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (userID === null || userID === undefined || typeof userID !== 'number') {
      throw new Error('userID cannot be null or undefined and it must be of type number.');
    }
    if (queueID === null || queueID === undefined || typeof queueID !== 'number') {
      throw new Error('queueID cannot be null or undefined and it must be of type number.');
    }
    if (model === null || model === undefined) {
      throw new Error('model cannot be null or undefined.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'v1/directory/users/{userID}/queues/{queueID}';
  requestUrl = requestUrl.replace('{userID}', encodeURIComponent(userID.toString()));
  requestUrl = requestUrl.replace('{queueID}', encodeURIComponent(queueID.toString()));

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'PUT';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (model !== null && model !== undefined) {
      let requestModelMapper = new client.models['UserQueueModel']().mapper();
      requestModel = client.serialize(requestModelMapper, model, 'model');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(model, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 204 && statusCode !== 403) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 204) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = {
            required: false,
            serializedName: 'parsedResponse',
            type: {
              name: 'Object'
            }
          };
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Deletes a user queue association;
 *
 * @param {number} userID The user identifier.
 *
 * @param {number} queueID The queue identifier.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _deleteUserQueueAssociation(userID, queueID, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (userID === null || userID === undefined || typeof userID !== 'number') {
      throw new Error('userID cannot be null or undefined and it must be of type number.');
    }
    if (queueID === null || queueID === undefined || typeof queueID !== 'number') {
      throw new Error('queueID cannot be null or undefined and it must be of type number.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'v1/directory/users/{userID}/queues/{queueID}';
  requestUrl = requestUrl.replace('{userID}', encodeURIComponent(userID.toString()));
  requestUrl = requestUrl.replace('{queueID}', encodeURIComponent(queueID.toString()));

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'DELETE';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 204 && statusCode !== 403 && statusCode !== 404) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 204) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = {
            required: false,
            serializedName: 'parsedResponse',
            type: {
              name: 'Object'
            }
          };
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets a list of application user associations.
 *
 * @param {number} applicationID The application identifier.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {number} [options.userID] The user identifier.
 *
 * @param {number} [options.acl] Gets or sets the access control level
 * permissions.
 *
 * @param {number} [options.page] Gets or sets the page number.
 *
 * @param {number} [options.pageSize] Gets or sets the size of the page.
 *
 * @param {string} [options.sortOrder] Gets or sets the order. Possible values
 * include: 'Unspecified', 'Ascending', 'Descending'
 *
 * @param {string} [options.sortBy] Gets or sets the column to order by.
 * Possible values include: 'Unspecified', 'DrawerID', 'ApplicationID',
 * 'GroupID', 'UserID', 'QueueID', 'Acl'
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {array} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getApplicationUserAssociations(applicationID, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let userID = (options && options.userID !== undefined) ? options.userID : undefined;
  let acl = (options && options.acl !== undefined) ? options.acl : undefined;
  let page = (options && options.page !== undefined) ? options.page : undefined;
  let pageSize = (options && options.pageSize !== undefined) ? options.pageSize : undefined;
  let sortOrder = (options && options.sortOrder !== undefined) ? options.sortOrder : undefined;
  let sortBy = (options && options.sortBy !== undefined) ? options.sortBy : undefined;
  // Validate
  try {
    if (userID !== null && userID !== undefined && typeof userID !== 'number') {
      throw new Error('userID must be of type number.');
    }
    if (applicationID === null || applicationID === undefined || typeof applicationID !== 'number') {
      throw new Error('applicationID cannot be null or undefined and it must be of type number.');
    }
    if (acl !== null && acl !== undefined && typeof acl !== 'number') {
      throw new Error('acl must be of type number.');
    }
    if (page !== null && page !== undefined && typeof page !== 'number') {
      throw new Error('page must be of type number.');
    }
    if (page !== null && page !== undefined) {
      if (page > 2147483647)
      {
        throw new Error('"page" should satisfy the constraint - "InclusiveMaximum": 2147483647');
      }
      if (page < 1)
      {
        throw new Error('"page" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
    if (pageSize !== null && pageSize !== undefined && typeof pageSize !== 'number') {
      throw new Error('pageSize must be of type number.');
    }
    if (pageSize !== null && pageSize !== undefined) {
      if (pageSize > 1000)
      {
        throw new Error('"pageSize" should satisfy the constraint - "InclusiveMaximum": 1000');
      }
      if (pageSize < 1)
      {
        throw new Error('"pageSize" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
    if (sortOrder !== null && sortOrder !== undefined && typeof sortOrder.valueOf() !== 'string') {
      throw new Error('sortOrder must be of type string.');
    }
    if (sortBy !== null && sortBy !== undefined && typeof sortBy.valueOf() !== 'string') {
      throw new Error('sortBy must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'v1/directory/applications/{applicationID}/users';
  requestUrl = requestUrl.replace('{applicationID}', encodeURIComponent(applicationID.toString()));
  let queryParameters = [];
  if (userID !== null && userID !== undefined) {
    queryParameters.push('userID=' + encodeURIComponent(userID.toString()));
  }
  if (acl !== null && acl !== undefined) {
    queryParameters.push('acl=' + encodeURIComponent(acl.toString()));
  }
  if (page !== null && page !== undefined) {
    queryParameters.push('page=' + encodeURIComponent(page.toString()));
  }
  if (pageSize !== null && pageSize !== undefined) {
    queryParameters.push('pageSize=' + encodeURIComponent(pageSize.toString()));
  }
  if (sortOrder !== null && sortOrder !== undefined) {
    queryParameters.push('sortOrder=' + encodeURIComponent(sortOrder));
  }
  if (sortBy !== null && sortBy !== undefined) {
    queryParameters.push('sortBy=' + encodeURIComponent(sortBy));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200 && statusCode !== 403) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = {
            required: false,
            serializedName: 'parsedResponse',
            type: {
              name: 'Sequence',
              element: {
                  required: false,
                  serializedName: 'UserApplicationModelElementType',
                  type: {
                    name: 'Composite',
                    className: 'UserApplicationModel'
                  }
              }
            }
          };
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets a list of user application associations.
 *
 * @param {number} userID The user identifier.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {number} [options.applicationID] The application identifier.
 *
 * @param {number} [options.acl] Gets or sets the access control level
 * permissions.
 *
 * @param {number} [options.page] Gets or sets the page number.
 *
 * @param {number} [options.pageSize] Gets or sets the size of the page.
 *
 * @param {string} [options.sortOrder] Gets or sets the order. Possible values
 * include: 'Unspecified', 'Ascending', 'Descending'
 *
 * @param {string} [options.sortBy] Gets or sets the column to order by.
 * Possible values include: 'Unspecified', 'DrawerID', 'ApplicationID',
 * 'GroupID', 'UserID', 'QueueID', 'Acl'
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {array} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getUserApplicationAssociations(userID, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let applicationID = (options && options.applicationID !== undefined) ? options.applicationID : undefined;
  let acl = (options && options.acl !== undefined) ? options.acl : undefined;
  let page = (options && options.page !== undefined) ? options.page : undefined;
  let pageSize = (options && options.pageSize !== undefined) ? options.pageSize : undefined;
  let sortOrder = (options && options.sortOrder !== undefined) ? options.sortOrder : undefined;
  let sortBy = (options && options.sortBy !== undefined) ? options.sortBy : undefined;
  // Validate
  try {
    if (userID === null || userID === undefined || typeof userID !== 'number') {
      throw new Error('userID cannot be null or undefined and it must be of type number.');
    }
    if (applicationID !== null && applicationID !== undefined && typeof applicationID !== 'number') {
      throw new Error('applicationID must be of type number.');
    }
    if (acl !== null && acl !== undefined && typeof acl !== 'number') {
      throw new Error('acl must be of type number.');
    }
    if (page !== null && page !== undefined && typeof page !== 'number') {
      throw new Error('page must be of type number.');
    }
    if (page !== null && page !== undefined) {
      if (page > 2147483647)
      {
        throw new Error('"page" should satisfy the constraint - "InclusiveMaximum": 2147483647');
      }
      if (page < 1)
      {
        throw new Error('"page" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
    if (pageSize !== null && pageSize !== undefined && typeof pageSize !== 'number') {
      throw new Error('pageSize must be of type number.');
    }
    if (pageSize !== null && pageSize !== undefined) {
      if (pageSize > 1000)
      {
        throw new Error('"pageSize" should satisfy the constraint - "InclusiveMaximum": 1000');
      }
      if (pageSize < 1)
      {
        throw new Error('"pageSize" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
    if (sortOrder !== null && sortOrder !== undefined && typeof sortOrder.valueOf() !== 'string') {
      throw new Error('sortOrder must be of type string.');
    }
    if (sortBy !== null && sortBy !== undefined && typeof sortBy.valueOf() !== 'string') {
      throw new Error('sortBy must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'v1/directory/users/{userID}/applications';
  requestUrl = requestUrl.replace('{userID}', encodeURIComponent(userID.toString()));
  let queryParameters = [];
  if (applicationID !== null && applicationID !== undefined) {
    queryParameters.push('applicationID=' + encodeURIComponent(applicationID.toString()));
  }
  if (acl !== null && acl !== undefined) {
    queryParameters.push('acl=' + encodeURIComponent(acl.toString()));
  }
  if (page !== null && page !== undefined) {
    queryParameters.push('page=' + encodeURIComponent(page.toString()));
  }
  if (pageSize !== null && pageSize !== undefined) {
    queryParameters.push('pageSize=' + encodeURIComponent(pageSize.toString()));
  }
  if (sortOrder !== null && sortOrder !== undefined) {
    queryParameters.push('sortOrder=' + encodeURIComponent(sortOrder));
  }
  if (sortBy !== null && sortBy !== undefined) {
    queryParameters.push('sortBy=' + encodeURIComponent(sortBy));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200 && statusCode !== 403) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = {
            required: false,
            serializedName: 'parsedResponse',
            type: {
              name: 'Sequence',
              element: {
                  required: false,
                  serializedName: 'UserApplicationModelElementType',
                  type: {
                    name: 'Composite',
                    className: 'UserApplicationModel'
                  }
              }
            }
          };
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Inserts/Updates the application user association.
 *
 * @param {number} userID The user identifier.
 *
 * @param {number} applicationID The application identifier.
 *
 * @param {object} model The model.
 *
 * @param {number} [model.userID] Gets or sets the user identifier.
 *
 * @param {string} [model.userFullName] Gets or sets the full name of the user.
 *
 * @param {number} [model.applicationID] Gets or sets the application
 * identifier.
 *
 * @param {string} [model.applicationName] Gets or sets the name of the
 * application.
 *
 * @param {number} [model.acl] Gets or sets the access control level
 * permissions.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _createOrUpdateApplicationUserAssociation(userID, applicationID, model, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (userID === null || userID === undefined || typeof userID !== 'number') {
      throw new Error('userID cannot be null or undefined and it must be of type number.');
    }
    if (applicationID === null || applicationID === undefined || typeof applicationID !== 'number') {
      throw new Error('applicationID cannot be null or undefined and it must be of type number.');
    }
    if (model === null || model === undefined) {
      throw new Error('model cannot be null or undefined.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'v1/directory/applications/{applicationID}/users/{userID}';
  requestUrl = requestUrl.replace('{userID}', encodeURIComponent(userID.toString()));
  requestUrl = requestUrl.replace('{applicationID}', encodeURIComponent(applicationID.toString()));

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'PUT';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (model !== null && model !== undefined) {
      let requestModelMapper = new client.models['UserApplicationModel']().mapper();
      requestModel = client.serialize(requestModelMapper, model, 'model');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(model, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 204 && statusCode !== 403) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 204) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = {
            required: false,
            serializedName: 'parsedResponse',
            type: {
              name: 'Object'
            }
          };
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Deletes an application user association;
 *
 * @param {number} userID The user identifier.
 *
 * @param {number} applicationID The application identifier.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _deleteApplicationUserAssociation(userID, applicationID, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (userID === null || userID === undefined || typeof userID !== 'number') {
      throw new Error('userID cannot be null or undefined and it must be of type number.');
    }
    if (applicationID === null || applicationID === undefined || typeof applicationID !== 'number') {
      throw new Error('applicationID cannot be null or undefined and it must be of type number.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'v1/directory/applications/{applicationID}/users/{userID}';
  requestUrl = requestUrl.replace('{userID}', encodeURIComponent(userID.toString()));
  requestUrl = requestUrl.replace('{applicationID}', encodeURIComponent(applicationID.toString()));

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'DELETE';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 204 && statusCode !== 403 && statusCode !== 404) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 204) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = {
            required: false,
            serializedName: 'parsedResponse',
            type: {
              name: 'Object'
            }
          };
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Inserts/Updates the user application association.
 *
 * @param {number} userID The user identifier.
 *
 * @param {number} applicationID The application identifier.
 *
 * @param {object} model The model.
 *
 * @param {number} [model.userID] Gets or sets the user identifier.
 *
 * @param {string} [model.userFullName] Gets or sets the full name of the user.
 *
 * @param {number} [model.applicationID] Gets or sets the application
 * identifier.
 *
 * @param {string} [model.applicationName] Gets or sets the name of the
 * application.
 *
 * @param {number} [model.acl] Gets or sets the access control level
 * permissions.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _createOrUpdateUserApplicationAssociation(userID, applicationID, model, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (userID === null || userID === undefined || typeof userID !== 'number') {
      throw new Error('userID cannot be null or undefined and it must be of type number.');
    }
    if (applicationID === null || applicationID === undefined || typeof applicationID !== 'number') {
      throw new Error('applicationID cannot be null or undefined and it must be of type number.');
    }
    if (model === null || model === undefined) {
      throw new Error('model cannot be null or undefined.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'v1/directory/users/{userID}/applications/{applicationID}';
  requestUrl = requestUrl.replace('{userID}', encodeURIComponent(userID.toString()));
  requestUrl = requestUrl.replace('{applicationID}', encodeURIComponent(applicationID.toString()));

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'PUT';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (model !== null && model !== undefined) {
      let requestModelMapper = new client.models['UserApplicationModel']().mapper();
      requestModel = client.serialize(requestModelMapper, model, 'model');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(model, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 204 && statusCode !== 403) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 204) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = {
            required: false,
            serializedName: 'parsedResponse',
            type: {
              name: 'Object'
            }
          };
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Deletes a user application association;
 *
 * @param {number} userID The user identifier.
 *
 * @param {number} applicationID The application identifier.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _deleteUserApplicationAssociation(userID, applicationID, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (userID === null || userID === undefined || typeof userID !== 'number') {
      throw new Error('userID cannot be null or undefined and it must be of type number.');
    }
    if (applicationID === null || applicationID === undefined || typeof applicationID !== 'number') {
      throw new Error('applicationID cannot be null or undefined and it must be of type number.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'v1/directory/users/{userID}/applications/{applicationID}';
  requestUrl = requestUrl.replace('{userID}', encodeURIComponent(userID.toString()));
  requestUrl = requestUrl.replace('{applicationID}', encodeURIComponent(applicationID.toString()));

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'DELETE';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 204 && statusCode !== 403 && statusCode !== 404) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 204) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = {
            required: false,
            serializedName: 'parsedResponse',
            type: {
              name: 'Object'
            }
          };
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets a paged list of attachment metadata.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {string} [options.type] Gets or sets the type. Possible values
 * include: 'Standard', 'EntityLink', 'WebLink'
 *
 * @param {string} [options.extension] Gets or sets the extension.
 *
 * @param {number} [options.minSize] Gets or sets the minimum size.
 *
 * @param {number} [options.maxSize] Gets or sets the maximum size.
 *
 * @param {number} [options.acl] Gets or sets the access control list.
 *
 * @param {number} [options.entityID] Gets or sets the entity identifier.
 *
 * @param {number} [options.drawerID] Gets or sets the drawer identifier.
 *
 * @param {string} [options.name] Gets or sets the name.
 *
 * @param {number} [options.creatorUserID] Gets or sets the creator user
 * identifier.
 *
 * @param {number} [options.modifierUserID] Gets or sets the modifier user
 * identifier.
 *
 * @param {date} [options.minInsertionTime] Gets or sets the minimum insertion
 * time.
 *
 * @param {date} [options.maxInsertionTime] Gets or sets the maximum insertion
 * time.
 *
 * @param {date} [options.minModificationTime] Gets or sets the minimum
 * modification time.
 *
 * @param {date} [options.maxModificationTime] Gets or sets the maximum
 * modification time.
 *
 * @param {number} [options.page] Gets or sets the page number.
 *
 * @param {number} [options.pageSize] Gets or sets the size of the page.
 *
 * @param {string} [options.sortOrder] Gets or sets the order. Possible values
 * include: 'Unspecified', 'Ascending', 'Descending'
 *
 * @param {string} [options.sortBy] Gets or sets the column to order by.
 * Possible values include: 'PageNumber', 'ID', 'Type', 'InsertionTime',
 * 'ModificationTime', 'CrossReferenceID', 'SubType', 'Extension', 'Name'
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {array} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getAttachmentsByFilter(options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let type = (options && options.type !== undefined) ? options.type : undefined;
  let extension = (options && options.extension !== undefined) ? options.extension : undefined;
  let minSize = (options && options.minSize !== undefined) ? options.minSize : undefined;
  let maxSize = (options && options.maxSize !== undefined) ? options.maxSize : undefined;
  let acl = (options && options.acl !== undefined) ? options.acl : undefined;
  let entityID = (options && options.entityID !== undefined) ? options.entityID : undefined;
  let drawerID = (options && options.drawerID !== undefined) ? options.drawerID : undefined;
  let name = (options && options.name !== undefined) ? options.name : undefined;
  let creatorUserID = (options && options.creatorUserID !== undefined) ? options.creatorUserID : undefined;
  let modifierUserID = (options && options.modifierUserID !== undefined) ? options.modifierUserID : undefined;
  let minInsertionTime = (options && options.minInsertionTime !== undefined) ? options.minInsertionTime : undefined;
  let maxInsertionTime = (options && options.maxInsertionTime !== undefined) ? options.maxInsertionTime : undefined;
  let minModificationTime = (options && options.minModificationTime !== undefined) ? options.minModificationTime : undefined;
  let maxModificationTime = (options && options.maxModificationTime !== undefined) ? options.maxModificationTime : undefined;
  let page = (options && options.page !== undefined) ? options.page : undefined;
  let pageSize = (options && options.pageSize !== undefined) ? options.pageSize : undefined;
  let sortOrder = (options && options.sortOrder !== undefined) ? options.sortOrder : undefined;
  let sortBy = (options && options.sortBy !== undefined) ? options.sortBy : undefined;
  // Validate
  try {
    if (type !== null && type !== undefined && typeof type.valueOf() !== 'string') {
      throw new Error('type must be of type string.');
    }
    if (extension !== null && extension !== undefined && typeof extension.valueOf() !== 'string') {
      throw new Error('extension must be of type string.');
    }
    if (extension !== null && extension !== undefined) {
      if (extension.length > 255)
      {
        throw new Error('"extension" should satisfy the constraint - "MaxLength": 255');
      }
      if (extension.length < 0)
      {
        throw new Error('"extension" should satisfy the constraint - "MinLength": 0');
      }
    }
    if (minSize !== null && minSize !== undefined && typeof minSize !== 'number') {
      throw new Error('minSize must be of type number.');
    }
    if (minSize !== null && minSize !== undefined) {
      if (minSize < 0)
      {
        throw new Error('"minSize" should satisfy the constraint - "InclusiveMinimum": 0');
      }
    }
    if (maxSize !== null && maxSize !== undefined && typeof maxSize !== 'number') {
      throw new Error('maxSize must be of type number.');
    }
    if (maxSize !== null && maxSize !== undefined) {
      if (maxSize < 1)
      {
        throw new Error('"maxSize" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
    if (acl !== null && acl !== undefined && typeof acl !== 'number') {
      throw new Error('acl must be of type number.');
    }
    if (entityID !== null && entityID !== undefined && typeof entityID !== 'number') {
      throw new Error('entityID must be of type number.');
    }
    if (entityID !== null && entityID !== undefined) {
      if (entityID > 2147483647)
      {
        throw new Error('"entityID" should satisfy the constraint - "InclusiveMaximum": 2147483647');
      }
      if (entityID < 1)
      {
        throw new Error('"entityID" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
    if (drawerID !== null && drawerID !== undefined && typeof drawerID !== 'number') {
      throw new Error('drawerID must be of type number.');
    }
    if (drawerID !== null && drawerID !== undefined) {
      if (drawerID > 2147483647)
      {
        throw new Error('"drawerID" should satisfy the constraint - "InclusiveMaximum": 2147483647');
      }
      if (drawerID < 1)
      {
        throw new Error('"drawerID" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
    if (name !== null && name !== undefined && typeof name.valueOf() !== 'string') {
      throw new Error('name must be of type string.');
    }
    if (name !== null && name !== undefined) {
      if (name.length > 255)
      {
        throw new Error('"name" should satisfy the constraint - "MaxLength": 255');
      }
      if (name.length < 0)
      {
        throw new Error('"name" should satisfy the constraint - "MinLength": 0');
      }
    }
    if (creatorUserID !== null && creatorUserID !== undefined && typeof creatorUserID !== 'number') {
      throw new Error('creatorUserID must be of type number.');
    }
    if (creatorUserID !== null && creatorUserID !== undefined) {
      if (creatorUserID > 2147483647)
      {
        throw new Error('"creatorUserID" should satisfy the constraint - "InclusiveMaximum": 2147483647');
      }
      if (creatorUserID < 1)
      {
        throw new Error('"creatorUserID" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
    if (modifierUserID !== null && modifierUserID !== undefined && typeof modifierUserID !== 'number') {
      throw new Error('modifierUserID must be of type number.');
    }
    if (modifierUserID !== null && modifierUserID !== undefined) {
      if (modifierUserID > 2147483647)
      {
        throw new Error('"modifierUserID" should satisfy the constraint - "InclusiveMaximum": 2147483647');
      }
      if (modifierUserID < 1)
      {
        throw new Error('"modifierUserID" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
    if (minInsertionTime && !(minInsertionTime instanceof Date ||
        (typeof minInsertionTime.valueOf() === 'string' && !isNaN(Date.parse(minInsertionTime))))) {
          throw new Error('minInsertionTime must be of type date.');
        }
    if (maxInsertionTime && !(maxInsertionTime instanceof Date ||
        (typeof maxInsertionTime.valueOf() === 'string' && !isNaN(Date.parse(maxInsertionTime))))) {
          throw new Error('maxInsertionTime must be of type date.');
        }
    if (minModificationTime && !(minModificationTime instanceof Date ||
        (typeof minModificationTime.valueOf() === 'string' && !isNaN(Date.parse(minModificationTime))))) {
          throw new Error('minModificationTime must be of type date.');
        }
    if (maxModificationTime && !(maxModificationTime instanceof Date ||
        (typeof maxModificationTime.valueOf() === 'string' && !isNaN(Date.parse(maxModificationTime))))) {
          throw new Error('maxModificationTime must be of type date.');
        }
    if (page !== null && page !== undefined && typeof page !== 'number') {
      throw new Error('page must be of type number.');
    }
    if (page !== null && page !== undefined) {
      if (page > 2147483647)
      {
        throw new Error('"page" should satisfy the constraint - "InclusiveMaximum": 2147483647');
      }
      if (page < 1)
      {
        throw new Error('"page" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
    if (pageSize !== null && pageSize !== undefined && typeof pageSize !== 'number') {
      throw new Error('pageSize must be of type number.');
    }
    if (pageSize !== null && pageSize !== undefined) {
      if (pageSize > 1000)
      {
        throw new Error('"pageSize" should satisfy the constraint - "InclusiveMaximum": 1000');
      }
      if (pageSize < 1)
      {
        throw new Error('"pageSize" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
    if (sortOrder !== null && sortOrder !== undefined && typeof sortOrder.valueOf() !== 'string') {
      throw new Error('sortOrder must be of type string.');
    }
    if (sortBy !== null && sortBy !== undefined && typeof sortBy.valueOf() !== 'string') {
      throw new Error('sortBy must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'v1/content/attachments';
  let queryParameters = [];
  if (type !== null && type !== undefined) {
    queryParameters.push('type=' + encodeURIComponent(type));
  }
  if (extension !== null && extension !== undefined) {
    queryParameters.push('extension=' + encodeURIComponent(extension));
  }
  if (minSize !== null && minSize !== undefined) {
    queryParameters.push('minSize=' + encodeURIComponent(minSize.toString()));
  }
  if (maxSize !== null && maxSize !== undefined) {
    queryParameters.push('maxSize=' + encodeURIComponent(maxSize.toString()));
  }
  if (acl !== null && acl !== undefined) {
    queryParameters.push('acl=' + encodeURIComponent(acl.toString()));
  }
  if (entityID !== null && entityID !== undefined) {
    queryParameters.push('entityID=' + encodeURIComponent(entityID.toString()));
  }
  if (drawerID !== null && drawerID !== undefined) {
    queryParameters.push('drawerID=' + encodeURIComponent(drawerID.toString()));
  }
  if (name !== null && name !== undefined) {
    queryParameters.push('name=' + encodeURIComponent(name));
  }
  if (creatorUserID !== null && creatorUserID !== undefined) {
    queryParameters.push('creatorUserID=' + encodeURIComponent(creatorUserID.toString()));
  }
  if (modifierUserID !== null && modifierUserID !== undefined) {
    queryParameters.push('modifierUserID=' + encodeURIComponent(modifierUserID.toString()));
  }
  if (minInsertionTime !== null && minInsertionTime !== undefined) {
    queryParameters.push('minInsertionTime=' + encodeURIComponent(client.serializeObject(minInsertionTime)));
  }
  if (maxInsertionTime !== null && maxInsertionTime !== undefined) {
    queryParameters.push('maxInsertionTime=' + encodeURIComponent(client.serializeObject(maxInsertionTime)));
  }
  if (minModificationTime !== null && minModificationTime !== undefined) {
    queryParameters.push('minModificationTime=' + encodeURIComponent(client.serializeObject(minModificationTime)));
  }
  if (maxModificationTime !== null && maxModificationTime !== undefined) {
    queryParameters.push('maxModificationTime=' + encodeURIComponent(client.serializeObject(maxModificationTime)));
  }
  if (page !== null && page !== undefined) {
    queryParameters.push('page=' + encodeURIComponent(page.toString()));
  }
  if (pageSize !== null && pageSize !== undefined) {
    queryParameters.push('pageSize=' + encodeURIComponent(pageSize.toString()));
  }
  if (sortOrder !== null && sortOrder !== undefined) {
    queryParameters.push('sortOrder=' + encodeURIComponent(sortOrder));
  }
  if (sortBy !== null && sortBy !== undefined) {
    queryParameters.push('sortBy=' + encodeURIComponent(sortBy));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = {
            required: false,
            serializedName: 'parsedResponse',
            type: {
              name: 'Sequence',
              element: {
                  required: false,
                  serializedName: 'AttachmentModelElementType',
                  type: {
                    name: 'Composite',
                    className: 'AttachmentModel'
                  }
              }
            }
          };
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets a single attachment metadata based on its unique identifier.
 *
 * @param {number} drawer The drawer identifier.
 *
 * @param {number} id The attachment identifier.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link AttachmentModel} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getAttachmentById(drawer, id, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (drawer === null || drawer === undefined || typeof drawer !== 'number') {
      throw new Error('drawer cannot be null or undefined and it must be of type number.');
    }
    if (id === null || id === undefined || typeof id !== 'number') {
      throw new Error('id cannot be null or undefined and it must be of type number.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'v1/content/attachments/{drawer}/{id}';
  requestUrl = requestUrl.replace('{drawer}', encodeURIComponent(drawer.toString()));
  requestUrl = requestUrl.replace('{id}', encodeURIComponent(id.toString()));

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200 && statusCode !== 404) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['AttachmentModel']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Updates a specified attachment's metadata..
 *
 * @param {number} drawer The drawer identifier.
 *
 * @param {number} id The attachment identifier.
 *
 * @param {object} model The model.
 *
 * @param {number} [model.category] Gets or sets the category.
 *
 * @param {number} [model.classProperty] Gets or sets the class.
 *
 * @param {string} [model.name] Gets or sets the name.
 *
 * @param {number} [model.acl] Gets or sets the acl.
 *
 * @param {number} [model.pageNumber] Gets or sets the page number.
 *
 * @param {string} [model.state] Gets or sets the state. Possible values
 * include: 'Undefined', 'MaxStates', 'Reserved', 'UserDefined', 'Dynamic',
 * 'Static', 'New', 'CheckedOut', 'Internal', 'Statres5', 'Linked', 'Statres4',
 * 'Statres3', 'Statres2', 'Statres1', 'Locked', 'OnServerCache',
 * 'OnClientCache', 'Fetching', 'Dynres4', 'Dynres3', 'Dynres2', 'Dynres1',
 * 'User1', 'User2', 'User3', 'User4', 'User5', 'User6', 'User7', 'User8',
 * 'User9', 'User10', 'User11', 'User12', 'User13', 'User14', 'User15',
 * 'User16'
 *
 * @param {string} [model.note] Gets or sets the note.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _updateAttachment(drawer, id, model, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (drawer === null || drawer === undefined || typeof drawer !== 'number') {
      throw new Error('drawer cannot be null or undefined and it must be of type number.');
    }
    if (id === null || id === undefined || typeof id !== 'number') {
      throw new Error('id cannot be null or undefined and it must be of type number.');
    }
    if (model === null || model === undefined) {
      throw new Error('model cannot be null or undefined.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'v1/content/attachments/{drawer}/{id}';
  requestUrl = requestUrl.replace('{drawer}', encodeURIComponent(drawer.toString()));
  requestUrl = requestUrl.replace('{id}', encodeURIComponent(id.toString()));

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'PUT';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (model !== null && model !== undefined) {
      let requestModelMapper = new client.models['UpdateAttachmentRequestModel']().mapper();
      requestModel = client.serialize(requestModelMapper, model, 'model');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(model, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 204 && statusCode !== 403 && statusCode !== 404) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 204) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = {
            required: false,
            serializedName: 'parsedResponse',
            type: {
              name: 'Object'
            }
          };
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Deletes an attachment
 *
 * @param {number} drawer The drawer identifier.
 *
 * @param {number} id The attachment identifier.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _deleteAttachment(drawer, id, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (drawer === null || drawer === undefined || typeof drawer !== 'number') {
      throw new Error('drawer cannot be null or undefined and it must be of type number.');
    }
    if (id === null || id === undefined || typeof id !== 'number') {
      throw new Error('id cannot be null or undefined and it must be of type number.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'v1/content/attachments/{drawer}/{id}';
  requestUrl = requestUrl.replace('{drawer}', encodeURIComponent(drawer.toString()));
  requestUrl = requestUrl.replace('{id}', encodeURIComponent(id.toString()));

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'DELETE';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 204 && statusCode !== 403 && statusCode !== 404) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 204) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = {
            required: false,
            serializedName: 'parsedResponse',
            type: {
              name: 'Object'
            }
          };
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets an attachment's file content.
 *
 * @param {number} drawer The drawer identifier.
 *
 * @param {number} id The attachment identifier.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getAttachmentFileContent(drawer, id, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (drawer === null || drawer === undefined || typeof drawer !== 'number') {
      throw new Error('drawer cannot be null or undefined and it must be of type number.');
    }
    if (id === null || id === undefined || typeof id !== 'number') {
      throw new Error('id cannot be null or undefined and it must be of type number.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'v1/content/attachments/{drawer}/{id}/file';
  requestUrl = requestUrl.replace('{drawer}', encodeURIComponent(drawer.toString()));
  requestUrl = requestUrl.replace('{id}', encodeURIComponent(id.toString()));

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200 && statusCode !== 403 && statusCode !== 404) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = {
            required: false,
            serializedName: 'parsedResponse',
            type: {
              name: 'Object'
            }
          };
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Inserts a new file attachment.
 *
 * @param {number} drawer The drawer identifier.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link AttachmentModel} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _createAttachment(drawer, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (drawer === null || drawer === undefined || typeof drawer !== 'number') {
      throw new Error('drawer cannot be null or undefined and it must be of type number.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'v1/content/attachments/{drawer}';
  requestUrl = requestUrl.replace('{drawer}', encodeURIComponent(drawer.toString()));

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 201 && statusCode !== 400 && statusCode !== 403 && statusCode !== 404) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 201) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['AttachmentModel']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Archives an attachment
 *
 * @param {number} drawer The drawer identifier.
 *
 * @param {number} id The attachment identifier.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _archiveAttachment(drawer, id, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (drawer === null || drawer === undefined || typeof drawer !== 'number') {
      throw new Error('drawer cannot be null or undefined and it must be of type number.');
    }
    if (id === null || id === undefined || typeof id !== 'number') {
      throw new Error('id cannot be null or undefined and it must be of type number.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'v1/content/attachments/{drawer}/{id}/archive';
  requestUrl = requestUrl.replace('{drawer}', encodeURIComponent(drawer.toString()));
  requestUrl = requestUrl.replace('{id}', encodeURIComponent(id.toString()));

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'PUT';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 204 && statusCode !== 400 && statusCode !== 403 && statusCode !== 404) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 204) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = {
            required: false,
            serializedName: 'parsedResponse',
            type: {
              name: 'Object'
            }
          };
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets the paged list of attachment versions.
 *
 * @param {number} drawer The drawer identifier.
 *
 * @param {number} id The attachment identifier.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {number} [options.version] Gets or sets the indexed version value.
 *
 * @param {number} [options.creatorUserID] Gets or sets the creator identifier.
 *
 * @param {number} [options.accessorUserID] Gets or sets the identifier of the
 * user who accessed the attachment version.
 *
 * @param {date} [options.minAccessTime] Gets or sets the min time the version
 * was last accessed.
 *
 * @param {date} [options.maxAccessTime] Gets or sets the max time the version
 * was last accessed.
 *
 * @param {date} [options.minCreationTime] Gets or sets the min creation time
 * of the attachment version.
 *
 * @param {date} [options.maxCreationTime] Gets or sets the max creation time
 * of the attachment version.
 *
 * @param {date} [options.minModificationTime] Gets or sets the min
 * modification time of the attachment version.
 *
 * @param {date} [options.maxModificationTime] Gets or sets the max
 * modification time of the attachment version.
 *
 * @param {number} [options.page] Gets or sets the page number.
 *
 * @param {number} [options.pageSize] Gets or sets the size of the page.
 *
 * @param {string} [options.sortOrder] Gets or sets the order. Possible values
 * include: 'Unspecified', 'Ascending', 'Descending'
 *
 * @param {string} [options.sortBy] Gets or sets the column to order by.
 * Possible values include: 'Version', 'CreatorUserID', 'AccessorUserID',
 * 'AccessTime', 'CreationTime', 'ModificationTime'
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {array} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getAttachmentVersionsByFilter(drawer, id, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let version = (options && options.version !== undefined) ? options.version : undefined;
  let creatorUserID = (options && options.creatorUserID !== undefined) ? options.creatorUserID : undefined;
  let accessorUserID = (options && options.accessorUserID !== undefined) ? options.accessorUserID : undefined;
  let minAccessTime = (options && options.minAccessTime !== undefined) ? options.minAccessTime : undefined;
  let maxAccessTime = (options && options.maxAccessTime !== undefined) ? options.maxAccessTime : undefined;
  let minCreationTime = (options && options.minCreationTime !== undefined) ? options.minCreationTime : undefined;
  let maxCreationTime = (options && options.maxCreationTime !== undefined) ? options.maxCreationTime : undefined;
  let minModificationTime = (options && options.minModificationTime !== undefined) ? options.minModificationTime : undefined;
  let maxModificationTime = (options && options.maxModificationTime !== undefined) ? options.maxModificationTime : undefined;
  let page = (options && options.page !== undefined) ? options.page : undefined;
  let pageSize = (options && options.pageSize !== undefined) ? options.pageSize : undefined;
  let sortOrder = (options && options.sortOrder !== undefined) ? options.sortOrder : undefined;
  let sortBy = (options && options.sortBy !== undefined) ? options.sortBy : undefined;
  // Validate
  try {
    if (drawer === null || drawer === undefined || typeof drawer !== 'number') {
      throw new Error('drawer cannot be null or undefined and it must be of type number.');
    }
    if (id === null || id === undefined || typeof id !== 'number') {
      throw new Error('id cannot be null or undefined and it must be of type number.');
    }
    if (version !== null && version !== undefined && typeof version !== 'number') {
      throw new Error('version must be of type number.');
    }
    if (version !== null && version !== undefined) {
      if (version > 2147483647)
      {
        throw new Error('"version" should satisfy the constraint - "InclusiveMaximum": 2147483647');
      }
      if (version < 1)
      {
        throw new Error('"version" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
    if (creatorUserID !== null && creatorUserID !== undefined && typeof creatorUserID !== 'number') {
      throw new Error('creatorUserID must be of type number.');
    }
    if (creatorUserID !== null && creatorUserID !== undefined) {
      if (creatorUserID > 2147483647)
      {
        throw new Error('"creatorUserID" should satisfy the constraint - "InclusiveMaximum": 2147483647');
      }
      if (creatorUserID < 1)
      {
        throw new Error('"creatorUserID" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
    if (accessorUserID !== null && accessorUserID !== undefined && typeof accessorUserID !== 'number') {
      throw new Error('accessorUserID must be of type number.');
    }
    if (accessorUserID !== null && accessorUserID !== undefined) {
      if (accessorUserID > 2147483647)
      {
        throw new Error('"accessorUserID" should satisfy the constraint - "InclusiveMaximum": 2147483647');
      }
      if (accessorUserID < 1)
      {
        throw new Error('"accessorUserID" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
    if (minAccessTime && !(minAccessTime instanceof Date ||
        (typeof minAccessTime.valueOf() === 'string' && !isNaN(Date.parse(minAccessTime))))) {
          throw new Error('minAccessTime must be of type date.');
        }
    if (maxAccessTime && !(maxAccessTime instanceof Date ||
        (typeof maxAccessTime.valueOf() === 'string' && !isNaN(Date.parse(maxAccessTime))))) {
          throw new Error('maxAccessTime must be of type date.');
        }
    if (minCreationTime && !(minCreationTime instanceof Date ||
        (typeof minCreationTime.valueOf() === 'string' && !isNaN(Date.parse(minCreationTime))))) {
          throw new Error('minCreationTime must be of type date.');
        }
    if (maxCreationTime && !(maxCreationTime instanceof Date ||
        (typeof maxCreationTime.valueOf() === 'string' && !isNaN(Date.parse(maxCreationTime))))) {
          throw new Error('maxCreationTime must be of type date.');
        }
    if (minModificationTime && !(minModificationTime instanceof Date ||
        (typeof minModificationTime.valueOf() === 'string' && !isNaN(Date.parse(minModificationTime))))) {
          throw new Error('minModificationTime must be of type date.');
        }
    if (maxModificationTime && !(maxModificationTime instanceof Date ||
        (typeof maxModificationTime.valueOf() === 'string' && !isNaN(Date.parse(maxModificationTime))))) {
          throw new Error('maxModificationTime must be of type date.');
        }
    if (page !== null && page !== undefined && typeof page !== 'number') {
      throw new Error('page must be of type number.');
    }
    if (page !== null && page !== undefined) {
      if (page > 2147483647)
      {
        throw new Error('"page" should satisfy the constraint - "InclusiveMaximum": 2147483647');
      }
      if (page < 1)
      {
        throw new Error('"page" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
    if (pageSize !== null && pageSize !== undefined && typeof pageSize !== 'number') {
      throw new Error('pageSize must be of type number.');
    }
    if (pageSize !== null && pageSize !== undefined) {
      if (pageSize > 1000)
      {
        throw new Error('"pageSize" should satisfy the constraint - "InclusiveMaximum": 1000');
      }
      if (pageSize < 1)
      {
        throw new Error('"pageSize" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
    if (sortOrder !== null && sortOrder !== undefined && typeof sortOrder.valueOf() !== 'string') {
      throw new Error('sortOrder must be of type string.');
    }
    if (sortBy !== null && sortBy !== undefined && typeof sortBy.valueOf() !== 'string') {
      throw new Error('sortBy must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'v1/content/attachments/{drawer}/{id}/versions';
  requestUrl = requestUrl.replace('{drawer}', encodeURIComponent(drawer.toString()));
  requestUrl = requestUrl.replace('{id}', encodeURIComponent(id.toString()));
  let queryParameters = [];
  if (version !== null && version !== undefined) {
    queryParameters.push('version=' + encodeURIComponent(version.toString()));
  }
  if (creatorUserID !== null && creatorUserID !== undefined) {
    queryParameters.push('creatorUserID=' + encodeURIComponent(creatorUserID.toString()));
  }
  if (accessorUserID !== null && accessorUserID !== undefined) {
    queryParameters.push('accessorUserID=' + encodeURIComponent(accessorUserID.toString()));
  }
  if (minAccessTime !== null && minAccessTime !== undefined) {
    queryParameters.push('minAccessTime=' + encodeURIComponent(client.serializeObject(minAccessTime)));
  }
  if (maxAccessTime !== null && maxAccessTime !== undefined) {
    queryParameters.push('maxAccessTime=' + encodeURIComponent(client.serializeObject(maxAccessTime)));
  }
  if (minCreationTime !== null && minCreationTime !== undefined) {
    queryParameters.push('minCreationTime=' + encodeURIComponent(client.serializeObject(minCreationTime)));
  }
  if (maxCreationTime !== null && maxCreationTime !== undefined) {
    queryParameters.push('maxCreationTime=' + encodeURIComponent(client.serializeObject(maxCreationTime)));
  }
  if (minModificationTime !== null && minModificationTime !== undefined) {
    queryParameters.push('minModificationTime=' + encodeURIComponent(client.serializeObject(minModificationTime)));
  }
  if (maxModificationTime !== null && maxModificationTime !== undefined) {
    queryParameters.push('maxModificationTime=' + encodeURIComponent(client.serializeObject(maxModificationTime)));
  }
  if (page !== null && page !== undefined) {
    queryParameters.push('page=' + encodeURIComponent(page.toString()));
  }
  if (pageSize !== null && pageSize !== undefined) {
    queryParameters.push('pageSize=' + encodeURIComponent(pageSize.toString()));
  }
  if (sortOrder !== null && sortOrder !== undefined) {
    queryParameters.push('sortOrder=' + encodeURIComponent(sortOrder));
  }
  if (sortBy !== null && sortBy !== undefined) {
    queryParameters.push('sortBy=' + encodeURIComponent(sortBy));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200 && statusCode !== 404) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = {
            required: false,
            serializedName: 'parsedResponse',
            type: {
              name: 'Sequence',
              element: {
                  required: false,
                  serializedName: 'AttachmentVersionModelElementType',
                  type: {
                    name: 'Composite',
                    className: 'AttachmentVersionModel'
                  }
              }
            }
          };
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets a file for a specified attachment version.
 *
 * @param {number} drawer The drawer identifier.
 *
 * @param {number} id The attachment identifier.
 *
 * @param {number} versionID The version identifier.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getAttachmentVersionFileContent(drawer, id, versionID, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (drawer === null || drawer === undefined || typeof drawer !== 'number') {
      throw new Error('drawer cannot be null or undefined and it must be of type number.');
    }
    if (id === null || id === undefined || typeof id !== 'number') {
      throw new Error('id cannot be null or undefined and it must be of type number.');
    }
    if (versionID === null || versionID === undefined || typeof versionID !== 'number') {
      throw new Error('versionID cannot be null or undefined and it must be of type number.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'v1/content/attachments/{drawer}/{id}/versions/{versionID}';
  requestUrl = requestUrl.replace('{drawer}', encodeURIComponent(drawer.toString()));
  requestUrl = requestUrl.replace('{id}', encodeURIComponent(id.toString()));
  requestUrl = requestUrl.replace('{versionID}', encodeURIComponent(versionID.toString()));

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200 && statusCode !== 403 && statusCode !== 404) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = {
            required: false,
            serializedName: 'parsedResponse',
            type: {
              name: 'Object'
            }
          };
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Checks out the attachment file.
 *
 * @param {number} drawer The drawer identifier.
 *
 * @param {number} id The attachment identifier.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _checkOutAttachment(drawer, id, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (drawer === null || drawer === undefined || typeof drawer !== 'number') {
      throw new Error('drawer cannot be null or undefined and it must be of type number.');
    }
    if (id === null || id === undefined || typeof id !== 'number') {
      throw new Error('id cannot be null or undefined and it must be of type number.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'v1/content/attachments/{drawer}/{id}/checkout';
  requestUrl = requestUrl.replace('{drawer}', encodeURIComponent(drawer.toString()));
  requestUrl = requestUrl.replace('{id}', encodeURIComponent(id.toString()));

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'PUT';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 204 && statusCode !== 400 && statusCode !== 403 && statusCode !== 404) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 204) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = {
            required: false,
            serializedName: 'parsedResponse',
            type: {
              name: 'Object'
            }
          };
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Undoes the attachment check out of the attachment file.
 *
 * @param {number} drawer The drawer identifier.
 *
 * @param {number} id The attachment identifier.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _undoCheckOutAttachment(drawer, id, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (drawer === null || drawer === undefined || typeof drawer !== 'number') {
      throw new Error('drawer cannot be null or undefined and it must be of type number.');
    }
    if (id === null || id === undefined || typeof id !== 'number') {
      throw new Error('id cannot be null or undefined and it must be of type number.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'v1/content/attachments/{drawer}/{id}/checkout';
  requestUrl = requestUrl.replace('{drawer}', encodeURIComponent(drawer.toString()));
  requestUrl = requestUrl.replace('{id}', encodeURIComponent(id.toString()));

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'DELETE';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 204 && statusCode !== 400 && statusCode !== 403 && statusCode !== 404) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 204) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = {
            required: false,
            serializedName: 'parsedResponse',
            type: {
              name: 'Object'
            }
          };
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Checks in the new version of attachment file.
 *
 * @param {number} drawer The drawer identifier.
 *
 * @param {number} id The attachment identifier.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _checkInAttachment(drawer, id, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (drawer === null || drawer === undefined || typeof drawer !== 'number') {
      throw new Error('drawer cannot be null or undefined and it must be of type number.');
    }
    if (id === null || id === undefined || typeof id !== 'number') {
      throw new Error('id cannot be null or undefined and it must be of type number.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'v1/content/attachments/{drawer}/{id}/checkin';
  requestUrl = requestUrl.replace('{drawer}', encodeURIComponent(drawer.toString()));
  requestUrl = requestUrl.replace('{id}', encodeURIComponent(id.toString()));

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'PUT';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 204 && statusCode !== 400 && statusCode !== 403 && statusCode !== 404) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 204) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = {
            required: false,
            serializedName: 'parsedResponse',
            type: {
              name: 'Object'
            }
          };
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Rolls back to a specified version the attachment file.
 *
 * @param {number} drawer The drawer identifier.
 *
 * @param {number} id The attachment identifier.
 *
 * @param {number} versionID The version identifier.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _rollbackAttachmentVersion(drawer, id, versionID, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (drawer === null || drawer === undefined || typeof drawer !== 'number') {
      throw new Error('drawer cannot be null or undefined and it must be of type number.');
    }
    if (id === null || id === undefined || typeof id !== 'number') {
      throw new Error('id cannot be null or undefined and it must be of type number.');
    }
    if (versionID === null || versionID === undefined || typeof versionID !== 'number') {
      throw new Error('versionID cannot be null or undefined and it must be of type number.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'v1/content/attachments/{drawer}/{id}/rollback/{versionID}';
  requestUrl = requestUrl.replace('{drawer}', encodeURIComponent(drawer.toString()));
  requestUrl = requestUrl.replace('{id}', encodeURIComponent(id.toString()));
  requestUrl = requestUrl.replace('{versionID}', encodeURIComponent(versionID.toString()));

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'PUT';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 204 && statusCode !== 400 && statusCode !== 403 && statusCode !== 404) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 204) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = {
            required: false,
            serializedName: 'parsedResponse',
            type: {
              name: 'Object'
            }
          };
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets a list of all available drawers.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {array} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getAllDrawers(options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'v1/directory/drawers';

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = {
            required: false,
            serializedName: 'parsedResponse',
            type: {
              name: 'Sequence',
              element: {
                  required: false,
                  serializedName: 'DrawerModelElementType',
                  type: {
                    name: 'Composite',
                    className: 'DrawerModel'
                  }
              }
            }
          };
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets a single drawer by its unique identifier.
 *
 * @param {number} id The drawer identifier.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link DrawerModel} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getDrawerById(id, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (id === null || id === undefined || typeof id !== 'number') {
      throw new Error('id cannot be null or undefined and it must be of type number.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'v1/directory/drawers/{id}';
  requestUrl = requestUrl.replace('{id}', encodeURIComponent(id.toString()));

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200 && statusCode !== 404) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['DrawerModel']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Updates a specified drawer.
 *
 * @param {number} id The drawer identifier.
 *
 * @param {object} model The model.
 *
 * @param {string} model.name Gets or sets the name.
 *
 * @param {number} [model.edition] Gets or sets the edition.
 *
 * @param {number} [model.state] Gets or sets the state.
 *
 * @param {number} [model.entityFeature] Gets or sets the entity feature.
 *
 * @param {number} [model.attachmentFeature] Gets or sets the attachment
 * feature.
 *
 * @param {number} [model.noteFeature] Gets or sets the note feature.
 *
 * @param {number} [model.reservedInt1] Gets or sets the reserved integer 1.
 *
 * @param {number} [model.reservedInt2] Gets or sets the reserved integer 2.
 *
 * @param {string} [model.reservedString1] Gets or sets the reserved string1.
 *
 * @param {string} [model.reservedString2] Gets or sets the reserved string2.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _updateDrawer(id, model, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (id === null || id === undefined || typeof id !== 'number') {
      throw new Error('id cannot be null or undefined and it must be of type number.');
    }
    if (model === null || model === undefined) {
      throw new Error('model cannot be null or undefined.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'v1/directory/drawers/{id}';
  requestUrl = requestUrl.replace('{id}', encodeURIComponent(id.toString()));

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'PUT';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (model !== null && model !== undefined) {
      let requestModelMapper = new client.models['DrawerBase']().mapper();
      requestModel = client.serialize(requestModelMapper, model, 'model');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(model, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 204 && statusCode !== 403 && statusCode !== 404) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 204) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = {
            required: false,
            serializedName: 'parsedResponse',
            type: {
              name: 'Object'
            }
          };
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets a single drawer by its name.
 *
 * @param {string} name The drawer name.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link DrawerModel} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getDrawerByName(name, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'v1/directory/drawers/{name}';
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200 && statusCode !== 404) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['DrawerModel']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets a paged list of entity summaries.
 *
 * @param {number} drawerID Gets or sets the drawer identifier.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {number} [options.acl] Gets or sets the access control list.
 *
 * @param {number} [options.type] Gets or sets the type of the entity.
 *
 * @param {string} [options.name] Gets or sets the name.
 *
 * @param {string} [options.state] Gets or sets the state. Possible values
 * include: 'Undefined', 'Available', 'Locked', 'Suspended', 'Archived',
 * 'Deleted', 'Canceled', 'Complete', 'Reviewed', 'ReviewedSuspended',
 * 'ReviewedComplete', 'Rejected', 'RoutingSlipOpen', 'ReviewedRoutingSlipOpen'
 *
 * @param {number} [options.referenceCount] Gets or sets the reference count.
 *
 * @param {number} [options.attachCount] Gets or sets the attach count.
 *
 * @param {number} [options.noteCount] Gets or sets the note count.
 *
 * @param {number} [options.ownerUserID] Gets or sets the owner user
 * identifier.
 *
 * @param {number} [options.ownerGroupID] Gets or sets the owner group
 * identifier.
 *
 * @param {number} [options.creatorUserID] Gets or sets the creator user
 * identifier.
 *
 * @param {number} [options.creatorGroupID] Gets or sets the creator group
 * identifier.
 *
 * @param {number} [options.modifierUserID] Gets or sets the modifier user
 * identifier.
 *
 * @param {number} [options.modifierGroupID] Gets or sets the modifier group
 * identifier.
 *
 * @param {date} [options.minCreationTime] Gets or sets the minimum creation
 * time.
 *
 * @param {date} [options.maxCreationTime] Gets or sets the maximum creation
 * time.
 *
 * @param {date} [options.minModificationTime] Gets or sets the minimum
 * modification time.
 *
 * @param {date} [options.maxModificationTime] Gets or sets the maximum
 * modification time.
 *
 * @param {array} [options.metadata] Gets or sets the metadata.
 *
 * @param {number} [options.page] Gets or sets the page number.
 *
 * @param {number} [options.pageSize] Gets or sets the size of the page.
 *
 * @param {string} [options.sortOrder] Gets or sets the order. Possible values
 * include: 'Unspecified', 'Ascending', 'Descending'
 *
 * @param {string} [options.sortBy] Gets or sets the column to order by.
 * Possible values include: 'ID', 'Type', 'CreationTime', 'ModificationTime',
 * 'State', 'Name'
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {array} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getEntitiesByFilter(drawerID, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let acl = (options && options.acl !== undefined) ? options.acl : undefined;
  let type = (options && options.type !== undefined) ? options.type : undefined;
  let name = (options && options.name !== undefined) ? options.name : undefined;
  let state = (options && options.state !== undefined) ? options.state : undefined;
  let referenceCount = (options && options.referenceCount !== undefined) ? options.referenceCount : undefined;
  let attachCount = (options && options.attachCount !== undefined) ? options.attachCount : undefined;
  let noteCount = (options && options.noteCount !== undefined) ? options.noteCount : undefined;
  let ownerUserID = (options && options.ownerUserID !== undefined) ? options.ownerUserID : undefined;
  let ownerGroupID = (options && options.ownerGroupID !== undefined) ? options.ownerGroupID : undefined;
  let creatorUserID = (options && options.creatorUserID !== undefined) ? options.creatorUserID : undefined;
  let creatorGroupID = (options && options.creatorGroupID !== undefined) ? options.creatorGroupID : undefined;
  let modifierUserID = (options && options.modifierUserID !== undefined) ? options.modifierUserID : undefined;
  let modifierGroupID = (options && options.modifierGroupID !== undefined) ? options.modifierGroupID : undefined;
  let minCreationTime = (options && options.minCreationTime !== undefined) ? options.minCreationTime : undefined;
  let maxCreationTime = (options && options.maxCreationTime !== undefined) ? options.maxCreationTime : undefined;
  let minModificationTime = (options && options.minModificationTime !== undefined) ? options.minModificationTime : undefined;
  let maxModificationTime = (options && options.maxModificationTime !== undefined) ? options.maxModificationTime : undefined;
  let metadata = (options && options.metadata !== undefined) ? options.metadata : undefined;
  let page = (options && options.page !== undefined) ? options.page : undefined;
  let pageSize = (options && options.pageSize !== undefined) ? options.pageSize : undefined;
  let sortOrder = (options && options.sortOrder !== undefined) ? options.sortOrder : undefined;
  let sortBy = (options && options.sortBy !== undefined) ? options.sortBy : undefined;
  // Validate
  try {
    if (drawerID === null || drawerID === undefined || typeof drawerID !== 'number') {
      throw new Error('drawerID cannot be null or undefined and it must be of type number.');
    }
    if (drawerID !== null && drawerID !== undefined) {
      if (drawerID > 2147483647)
      {
        throw new Error('"drawerID" should satisfy the constraint - "InclusiveMaximum": 2147483647');
      }
      if (drawerID < 1)
      {
        throw new Error('"drawerID" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
    if (acl !== null && acl !== undefined && typeof acl !== 'number') {
      throw new Error('acl must be of type number.');
    }
    if (type !== null && type !== undefined && typeof type !== 'number') {
      throw new Error('type must be of type number.');
    }
    if (type !== null && type !== undefined) {
      if (type > 2147483647)
      {
        throw new Error('"type" should satisfy the constraint - "InclusiveMaximum": 2147483647');
      }
      if (type < 1)
      {
        throw new Error('"type" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
    if (name !== null && name !== undefined && typeof name.valueOf() !== 'string') {
      throw new Error('name must be of type string.');
    }
    if (name !== null && name !== undefined) {
      if (name.length > 255)
      {
        throw new Error('"name" should satisfy the constraint - "MaxLength": 255');
      }
      if (name.length < 0)
      {
        throw new Error('"name" should satisfy the constraint - "MinLength": 0');
      }
    }
    if (state !== null && state !== undefined && typeof state.valueOf() !== 'string') {
      throw new Error('state must be of type string.');
    }
    if (referenceCount !== null && referenceCount !== undefined && typeof referenceCount !== 'number') {
      throw new Error('referenceCount must be of type number.');
    }
    if (referenceCount !== null && referenceCount !== undefined) {
      if (referenceCount > 2147483647)
      {
        throw new Error('"referenceCount" should satisfy the constraint - "InclusiveMaximum": 2147483647');
      }
      if (referenceCount < 0)
      {
        throw new Error('"referenceCount" should satisfy the constraint - "InclusiveMinimum": 0');
      }
    }
    if (attachCount !== null && attachCount !== undefined && typeof attachCount !== 'number') {
      throw new Error('attachCount must be of type number.');
    }
    if (attachCount !== null && attachCount !== undefined) {
      if (attachCount > 2147483647)
      {
        throw new Error('"attachCount" should satisfy the constraint - "InclusiveMaximum": 2147483647');
      }
      if (attachCount < 0)
      {
        throw new Error('"attachCount" should satisfy the constraint - "InclusiveMinimum": 0');
      }
    }
    if (noteCount !== null && noteCount !== undefined && typeof noteCount !== 'number') {
      throw new Error('noteCount must be of type number.');
    }
    if (noteCount !== null && noteCount !== undefined) {
      if (noteCount > 2147483647)
      {
        throw new Error('"noteCount" should satisfy the constraint - "InclusiveMaximum": 2147483647');
      }
      if (noteCount < 0)
      {
        throw new Error('"noteCount" should satisfy the constraint - "InclusiveMinimum": 0');
      }
    }
    if (ownerUserID !== null && ownerUserID !== undefined && typeof ownerUserID !== 'number') {
      throw new Error('ownerUserID must be of type number.');
    }
    if (ownerUserID !== null && ownerUserID !== undefined) {
      if (ownerUserID > 2147483647)
      {
        throw new Error('"ownerUserID" should satisfy the constraint - "InclusiveMaximum": 2147483647');
      }
      if (ownerUserID < 1)
      {
        throw new Error('"ownerUserID" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
    if (ownerGroupID !== null && ownerGroupID !== undefined && typeof ownerGroupID !== 'number') {
      throw new Error('ownerGroupID must be of type number.');
    }
    if (ownerGroupID !== null && ownerGroupID !== undefined) {
      if (ownerGroupID > 2147483647)
      {
        throw new Error('"ownerGroupID" should satisfy the constraint - "InclusiveMaximum": 2147483647');
      }
      if (ownerGroupID < 0)
      {
        throw new Error('"ownerGroupID" should satisfy the constraint - "InclusiveMinimum": 0');
      }
    }
    if (creatorUserID !== null && creatorUserID !== undefined && typeof creatorUserID !== 'number') {
      throw new Error('creatorUserID must be of type number.');
    }
    if (creatorUserID !== null && creatorUserID !== undefined) {
      if (creatorUserID > 2147483647)
      {
        throw new Error('"creatorUserID" should satisfy the constraint - "InclusiveMaximum": 2147483647');
      }
      if (creatorUserID < 1)
      {
        throw new Error('"creatorUserID" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
    if (creatorGroupID !== null && creatorGroupID !== undefined && typeof creatorGroupID !== 'number') {
      throw new Error('creatorGroupID must be of type number.');
    }
    if (creatorGroupID !== null && creatorGroupID !== undefined) {
      if (creatorGroupID > 2147483647)
      {
        throw new Error('"creatorGroupID" should satisfy the constraint - "InclusiveMaximum": 2147483647');
      }
      if (creatorGroupID < 0)
      {
        throw new Error('"creatorGroupID" should satisfy the constraint - "InclusiveMinimum": 0');
      }
    }
    if (modifierUserID !== null && modifierUserID !== undefined && typeof modifierUserID !== 'number') {
      throw new Error('modifierUserID must be of type number.');
    }
    if (modifierUserID !== null && modifierUserID !== undefined) {
      if (modifierUserID > 2147483647)
      {
        throw new Error('"modifierUserID" should satisfy the constraint - "InclusiveMaximum": 2147483647');
      }
      if (modifierUserID < 1)
      {
        throw new Error('"modifierUserID" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
    if (modifierGroupID !== null && modifierGroupID !== undefined && typeof modifierGroupID !== 'number') {
      throw new Error('modifierGroupID must be of type number.');
    }
    if (modifierGroupID !== null && modifierGroupID !== undefined) {
      if (modifierGroupID > 2147483647)
      {
        throw new Error('"modifierGroupID" should satisfy the constraint - "InclusiveMaximum": 2147483647');
      }
      if (modifierGroupID < 0)
      {
        throw new Error('"modifierGroupID" should satisfy the constraint - "InclusiveMinimum": 0');
      }
    }
    if (minCreationTime && !(minCreationTime instanceof Date ||
        (typeof minCreationTime.valueOf() === 'string' && !isNaN(Date.parse(minCreationTime))))) {
          throw new Error('minCreationTime must be of type date.');
        }
    if (maxCreationTime && !(maxCreationTime instanceof Date ||
        (typeof maxCreationTime.valueOf() === 'string' && !isNaN(Date.parse(maxCreationTime))))) {
          throw new Error('maxCreationTime must be of type date.');
        }
    if (minModificationTime && !(minModificationTime instanceof Date ||
        (typeof minModificationTime.valueOf() === 'string' && !isNaN(Date.parse(minModificationTime))))) {
          throw new Error('minModificationTime must be of type date.');
        }
    if (maxModificationTime && !(maxModificationTime instanceof Date ||
        (typeof maxModificationTime.valueOf() === 'string' && !isNaN(Date.parse(maxModificationTime))))) {
          throw new Error('maxModificationTime must be of type date.');
        }
    if (Array.isArray(metadata)) {
      for (let i = 0; i < metadata.length; i++) {
        if (metadata[i] !== null && metadata[i] !== undefined && typeof metadata[i] !== 'object') {
          throw new Error('metadata[i] must be of type object.');
        }
      }
    }
    if (page !== null && page !== undefined && typeof page !== 'number') {
      throw new Error('page must be of type number.');
    }
    if (page !== null && page !== undefined) {
      if (page > 2147483647)
      {
        throw new Error('"page" should satisfy the constraint - "InclusiveMaximum": 2147483647');
      }
      if (page < 1)
      {
        throw new Error('"page" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
    if (pageSize !== null && pageSize !== undefined && typeof pageSize !== 'number') {
      throw new Error('pageSize must be of type number.');
    }
    if (pageSize !== null && pageSize !== undefined) {
      if (pageSize > 1000)
      {
        throw new Error('"pageSize" should satisfy the constraint - "InclusiveMaximum": 1000');
      }
      if (pageSize < 1)
      {
        throw new Error('"pageSize" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
    if (sortOrder !== null && sortOrder !== undefined && typeof sortOrder.valueOf() !== 'string') {
      throw new Error('sortOrder must be of type string.');
    }
    if (sortBy !== null && sortBy !== undefined && typeof sortBy.valueOf() !== 'string') {
      throw new Error('sortBy must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'v1/content/entities';
  let queryParameters = [];
  queryParameters.push('drawerID=' + encodeURIComponent(drawerID.toString()));
  if (acl !== null && acl !== undefined) {
    queryParameters.push('acl=' + encodeURIComponent(acl.toString()));
  }
  if (type !== null && type !== undefined) {
    queryParameters.push('type=' + encodeURIComponent(type.toString()));
  }
  if (name !== null && name !== undefined) {
    queryParameters.push('name=' + encodeURIComponent(name));
  }
  if (state !== null && state !== undefined) {
    queryParameters.push('state=' + encodeURIComponent(state));
  }
  if (referenceCount !== null && referenceCount !== undefined) {
    queryParameters.push('referenceCount=' + encodeURIComponent(referenceCount.toString()));
  }
  if (attachCount !== null && attachCount !== undefined) {
    queryParameters.push('attachCount=' + encodeURIComponent(attachCount.toString()));
  }
  if (noteCount !== null && noteCount !== undefined) {
    queryParameters.push('noteCount=' + encodeURIComponent(noteCount.toString()));
  }
  if (ownerUserID !== null && ownerUserID !== undefined) {
    queryParameters.push('ownerUserID=' + encodeURIComponent(ownerUserID.toString()));
  }
  if (ownerGroupID !== null && ownerGroupID !== undefined) {
    queryParameters.push('ownerGroupID=' + encodeURIComponent(ownerGroupID.toString()));
  }
  if (creatorUserID !== null && creatorUserID !== undefined) {
    queryParameters.push('creatorUserID=' + encodeURIComponent(creatorUserID.toString()));
  }
  if (creatorGroupID !== null && creatorGroupID !== undefined) {
    queryParameters.push('creatorGroupID=' + encodeURIComponent(creatorGroupID.toString()));
  }
  if (modifierUserID !== null && modifierUserID !== undefined) {
    queryParameters.push('modifierUserID=' + encodeURIComponent(modifierUserID.toString()));
  }
  if (modifierGroupID !== null && modifierGroupID !== undefined) {
    queryParameters.push('modifierGroupID=' + encodeURIComponent(modifierGroupID.toString()));
  }
  if (minCreationTime !== null && minCreationTime !== undefined) {
    queryParameters.push('minCreationTime=' + encodeURIComponent(client.serializeObject(minCreationTime)));
  }
  if (maxCreationTime !== null && maxCreationTime !== undefined) {
    queryParameters.push('maxCreationTime=' + encodeURIComponent(client.serializeObject(maxCreationTime)));
  }
  if (minModificationTime !== null && minModificationTime !== undefined) {
    queryParameters.push('minModificationTime=' + encodeURIComponent(client.serializeObject(minModificationTime)));
  }
  if (maxModificationTime !== null && maxModificationTime !== undefined) {
    queryParameters.push('maxModificationTime=' + encodeURIComponent(client.serializeObject(maxModificationTime)));
  }
  if (metadata !== null && metadata !== undefined) {
    if (metadata.length == 0) {
      queryParameters.push('metadata=' + encodeURIComponent(''));
    } else {
      for (let item of metadata) {
        item = (item === null || item === undefined) ? '' : item;
        queryParameters.push('metadata=' + encodeURIComponent('' + item));
      }
    }
  }
  if (page !== null && page !== undefined) {
    queryParameters.push('page=' + encodeURIComponent(page.toString()));
  }
  if (pageSize !== null && pageSize !== undefined) {
    queryParameters.push('pageSize=' + encodeURIComponent(pageSize.toString()));
  }
  if (sortOrder !== null && sortOrder !== undefined) {
    queryParameters.push('sortOrder=' + encodeURIComponent(sortOrder));
  }
  if (sortBy !== null && sortBy !== undefined) {
    queryParameters.push('sortBy=' + encodeURIComponent(sortBy));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = {
            required: false,
            serializedName: 'parsedResponse',
            type: {
              name: 'Sequence',
              element: {
                  required: false,
                  serializedName: 'GetEntityBaseResponseElementType',
                  type: {
                    name: 'Composite',
                    className: 'GetEntityBaseResponse'
                  }
              }
            }
          };
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets a single entity complete with all profile metadata.
 *
 * @param {number} drawer The drawer identifier.
 *
 * @param {number} id The entity identifier.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link EntityModel} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getEntityById(drawer, id, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (drawer === null || drawer === undefined || typeof drawer !== 'number') {
      throw new Error('drawer cannot be null or undefined and it must be of type number.');
    }
    if (id === null || id === undefined || typeof id !== 'number') {
      throw new Error('id cannot be null or undefined and it must be of type number.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'v1/content/entities/{drawer}/{id}';
  requestUrl = requestUrl.replace('{drawer}', encodeURIComponent(drawer.toString()));
  requestUrl = requestUrl.replace('{id}', encodeURIComponent(id.toString()));

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200 && statusCode !== 403 && statusCode !== 404) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['EntityModel']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Updates a specified entity.
 *
 * @param {number} drawer The drawer identifier.
 *
 * @param {number} id The entity identifier.
 *
 * @param {object} model The entity model.
 *
 * @param {array} [model.profiles] Gets or sets the profiles.
 *
 * @param {string} [model.state] Gets or sets the state. Possible values
 * include: 'Undefined', 'Available', 'Locked', 'Suspended', 'Archived',
 * 'Deleted', 'Canceled', 'Complete', 'Reviewed', 'ReviewedSuspended',
 * 'ReviewedComplete', 'Rejected', 'RoutingSlipOpen', 'ReviewedRoutingSlipOpen'
 *
 * @param {string} [model.name] Gets or sets the name.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _updateEntity(drawer, id, model, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (drawer === null || drawer === undefined || typeof drawer !== 'number') {
      throw new Error('drawer cannot be null or undefined and it must be of type number.');
    }
    if (id === null || id === undefined || typeof id !== 'number') {
      throw new Error('id cannot be null or undefined and it must be of type number.');
    }
    if (model === null || model === undefined) {
      throw new Error('model cannot be null or undefined.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'v1/content/entities/{drawer}/{id}';
  requestUrl = requestUrl.replace('{drawer}', encodeURIComponent(drawer.toString()));
  requestUrl = requestUrl.replace('{id}', encodeURIComponent(id.toString()));

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'PUT';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (model !== null && model !== undefined) {
      let requestModelMapper = new client.models['UpdateEntityRequestModel']().mapper();
      requestModel = client.serialize(requestModelMapper, model, 'model');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(model, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 204 && statusCode !== 403 && statusCode !== 404) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 204) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = {
            required: false,
            serializedName: 'parsedResponse',
            type: {
              name: 'Object'
            }
          };
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Deletes a specified entity.
 *
 * @param {number} drawer The drawer identifier.
 *
 * @param {number} id The entity identifier.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _deleteEntity(drawer, id, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (drawer === null || drawer === undefined || typeof drawer !== 'number') {
      throw new Error('drawer cannot be null or undefined and it must be of type number.');
    }
    if (id === null || id === undefined || typeof id !== 'number') {
      throw new Error('id cannot be null or undefined and it must be of type number.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'v1/content/entities/{drawer}/{id}';
  requestUrl = requestUrl.replace('{drawer}', encodeURIComponent(drawer.toString()));
  requestUrl = requestUrl.replace('{id}', encodeURIComponent(id.toString()));

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'DELETE';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 204 && statusCode !== 403 && statusCode !== 404) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 204) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = {
            required: false,
            serializedName: 'parsedResponse',
            type: {
              name: 'Object'
            }
          };
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Creates a new entity.
 *
 * @param {number} drawer The drawer identifier.
 *
 * @param {object} model The entity model.
 *
 * @param {array} [model.profiles] Gets or sets the profiles.
 *
 * @param {number} [model.acl] Gets or sets the access control list.
 *
 * @param {number} [model.type] Gets or sets the type.
 *
 * @param {string} model.name Gets or sets the Name.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link EntityModel} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _createEntity(drawer, model, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (drawer === null || drawer === undefined || typeof drawer !== 'number') {
      throw new Error('drawer cannot be null or undefined and it must be of type number.');
    }
    if (model === null || model === undefined) {
      throw new Error('model cannot be null or undefined.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'v1/content/entities/{drawer}';
  requestUrl = requestUrl.replace('{drawer}', encodeURIComponent(drawer.toString()));

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (model !== null && model !== undefined) {
      let requestModelMapper = new client.models['InsertEntityRequestModel']().mapper();
      requestModel = client.serialize(requestModelMapper, model, 'model');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(model, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 201 && statusCode !== 404) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 201) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['EntityModel']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Copies the contents of an entity.
 *
 * @param {number} drawer The drawer.
 *
 * @param {number} id The entity identifier.
 *
 * @param {object} model The model.
 *
 * @param {string} [model.entityContent] Gets or sets the content of the
 * entity. Possible values include: 'None', 'All', 'Profiles', 'Attachments',
 * 'Notes', 'Links', 'Events'
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link EntityModel} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _copyEntity(drawer, id, model, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (drawer === null || drawer === undefined || typeof drawer !== 'number') {
      throw new Error('drawer cannot be null or undefined and it must be of type number.');
    }
    if (id === null || id === undefined || typeof id !== 'number') {
      throw new Error('id cannot be null or undefined and it must be of type number.');
    }
    if (model === null || model === undefined) {
      throw new Error('model cannot be null or undefined.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'v1/content/entities/{drawer}/{id}/copy';
  requestUrl = requestUrl.replace('{drawer}', encodeURIComponent(drawer.toString()));
  requestUrl = requestUrl.replace('{id}', encodeURIComponent(id.toString()));

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (model !== null && model !== undefined) {
      let requestModelMapper = new client.models['EntityContentModel']().mapper();
      requestModel = client.serialize(requestModelMapper, model, 'model');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(model, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 201 && statusCode !== 404) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 201) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['EntityModel']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets a paged list of events.
 *
 * @param {number} drawerID Gets or sets the drawer identifier.
 *
 * @param {number} entityID Gets or sets the entity identifier.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {string} [options.type] Gets or sets the type. Possible values
 * include: 'Undefined', 'Fatal', 'Warning', 'Info', 'Debug', 'Process', 'RPC',
 * 'SQL', 'DDE'
 *
 * @param {date} [options.minEventTime] Gets or sets the minimum event time.
 *
 * @param {date} [options.maxEventTime] Gets or sets the maximum event time.
 *
 * @param {number} [options.eventUserID] Gets or sets the event user
 * identifier.
 *
 * @param {number} [options.eventGroupID] Gets or sets the event group
 * identifier.
 *
 * @param {string} [options.category] Gets or sets the category. Possible
 * values include: 'Undefined', 'Entity', 'Profile', 'Attachment',
 * 'Discussion', 'Field', 'Workflow'
 *
 * @param {string} [options.classProperty] Gets or sets the class. Possible
 * values include: 'Undefined', 'Application', 'Security', 'System'
 *
 * @param {string} [options.operation] Gets or sets the operation. Possible
 * values include: 'Undefined', 'Insert', 'Update', 'Delete', 'Copy', 'Lock',
 * 'Unlock', 'Open', 'Close', 'Checkout', 'Checkin', 'View', 'Merge', 'Split',
 * 'Classify', 'Null', 'OpenWF', 'Remove', 'ReturnToTop', 'ReturnToBottom',
 * 'Accept', 'Suspend', 'Reject', 'Route', 'Forward', 'Reply', 'Reassign',
 * 'Reset', 'Override', 'Rollback', 'Archive'
 *
 * @param {number} [options.minProcessingTime] Gets or sets the minimum
 * processing time.
 *
 * @param {number} [options.maxProcessingTime] Gets or sets the maximum
 * processing time.
 *
 * @param {number} [options.page] Gets or sets the page number.
 *
 * @param {number} [options.pageSize] Gets or sets the size of the page.
 *
 * @param {string} [options.sortOrder] Gets or sets the order. Possible values
 * include: 'Unspecified', 'Ascending', 'Descending'
 *
 * @param {string} [options.sortBy] Gets or sets the column to order by.
 * Possible values include: 'ID', 'Type', 'EventTime'
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {array} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getEventsByFilter(drawerID, entityID, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let type = (options && options.type !== undefined) ? options.type : undefined;
  let minEventTime = (options && options.minEventTime !== undefined) ? options.minEventTime : undefined;
  let maxEventTime = (options && options.maxEventTime !== undefined) ? options.maxEventTime : undefined;
  let eventUserID = (options && options.eventUserID !== undefined) ? options.eventUserID : undefined;
  let eventGroupID = (options && options.eventGroupID !== undefined) ? options.eventGroupID : undefined;
  let category = (options && options.category !== undefined) ? options.category : undefined;
  let classProperty = (options && options.classProperty !== undefined) ? options.classProperty : undefined;
  let operation = (options && options.operation !== undefined) ? options.operation : undefined;
  let minProcessingTime = (options && options.minProcessingTime !== undefined) ? options.minProcessingTime : undefined;
  let maxProcessingTime = (options && options.maxProcessingTime !== undefined) ? options.maxProcessingTime : undefined;
  let page = (options && options.page !== undefined) ? options.page : undefined;
  let pageSize = (options && options.pageSize !== undefined) ? options.pageSize : undefined;
  let sortOrder = (options && options.sortOrder !== undefined) ? options.sortOrder : undefined;
  let sortBy = (options && options.sortBy !== undefined) ? options.sortBy : undefined;
  // Validate
  try {
    if (drawerID === null || drawerID === undefined || typeof drawerID !== 'number') {
      throw new Error('drawerID cannot be null or undefined and it must be of type number.');
    }
    if (drawerID !== null && drawerID !== undefined) {
      if (drawerID > 2147483647)
      {
        throw new Error('"drawerID" should satisfy the constraint - "InclusiveMaximum": 2147483647');
      }
      if (drawerID < 1)
      {
        throw new Error('"drawerID" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
    if (entityID === null || entityID === undefined || typeof entityID !== 'number') {
      throw new Error('entityID cannot be null or undefined and it must be of type number.');
    }
    if (entityID !== null && entityID !== undefined) {
      if (entityID > 2147483647)
      {
        throw new Error('"entityID" should satisfy the constraint - "InclusiveMaximum": 2147483647');
      }
      if (entityID < 1)
      {
        throw new Error('"entityID" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
    if (type !== null && type !== undefined && typeof type.valueOf() !== 'string') {
      throw new Error('type must be of type string.');
    }
    if (minEventTime && !(minEventTime instanceof Date ||
        (typeof minEventTime.valueOf() === 'string' && !isNaN(Date.parse(minEventTime))))) {
          throw new Error('minEventTime must be of type date.');
        }
    if (maxEventTime && !(maxEventTime instanceof Date ||
        (typeof maxEventTime.valueOf() === 'string' && !isNaN(Date.parse(maxEventTime))))) {
          throw new Error('maxEventTime must be of type date.');
        }
    if (eventUserID !== null && eventUserID !== undefined && typeof eventUserID !== 'number') {
      throw new Error('eventUserID must be of type number.');
    }
    if (eventUserID !== null && eventUserID !== undefined) {
      if (eventUserID > 2147483647)
      {
        throw new Error('"eventUserID" should satisfy the constraint - "InclusiveMaximum": 2147483647');
      }
      if (eventUserID < 1)
      {
        throw new Error('"eventUserID" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
    if (eventGroupID !== null && eventGroupID !== undefined && typeof eventGroupID !== 'number') {
      throw new Error('eventGroupID must be of type number.');
    }
    if (eventGroupID !== null && eventGroupID !== undefined) {
      if (eventGroupID > 2147483647)
      {
        throw new Error('"eventGroupID" should satisfy the constraint - "InclusiveMaximum": 2147483647');
      }
      if (eventGroupID < 1)
      {
        throw new Error('"eventGroupID" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
    if (category !== null && category !== undefined && typeof category.valueOf() !== 'string') {
      throw new Error('category must be of type string.');
    }
    if (classParameter !== null && classParameter !== undefined && typeof classParameter.valueOf() !== 'string') {
      throw new Error('classParameter must be of type string.');
    }
    if (operation !== null && operation !== undefined && typeof operation.valueOf() !== 'string') {
      throw new Error('operation must be of type string.');
    }
    if (minProcessingTime !== null && minProcessingTime !== undefined && typeof minProcessingTime !== 'number') {
      throw new Error('minProcessingTime must be of type number.');
    }
    if (maxProcessingTime !== null && maxProcessingTime !== undefined && typeof maxProcessingTime !== 'number') {
      throw new Error('maxProcessingTime must be of type number.');
    }
    if (page !== null && page !== undefined && typeof page !== 'number') {
      throw new Error('page must be of type number.');
    }
    if (page !== null && page !== undefined) {
      if (page > 2147483647)
      {
        throw new Error('"page" should satisfy the constraint - "InclusiveMaximum": 2147483647');
      }
      if (page < 1)
      {
        throw new Error('"page" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
    if (pageSize !== null && pageSize !== undefined && typeof pageSize !== 'number') {
      throw new Error('pageSize must be of type number.');
    }
    if (pageSize !== null && pageSize !== undefined) {
      if (pageSize > 1000)
      {
        throw new Error('"pageSize" should satisfy the constraint - "InclusiveMaximum": 1000');
      }
      if (pageSize < 1)
      {
        throw new Error('"pageSize" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
    if (sortOrder !== null && sortOrder !== undefined && typeof sortOrder.valueOf() !== 'string') {
      throw new Error('sortOrder must be of type string.');
    }
    if (sortBy !== null && sortBy !== undefined && typeof sortBy.valueOf() !== 'string') {
      throw new Error('sortBy must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'v1/content/events';
  let queryParameters = [];
  queryParameters.push('drawerID=' + encodeURIComponent(drawerID.toString()));
  queryParameters.push('entityID=' + encodeURIComponent(entityID.toString()));
  if (type !== null && type !== undefined) {
    queryParameters.push('type=' + encodeURIComponent(type));
  }
  if (minEventTime !== null && minEventTime !== undefined) {
    queryParameters.push('minEventTime=' + encodeURIComponent(client.serializeObject(minEventTime)));
  }
  if (maxEventTime !== null && maxEventTime !== undefined) {
    queryParameters.push('maxEventTime=' + encodeURIComponent(client.serializeObject(maxEventTime)));
  }
  if (eventUserID !== null && eventUserID !== undefined) {
    queryParameters.push('eventUserID=' + encodeURIComponent(eventUserID.toString()));
  }
  if (eventGroupID !== null && eventGroupID !== undefined) {
    queryParameters.push('eventGroupID=' + encodeURIComponent(eventGroupID.toString()));
  }
  if (category !== null && category !== undefined) {
    queryParameters.push('category=' + encodeURIComponent(category));
  }
  if (classParameter !== null && classParameter !== undefined) {
    queryParameters.push('class=' + encodeURIComponent(classParameter));
  }
  if (operation !== null && operation !== undefined) {
    queryParameters.push('operation=' + encodeURIComponent(operation));
  }
  if (minProcessingTime !== null && minProcessingTime !== undefined) {
    queryParameters.push('minProcessingTime=' + encodeURIComponent(minProcessingTime.toString()));
  }
  if (maxProcessingTime !== null && maxProcessingTime !== undefined) {
    queryParameters.push('maxProcessingTime=' + encodeURIComponent(maxProcessingTime.toString()));
  }
  if (page !== null && page !== undefined) {
    queryParameters.push('page=' + encodeURIComponent(page.toString()));
  }
  if (pageSize !== null && pageSize !== undefined) {
    queryParameters.push('pageSize=' + encodeURIComponent(pageSize.toString()));
  }
  if (sortOrder !== null && sortOrder !== undefined) {
    queryParameters.push('sortOrder=' + encodeURIComponent(sortOrder));
  }
  if (sortBy !== null && sortBy !== undefined) {
    queryParameters.push('sortBy=' + encodeURIComponent(sortBy));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = {
            required: false,
            serializedName: 'parsedResponse',
            type: {
              name: 'Sequence',
              element: {
                  required: false,
                  serializedName: 'EventModelElementType',
                  type: {
                    name: 'Composite',
                    className: 'EventModel'
                  }
              }
            }
          };
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Retrieves a single event based on its unique identifier.
 *
 * @param {number} drawer The drawer identifier.
 *
 * @param {number} id The event identifier.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link EventModel} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getEventById(drawer, id, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (drawer === null || drawer === undefined || typeof drawer !== 'number') {
      throw new Error('drawer cannot be null or undefined and it must be of type number.');
    }
    if (id === null || id === undefined || typeof id !== 'number') {
      throw new Error('id cannot be null or undefined and it must be of type number.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'v1/content/events/{drawer}/{id}';
  requestUrl = requestUrl.replace('{drawer}', encodeURIComponent(drawer.toString()));
  requestUrl = requestUrl.replace('{id}', encodeURIComponent(id.toString()));

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200 && statusCode !== 404) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['EventModel']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Creates a new event.
 *
 * @param {number} drawer The drawer identifier.
 *
 * @param {object} model The event model.
 *
 * @param {number} [model.id] Gets or sets the identifier.
 *
 * @param {number} [model.drawerID] Gets or sets the drawer identifier.
 *
 * @param {number} [model.entityID] Gets or sets the entity identifier.
 *
 * @param {string} [model.type] Gets or sets the type. Possible values include:
 * 'Undefined', 'Fatal', 'Warning', 'Info', 'Debug', 'Process', 'RPC', 'SQL',
 * 'DDE'
 *
 * @param {date} [model.eventTime] Gets or sets the event time.
 *
 * @param {number} [model.eventUserID] Gets or sets the event user identifier.
 *
 * @param {string} [model.eventUserFullName] Gets or sets the full name of the
 * event user.
 *
 * @param {number} [model.eventGroupID] Gets or sets the event group
 * identifier.
 *
 * @param {string} [model.eventGroupName] Gets or sets the name of the event
 * group.
 *
 * @param {string} [model.category] Gets or sets the category. Possible values
 * include: 'Undefined', 'Entity', 'Profile', 'Attachment', 'Discussion',
 * 'Field', 'Workflow'
 *
 * @param {string} [model.classProperty] Gets or sets the class. Possible
 * values include: 'Undefined', 'Application', 'Security', 'System'
 *
 * @param {string} [model.operation] Gets or sets the operation. Possible
 * values include: 'Undefined', 'Insert', 'Update', 'Delete', 'Copy', 'Lock',
 * 'Unlock', 'Open', 'Close', 'Checkout', 'Checkin', 'View', 'Merge', 'Split',
 * 'Classify', 'Null', 'OpenWF', 'Remove', 'ReturnToTop', 'ReturnToBottom',
 * 'Accept', 'Suspend', 'Reject', 'Route', 'Forward', 'Reply', 'Reassign',
 * 'Reset', 'Override', 'Rollback', 'Archive'
 *
 * @param {string} [model.source] Gets or sets the source.
 *
 * @param {string} [model.computer] Gets or sets the computer.
 *
 * @param {string} [model.iPAddress] Gets or sets the ip address.
 *
 * @param {string} [model.description] Gets or sets the description.
 *
 * @param {number} [model.processTime] Gets or sets the process time.
 *
 * @param {object} [model.details] Gets or sets the details.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link EventModel} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _createEvent(drawer, model, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (drawer === null || drawer === undefined || typeof drawer !== 'number') {
      throw new Error('drawer cannot be null or undefined and it must be of type number.');
    }
    if (model === null || model === undefined) {
      throw new Error('model cannot be null or undefined.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'v1/content/events/{drawer}';
  requestUrl = requestUrl.replace('{drawer}', encodeURIComponent(drawer.toString()));

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (model !== null && model !== undefined) {
      let requestModelMapper = new client.models['EventModel']().mapper();
      requestModel = client.serialize(requestModelMapper, model, 'model');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(model, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 201 && statusCode !== 404) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 201) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['EventModel']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets a paged list of extension rows
 *
 * @param {number} drawerID Gets or sets the drawer identifier.
 *
 * @param {number} entityID Gets or sets the entity identifier.
 *
 * @param {number} profileID Gets or sets the profile identifier.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {number} [options.iD] Gets or sets the extension identifier.
 *
 * @param {number} [options.type] Gets or sets the type of the extension.
 *
 * @param {number} [options.page] Gets or sets the page number.
 *
 * @param {number} [options.pageSize] Gets or sets the size of the page.
 *
 * @param {string} [options.sortOrder] Gets or sets the order. Possible values
 * include: 'Unspecified', 'Ascending', 'Descending'
 *
 * @param {string} [options.sortBy] Gets or sets the column to order by.
 * Possible values include: 'RowNumber', 'ID', 'Type', 'String', 'Integer',
 * 'Double', 'Date'
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {array} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getExtensionsByFilter(drawerID, entityID, profileID, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let iD = (options && options.iD !== undefined) ? options.iD : undefined;
  let type = (options && options.type !== undefined) ? options.type : undefined;
  let page = (options && options.page !== undefined) ? options.page : undefined;
  let pageSize = (options && options.pageSize !== undefined) ? options.pageSize : undefined;
  let sortOrder = (options && options.sortOrder !== undefined) ? options.sortOrder : undefined;
  let sortBy = (options && options.sortBy !== undefined) ? options.sortBy : undefined;
  // Validate
  try {
    if (drawerID === null || drawerID === undefined || typeof drawerID !== 'number') {
      throw new Error('drawerID cannot be null or undefined and it must be of type number.');
    }
    if (drawerID !== null && drawerID !== undefined) {
      if (drawerID > 2147483647)
      {
        throw new Error('"drawerID" should satisfy the constraint - "InclusiveMaximum": 2147483647');
      }
      if (drawerID < 1)
      {
        throw new Error('"drawerID" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
    if (entityID === null || entityID === undefined || typeof entityID !== 'number') {
      throw new Error('entityID cannot be null or undefined and it must be of type number.');
    }
    if (entityID !== null && entityID !== undefined) {
      if (entityID > 2147483647)
      {
        throw new Error('"entityID" should satisfy the constraint - "InclusiveMaximum": 2147483647');
      }
      if (entityID < 1)
      {
        throw new Error('"entityID" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
    if (profileID === null || profileID === undefined || typeof profileID !== 'number') {
      throw new Error('profileID cannot be null or undefined and it must be of type number.');
    }
    if (profileID !== null && profileID !== undefined) {
      if (profileID > 2147483647)
      {
        throw new Error('"profileID" should satisfy the constraint - "InclusiveMaximum": 2147483647');
      }
      if (profileID < 1)
      {
        throw new Error('"profileID" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
    if (iD !== null && iD !== undefined && typeof iD !== 'number') {
      throw new Error('iD must be of type number.');
    }
    if (iD !== null && iD !== undefined) {
      if (iD > 2147483647)
      {
        throw new Error('"iD" should satisfy the constraint - "InclusiveMaximum": 2147483647');
      }
      if (iD < 1)
      {
        throw new Error('"iD" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
    if (type !== null && type !== undefined && typeof type !== 'number') {
      throw new Error('type must be of type number.');
    }
    if (type !== null && type !== undefined) {
      if (type > 2147483647)
      {
        throw new Error('"type" should satisfy the constraint - "InclusiveMaximum": 2147483647');
      }
      if (type < 0)
      {
        throw new Error('"type" should satisfy the constraint - "InclusiveMinimum": 0');
      }
    }
    if (page !== null && page !== undefined && typeof page !== 'number') {
      throw new Error('page must be of type number.');
    }
    if (page !== null && page !== undefined) {
      if (page > 2147483647)
      {
        throw new Error('"page" should satisfy the constraint - "InclusiveMaximum": 2147483647');
      }
      if (page < 1)
      {
        throw new Error('"page" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
    if (pageSize !== null && pageSize !== undefined && typeof pageSize !== 'number') {
      throw new Error('pageSize must be of type number.');
    }
    if (pageSize !== null && pageSize !== undefined) {
      if (pageSize > 1000)
      {
        throw new Error('"pageSize" should satisfy the constraint - "InclusiveMaximum": 1000');
      }
      if (pageSize < 1)
      {
        throw new Error('"pageSize" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
    if (sortOrder !== null && sortOrder !== undefined && typeof sortOrder.valueOf() !== 'string') {
      throw new Error('sortOrder must be of type string.');
    }
    if (sortBy !== null && sortBy !== undefined && typeof sortBy.valueOf() !== 'string') {
      throw new Error('sortBy must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'v1/content/extensions';
  let queryParameters = [];
  queryParameters.push('drawerID=' + encodeURIComponent(drawerID.toString()));
  queryParameters.push('entityID=' + encodeURIComponent(entityID.toString()));
  queryParameters.push('profileID=' + encodeURIComponent(profileID.toString()));
  if (iD !== null && iD !== undefined) {
    queryParameters.push('iD=' + encodeURIComponent(iD.toString()));
  }
  if (type !== null && type !== undefined) {
    queryParameters.push('type=' + encodeURIComponent(type.toString()));
  }
  if (page !== null && page !== undefined) {
    queryParameters.push('page=' + encodeURIComponent(page.toString()));
  }
  if (pageSize !== null && pageSize !== undefined) {
    queryParameters.push('pageSize=' + encodeURIComponent(pageSize.toString()));
  }
  if (sortOrder !== null && sortOrder !== undefined) {
    queryParameters.push('sortOrder=' + encodeURIComponent(sortOrder));
  }
  if (sortBy !== null && sortBy !== undefined) {
    queryParameters.push('sortBy=' + encodeURIComponent(sortBy));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = {
            required: false,
            serializedName: 'parsedResponse',
            type: {
              name: 'Sequence',
              element: {
                  required: false,
                  serializedName: 'ExtensionModelElementType',
                  type: {
                    name: 'Composite',
                    className: 'ExtensionModel'
                  }
              }
            }
          };
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets a paged list of flows.
 *
 * @param {number} drawerID Gets or sets the drawer identifier.
 *
 * @param {number} entityID Gets or sets the entity identifier.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {string} [options.type] Gets or sets the type. Possible values
 * include: 'None', 'Workflow', 'Fatal', 'Warning', 'Info', 'Debug', 'Process',
 * 'Rpc', 'Sql', 'Dde'
 *
 * @param {number} [options.queueID] Gets or sets the queue identifier.
 *
 * @param {date} [options.minWorkflowTime] Gets or sets the minimum workflow
 * time.
 *
 * @param {date} [options.maxWorkflowTime] Gets or sets the maximum workflow
 * time.
 *
 * @param {date} [options.minInsertionTime] Gets or sets the minimum insertion
 * time.
 *
 * @param {date} [options.maxInsertionTime] Gets or sets the maximum insertion
 * time.
 *
 * @param {number} [options.workflowUserID] Gets or sets the workflow user
 * identifier.
 *
 * @param {number} [options.workflowGroupID] Gets or sets the workflow group
 * identifier.
 *
 * @param {string} [options.operation] Gets or sets the operation. Possible
 * values include: 'None', 'Update', 'Reset', 'Override', 'Null'
 *
 * @param {string} [options.category] Gets or sets the category. Possible
 * values include: 'None', 'Direct', 'AdHoc', 'Production', 'Review', 'Reset',
 * 'RoutingSlip', 'ReviewRoutingSlip', 'Override'
 *
 * @param {string} [options.status] Gets or sets the status. Possible values
 * include: 'None', 'Approved', 'Rejected', 'Suspended', 'ApprovedR', 'NoneR'
 *
 * @param {string} [options.state] Gets or sets the state. Possible values
 * include: 'None', 'Processed', 'Pending', 'Waiting', 'ProcessedR',
 * 'Override', 'OverrideR', 'WaitingR'
 *
 * @param {number} [options.minIndex1] Gets or sets the minimum index 1.
 *
 * @param {number} [options.maxIndex1] Gets or sets the maximum index 1.
 *
 * @param {number} [options.minIndex2] Gets or sets the minimum index 2.
 *
 * @param {number} [options.maxIndex2] Gets or sets the maximum index 2.
 *
 * @param {number} [options.page] Gets or sets the page number.
 *
 * @param {number} [options.pageSize] Gets or sets the size of the page.
 *
 * @param {string} [options.sortOrder] Gets or sets the order. Possible values
 * include: 'Unspecified', 'Ascending', 'Descending'
 *
 * @param {string} [options.sortBy] Gets or sets the column to order by.
 * Possible values include: 'ID', 'Type', 'QueueID', 'WorkflowTime',
 * 'InsertionTime', 'Index'
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {array} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getFlowsByFilter(drawerID, entityID, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let type = (options && options.type !== undefined) ? options.type : undefined;
  let queueID = (options && options.queueID !== undefined) ? options.queueID : undefined;
  let minWorkflowTime = (options && options.minWorkflowTime !== undefined) ? options.minWorkflowTime : undefined;
  let maxWorkflowTime = (options && options.maxWorkflowTime !== undefined) ? options.maxWorkflowTime : undefined;
  let minInsertionTime = (options && options.minInsertionTime !== undefined) ? options.minInsertionTime : undefined;
  let maxInsertionTime = (options && options.maxInsertionTime !== undefined) ? options.maxInsertionTime : undefined;
  let workflowUserID = (options && options.workflowUserID !== undefined) ? options.workflowUserID : undefined;
  let workflowGroupID = (options && options.workflowGroupID !== undefined) ? options.workflowGroupID : undefined;
  let operation = (options && options.operation !== undefined) ? options.operation : undefined;
  let category = (options && options.category !== undefined) ? options.category : undefined;
  let status = (options && options.status !== undefined) ? options.status : undefined;
  let state = (options && options.state !== undefined) ? options.state : undefined;
  let minIndex1 = (options && options.minIndex1 !== undefined) ? options.minIndex1 : undefined;
  let maxIndex1 = (options && options.maxIndex1 !== undefined) ? options.maxIndex1 : undefined;
  let minIndex2 = (options && options.minIndex2 !== undefined) ? options.minIndex2 : undefined;
  let maxIndex2 = (options && options.maxIndex2 !== undefined) ? options.maxIndex2 : undefined;
  let page = (options && options.page !== undefined) ? options.page : undefined;
  let pageSize = (options && options.pageSize !== undefined) ? options.pageSize : undefined;
  let sortOrder = (options && options.sortOrder !== undefined) ? options.sortOrder : undefined;
  let sortBy = (options && options.sortBy !== undefined) ? options.sortBy : undefined;
  // Validate
  try {
    if (drawerID === null || drawerID === undefined || typeof drawerID !== 'number') {
      throw new Error('drawerID cannot be null or undefined and it must be of type number.');
    }
    if (drawerID !== null && drawerID !== undefined) {
      if (drawerID > 2147483647)
      {
        throw new Error('"drawerID" should satisfy the constraint - "InclusiveMaximum": 2147483647');
      }
      if (drawerID < 1)
      {
        throw new Error('"drawerID" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
    if (entityID === null || entityID === undefined || typeof entityID !== 'number') {
      throw new Error('entityID cannot be null or undefined and it must be of type number.');
    }
    if (entityID !== null && entityID !== undefined) {
      if (entityID > 2147483647)
      {
        throw new Error('"entityID" should satisfy the constraint - "InclusiveMaximum": 2147483647');
      }
      if (entityID < 1)
      {
        throw new Error('"entityID" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
    if (type !== null && type !== undefined && typeof type.valueOf() !== 'string') {
      throw new Error('type must be of type string.');
    }
    if (queueID !== null && queueID !== undefined && typeof queueID !== 'number') {
      throw new Error('queueID must be of type number.');
    }
    if (queueID !== null && queueID !== undefined) {
      if (queueID > 2147483647)
      {
        throw new Error('"queueID" should satisfy the constraint - "InclusiveMaximum": 2147483647');
      }
      if (queueID < 1)
      {
        throw new Error('"queueID" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
    if (minWorkflowTime && !(minWorkflowTime instanceof Date ||
        (typeof minWorkflowTime.valueOf() === 'string' && !isNaN(Date.parse(minWorkflowTime))))) {
          throw new Error('minWorkflowTime must be of type date.');
        }
    if (maxWorkflowTime && !(maxWorkflowTime instanceof Date ||
        (typeof maxWorkflowTime.valueOf() === 'string' && !isNaN(Date.parse(maxWorkflowTime))))) {
          throw new Error('maxWorkflowTime must be of type date.');
        }
    if (minInsertionTime && !(minInsertionTime instanceof Date ||
        (typeof minInsertionTime.valueOf() === 'string' && !isNaN(Date.parse(minInsertionTime))))) {
          throw new Error('minInsertionTime must be of type date.');
        }
    if (maxInsertionTime && !(maxInsertionTime instanceof Date ||
        (typeof maxInsertionTime.valueOf() === 'string' && !isNaN(Date.parse(maxInsertionTime))))) {
          throw new Error('maxInsertionTime must be of type date.');
        }
    if (workflowUserID !== null && workflowUserID !== undefined && typeof workflowUserID !== 'number') {
      throw new Error('workflowUserID must be of type number.');
    }
    if (workflowUserID !== null && workflowUserID !== undefined) {
      if (workflowUserID > 2147483647)
      {
        throw new Error('"workflowUserID" should satisfy the constraint - "InclusiveMaximum": 2147483647');
      }
      if (workflowUserID < 1)
      {
        throw new Error('"workflowUserID" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
    if (workflowGroupID !== null && workflowGroupID !== undefined && typeof workflowGroupID !== 'number') {
      throw new Error('workflowGroupID must be of type number.');
    }
    if (workflowGroupID !== null && workflowGroupID !== undefined) {
      if (workflowGroupID > 2147483647)
      {
        throw new Error('"workflowGroupID" should satisfy the constraint - "InclusiveMaximum": 2147483647');
      }
      if (workflowGroupID < 1)
      {
        throw new Error('"workflowGroupID" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
    if (operation !== null && operation !== undefined && typeof operation.valueOf() !== 'string') {
      throw new Error('operation must be of type string.');
    }
    if (category !== null && category !== undefined && typeof category.valueOf() !== 'string') {
      throw new Error('category must be of type string.');
    }
    if (status !== null && status !== undefined && typeof status.valueOf() !== 'string') {
      throw new Error('status must be of type string.');
    }
    if (state !== null && state !== undefined && typeof state.valueOf() !== 'string') {
      throw new Error('state must be of type string.');
    }
    if (minIndex1 !== null && minIndex1 !== undefined && typeof minIndex1 !== 'number') {
      throw new Error('minIndex1 must be of type number.');
    }
    if (maxIndex1 !== null && maxIndex1 !== undefined && typeof maxIndex1 !== 'number') {
      throw new Error('maxIndex1 must be of type number.');
    }
    if (minIndex2 !== null && minIndex2 !== undefined && typeof minIndex2 !== 'number') {
      throw new Error('minIndex2 must be of type number.');
    }
    if (maxIndex2 !== null && maxIndex2 !== undefined && typeof maxIndex2 !== 'number') {
      throw new Error('maxIndex2 must be of type number.');
    }
    if (page !== null && page !== undefined && typeof page !== 'number') {
      throw new Error('page must be of type number.');
    }
    if (page !== null && page !== undefined) {
      if (page > 2147483647)
      {
        throw new Error('"page" should satisfy the constraint - "InclusiveMaximum": 2147483647');
      }
      if (page < 1)
      {
        throw new Error('"page" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
    if (pageSize !== null && pageSize !== undefined && typeof pageSize !== 'number') {
      throw new Error('pageSize must be of type number.');
    }
    if (pageSize !== null && pageSize !== undefined) {
      if (pageSize > 1000)
      {
        throw new Error('"pageSize" should satisfy the constraint - "InclusiveMaximum": 1000');
      }
      if (pageSize < 1)
      {
        throw new Error('"pageSize" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
    if (sortOrder !== null && sortOrder !== undefined && typeof sortOrder.valueOf() !== 'string') {
      throw new Error('sortOrder must be of type string.');
    }
    if (sortBy !== null && sortBy !== undefined && typeof sortBy.valueOf() !== 'string') {
      throw new Error('sortBy must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'v1/content/flows';
  let queryParameters = [];
  queryParameters.push('drawerID=' + encodeURIComponent(drawerID.toString()));
  queryParameters.push('entityID=' + encodeURIComponent(entityID.toString()));
  if (type !== null && type !== undefined) {
    queryParameters.push('type=' + encodeURIComponent(type));
  }
  if (queueID !== null && queueID !== undefined) {
    queryParameters.push('queueID=' + encodeURIComponent(queueID.toString()));
  }
  if (minWorkflowTime !== null && minWorkflowTime !== undefined) {
    queryParameters.push('minWorkflowTime=' + encodeURIComponent(client.serializeObject(minWorkflowTime)));
  }
  if (maxWorkflowTime !== null && maxWorkflowTime !== undefined) {
    queryParameters.push('maxWorkflowTime=' + encodeURIComponent(client.serializeObject(maxWorkflowTime)));
  }
  if (minInsertionTime !== null && minInsertionTime !== undefined) {
    queryParameters.push('minInsertionTime=' + encodeURIComponent(client.serializeObject(minInsertionTime)));
  }
  if (maxInsertionTime !== null && maxInsertionTime !== undefined) {
    queryParameters.push('maxInsertionTime=' + encodeURIComponent(client.serializeObject(maxInsertionTime)));
  }
  if (workflowUserID !== null && workflowUserID !== undefined) {
    queryParameters.push('workflowUserID=' + encodeURIComponent(workflowUserID.toString()));
  }
  if (workflowGroupID !== null && workflowGroupID !== undefined) {
    queryParameters.push('workflowGroupID=' + encodeURIComponent(workflowGroupID.toString()));
  }
  if (operation !== null && operation !== undefined) {
    queryParameters.push('operation=' + encodeURIComponent(operation));
  }
  if (category !== null && category !== undefined) {
    queryParameters.push('category=' + encodeURIComponent(category));
  }
  if (status !== null && status !== undefined) {
    queryParameters.push('status=' + encodeURIComponent(status));
  }
  if (state !== null && state !== undefined) {
    queryParameters.push('state=' + encodeURIComponent(state));
  }
  if (minIndex1 !== null && minIndex1 !== undefined) {
    queryParameters.push('minIndex1=' + encodeURIComponent(minIndex1.toString()));
  }
  if (maxIndex1 !== null && maxIndex1 !== undefined) {
    queryParameters.push('maxIndex1=' + encodeURIComponent(maxIndex1.toString()));
  }
  if (minIndex2 !== null && minIndex2 !== undefined) {
    queryParameters.push('minIndex2=' + encodeURIComponent(minIndex2.toString()));
  }
  if (maxIndex2 !== null && maxIndex2 !== undefined) {
    queryParameters.push('maxIndex2=' + encodeURIComponent(maxIndex2.toString()));
  }
  if (page !== null && page !== undefined) {
    queryParameters.push('page=' + encodeURIComponent(page.toString()));
  }
  if (pageSize !== null && pageSize !== undefined) {
    queryParameters.push('pageSize=' + encodeURIComponent(pageSize.toString()));
  }
  if (sortOrder !== null && sortOrder !== undefined) {
    queryParameters.push('sortOrder=' + encodeURIComponent(sortOrder));
  }
  if (sortBy !== null && sortBy !== undefined) {
    queryParameters.push('sortBy=' + encodeURIComponent(sortBy));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = {
            required: false,
            serializedName: 'parsedResponse',
            type: {
              name: 'Sequence',
              element: {
                  required: false,
                  serializedName: 'FlowModelElementType',
                  type: {
                    name: 'Composite',
                    className: 'FlowModel'
                  }
              }
            }
          };
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets a single flow based on its unique identifier.
 *
 * @param {number} drawer The drawer identifier.
 *
 * @param {number} id The flow identifier.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link FlowModel} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getFlowById(drawer, id, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (drawer === null || drawer === undefined || typeof drawer !== 'number') {
      throw new Error('drawer cannot be null or undefined and it must be of type number.');
    }
    if (id === null || id === undefined || typeof id !== 'number') {
      throw new Error('id cannot be null or undefined and it must be of type number.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'v1/content/flows/{drawer}/{id}';
  requestUrl = requestUrl.replace('{drawer}', encodeURIComponent(drawer.toString()));
  requestUrl = requestUrl.replace('{id}', encodeURIComponent(id.toString()));

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200 && statusCode !== 404) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['FlowModel']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets a paged list of entity template definitions.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {number} [options.drawerID] Gets or sets the drawer identifier.
 *
 * @param {string} [options.name] Gets or sets the name.
 *
 * @param {string} [options.category] Gets or sets the category.
 *
 * @param {number} [options.page] Gets or sets the page number.
 *
 * @param {number} [options.pageSize] Gets or sets the size of the page.
 *
 * @param {string} [options.sortOrder] Gets or sets the order. Possible values
 * include: 'Unspecified', 'Ascending', 'Descending'
 *
 * @param {number} [options.sortBy] Gets or sets the column to order by.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {array} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getTemplatesByFilter(options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let drawerID = (options && options.drawerID !== undefined) ? options.drawerID : undefined;
  let name = (options && options.name !== undefined) ? options.name : undefined;
  let category = (options && options.category !== undefined) ? options.category : undefined;
  let page = (options && options.page !== undefined) ? options.page : undefined;
  let pageSize = (options && options.pageSize !== undefined) ? options.pageSize : undefined;
  let sortOrder = (options && options.sortOrder !== undefined) ? options.sortOrder : undefined;
  let sortBy = (options && options.sortBy !== undefined) ? options.sortBy : undefined;
  // Validate
  try {
    if (drawerID !== null && drawerID !== undefined && typeof drawerID !== 'number') {
      throw new Error('drawerID must be of type number.');
    }
    if (drawerID !== null && drawerID !== undefined) {
      if (drawerID > 2147483647)
      {
        throw new Error('"drawerID" should satisfy the constraint - "InclusiveMaximum": 2147483647');
      }
      if (drawerID < 1)
      {
        throw new Error('"drawerID" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
    if (name !== null && name !== undefined && typeof name.valueOf() !== 'string') {
      throw new Error('name must be of type string.');
    }
    if (name !== null && name !== undefined) {
      if (name.length > 255)
      {
        throw new Error('"name" should satisfy the constraint - "MaxLength": 255');
      }
      if (name.length < 0)
      {
        throw new Error('"name" should satisfy the constraint - "MinLength": 0');
      }
    }
    if (category !== null && category !== undefined && typeof category.valueOf() !== 'string') {
      throw new Error('category must be of type string.');
    }
    if (category !== null && category !== undefined) {
      if (category.length > 255)
      {
        throw new Error('"category" should satisfy the constraint - "MaxLength": 255');
      }
      if (category.length < 0)
      {
        throw new Error('"category" should satisfy the constraint - "MinLength": 0');
      }
    }
    if (page !== null && page !== undefined && typeof page !== 'number') {
      throw new Error('page must be of type number.');
    }
    if (page !== null && page !== undefined) {
      if (page > 2147483647)
      {
        throw new Error('"page" should satisfy the constraint - "InclusiveMaximum": 2147483647');
      }
      if (page < 1)
      {
        throw new Error('"page" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
    if (pageSize !== null && pageSize !== undefined && typeof pageSize !== 'number') {
      throw new Error('pageSize must be of type number.');
    }
    if (pageSize !== null && pageSize !== undefined) {
      if (pageSize > 1000)
      {
        throw new Error('"pageSize" should satisfy the constraint - "InclusiveMaximum": 1000');
      }
      if (pageSize < 1)
      {
        throw new Error('"pageSize" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
    if (sortOrder !== null && sortOrder !== undefined && typeof sortOrder.valueOf() !== 'string') {
      throw new Error('sortOrder must be of type string.');
    }
    if (sortBy !== null && sortBy !== undefined && typeof sortBy !== 'number') {
      throw new Error('sortBy must be of type number.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'v1/template/ftl';
  let queryParameters = [];
  if (drawerID !== null && drawerID !== undefined) {
    queryParameters.push('drawerID=' + encodeURIComponent(drawerID.toString()));
  }
  if (name !== null && name !== undefined) {
    queryParameters.push('name=' + encodeURIComponent(name));
  }
  if (category !== null && category !== undefined) {
    queryParameters.push('category=' + encodeURIComponent(category));
  }
  if (page !== null && page !== undefined) {
    queryParameters.push('page=' + encodeURIComponent(page.toString()));
  }
  if (pageSize !== null && pageSize !== undefined) {
    queryParameters.push('pageSize=' + encodeURIComponent(pageSize.toString()));
  }
  if (sortOrder !== null && sortOrder !== undefined) {
    queryParameters.push('sortOrder=' + encodeURIComponent(sortOrder));
  }
  if (sortBy !== null && sortBy !== undefined) {
    queryParameters.push('sortBy=' + encodeURIComponent(sortBy.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = {
            required: false,
            serializedName: 'parsedResponse',
            type: {
              name: 'Sequence',
              element: {
                  required: false,
                  serializedName: 'EntityDefinitionModelElementType',
                  type: {
                    name: 'Composite',
                    className: 'EntityDefinitionModel'
                  }
              }
            }
          };
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Creates a new entity template definition.
 *
 * @param {object} model The entity template model.
 *
 * @param {number} model.type Gets or sets the type of template.
 *
 * @param {string} model.category Gets or sets the category of template.
 *
 * @param {string} model.name Gets or sets the name of template.
 *
 * @param {boolean} [model.hasClass] Gets or sets if the template has classes.
 *
 * @param {boolean} [model.hasSecurity] Gets or sets if the template has
 * security.
 *
 * @param {boolean} [model.hasProfiles] Gets or sets if the template has
 * profiles.
 *
 * @param {boolean} [model.hasItems] Gets or sets the has items.
 *
 * @param {string} [model.smallImage] Gets or sets the small image.
 *
 * @param {string} [model.largeImage] Gets or sets the large image.
 *
 * @param {boolean} [model.hasAudit] Gets or sets if the template has auditing
 * enabled.
 *
 * @param {boolean} [model.allowsViewImages] Gets or sets if the template
 * allows viewing images.
 *
 * @param {boolean} [model.isReviewState] Gets or sets if the entity is created
 * in a review state.
 *
 * @param {string} [model.reservedString1] Gets or sets the reserved string1.
 *
 * @param {string} [model.reservedString2] Gets or sets the reserved string2.
 *
 * @param {number} [model.reservedInt1] Gets or sets the reserved int1.
 *
 * @param {number} [model.reservedInt2] Gets or sets the reserved int2.
 *
 * @param {array} [model.drawers] Gets or sets the drawers.
 *
 * @param {array} [model.profiles] Gets or sets the profiles.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link EntityDefinitionModel} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _createTemplate(model, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (model === null || model === undefined) {
      throw new Error('model cannot be null or undefined.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'v1/template/ftl';

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (model !== null && model !== undefined) {
      let requestModelMapper = new client.models['EntityDefinitionBase']().mapper();
      requestModel = client.serialize(requestModelMapper, model, 'model');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(model, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 201 && statusCode !== 403 && statusCode !== 404 && statusCode !== 409) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 201) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['EntityDefinitionModel']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets a single entity template definition by its type.
 *
 * @param {number} type The unique template type.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link EntityDefinitionModel} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getTemplateByType(type, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (type === null || type === undefined || typeof type !== 'number') {
      throw new Error('type cannot be null or undefined and it must be of type number.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'v1/template/ftl/{type}';
  requestUrl = requestUrl.replace('{type}', encodeURIComponent(type.toString()));

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200 && statusCode !== 404) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['EntityDefinitionModel']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Updates a specified entity template definition by type.
 *
 * @param {number} type The unique template type.
 *
 * @param {object} model The entity template model.
 *
 * @param {string} [model.category] Gets or sets the category of template.
 *
 * @param {string} [model.name] Gets or sets the name of templates.
 *
 * @param {string} [model.smallImage] Gets or sets the small image.
 *
 * @param {string} [model.largeImage] Gets or sets the large image.
 *
 * @param {boolean} [model.hasAudit] Gets or sets if the template has auditing
 * enabled.
 *
 * @param {boolean} [model.allowsViewImages] Gets or sets if the template
 * allows viewing images.
 *
 * @param {boolean} [model.isReviewState] Gets or sets if the entity is created
 * in a review state.
 *
 * @param {array} [model.profiles] Gets or sets the profiles.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _updateTemplateByType(type, model, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (type === null || type === undefined || typeof type !== 'number') {
      throw new Error('type cannot be null or undefined and it must be of type number.');
    }
    if (model === null || model === undefined) {
      throw new Error('model cannot be null or undefined.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'v1/template/ftl/{type}';
  requestUrl = requestUrl.replace('{type}', encodeURIComponent(type.toString()));

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'PUT';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (model !== null && model !== undefined) {
      let requestModelMapper = new client.models['UpdateEntityDefinitionRequestModel']().mapper();
      requestModel = client.serialize(requestModelMapper, model, 'model');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(model, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 204 && statusCode !== 403 && statusCode !== 404) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 204) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = {
            required: false,
            serializedName: 'parsedResponse',
            type: {
              name: 'Object'
            }
          };
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Deletes a specified entity template definition by type.
 *
 * @param {number} type The unique template type.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _deleteTemplateByType(type, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (type === null || type === undefined || typeof type !== 'number') {
      throw new Error('type cannot be null or undefined and it must be of type number.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'v1/template/ftl/{type}';
  requestUrl = requestUrl.replace('{type}', encodeURIComponent(type.toString()));

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'DELETE';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 204 && statusCode !== 403 && statusCode !== 404) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 204) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = {
            required: false,
            serializedName: 'parsedResponse',
            type: {
              name: 'Object'
            }
          };
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets a single entity template definition by its unique identifier.
 *
 * @param {string} id The template identifier.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link EntityDefinitionModel} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getTemplateById(id, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (id === null || id === undefined || typeof id.valueOf() !== 'string') {
      throw new Error('id cannot be null or undefined and it must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'v1/template/ftl/{id}';
  requestUrl = requestUrl.replace('{id}', encodeURIComponent(id));

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200 && statusCode !== 404) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['EntityDefinitionModel']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Updates a specified entity template definition by identifier.
 *
 * @param {string} id The unique template identifier.
 *
 * @param {object} model The entity template model.
 *
 * @param {string} [model.category] Gets or sets the category of template.
 *
 * @param {string} [model.name] Gets or sets the name of templates.
 *
 * @param {string} [model.smallImage] Gets or sets the small image.
 *
 * @param {string} [model.largeImage] Gets or sets the large image.
 *
 * @param {boolean} [model.hasAudit] Gets or sets if the template has auditing
 * enabled.
 *
 * @param {boolean} [model.allowsViewImages] Gets or sets if the template
 * allows viewing images.
 *
 * @param {boolean} [model.isReviewState] Gets or sets if the entity is created
 * in a review state.
 *
 * @param {array} [model.profiles] Gets or sets the profiles.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _updateTemplateById(id, model, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (id === null || id === undefined || typeof id.valueOf() !== 'string') {
      throw new Error('id cannot be null or undefined and it must be of type string.');
    }
    if (model === null || model === undefined) {
      throw new Error('model cannot be null or undefined.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'v1/template/ftl/{id}';
  requestUrl = requestUrl.replace('{id}', encodeURIComponent(id));

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'PUT';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (model !== null && model !== undefined) {
      let requestModelMapper = new client.models['UpdateEntityDefinitionRequestModel']().mapper();
      requestModel = client.serialize(requestModelMapper, model, 'model');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(model, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 204 && statusCode !== 403 && statusCode !== 404) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 204) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = {
            required: false,
            serializedName: 'parsedResponse',
            type: {
              name: 'Object'
            }
          };
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Deletes a specified entity template definition by identifier.
 *
 * @param {string} id The unique template identifier.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _deleteTemplateById(id, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (id === null || id === undefined || typeof id.valueOf() !== 'string') {
      throw new Error('id cannot be null or undefined and it must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'v1/template/ftl/{id}';
  requestUrl = requestUrl.replace('{id}', encodeURIComponent(id));

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'DELETE';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 204 && statusCode !== 403 && statusCode !== 404) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 204) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = {
            required: false,
            serializedName: 'parsedResponse',
            type: {
              name: 'Object'
            }
          };
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Validates the specified template field.
 *
 * @param {number} type The template type.
 *
 * @param {string} fieldID The field name.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {string} [options.sortColumn] Gets or sets the sort column.
 *
 * @param {array} [options.metadata] Gets or sets the metadata search options.
 *
 * @param {number} [options.page] Gets or sets the page number.
 *
 * @param {number} [options.pageSize] Gets or sets the size of the page.
 *
 * @param {string} [options.sortOrder] Gets or sets the order. Possible values
 * include: 'Unspecified', 'Ascending', 'Descending'
 *
 * @param {number} [options.sortBy] Gets or sets the column to order by.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link FieldValidationModel} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _validateTemplateField(type, fieldID, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let sortColumn = (options && options.sortColumn !== undefined) ? options.sortColumn : undefined;
  let metadata = (options && options.metadata !== undefined) ? options.metadata : undefined;
  let page = (options && options.page !== undefined) ? options.page : undefined;
  let pageSize = (options && options.pageSize !== undefined) ? options.pageSize : undefined;
  let sortOrder = (options && options.sortOrder !== undefined) ? options.sortOrder : undefined;
  let sortBy = (options && options.sortBy !== undefined) ? options.sortBy : undefined;
  // Validate
  try {
    if (type === null || type === undefined || typeof type !== 'number') {
      throw new Error('type cannot be null or undefined and it must be of type number.');
    }
    if (fieldID === null || fieldID === undefined || typeof fieldID.valueOf() !== 'string') {
      throw new Error('fieldID cannot be null or undefined and it must be of type string.');
    }
    if (sortColumn !== null && sortColumn !== undefined && typeof sortColumn.valueOf() !== 'string') {
      throw new Error('sortColumn must be of type string.');
    }
    if (Array.isArray(metadata)) {
      for (let i = 0; i < metadata.length; i++) {
        if (metadata[i] !== null && metadata[i] !== undefined && typeof metadata[i] !== 'object') {
          throw new Error('metadata[i] must be of type object.');
        }
      }
    }
    if (page !== null && page !== undefined && typeof page !== 'number') {
      throw new Error('page must be of type number.');
    }
    if (page !== null && page !== undefined) {
      if (page > 2147483647)
      {
        throw new Error('"page" should satisfy the constraint - "InclusiveMaximum": 2147483647');
      }
      if (page < 1)
      {
        throw new Error('"page" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
    if (pageSize !== null && pageSize !== undefined && typeof pageSize !== 'number') {
      throw new Error('pageSize must be of type number.');
    }
    if (pageSize !== null && pageSize !== undefined) {
      if (pageSize > 1000)
      {
        throw new Error('"pageSize" should satisfy the constraint - "InclusiveMaximum": 1000');
      }
      if (pageSize < 1)
      {
        throw new Error('"pageSize" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
    if (sortOrder !== null && sortOrder !== undefined && typeof sortOrder.valueOf() !== 'string') {
      throw new Error('sortOrder must be of type string.');
    }
    if (sortBy !== null && sortBy !== undefined && typeof sortBy !== 'number') {
      throw new Error('sortBy must be of type number.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'v1/template/ftl/{type}/validate/{fieldID}';
  requestUrl = requestUrl.replace('{type}', encodeURIComponent(type.toString()));
  requestUrl = requestUrl.replace('{fieldID}', encodeURIComponent(fieldID));
  let queryParameters = [];
  if (sortColumn !== null && sortColumn !== undefined) {
    queryParameters.push('sortColumn=' + encodeURIComponent(sortColumn));
  }
  if (metadata !== null && metadata !== undefined) {
    if (metadata.length == 0) {
      queryParameters.push('metadata=' + encodeURIComponent(''));
    } else {
      for (let item of metadata) {
        item = (item === null || item === undefined) ? '' : item;
        queryParameters.push('metadata=' + encodeURIComponent('' + item));
      }
    }
  }
  if (page !== null && page !== undefined) {
    queryParameters.push('page=' + encodeURIComponent(page.toString()));
  }
  if (pageSize !== null && pageSize !== undefined) {
    queryParameters.push('pageSize=' + encodeURIComponent(pageSize.toString()));
  }
  if (sortOrder !== null && sortOrder !== undefined) {
    queryParameters.push('sortOrder=' + encodeURIComponent(sortOrder));
  }
  if (sortBy !== null && sortBy !== undefined) {
    queryParameters.push('sortBy=' + encodeURIComponent(sortBy.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200 && statusCode !== 404) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['FieldValidationModel']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets a paged list of groups.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {number} [options.iD] Gets or sets the group identifier.
 *
 * @param {number} [options.userID] Gets or sets the user identifier.
 *
 * @param {string} [options.name] Gets or sets the name.
 *
 * @param {string} [options.type] Gets or sets the type. Possible values
 * include: 'Generic', 'Access', 'Role'
 *
 * @param {string} [options.state] Gets or sets the state. Possible values
 * include: 'Inactive', 'Active'
 *
 * @param {number} [options.page] Gets or sets the page number.
 *
 * @param {number} [options.pageSize] Gets or sets the size of the page.
 *
 * @param {string} [options.sortOrder] Gets or sets the order. Possible values
 * include: 'Unspecified', 'Ascending', 'Descending'
 *
 * @param {string} [options.sortBy] Gets or sets the column to order by.
 * Possible values include: 'ID', 'Name', 'Type', 'State'
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {array} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getGroupsByFilter(options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let iD = (options && options.iD !== undefined) ? options.iD : undefined;
  let userID = (options && options.userID !== undefined) ? options.userID : undefined;
  let name = (options && options.name !== undefined) ? options.name : undefined;
  let type = (options && options.type !== undefined) ? options.type : undefined;
  let state = (options && options.state !== undefined) ? options.state : undefined;
  let page = (options && options.page !== undefined) ? options.page : undefined;
  let pageSize = (options && options.pageSize !== undefined) ? options.pageSize : undefined;
  let sortOrder = (options && options.sortOrder !== undefined) ? options.sortOrder : undefined;
  let sortBy = (options && options.sortBy !== undefined) ? options.sortBy : undefined;
  // Validate
  try {
    if (iD !== null && iD !== undefined && typeof iD !== 'number') {
      throw new Error('iD must be of type number.');
    }
    if (iD !== null && iD !== undefined) {
      if (iD > 2147483647)
      {
        throw new Error('"iD" should satisfy the constraint - "InclusiveMaximum": 2147483647');
      }
      if (iD < 1)
      {
        throw new Error('"iD" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
    if (userID !== null && userID !== undefined && typeof userID !== 'number') {
      throw new Error('userID must be of type number.');
    }
    if (userID !== null && userID !== undefined) {
      if (userID > 2147483647)
      {
        throw new Error('"userID" should satisfy the constraint - "InclusiveMaximum": 2147483647');
      }
      if (userID < 1)
      {
        throw new Error('"userID" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
    if (name !== null && name !== undefined && typeof name.valueOf() !== 'string') {
      throw new Error('name must be of type string.');
    }
    if (name !== null && name !== undefined) {
      if (name.length > 255)
      {
        throw new Error('"name" should satisfy the constraint - "MaxLength": 255');
      }
      if (name.length < 0)
      {
        throw new Error('"name" should satisfy the constraint - "MinLength": 0');
      }
    }
    if (type !== null && type !== undefined && typeof type.valueOf() !== 'string') {
      throw new Error('type must be of type string.');
    }
    if (state !== null && state !== undefined && typeof state.valueOf() !== 'string') {
      throw new Error('state must be of type string.');
    }
    if (page !== null && page !== undefined && typeof page !== 'number') {
      throw new Error('page must be of type number.');
    }
    if (page !== null && page !== undefined) {
      if (page > 2147483647)
      {
        throw new Error('"page" should satisfy the constraint - "InclusiveMaximum": 2147483647');
      }
      if (page < 1)
      {
        throw new Error('"page" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
    if (pageSize !== null && pageSize !== undefined && typeof pageSize !== 'number') {
      throw new Error('pageSize must be of type number.');
    }
    if (pageSize !== null && pageSize !== undefined) {
      if (pageSize > 1000)
      {
        throw new Error('"pageSize" should satisfy the constraint - "InclusiveMaximum": 1000');
      }
      if (pageSize < 1)
      {
        throw new Error('"pageSize" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
    if (sortOrder !== null && sortOrder !== undefined && typeof sortOrder.valueOf() !== 'string') {
      throw new Error('sortOrder must be of type string.');
    }
    if (sortBy !== null && sortBy !== undefined && typeof sortBy.valueOf() !== 'string') {
      throw new Error('sortBy must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'v1/directory/groups';
  let queryParameters = [];
  if (iD !== null && iD !== undefined) {
    queryParameters.push('iD=' + encodeURIComponent(iD.toString()));
  }
  if (userID !== null && userID !== undefined) {
    queryParameters.push('userID=' + encodeURIComponent(userID.toString()));
  }
  if (name !== null && name !== undefined) {
    queryParameters.push('name=' + encodeURIComponent(name));
  }
  if (type !== null && type !== undefined) {
    queryParameters.push('type=' + encodeURIComponent(type));
  }
  if (state !== null && state !== undefined) {
    queryParameters.push('state=' + encodeURIComponent(state));
  }
  if (page !== null && page !== undefined) {
    queryParameters.push('page=' + encodeURIComponent(page.toString()));
  }
  if (pageSize !== null && pageSize !== undefined) {
    queryParameters.push('pageSize=' + encodeURIComponent(pageSize.toString()));
  }
  if (sortOrder !== null && sortOrder !== undefined) {
    queryParameters.push('sortOrder=' + encodeURIComponent(sortOrder));
  }
  if (sortBy !== null && sortBy !== undefined) {
    queryParameters.push('sortBy=' + encodeURIComponent(sortBy));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200 && statusCode !== 403) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = {
            required: false,
            serializedName: 'parsedResponse',
            type: {
              name: 'Sequence',
              element: {
                  required: false,
                  serializedName: 'GroupModelElementType',
                  type: {
                    name: 'Composite',
                    className: 'GroupModel'
                  }
              }
            }
          };
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Creates a new group.
 *
 * @param {object} model The group model.
 *
 * @param {string} model.name Gets or sets the name.
 *
 * @param {string} [model.type] Gets or sets the type. Possible values include:
 * 'Generic', 'Access', 'Role'
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link GroupModel} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _createGroup(model, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (model === null || model === undefined) {
      throw new Error('model cannot be null or undefined.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'v1/directory/groups';

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (model !== null && model !== undefined) {
      let requestModelMapper = new client.models['InsertGroupRequestModel']().mapper();
      requestModel = client.serialize(requestModelMapper, model, 'model');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(model, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 201 && statusCode !== 403 && statusCode !== 409) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 201) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['GroupModel']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets a single group by its unique identifier.
 *
 * @param {number} id The group identifier.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link GroupModel} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getGroupById(id, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (id === null || id === undefined || typeof id !== 'number') {
      throw new Error('id cannot be null or undefined and it must be of type number.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'v1/directory/groups/{id}';
  requestUrl = requestUrl.replace('{id}', encodeURIComponent(id.toString()));

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200 && statusCode !== 403 && statusCode !== 404) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['GroupModel']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Updates a specified group.
 *
 * @param {number} id The group identifier.
 *
 * @param {object} model The group model.
 *
 * @param {number} [model.userID] Gets or sets the user identifier.
 *
 * @param {string} model.name Gets or sets the name.
 *
 * @param {string} [model.type] Gets or sets the type. Possible values include:
 * 'Generic', 'Access', 'Role'
 *
 * @param {string} [model.state] Gets or sets the state. Possible values
 * include: 'Inactive', 'Active'
 *
 * @param {number} [model.reservedInt1] Gets or sets the reserved int1.
 *
 * @param {number} [model.reservedInt2] Gets or sets the reserved int2.
 *
 * @param {string} [model.reservedString1] Gets or sets the reserved string1.
 *
 * @param {string} [model.reservedString2] Gets or sets the reserved string2.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _updateGroup(id, model, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (id === null || id === undefined || typeof id !== 'number') {
      throw new Error('id cannot be null or undefined and it must be of type number.');
    }
    if (model === null || model === undefined) {
      throw new Error('model cannot be null or undefined.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'v1/directory/groups/{id}';
  requestUrl = requestUrl.replace('{id}', encodeURIComponent(id.toString()));

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'PUT';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (model !== null && model !== undefined) {
      let requestModelMapper = new client.models['GroupBase']().mapper();
      requestModel = client.serialize(requestModelMapper, model, 'model');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(model, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 204 && statusCode !== 403 && statusCode !== 404 && statusCode !== 500) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 204) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = {
            required: false,
            serializedName: 'parsedResponse',
            type: {
              name: 'Object'
            }
          };
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Deactivates a group and removes all group associations.
 *
 * @param {number} id The group identifier.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _deleteGroup(id, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (id === null || id === undefined || typeof id !== 'number') {
      throw new Error('id cannot be null or undefined and it must be of type number.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'v1/directory/groups/{id}';
  requestUrl = requestUrl.replace('{id}', encodeURIComponent(id.toString()));

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'DELETE';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 204 && statusCode !== 403 && statusCode !== 404 && statusCode !== 500) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 204) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = {
            required: false,
            serializedName: 'parsedResponse',
            type: {
              name: 'Object'
            }
          };
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets a paged list of entity links
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {number} [options.childEntityID] Gets or sets the child entity
 * identifier.
 *
 * @param {number} [options.childDrawerID] Gets or sets the child drawer
 * identifier.
 *
 * @param {number} [options.childType] Gets or sets the type of the child.
 *
 * @param {number} [options.acl] Gets or sets the access control list.
 *
 * @param {number} [options.entityID] Gets or sets the entity identifier.
 *
 * @param {number} [options.drawerID] Gets or sets the drawer identifier.
 *
 * @param {string} [options.name] Gets or sets the name.
 *
 * @param {number} [options.creatorUserID] Gets or sets the creator user
 * identifier.
 *
 * @param {number} [options.modifierUserID] Gets or sets the modifier user
 * identifier.
 *
 * @param {date} [options.minInsertionTime] Gets or sets the minimum insertion
 * time.
 *
 * @param {date} [options.maxInsertionTime] Gets or sets the maximum insertion
 * time.
 *
 * @param {date} [options.minModificationTime] Gets or sets the minimum
 * modification time.
 *
 * @param {date} [options.maxModificationTime] Gets or sets the maximum
 * modification time.
 *
 * @param {number} [options.page] Gets or sets the page number.
 *
 * @param {number} [options.pageSize] Gets or sets the size of the page.
 *
 * @param {string} [options.sortOrder] Gets or sets the order. Possible values
 * include: 'Unspecified', 'Ascending', 'Descending'
 *
 * @param {string} [options.sortBy] Gets or sets the column to order by.
 * Possible values include: 'PageNumber', 'ID', 'Type', 'InsertionTime',
 * 'ModificationTime', 'CrossReferenceID', 'SubType', 'Extension', 'Name'
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {array} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getLinksByFilter(options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let childEntityID = (options && options.childEntityID !== undefined) ? options.childEntityID : undefined;
  let childDrawerID = (options && options.childDrawerID !== undefined) ? options.childDrawerID : undefined;
  let childType = (options && options.childType !== undefined) ? options.childType : undefined;
  let acl = (options && options.acl !== undefined) ? options.acl : undefined;
  let entityID = (options && options.entityID !== undefined) ? options.entityID : undefined;
  let drawerID = (options && options.drawerID !== undefined) ? options.drawerID : undefined;
  let name = (options && options.name !== undefined) ? options.name : undefined;
  let creatorUserID = (options && options.creatorUserID !== undefined) ? options.creatorUserID : undefined;
  let modifierUserID = (options && options.modifierUserID !== undefined) ? options.modifierUserID : undefined;
  let minInsertionTime = (options && options.minInsertionTime !== undefined) ? options.minInsertionTime : undefined;
  let maxInsertionTime = (options && options.maxInsertionTime !== undefined) ? options.maxInsertionTime : undefined;
  let minModificationTime = (options && options.minModificationTime !== undefined) ? options.minModificationTime : undefined;
  let maxModificationTime = (options && options.maxModificationTime !== undefined) ? options.maxModificationTime : undefined;
  let page = (options && options.page !== undefined) ? options.page : undefined;
  let pageSize = (options && options.pageSize !== undefined) ? options.pageSize : undefined;
  let sortOrder = (options && options.sortOrder !== undefined) ? options.sortOrder : undefined;
  let sortBy = (options && options.sortBy !== undefined) ? options.sortBy : undefined;
  // Validate
  try {
    if (childEntityID !== null && childEntityID !== undefined && typeof childEntityID !== 'number') {
      throw new Error('childEntityID must be of type number.');
    }
    if (childEntityID !== null && childEntityID !== undefined) {
      if (childEntityID > 2147483647)
      {
        throw new Error('"childEntityID" should satisfy the constraint - "InclusiveMaximum": 2147483647');
      }
      if (childEntityID < 1)
      {
        throw new Error('"childEntityID" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
    if (childDrawerID !== null && childDrawerID !== undefined && typeof childDrawerID !== 'number') {
      throw new Error('childDrawerID must be of type number.');
    }
    if (childDrawerID !== null && childDrawerID !== undefined) {
      if (childDrawerID > 2147483647)
      {
        throw new Error('"childDrawerID" should satisfy the constraint - "InclusiveMaximum": 2147483647');
      }
      if (childDrawerID < 1)
      {
        throw new Error('"childDrawerID" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
    if (childType !== null && childType !== undefined && typeof childType !== 'number') {
      throw new Error('childType must be of type number.');
    }
    if (childType !== null && childType !== undefined) {
      if (childType > 2147483647)
      {
        throw new Error('"childType" should satisfy the constraint - "InclusiveMaximum": 2147483647');
      }
      if (childType < 1)
      {
        throw new Error('"childType" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
    if (acl !== null && acl !== undefined && typeof acl !== 'number') {
      throw new Error('acl must be of type number.');
    }
    if (entityID !== null && entityID !== undefined && typeof entityID !== 'number') {
      throw new Error('entityID must be of type number.');
    }
    if (entityID !== null && entityID !== undefined) {
      if (entityID > 2147483647)
      {
        throw new Error('"entityID" should satisfy the constraint - "InclusiveMaximum": 2147483647');
      }
      if (entityID < 1)
      {
        throw new Error('"entityID" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
    if (drawerID !== null && drawerID !== undefined && typeof drawerID !== 'number') {
      throw new Error('drawerID must be of type number.');
    }
    if (drawerID !== null && drawerID !== undefined) {
      if (drawerID > 2147483647)
      {
        throw new Error('"drawerID" should satisfy the constraint - "InclusiveMaximum": 2147483647');
      }
      if (drawerID < 1)
      {
        throw new Error('"drawerID" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
    if (name !== null && name !== undefined && typeof name.valueOf() !== 'string') {
      throw new Error('name must be of type string.');
    }
    if (name !== null && name !== undefined) {
      if (name.length > 255)
      {
        throw new Error('"name" should satisfy the constraint - "MaxLength": 255');
      }
      if (name.length < 0)
      {
        throw new Error('"name" should satisfy the constraint - "MinLength": 0');
      }
    }
    if (creatorUserID !== null && creatorUserID !== undefined && typeof creatorUserID !== 'number') {
      throw new Error('creatorUserID must be of type number.');
    }
    if (creatorUserID !== null && creatorUserID !== undefined) {
      if (creatorUserID > 2147483647)
      {
        throw new Error('"creatorUserID" should satisfy the constraint - "InclusiveMaximum": 2147483647');
      }
      if (creatorUserID < 1)
      {
        throw new Error('"creatorUserID" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
    if (modifierUserID !== null && modifierUserID !== undefined && typeof modifierUserID !== 'number') {
      throw new Error('modifierUserID must be of type number.');
    }
    if (modifierUserID !== null && modifierUserID !== undefined) {
      if (modifierUserID > 2147483647)
      {
        throw new Error('"modifierUserID" should satisfy the constraint - "InclusiveMaximum": 2147483647');
      }
      if (modifierUserID < 1)
      {
        throw new Error('"modifierUserID" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
    if (minInsertionTime && !(minInsertionTime instanceof Date ||
        (typeof minInsertionTime.valueOf() === 'string' && !isNaN(Date.parse(minInsertionTime))))) {
          throw new Error('minInsertionTime must be of type date.');
        }
    if (maxInsertionTime && !(maxInsertionTime instanceof Date ||
        (typeof maxInsertionTime.valueOf() === 'string' && !isNaN(Date.parse(maxInsertionTime))))) {
          throw new Error('maxInsertionTime must be of type date.');
        }
    if (minModificationTime && !(minModificationTime instanceof Date ||
        (typeof minModificationTime.valueOf() === 'string' && !isNaN(Date.parse(minModificationTime))))) {
          throw new Error('minModificationTime must be of type date.');
        }
    if (maxModificationTime && !(maxModificationTime instanceof Date ||
        (typeof maxModificationTime.valueOf() === 'string' && !isNaN(Date.parse(maxModificationTime))))) {
          throw new Error('maxModificationTime must be of type date.');
        }
    if (page !== null && page !== undefined && typeof page !== 'number') {
      throw new Error('page must be of type number.');
    }
    if (page !== null && page !== undefined) {
      if (page > 2147483647)
      {
        throw new Error('"page" should satisfy the constraint - "InclusiveMaximum": 2147483647');
      }
      if (page < 1)
      {
        throw new Error('"page" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
    if (pageSize !== null && pageSize !== undefined && typeof pageSize !== 'number') {
      throw new Error('pageSize must be of type number.');
    }
    if (pageSize !== null && pageSize !== undefined) {
      if (pageSize > 1000)
      {
        throw new Error('"pageSize" should satisfy the constraint - "InclusiveMaximum": 1000');
      }
      if (pageSize < 1)
      {
        throw new Error('"pageSize" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
    if (sortOrder !== null && sortOrder !== undefined && typeof sortOrder.valueOf() !== 'string') {
      throw new Error('sortOrder must be of type string.');
    }
    if (sortBy !== null && sortBy !== undefined && typeof sortBy.valueOf() !== 'string') {
      throw new Error('sortBy must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'v1/content/links';
  let queryParameters = [];
  if (childEntityID !== null && childEntityID !== undefined) {
    queryParameters.push('childEntityID=' + encodeURIComponent(childEntityID.toString()));
  }
  if (childDrawerID !== null && childDrawerID !== undefined) {
    queryParameters.push('childDrawerID=' + encodeURIComponent(childDrawerID.toString()));
  }
  if (childType !== null && childType !== undefined) {
    queryParameters.push('childType=' + encodeURIComponent(childType.toString()));
  }
  if (acl !== null && acl !== undefined) {
    queryParameters.push('acl=' + encodeURIComponent(acl.toString()));
  }
  if (entityID !== null && entityID !== undefined) {
    queryParameters.push('entityID=' + encodeURIComponent(entityID.toString()));
  }
  if (drawerID !== null && drawerID !== undefined) {
    queryParameters.push('drawerID=' + encodeURIComponent(drawerID.toString()));
  }
  if (name !== null && name !== undefined) {
    queryParameters.push('name=' + encodeURIComponent(name));
  }
  if (creatorUserID !== null && creatorUserID !== undefined) {
    queryParameters.push('creatorUserID=' + encodeURIComponent(creatorUserID.toString()));
  }
  if (modifierUserID !== null && modifierUserID !== undefined) {
    queryParameters.push('modifierUserID=' + encodeURIComponent(modifierUserID.toString()));
  }
  if (minInsertionTime !== null && minInsertionTime !== undefined) {
    queryParameters.push('minInsertionTime=' + encodeURIComponent(client.serializeObject(minInsertionTime)));
  }
  if (maxInsertionTime !== null && maxInsertionTime !== undefined) {
    queryParameters.push('maxInsertionTime=' + encodeURIComponent(client.serializeObject(maxInsertionTime)));
  }
  if (minModificationTime !== null && minModificationTime !== undefined) {
    queryParameters.push('minModificationTime=' + encodeURIComponent(client.serializeObject(minModificationTime)));
  }
  if (maxModificationTime !== null && maxModificationTime !== undefined) {
    queryParameters.push('maxModificationTime=' + encodeURIComponent(client.serializeObject(maxModificationTime)));
  }
  if (page !== null && page !== undefined) {
    queryParameters.push('page=' + encodeURIComponent(page.toString()));
  }
  if (pageSize !== null && pageSize !== undefined) {
    queryParameters.push('pageSize=' + encodeURIComponent(pageSize.toString()));
  }
  if (sortOrder !== null && sortOrder !== undefined) {
    queryParameters.push('sortOrder=' + encodeURIComponent(sortOrder));
  }
  if (sortBy !== null && sortBy !== undefined) {
    queryParameters.push('sortBy=' + encodeURIComponent(sortBy));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = {
            required: false,
            serializedName: 'parsedResponse',
            type: {
              name: 'Sequence',
              element: {
                  required: false,
                  serializedName: 'EntityLinkModelElementType',
                  type: {
                    name: 'Composite',
                    className: 'EntityLinkModel'
                  }
              }
            }
          };
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets a link based on its unique identifier.
 *
 * @param {number} drawer The drawer identifier.
 *
 * @param {number} id The link identifier.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link EntityLinkModel} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getLinkById(drawer, id, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (drawer === null || drawer === undefined || typeof drawer !== 'number') {
      throw new Error('drawer cannot be null or undefined and it must be of type number.');
    }
    if (id === null || id === undefined || typeof id !== 'number') {
      throw new Error('id cannot be null or undefined and it must be of type number.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'v1/content/links/{drawer}/{id}';
  requestUrl = requestUrl.replace('{drawer}', encodeURIComponent(drawer.toString()));
  requestUrl = requestUrl.replace('{id}', encodeURIComponent(id.toString()));

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200 && statusCode !== 403 && statusCode !== 404) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['EntityLinkModel']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Updates a specified link.
 *
 * @param {number} drawer The drawer identifier.
 *
 * @param {number} id The link identifier.
 *
 * @param {object} model The model.
 *
 * @param {string} [model.virtualName] Gets or sets the name of the virtual.
 *
 * @param {number} [model.classProperty] Gets or sets the class.
 *
 * @param {string} [model.name] Gets or sets the name.
 *
 * @param {number} [model.acl] Gets or sets the acl.
 *
 * @param {number} [model.pageNumber] Gets or sets the page number.
 *
 * @param {string} [model.state] Gets or sets the state. Possible values
 * include: 'Undefined', 'MaxStates', 'Reserved', 'UserDefined', 'Dynamic',
 * 'Static', 'New', 'CheckedOut', 'Internal', 'Statres5', 'Linked', 'Statres4',
 * 'Statres3', 'Statres2', 'Statres1', 'Locked', 'OnServerCache',
 * 'OnClientCache', 'Fetching', 'Dynres4', 'Dynres3', 'Dynres2', 'Dynres1',
 * 'User1', 'User2', 'User3', 'User4', 'User5', 'User6', 'User7', 'User8',
 * 'User9', 'User10', 'User11', 'User12', 'User13', 'User14', 'User15',
 * 'User16'
 *
 * @param {string} [model.note] Gets or sets the note.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _updateLink(drawer, id, model, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (drawer === null || drawer === undefined || typeof drawer !== 'number') {
      throw new Error('drawer cannot be null or undefined and it must be of type number.');
    }
    if (id === null || id === undefined || typeof id !== 'number') {
      throw new Error('id cannot be null or undefined and it must be of type number.');
    }
    if (model === null || model === undefined) {
      throw new Error('model cannot be null or undefined.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'v1/content/links/{drawer}/{id}';
  requestUrl = requestUrl.replace('{drawer}', encodeURIComponent(drawer.toString()));
  requestUrl = requestUrl.replace('{id}', encodeURIComponent(id.toString()));

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'PUT';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (model !== null && model !== undefined) {
      let requestModelMapper = new client.models['UpdateEntityLinkRequestModel']().mapper();
      requestModel = client.serialize(requestModelMapper, model, 'model');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(model, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 204 && statusCode !== 403 && statusCode !== 404) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 204) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = {
            required: false,
            serializedName: 'parsedResponse',
            type: {
              name: 'Object'
            }
          };
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Deletes a specified link.
 *
 * @param {number} drawer The drawer identifier.
 *
 * @param {number} id The link identifier.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _deleteLink(drawer, id, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (drawer === null || drawer === undefined || typeof drawer !== 'number') {
      throw new Error('drawer cannot be null or undefined and it must be of type number.');
    }
    if (id === null || id === undefined || typeof id !== 'number') {
      throw new Error('id cannot be null or undefined and it must be of type number.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'v1/content/links/{drawer}/{id}';
  requestUrl = requestUrl.replace('{drawer}', encodeURIComponent(drawer.toString()));
  requestUrl = requestUrl.replace('{id}', encodeURIComponent(id.toString()));

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'DELETE';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 204 && statusCode !== 403 && statusCode !== 404) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 204) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = {
            required: false,
            serializedName: 'parsedResponse',
            type: {
              name: 'Object'
            }
          };
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Creates a new link.
 *
 * @param {number} drawer The drawer identifier.
 *
 * @param {object} model The link model.
 *
 * @param {number} [model.classProperty] Gets or sets the class.
 *
 * @param {string} model.name Gets or sets the name.
 *
 * @param {number} [model.acl] Gets or sets the acl.
 *
 * @param {number} [model.pageNumber] Gets or sets the page number.
 *
 * @param {string} [model.note] Gets or sets the note.
 *
 * @param {number} [model.childDrawerID] Gets or sets the child drawer
 * identifier.
 *
 * @param {number} [model.childEntityID] Gets or sets the child entity
 * identifier.
 *
 * @param {number} [model.childType] Gets or sets the type of the child.
 *
 * @param {number} [model.entityID] Gets or sets the entity identifier.
 *
 * @param {string} [model.virtualName] Gets or sets the name of the virtual.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link EntityLinkModel} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _createLink(drawer, model, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (drawer === null || drawer === undefined || typeof drawer !== 'number') {
      throw new Error('drawer cannot be null or undefined and it must be of type number.');
    }
    if (model === null || model === undefined) {
      throw new Error('model cannot be null or undefined.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'v1/content/links/{drawer}';
  requestUrl = requestUrl.replace('{drawer}', encodeURIComponent(drawer.toString()));

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (model !== null && model !== undefined) {
      let requestModelMapper = new client.models['InsertEntityLinkRequestModel']().mapper();
      requestModel = client.serialize(requestModelMapper, model, 'model');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(model, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 201 && statusCode !== 403 && statusCode !== 404 && statusCode !== 409) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 201) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['EntityLinkModel']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets a lock for a single entity based on its unique identifier.
 *
 * @param {number} drawer The drawer identifier.
 *
 * @param {number} id The entity identifier.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link LockModel} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getLocksByFilter(drawer, id, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (drawer === null || drawer === undefined || typeof drawer !== 'number') {
      throw new Error('drawer cannot be null or undefined and it must be of type number.');
    }
    if (id === null || id === undefined || typeof id !== 'number') {
      throw new Error('id cannot be null or undefined and it must be of type number.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'v1/content/entities/{drawer}/{id}/locks';
  requestUrl = requestUrl.replace('{drawer}', encodeURIComponent(drawer.toString()));
  requestUrl = requestUrl.replace('{id}', encodeURIComponent(id.toString()));

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200 && statusCode !== 404) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['LockModel']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Inserts or updates lock on a specified entity.
 *
 * @param {number} drawer The drawer identifier.
 *
 * @param {number} id The entity identifier.
 *
 * @param {object} model The lock model.
 *
 * @param {number} [model.expirationDuration] Gets or sets the expiration
 * duration of the lock in minutes.
 *
 * @param {number} [model.acl] Gets or sets the access control level
 * permissions of the lock.
 *
 * @param {string} [model.applicationName] Gets or sets the name of the
 * application creating the lock.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _createOrUpdateLock(drawer, id, model, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (drawer === null || drawer === undefined || typeof drawer !== 'number') {
      throw new Error('drawer cannot be null or undefined and it must be of type number.');
    }
    if (id === null || id === undefined || typeof id !== 'number') {
      throw new Error('id cannot be null or undefined and it must be of type number.');
    }
    if (model === null || model === undefined) {
      throw new Error('model cannot be null or undefined.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'v1/content/entities/{drawer}/{id}/locks';
  requestUrl = requestUrl.replace('{drawer}', encodeURIComponent(drawer.toString()));
  requestUrl = requestUrl.replace('{id}', encodeURIComponent(id.toString()));

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'PUT';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (model !== null && model !== undefined) {
      let requestModelMapper = new client.models['UpdateLockRequestModel']().mapper();
      requestModel = client.serialize(requestModelMapper, model, 'model');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(model, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 201 && statusCode !== 403 && statusCode !== 404) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 201) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = {
            required: false,
            serializedName: 'parsedResponse',
            type: {
              name: 'Object'
            }
          };
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Deletes a lock on a specified entity.
 *
 * @param {number} drawer The drawer identifier.
 *
 * @param {number} id The entity identifier.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _deleteLock(drawer, id, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (drawer === null || drawer === undefined || typeof drawer !== 'number') {
      throw new Error('drawer cannot be null or undefined and it must be of type number.');
    }
    if (id === null || id === undefined || typeof id !== 'number') {
      throw new Error('id cannot be null or undefined and it must be of type number.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'v1/content/entities/{drawer}/{id}/locks';
  requestUrl = requestUrl.replace('{drawer}', encodeURIComponent(drawer.toString()));
  requestUrl = requestUrl.replace('{id}', encodeURIComponent(id.toString()));

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'DELETE';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 204 && statusCode !== 403 && statusCode !== 404) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 204) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = {
            required: false,
            serializedName: 'parsedResponse',
            type: {
              name: 'Object'
            }
          };
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets a paged list of notes.
 *
 * @param {number} drawerID Gets or sets the drawer identifier.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {number} [options.entityID] Gets or sets the entity identifier.
 *
 * @param {string} [options.name] Gets or sets the name.
 *
 * @param {number} [options.creatorUserID] Gets or sets the creator user
 * identifier.
 *
 * @param {number} [options.modifierUserID] Gets or sets the modifier user
 * identifier.
 *
 * @param {date} [options.minCreationTime] Gets or sets the minimum creation
 * time.
 *
 * @param {date} [options.maxCreationTime] Gets or sets the maximum creation
 * time.
 *
 * @param {date} [options.minModificationTime] Gets or sets the minimum
 * modification time.
 *
 * @param {date} [options.maxModificationTime] Gets or sets the maximum
 * modification time.
 *
 * @param {number} [options.parentID] Gets or sets the parent note identifier.
 *
 * @param {number} [options.page] Gets or sets the page number.
 *
 * @param {number} [options.pageSize] Gets or sets the size of the page.
 *
 * @param {string} [options.sortOrder] Gets or sets the order. Possible values
 * include: 'Unspecified', 'Ascending', 'Descending'
 *
 * @param {string} [options.sortBy] Gets or sets the column to order by.
 * Possible values include: 'ID', 'EntityID', 'Name', 'CreationTime',
 * 'ModificationTime'
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {array} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getNotesByFilter(drawerID, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let entityID = (options && options.entityID !== undefined) ? options.entityID : undefined;
  let name = (options && options.name !== undefined) ? options.name : undefined;
  let creatorUserID = (options && options.creatorUserID !== undefined) ? options.creatorUserID : undefined;
  let modifierUserID = (options && options.modifierUserID !== undefined) ? options.modifierUserID : undefined;
  let minCreationTime = (options && options.minCreationTime !== undefined) ? options.minCreationTime : undefined;
  let maxCreationTime = (options && options.maxCreationTime !== undefined) ? options.maxCreationTime : undefined;
  let minModificationTime = (options && options.minModificationTime !== undefined) ? options.minModificationTime : undefined;
  let maxModificationTime = (options && options.maxModificationTime !== undefined) ? options.maxModificationTime : undefined;
  let parentID = (options && options.parentID !== undefined) ? options.parentID : undefined;
  let page = (options && options.page !== undefined) ? options.page : undefined;
  let pageSize = (options && options.pageSize !== undefined) ? options.pageSize : undefined;
  let sortOrder = (options && options.sortOrder !== undefined) ? options.sortOrder : undefined;
  let sortBy = (options && options.sortBy !== undefined) ? options.sortBy : undefined;
  // Validate
  try {
    if (drawerID === null || drawerID === undefined || typeof drawerID !== 'number') {
      throw new Error('drawerID cannot be null or undefined and it must be of type number.');
    }
    if (drawerID !== null && drawerID !== undefined) {
      if (drawerID > 2147483647)
      {
        throw new Error('"drawerID" should satisfy the constraint - "InclusiveMaximum": 2147483647');
      }
      if (drawerID < 1)
      {
        throw new Error('"drawerID" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
    if (entityID !== null && entityID !== undefined && typeof entityID !== 'number') {
      throw new Error('entityID must be of type number.');
    }
    if (entityID !== null && entityID !== undefined) {
      if (entityID > 2147483647)
      {
        throw new Error('"entityID" should satisfy the constraint - "InclusiveMaximum": 2147483647');
      }
      if (entityID < 1)
      {
        throw new Error('"entityID" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
    if (name !== null && name !== undefined && typeof name.valueOf() !== 'string') {
      throw new Error('name must be of type string.');
    }
    if (name !== null && name !== undefined) {
      if (name.length > 255)
      {
        throw new Error('"name" should satisfy the constraint - "MaxLength": 255');
      }
      if (name.length < 0)
      {
        throw new Error('"name" should satisfy the constraint - "MinLength": 0');
      }
    }
    if (creatorUserID !== null && creatorUserID !== undefined && typeof creatorUserID !== 'number') {
      throw new Error('creatorUserID must be of type number.');
    }
    if (creatorUserID !== null && creatorUserID !== undefined) {
      if (creatorUserID > 2147483647)
      {
        throw new Error('"creatorUserID" should satisfy the constraint - "InclusiveMaximum": 2147483647');
      }
      if (creatorUserID < 1)
      {
        throw new Error('"creatorUserID" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
    if (modifierUserID !== null && modifierUserID !== undefined && typeof modifierUserID !== 'number') {
      throw new Error('modifierUserID must be of type number.');
    }
    if (modifierUserID !== null && modifierUserID !== undefined) {
      if (modifierUserID > 2147483647)
      {
        throw new Error('"modifierUserID" should satisfy the constraint - "InclusiveMaximum": 2147483647');
      }
      if (modifierUserID < 1)
      {
        throw new Error('"modifierUserID" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
    if (minCreationTime && !(minCreationTime instanceof Date ||
        (typeof minCreationTime.valueOf() === 'string' && !isNaN(Date.parse(minCreationTime))))) {
          throw new Error('minCreationTime must be of type date.');
        }
    if (maxCreationTime && !(maxCreationTime instanceof Date ||
        (typeof maxCreationTime.valueOf() === 'string' && !isNaN(Date.parse(maxCreationTime))))) {
          throw new Error('maxCreationTime must be of type date.');
        }
    if (minModificationTime && !(minModificationTime instanceof Date ||
        (typeof minModificationTime.valueOf() === 'string' && !isNaN(Date.parse(minModificationTime))))) {
          throw new Error('minModificationTime must be of type date.');
        }
    if (maxModificationTime && !(maxModificationTime instanceof Date ||
        (typeof maxModificationTime.valueOf() === 'string' && !isNaN(Date.parse(maxModificationTime))))) {
          throw new Error('maxModificationTime must be of type date.');
        }
    if (parentID !== null && parentID !== undefined && typeof parentID !== 'number') {
      throw new Error('parentID must be of type number.');
    }
    if (parentID !== null && parentID !== undefined) {
      if (parentID > 2147483647)
      {
        throw new Error('"parentID" should satisfy the constraint - "InclusiveMaximum": 2147483647');
      }
      if (parentID < 1)
      {
        throw new Error('"parentID" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
    if (page !== null && page !== undefined && typeof page !== 'number') {
      throw new Error('page must be of type number.');
    }
    if (page !== null && page !== undefined) {
      if (page > 2147483647)
      {
        throw new Error('"page" should satisfy the constraint - "InclusiveMaximum": 2147483647');
      }
      if (page < 1)
      {
        throw new Error('"page" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
    if (pageSize !== null && pageSize !== undefined && typeof pageSize !== 'number') {
      throw new Error('pageSize must be of type number.');
    }
    if (pageSize !== null && pageSize !== undefined) {
      if (pageSize > 1000)
      {
        throw new Error('"pageSize" should satisfy the constraint - "InclusiveMaximum": 1000');
      }
      if (pageSize < 1)
      {
        throw new Error('"pageSize" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
    if (sortOrder !== null && sortOrder !== undefined && typeof sortOrder.valueOf() !== 'string') {
      throw new Error('sortOrder must be of type string.');
    }
    if (sortBy !== null && sortBy !== undefined && typeof sortBy.valueOf() !== 'string') {
      throw new Error('sortBy must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'v1/content/notes';
  let queryParameters = [];
  queryParameters.push('drawerID=' + encodeURIComponent(drawerID.toString()));
  if (entityID !== null && entityID !== undefined) {
    queryParameters.push('entityID=' + encodeURIComponent(entityID.toString()));
  }
  if (name !== null && name !== undefined) {
    queryParameters.push('name=' + encodeURIComponent(name));
  }
  if (creatorUserID !== null && creatorUserID !== undefined) {
    queryParameters.push('creatorUserID=' + encodeURIComponent(creatorUserID.toString()));
  }
  if (modifierUserID !== null && modifierUserID !== undefined) {
    queryParameters.push('modifierUserID=' + encodeURIComponent(modifierUserID.toString()));
  }
  if (minCreationTime !== null && minCreationTime !== undefined) {
    queryParameters.push('minCreationTime=' + encodeURIComponent(client.serializeObject(minCreationTime)));
  }
  if (maxCreationTime !== null && maxCreationTime !== undefined) {
    queryParameters.push('maxCreationTime=' + encodeURIComponent(client.serializeObject(maxCreationTime)));
  }
  if (minModificationTime !== null && minModificationTime !== undefined) {
    queryParameters.push('minModificationTime=' + encodeURIComponent(client.serializeObject(minModificationTime)));
  }
  if (maxModificationTime !== null && maxModificationTime !== undefined) {
    queryParameters.push('maxModificationTime=' + encodeURIComponent(client.serializeObject(maxModificationTime)));
  }
  if (parentID !== null && parentID !== undefined) {
    queryParameters.push('parentID=' + encodeURIComponent(parentID.toString()));
  }
  if (page !== null && page !== undefined) {
    queryParameters.push('page=' + encodeURIComponent(page.toString()));
  }
  if (pageSize !== null && pageSize !== undefined) {
    queryParameters.push('pageSize=' + encodeURIComponent(pageSize.toString()));
  }
  if (sortOrder !== null && sortOrder !== undefined) {
    queryParameters.push('sortOrder=' + encodeURIComponent(sortOrder));
  }
  if (sortBy !== null && sortBy !== undefined) {
    queryParameters.push('sortBy=' + encodeURIComponent(sortBy));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = {
            required: false,
            serializedName: 'parsedResponse',
            type: {
              name: 'Sequence',
              element: {
                  required: false,
                  serializedName: 'NoteModelElementType',
                  type: {
                    name: 'Composite',
                    className: 'NoteModel'
                  }
              }
            }
          };
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets a note by its unique identifier.
 *
 * @param {number} drawer The drawer identifier.
 *
 * @param {number} id The note identifier.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link NoteModel} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getNoteById(drawer, id, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (drawer === null || drawer === undefined || typeof drawer !== 'number') {
      throw new Error('drawer cannot be null or undefined and it must be of type number.');
    }
    if (id === null || id === undefined || typeof id !== 'number') {
      throw new Error('id cannot be null or undefined and it must be of type number.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'v1/content/notes/{drawer}/{id}';
  requestUrl = requestUrl.replace('{drawer}', encodeURIComponent(drawer.toString()));
  requestUrl = requestUrl.replace('{id}', encodeURIComponent(id.toString()));

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200 && statusCode !== 403 && statusCode !== 404) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['NoteModel']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Updates a specified note.
 *
 * @param {number} drawer The drawer identifier.
 *
 * @param {number} id The note identifier.
 *
 * @param {object} model The note model.
 *
 * @param {number} [model.acl] Gets or sets the acl.
 *
 * @param {string} [model.name] Gets or sets the name.
 *
 * @param {string} [model.note] Gets or sets the note.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _updateNote(drawer, id, model, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (drawer === null || drawer === undefined || typeof drawer !== 'number') {
      throw new Error('drawer cannot be null or undefined and it must be of type number.');
    }
    if (id === null || id === undefined || typeof id !== 'number') {
      throw new Error('id cannot be null or undefined and it must be of type number.');
    }
    if (model === null || model === undefined) {
      throw new Error('model cannot be null or undefined.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'v1/content/notes/{drawer}/{id}';
  requestUrl = requestUrl.replace('{drawer}', encodeURIComponent(drawer.toString()));
  requestUrl = requestUrl.replace('{id}', encodeURIComponent(id.toString()));

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'PUT';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (model !== null && model !== undefined) {
      let requestModelMapper = new client.models['NoteBase']().mapper();
      requestModel = client.serialize(requestModelMapper, model, 'model');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(model, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 204 && statusCode !== 403 && statusCode !== 404) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 204) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = {
            required: false,
            serializedName: 'parsedResponse',
            type: {
              name: 'Object'
            }
          };
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Deletes a specified note.
 *
 * @param {number} drawer The drawer identifier.
 *
 * @param {number} id The note identifier.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _deleteNote(drawer, id, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (drawer === null || drawer === undefined || typeof drawer !== 'number') {
      throw new Error('drawer cannot be null or undefined and it must be of type number.');
    }
    if (id === null || id === undefined || typeof id !== 'number') {
      throw new Error('id cannot be null or undefined and it must be of type number.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'v1/content/notes/{drawer}/{id}';
  requestUrl = requestUrl.replace('{drawer}', encodeURIComponent(drawer.toString()));
  requestUrl = requestUrl.replace('{id}', encodeURIComponent(id.toString()));

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'DELETE';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 204 && statusCode !== 403 && statusCode !== 404) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 204) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = {
            required: false,
            serializedName: 'parsedResponse',
            type: {
              name: 'Object'
            }
          };
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Creates a new note.
 *
 * @param {number} drawer The drawer identifier.
 *
 * @param {object} model The note model.
 *
 * @param {number} [model.acl] Gets or sets the acl.
 *
 * @param {number} [model.entityID] Gets or sets the entity identifier.
 *
 * @param {string} model.name Gets or sets the name.
 *
 * @param {string} model.note Gets or sets the note.
 *
 * @param {number} [model.parentID] Gets or sets the parent identifier.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link NoteModel} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _createNote(drawer, model, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (drawer === null || drawer === undefined || typeof drawer !== 'number') {
      throw new Error('drawer cannot be null or undefined and it must be of type number.');
    }
    if (model === null || model === undefined) {
      throw new Error('model cannot be null or undefined.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'v1/content/notes/{drawer}';
  requestUrl = requestUrl.replace('{drawer}', encodeURIComponent(drawer.toString()));

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (model !== null && model !== undefined) {
      let requestModelMapper = new client.models['InsertNoteRequestModel']().mapper();
      requestModel = client.serialize(requestModelMapper, model, 'model');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(model, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 201 && statusCode !== 403 && statusCode !== 404) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 201) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['NoteModel']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets a paged list of queue assignments.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {number} [options.queueID] Gets or sets the unique queue identifier.
 *
 * @param {number} [options.userID] Gets or sets the user identifier.
 *
 * @param {number} [options.groupID] Gets or sets the group identifier.
 *
 * @param {string} [options.type] Gets or sets the queue assignment type.
 * Possible values include: 'Unspecified', 'Primary', 'Secondary'
 *
 * @param {number} [options.order] Gets or sets the sort order.
 *
 * @param {string} [options.taskSortColumn] Gets or sets the task sort column.
 * Possible values include: 'TaskID', 'QueueID', 'DrawerID', 'AddressID',
 * 'ObjectID', 'ObjectType', 'State', 'Priority', 'Description', 'Message1',
 * 'Message2', 'Message3', 'Message4', 'Message5', 'OwnerUserID',
 * 'OwnerGroupID', 'EffectiveUserID', 'EffectiveGroupID', 'PreviousQueueID',
 * 'NextQueueID', 'InsertionTime', 'ResolutionTime', 'TaskFileAttachment',
 * 'ReservedInt1', 'ReservedString1'
 *
 * @param {string} [options.state] Gets or sets the state. Possible values
 * include: 'Unspecified', 'Inactive', 'Active'
 *
 * @param {string} [options.fetchType] Gets or sets the type of the fetch.
 * Possible values include: 'Unspecified', 'Manual', 'Push'
 *
 * @param {number} [options.page] Gets or sets the page number.
 *
 * @param {number} [options.pageSize] Gets or sets the size of the page.
 *
 * @param {string} [options.sortOrder] Gets or sets the order. Possible values
 * include: 'Unspecified', 'Ascending', 'Descending'
 *
 * @param {string} [options.sortBy] Gets or sets the column to order by.
 * Possible values include: 'QueueID', 'UserID', 'GroupID', 'Type', 'State',
 * 'Order', 'FetchType'
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {array} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getQueueAssignmentsByFilter(options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let queueID = (options && options.queueID !== undefined) ? options.queueID : undefined;
  let userID = (options && options.userID !== undefined) ? options.userID : undefined;
  let groupID = (options && options.groupID !== undefined) ? options.groupID : undefined;
  let type = (options && options.type !== undefined) ? options.type : undefined;
  let order = (options && options.order !== undefined) ? options.order : undefined;
  let taskSortColumn = (options && options.taskSortColumn !== undefined) ? options.taskSortColumn : undefined;
  let state = (options && options.state !== undefined) ? options.state : undefined;
  let fetchType = (options && options.fetchType !== undefined) ? options.fetchType : undefined;
  let page = (options && options.page !== undefined) ? options.page : undefined;
  let pageSize = (options && options.pageSize !== undefined) ? options.pageSize : undefined;
  let sortOrder = (options && options.sortOrder !== undefined) ? options.sortOrder : undefined;
  let sortBy = (options && options.sortBy !== undefined) ? options.sortBy : undefined;
  // Validate
  try {
    if (queueID !== null && queueID !== undefined && typeof queueID !== 'number') {
      throw new Error('queueID must be of type number.');
    }
    if (queueID !== null && queueID !== undefined) {
      if (queueID > 2147483647)
      {
        throw new Error('"queueID" should satisfy the constraint - "InclusiveMaximum": 2147483647');
      }
      if (queueID < 1)
      {
        throw new Error('"queueID" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
    if (userID !== null && userID !== undefined && typeof userID !== 'number') {
      throw new Error('userID must be of type number.');
    }
    if (userID !== null && userID !== undefined) {
      if (userID > 2147483647)
      {
        throw new Error('"userID" should satisfy the constraint - "InclusiveMaximum": 2147483647');
      }
      if (userID < 1)
      {
        throw new Error('"userID" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
    if (groupID !== null && groupID !== undefined && typeof groupID !== 'number') {
      throw new Error('groupID must be of type number.');
    }
    if (groupID !== null && groupID !== undefined) {
      if (groupID > 2147483647)
      {
        throw new Error('"groupID" should satisfy the constraint - "InclusiveMaximum": 2147483647');
      }
      if (groupID < 1)
      {
        throw new Error('"groupID" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
    if (type !== null && type !== undefined && typeof type.valueOf() !== 'string') {
      throw new Error('type must be of type string.');
    }
    if (order !== null && order !== undefined && typeof order !== 'number') {
      throw new Error('order must be of type number.');
    }
    if (order !== null && order !== undefined) {
      if (order > 2147483647)
      {
        throw new Error('"order" should satisfy the constraint - "InclusiveMaximum": 2147483647');
      }
      if (order < 1)
      {
        throw new Error('"order" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
    if (taskSortColumn !== null && taskSortColumn !== undefined && typeof taskSortColumn.valueOf() !== 'string') {
      throw new Error('taskSortColumn must be of type string.');
    }
    if (state !== null && state !== undefined && typeof state.valueOf() !== 'string') {
      throw new Error('state must be of type string.');
    }
    if (fetchType !== null && fetchType !== undefined && typeof fetchType.valueOf() !== 'string') {
      throw new Error('fetchType must be of type string.');
    }
    if (page !== null && page !== undefined && typeof page !== 'number') {
      throw new Error('page must be of type number.');
    }
    if (page !== null && page !== undefined) {
      if (page > 2147483647)
      {
        throw new Error('"page" should satisfy the constraint - "InclusiveMaximum": 2147483647');
      }
      if (page < 1)
      {
        throw new Error('"page" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
    if (pageSize !== null && pageSize !== undefined && typeof pageSize !== 'number') {
      throw new Error('pageSize must be of type number.');
    }
    if (pageSize !== null && pageSize !== undefined) {
      if (pageSize > 1000)
      {
        throw new Error('"pageSize" should satisfy the constraint - "InclusiveMaximum": 1000');
      }
      if (pageSize < 1)
      {
        throw new Error('"pageSize" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
    if (sortOrder !== null && sortOrder !== undefined && typeof sortOrder.valueOf() !== 'string') {
      throw new Error('sortOrder must be of type string.');
    }
    if (sortBy !== null && sortBy !== undefined && typeof sortBy.valueOf() !== 'string') {
      throw new Error('sortBy must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'v1/workflow/assignments';
  let queryParameters = [];
  if (queueID !== null && queueID !== undefined) {
    queryParameters.push('queueID=' + encodeURIComponent(queueID.toString()));
  }
  if (userID !== null && userID !== undefined) {
    queryParameters.push('userID=' + encodeURIComponent(userID.toString()));
  }
  if (groupID !== null && groupID !== undefined) {
    queryParameters.push('groupID=' + encodeURIComponent(groupID.toString()));
  }
  if (type !== null && type !== undefined) {
    queryParameters.push('type=' + encodeURIComponent(type));
  }
  if (order !== null && order !== undefined) {
    queryParameters.push('order=' + encodeURIComponent(order.toString()));
  }
  if (taskSortColumn !== null && taskSortColumn !== undefined) {
    queryParameters.push('taskSortColumn=' + encodeURIComponent(taskSortColumn));
  }
  if (state !== null && state !== undefined) {
    queryParameters.push('state=' + encodeURIComponent(state));
  }
  if (fetchType !== null && fetchType !== undefined) {
    queryParameters.push('fetchType=' + encodeURIComponent(fetchType));
  }
  if (page !== null && page !== undefined) {
    queryParameters.push('page=' + encodeURIComponent(page.toString()));
  }
  if (pageSize !== null && pageSize !== undefined) {
    queryParameters.push('pageSize=' + encodeURIComponent(pageSize.toString()));
  }
  if (sortOrder !== null && sortOrder !== undefined) {
    queryParameters.push('sortOrder=' + encodeURIComponent(sortOrder));
  }
  if (sortBy !== null && sortBy !== undefined) {
    queryParameters.push('sortBy=' + encodeURIComponent(sortBy));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200 && statusCode !== 403) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = {
            required: false,
            serializedName: 'parsedResponse',
            type: {
              name: 'Sequence',
              element: {
                  required: false,
                  serializedName: 'QueueAssignmentModelElementType',
                  type: {
                    name: 'Composite',
                    className: 'QueueAssignmentModel'
                  }
              }
            }
          };
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Updates the specified queue assignment.
 *
 * @param {object} model The model.
 *
 * @param {number} [model.queueID] Gets or sets the unique queue identifier.
 *
 * @param {number} [model.userID] Gets or sets the user identifier.
 *
 * @param {number} [model.groupID] Gets or sets the group identifier.
 *
 * @param {string} [model.type] Gets or sets the queue assignment type.
 * Possible values include: 'Unspecified', 'Primary', 'Secondary'
 *
 * @param {number} [model.order] Gets or sets the sort order.
 *
 * @param {string} [model.taskSortColumn] Gets or sets the task sort column.
 * Possible values include: 'TaskID', 'QueueID', 'DrawerID', 'AddressID',
 * 'ObjectID', 'ObjectType', 'State', 'Priority', 'Description', 'Message1',
 * 'Message2', 'Message3', 'Message4', 'Message5', 'OwnerUserID',
 * 'OwnerGroupID', 'EffectiveUserID', 'EffectiveGroupID', 'PreviousQueueID',
 * 'NextQueueID', 'InsertionTime', 'ResolutionTime', 'TaskFileAttachment',
 * 'ReservedInt1', 'ReservedString1'
 *
 * @param {string} [model.state] Gets or sets the state. Possible values
 * include: 'Unspecified', 'Inactive', 'Active'
 *
 * @param {string} [model.fetchType] Gets or sets the type of the fetch.
 * Possible values include: 'Unspecified', 'Manual', 'Push'
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _updateQueueAssignemnt(model, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (model === null || model === undefined) {
      throw new Error('model cannot be null or undefined.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'v1/workflow/assignments';

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'PUT';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (model !== null && model !== undefined) {
      let requestModelMapper = new client.models['QueueAssignmentModel']().mapper();
      requestModel = client.serialize(requestModelMapper, model, 'model');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(model, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 204 && statusCode !== 403 && statusCode !== 404) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 204) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = {
            required: false,
            serializedName: 'parsedResponse',
            type: {
              name: 'Object'
            }
          };
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Creates a new queue assignment.
 *
 * @param {object} model The model.
 *
 * @param {number} [model.queueID] Gets or sets the unique queue identifier.
 *
 * @param {number} [model.userID] Gets or sets the user identifier.
 *
 * @param {string} [model.type] Gets or sets the queue assignment type.
 * Possible values include: 'Unspecified', 'Primary', 'Secondary'
 *
 * @param {number} [model.order] Gets or sets the sort order.
 *
 * @param {string} [model.taskSortColumn] Gets or sets the task sort column.
 * Possible values include: 'TaskID', 'QueueID', 'DrawerID', 'AddressID',
 * 'ObjectID', 'ObjectType', 'State', 'Priority', 'Description', 'Message1',
 * 'Message2', 'Message3', 'Message4', 'Message5', 'OwnerUserID',
 * 'OwnerGroupID', 'EffectiveUserID', 'EffectiveGroupID', 'PreviousQueueID',
 * 'NextQueueID', 'InsertionTime', 'ResolutionTime', 'TaskFileAttachment',
 * 'ReservedInt1', 'ReservedString1'
 *
 * @param {string} [model.fetchType] Gets or sets the type of the fetch.
 * Possible values include: 'Unspecified', 'Manual', 'Push'
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link QueueAssignmentModel} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _createQueueAssignment(model, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (model === null || model === undefined) {
      throw new Error('model cannot be null or undefined.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'v1/workflow/assignments';

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (model !== null && model !== undefined) {
      let requestModelMapper = new client.models['InsertQueueAssignmentRequestModel']().mapper();
      requestModel = client.serialize(requestModelMapper, model, 'model');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(model, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 201 && statusCode !== 403 && statusCode !== 404 && statusCode !== 409) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 201) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['QueueAssignmentModel']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets a single queue assignment based on user and queue identifiers.
 *
 * @param {number} userId The user identifier.
 *
 * @param {number} queueId The queue identifier.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link QueueAssignmentModel} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getQueueAssignmentsById(userId, queueId, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (userId === null || userId === undefined || typeof userId !== 'number') {
      throw new Error('userId cannot be null or undefined and it must be of type number.');
    }
    if (queueId === null || queueId === undefined || typeof queueId !== 'number') {
      throw new Error('queueId cannot be null or undefined and it must be of type number.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'v1/workflow/assignments/users/{userId}/queues/{queueId}';
  requestUrl = requestUrl.replace('{userId}', encodeURIComponent(userId.toString()));
  requestUrl = requestUrl.replace('{queueId}', encodeURIComponent(queueId.toString()));

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200 && statusCode !== 403 && statusCode !== 404) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['QueueAssignmentModel']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Deletes the specified queue assignment.
 *
 * @param {number} userId The user identifier.
 *
 * @param {number} queueId The queue identifier.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _deleteQueueAssignment(userId, queueId, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (userId === null || userId === undefined || typeof userId !== 'number') {
      throw new Error('userId cannot be null or undefined and it must be of type number.');
    }
    if (queueId === null || queueId === undefined || typeof queueId !== 'number') {
      throw new Error('queueId cannot be null or undefined and it must be of type number.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'v1/workflow/assignments/users/{userId}/queues/{queueId}';
  requestUrl = requestUrl.replace('{userId}', encodeURIComponent(userId.toString()));
  requestUrl = requestUrl.replace('{queueId}', encodeURIComponent(queueId.toString()));

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'DELETE';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 204 && statusCode !== 403 && statusCode !== 404) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 204) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = {
            required: false,
            serializedName: 'parsedResponse',
            type: {
              name: 'Object'
            }
          };
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets a paged list of queues.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {number} [options.iD] Gets or sets the queue identifier.
 *
 * @param {string} [options.name] Gets or sets the name.
 *
 * @param {string} [options.alias] Gets or sets the alias.
 *
 * @param {string} [options.type] Gets or sets the type. Possible values
 * include: 'Inbound', 'Outbound', 'Access', 'Any', 'Shared', 'Public',
 * 'Recycle', 'Fax', 'Print', 'Scan', 'Ocr', 'Workflow', 'Schedule', 'System',
 * 'Other', 'CdoInfostore', 'CdoFolder'
 *
 * @param {number} [options.access] Gets or sets the access level.
 *
 * @param {boolean} [options.bypassSecurity] Gets or sets a value indicating
 * whether to bypass security checks.
 *
 * @param {number} [options.page] Gets or sets the page number.
 *
 * @param {number} [options.pageSize] Gets or sets the size of the page.
 *
 * @param {string} [options.sortOrder] Gets or sets the order. Possible values
 * include: 'Unspecified', 'Ascending', 'Descending'
 *
 * @param {string} [options.sortBy] Gets or sets the column to order by.
 * Possible values include: 'ID', 'Type', 'Name', 'Alias'
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {array} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getQueuesByFilter(options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let iD = (options && options.iD !== undefined) ? options.iD : undefined;
  let name = (options && options.name !== undefined) ? options.name : undefined;
  let alias = (options && options.alias !== undefined) ? options.alias : undefined;
  let type = (options && options.type !== undefined) ? options.type : undefined;
  let access = (options && options.access !== undefined) ? options.access : undefined;
  let bypassSecurity = (options && options.bypassSecurity !== undefined) ? options.bypassSecurity : undefined;
  let page = (options && options.page !== undefined) ? options.page : undefined;
  let pageSize = (options && options.pageSize !== undefined) ? options.pageSize : undefined;
  let sortOrder = (options && options.sortOrder !== undefined) ? options.sortOrder : undefined;
  let sortBy = (options && options.sortBy !== undefined) ? options.sortBy : undefined;
  // Validate
  try {
    if (iD !== null && iD !== undefined && typeof iD !== 'number') {
      throw new Error('iD must be of type number.');
    }
    if (iD !== null && iD !== undefined) {
      if (iD > 2147483647)
      {
        throw new Error('"iD" should satisfy the constraint - "InclusiveMaximum": 2147483647');
      }
      if (iD < 1)
      {
        throw new Error('"iD" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
    if (name !== null && name !== undefined && typeof name.valueOf() !== 'string') {
      throw new Error('name must be of type string.');
    }
    if (name !== null && name !== undefined) {
      if (name.length > 255)
      {
        throw new Error('"name" should satisfy the constraint - "MaxLength": 255');
      }
      if (name.length < 0)
      {
        throw new Error('"name" should satisfy the constraint - "MinLength": 0');
      }
    }
    if (alias !== null && alias !== undefined && typeof alias.valueOf() !== 'string') {
      throw new Error('alias must be of type string.');
    }
    if (alias !== null && alias !== undefined) {
      if (alias.length > 255)
      {
        throw new Error('"alias" should satisfy the constraint - "MaxLength": 255');
      }
      if (alias.length < 0)
      {
        throw new Error('"alias" should satisfy the constraint - "MinLength": 0');
      }
    }
    if (type !== null && type !== undefined && typeof type.valueOf() !== 'string') {
      throw new Error('type must be of type string.');
    }
    if (access !== null && access !== undefined && typeof access !== 'number') {
      throw new Error('access must be of type number.');
    }
    if (bypassSecurity !== null && bypassSecurity !== undefined && typeof bypassSecurity !== 'boolean') {
      throw new Error('bypassSecurity must be of type boolean.');
    }
    if (page !== null && page !== undefined && typeof page !== 'number') {
      throw new Error('page must be of type number.');
    }
    if (page !== null && page !== undefined) {
      if (page > 2147483647)
      {
        throw new Error('"page" should satisfy the constraint - "InclusiveMaximum": 2147483647');
      }
      if (page < 1)
      {
        throw new Error('"page" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
    if (pageSize !== null && pageSize !== undefined && typeof pageSize !== 'number') {
      throw new Error('pageSize must be of type number.');
    }
    if (pageSize !== null && pageSize !== undefined) {
      if (pageSize > 1000)
      {
        throw new Error('"pageSize" should satisfy the constraint - "InclusiveMaximum": 1000');
      }
      if (pageSize < 1)
      {
        throw new Error('"pageSize" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
    if (sortOrder !== null && sortOrder !== undefined && typeof sortOrder.valueOf() !== 'string') {
      throw new Error('sortOrder must be of type string.');
    }
    if (sortBy !== null && sortBy !== undefined && typeof sortBy.valueOf() !== 'string') {
      throw new Error('sortBy must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'v1/workflow/queues';
  let queryParameters = [];
  if (iD !== null && iD !== undefined) {
    queryParameters.push('iD=' + encodeURIComponent(iD.toString()));
  }
  if (name !== null && name !== undefined) {
    queryParameters.push('name=' + encodeURIComponent(name));
  }
  if (alias !== null && alias !== undefined) {
    queryParameters.push('alias=' + encodeURIComponent(alias));
  }
  if (type !== null && type !== undefined) {
    queryParameters.push('type=' + encodeURIComponent(type));
  }
  if (access !== null && access !== undefined) {
    queryParameters.push('access=' + encodeURIComponent(access.toString()));
  }
  if (bypassSecurity !== null && bypassSecurity !== undefined) {
    queryParameters.push('bypassSecurity=' + encodeURIComponent(bypassSecurity.toString()));
  }
  if (page !== null && page !== undefined) {
    queryParameters.push('page=' + encodeURIComponent(page.toString()));
  }
  if (pageSize !== null && pageSize !== undefined) {
    queryParameters.push('pageSize=' + encodeURIComponent(pageSize.toString()));
  }
  if (sortOrder !== null && sortOrder !== undefined) {
    queryParameters.push('sortOrder=' + encodeURIComponent(sortOrder));
  }
  if (sortBy !== null && sortBy !== undefined) {
    queryParameters.push('sortBy=' + encodeURIComponent(sortBy));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = {
            required: false,
            serializedName: 'parsedResponse',
            type: {
              name: 'Sequence',
              element: {
                  required: false,
                  serializedName: 'QueueModelElementType',
                  type: {
                    name: 'Composite',
                    className: 'QueueModel'
                  }
              }
            }
          };
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Creates a new queue.
 *
 * @param {object} model The queue model.
 *
 * @param {string} model.name Gets or sets the name.
 *
 * @param {string} model.alias Gets or sets the alias.
 *
 * @param {string} model.type Gets or sets the type. Possible values include:
 * 'Inbound', 'Outbound', 'Access', 'Any', 'Shared', 'Public', 'Recycle',
 * 'Fax', 'Print', 'Scan', 'Ocr', 'Workflow', 'Schedule', 'System', 'Other',
 * 'CdoInfostore', 'CdoFolder'
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link QueueModel} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _createQueue(model, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (model === null || model === undefined) {
      throw new Error('model cannot be null or undefined.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'v1/workflow/queues';

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (model !== null && model !== undefined) {
      let requestModelMapper = new client.models['InsertQueueRequestModel']().mapper();
      requestModel = client.serialize(requestModelMapper, model, 'model');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(model, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 201 && statusCode !== 403) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 201) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['QueueModel']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets a single queue by its unique identifier.
 *
 * @param {number} id The queue identifier.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link QueueModel} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getQueueById(id, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (id === null || id === undefined || typeof id !== 'number') {
      throw new Error('id cannot be null or undefined and it must be of type number.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'v1/workflow/queues/{id}';
  requestUrl = requestUrl.replace('{id}', encodeURIComponent(id.toString()));

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200 && statusCode !== 404) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['QueueModel']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Updates a specified queue.
 *
 * @param {number} id The unique queue identifier.
 *
 * @param {object} model The queue model.
 *
 * @param {string} [model.name] Gets or sets the name.
 *
 * @param {string} [model.alias] Gets or sets the alias.
 *
 * @param {string} [model.state] Gets or sets the state. Possible values
 * include: 'Inactive', 'Active'
 *
 * @param {string} [model.type] Gets or sets the type. Possible values include:
 * 'Inbound', 'Outbound', 'Access', 'Any', 'Shared', 'Public', 'Recycle',
 * 'Fax', 'Print', 'Scan', 'Ocr', 'Workflow', 'Schedule', 'System', 'Other',
 * 'CdoInfostore', 'CdoFolder'
 *
 * @param {string} [model.category] Gets or sets the category.
 *
 * @param {string} [model.description] Gets or sets the description.
 *
 * @param {number} [model.reservedInt1] Gets or sets the reserved integer 1.
 *
 * @param {number} [model.reservedInt2] Gets or sets the reserved integer 2.
 *
 * @param {string} [model.reservedString1] Gets or sets the reserved string 1.
 *
 * @param {string} [model.reservedString2] Gets or sets the reserved string 2.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _updateQueue(id, model, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (id === null || id === undefined || typeof id !== 'number') {
      throw new Error('id cannot be null or undefined and it must be of type number.');
    }
    if (model === null || model === undefined) {
      throw new Error('model cannot be null or undefined.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'v1/workflow/queues/{id}';
  requestUrl = requestUrl.replace('{id}', encodeURIComponent(id.toString()));

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'PUT';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (model !== null && model !== undefined) {
      let requestModelMapper = new client.models['QueueBase']().mapper();
      requestModel = client.serialize(requestModelMapper, model, 'model');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(model, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200 && statusCode !== 403 && statusCode !== 404) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = {
            required: false,
            serializedName: 'parsedResponse',
            type: {
              name: 'Object'
            }
          };
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Deletes a specified queue.
 *
 * @param {number} id The queue identifier.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _deleteQueue(id, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (id === null || id === undefined || typeof id !== 'number') {
      throw new Error('id cannot be null or undefined and it must be of type number.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'v1/workflow/queues/{id}';
  requestUrl = requestUrl.replace('{id}', encodeURIComponent(id.toString()));

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'DELETE';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 204 && statusCode !== 403 && statusCode !== 404) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 204) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = {
            required: false,
            serializedName: 'parsedResponse',
            type: {
              name: 'Object'
            }
          };
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets a single queue by its name.
 *
 * @param {string} name The queue name.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link QueueModel} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getQueueByName(name, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'v1/workflow/queues/{name}';
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200 && statusCode !== 404) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['QueueModel']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets a paged list of tasks.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {number} [options.lastTaskID] Gets or sets the last task identifier.
 *
 * @param {number} [options.iD] Gets or sets the entity identifier.
 *
 * @param {number} [options.type] Gets or sets the type of the entity.
 *
 * @param {number} [options.queueID] Gets or sets the queue identifier.
 *
 * @param {number} [options.queueType] Gets or sets the type of the queue.
 *
 * @param {number} [options.drawerID] Gets or sets the drawer identifier.
 *
 * @param {string} [options.description] Gets or sets the task description.
 *
 * @param {number} [options.taskID] Gets or sets the task identifier.
 *
 * @param {number} [options.page] Gets or sets the page number.
 *
 * @param {number} [options.pageSize] Gets or sets the size of the page.
 *
 * @param {string} [options.sortOrder] Gets or sets the order. Possible values
 * include: 'Unspecified', 'Ascending', 'Descending'
 *
 * @param {string} [options.sortBy] Gets or sets the column to order by.
 * Possible values include: 'TaskID', 'QueueID', 'ObjectID', 'Priority',
 * 'Description', 'InsertionTime', 'ResolutionTime', 'ReservedInt1'
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {array} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getTasksByFilter(options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let lastTaskID = (options && options.lastTaskID !== undefined) ? options.lastTaskID : undefined;
  let iD = (options && options.iD !== undefined) ? options.iD : undefined;
  let type = (options && options.type !== undefined) ? options.type : undefined;
  let queueID = (options && options.queueID !== undefined) ? options.queueID : undefined;
  let queueType = (options && options.queueType !== undefined) ? options.queueType : undefined;
  let drawerID = (options && options.drawerID !== undefined) ? options.drawerID : undefined;
  let description = (options && options.description !== undefined) ? options.description : undefined;
  let taskID = (options && options.taskID !== undefined) ? options.taskID : undefined;
  let page = (options && options.page !== undefined) ? options.page : undefined;
  let pageSize = (options && options.pageSize !== undefined) ? options.pageSize : undefined;
  let sortOrder = (options && options.sortOrder !== undefined) ? options.sortOrder : undefined;
  let sortBy = (options && options.sortBy !== undefined) ? options.sortBy : undefined;
  // Validate
  try {
    if (lastTaskID !== null && lastTaskID !== undefined && typeof lastTaskID !== 'number') {
      throw new Error('lastTaskID must be of type number.');
    }
    if (lastTaskID !== null && lastTaskID !== undefined) {
      if (lastTaskID > 2147483647)
      {
        throw new Error('"lastTaskID" should satisfy the constraint - "InclusiveMaximum": 2147483647');
      }
      if (lastTaskID < 0)
      {
        throw new Error('"lastTaskID" should satisfy the constraint - "InclusiveMinimum": 0');
      }
    }
    if (iD !== null && iD !== undefined && typeof iD !== 'number') {
      throw new Error('iD must be of type number.');
    }
    if (iD !== null && iD !== undefined) {
      if (iD > 2147483647)
      {
        throw new Error('"iD" should satisfy the constraint - "InclusiveMaximum": 2147483647');
      }
      if (iD < 1)
      {
        throw new Error('"iD" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
    if (type !== null && type !== undefined && typeof type !== 'number') {
      throw new Error('type must be of type number.');
    }
    if (queueID !== null && queueID !== undefined && typeof queueID !== 'number') {
      throw new Error('queueID must be of type number.');
    }
    if (queueType !== null && queueType !== undefined && typeof queueType !== 'number') {
      throw new Error('queueType must be of type number.');
    }
    if (queueType !== null && queueType !== undefined) {
      if (queueType > 2147483647)
      {
        throw new Error('"queueType" should satisfy the constraint - "InclusiveMaximum": 2147483647');
      }
      if (queueType < 1)
      {
        throw new Error('"queueType" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
    if (drawerID !== null && drawerID !== undefined && typeof drawerID !== 'number') {
      throw new Error('drawerID must be of type number.');
    }
    if (drawerID !== null && drawerID !== undefined) {
      if (drawerID > 2147483647)
      {
        throw new Error('"drawerID" should satisfy the constraint - "InclusiveMaximum": 2147483647');
      }
      if (drawerID < 1)
      {
        throw new Error('"drawerID" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
    if (description !== null && description !== undefined && typeof description.valueOf() !== 'string') {
      throw new Error('description must be of type string.');
    }
    if (description !== null && description !== undefined) {
      if (description.length > 255)
      {
        throw new Error('"description" should satisfy the constraint - "MaxLength": 255');
      }
      if (description.length < 0)
      {
        throw new Error('"description" should satisfy the constraint - "MinLength": 0');
      }
    }
    if (taskID !== null && taskID !== undefined && typeof taskID !== 'number') {
      throw new Error('taskID must be of type number.');
    }
    if (page !== null && page !== undefined && typeof page !== 'number') {
      throw new Error('page must be of type number.');
    }
    if (page !== null && page !== undefined) {
      if (page > 2147483647)
      {
        throw new Error('"page" should satisfy the constraint - "InclusiveMaximum": 2147483647');
      }
      if (page < 1)
      {
        throw new Error('"page" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
    if (pageSize !== null && pageSize !== undefined && typeof pageSize !== 'number') {
      throw new Error('pageSize must be of type number.');
    }
    if (pageSize !== null && pageSize !== undefined) {
      if (pageSize > 1000)
      {
        throw new Error('"pageSize" should satisfy the constraint - "InclusiveMaximum": 1000');
      }
      if (pageSize < 1)
      {
        throw new Error('"pageSize" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
    if (sortOrder !== null && sortOrder !== undefined && typeof sortOrder.valueOf() !== 'string') {
      throw new Error('sortOrder must be of type string.');
    }
    if (sortBy !== null && sortBy !== undefined && typeof sortBy.valueOf() !== 'string') {
      throw new Error('sortBy must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'v1/workflow/tasks';
  let queryParameters = [];
  if (lastTaskID !== null && lastTaskID !== undefined) {
    queryParameters.push('lastTaskID=' + encodeURIComponent(lastTaskID.toString()));
  }
  if (iD !== null && iD !== undefined) {
    queryParameters.push('iD=' + encodeURIComponent(iD.toString()));
  }
  if (type !== null && type !== undefined) {
    queryParameters.push('type=' + encodeURIComponent(type.toString()));
  }
  if (queueID !== null && queueID !== undefined) {
    queryParameters.push('queueID=' + encodeURIComponent(queueID.toString()));
  }
  if (queueType !== null && queueType !== undefined) {
    queryParameters.push('queueType=' + encodeURIComponent(queueType.toString()));
  }
  if (drawerID !== null && drawerID !== undefined) {
    queryParameters.push('drawerID=' + encodeURIComponent(drawerID.toString()));
  }
  if (description !== null && description !== undefined) {
    queryParameters.push('description=' + encodeURIComponent(description));
  }
  if (taskID !== null && taskID !== undefined) {
    queryParameters.push('taskID=' + encodeURIComponent(taskID.toString()));
  }
  if (page !== null && page !== undefined) {
    queryParameters.push('page=' + encodeURIComponent(page.toString()));
  }
  if (pageSize !== null && pageSize !== undefined) {
    queryParameters.push('pageSize=' + encodeURIComponent(pageSize.toString()));
  }
  if (sortOrder !== null && sortOrder !== undefined) {
    queryParameters.push('sortOrder=' + encodeURIComponent(sortOrder));
  }
  if (sortBy !== null && sortBy !== undefined) {
    queryParameters.push('sortBy=' + encodeURIComponent(sortBy));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = {
            required: false,
            serializedName: 'parsedResponse',
            type: {
              name: 'Sequence',
              element: {
                  required: false,
                  serializedName: 'TaskModelElementType',
                  type: {
                    name: 'Composite',
                    className: 'TaskModel'
                  }
              }
            }
          };
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Creates a new task.
 *
 * @param {object} model The task model.
 *
 * @param {number} [model.queueID] Gets or sets the queue identifier.
 *
 * @param {number} [model.drawerID] Gets or sets the drawer identifier.
 *
 * @param {number} [model.objectID] Gets or sets the object identifier
 * (entity).
 *
 * @param {number} [model.objectType] Gets or sets the type of the object
 * (entity).
 *
 * @param {number} [model.prevQueueID] Gets or sets the previous queue
 * identifier.
 *
 * @param {number} [model.nextQueueID] Gets or sets the next queue identifier.
 *
 * @param {number} [model.addressID] Gets or sets the address identifier.
 *
 * @param {string} [model.description] Gets or sets the description of the
 * task.
 *
 * @param {string} [model.message1] Gets or sets message 1.
 *
 * @param {string} [model.message2] Gets or sets message 2.
 *
 * @param {string} [model.message3] Gets or sets message 3.
 *
 * @param {string} [model.message4] Gets or sets message 4.
 *
 * @param {string} [model.message5] Gets or sets message5.
 *
 * @param {string} [model.message6] Gets or sets message 6.
 *
 * @param {string} [model.message7] Gets or sets message 7.
 *
 * @param {string} [model.message8] Gets or sets message 8.
 *
 * @param {string} [model.message9] Gets or sets message 9.
 *
 * @param {string} [model.message10] Gets or sets message 10.
 *
 * @param {string} [model.message11] Gets or sets message 11.
 *
 * @param {string} [model.message12] Gets or sets message 12.
 *
 * @param {string} [model.message13] Gets or sets message 13.
 *
 * @param {string} [model.message14] Gets or sets message 14.
 *
 * @param {string} [model.message15] Gets or sets message 15.
 *
 * @param {string} [model.message16] Gets or sets message 16.
 *
 * @param {number} [model.state] Gets or sets the task state.
 *
 * @param {number} [model.priority] Gets or sets the task priority.
 *
 * @param {date} [model.resolutionTime] Gets or sets the task resolution time.
 *
 * @param {string} [model.taskFileAttachment] Gets or sets the task file
 * attachment name.
 *
 * @param {number} [model.reservedInt1] Gets or sets reserved integer 1.
 *
 * @param {string} [model.reservedString1] Gets or sets reserved string 1.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _createTask(model, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (model === null || model === undefined) {
      throw new Error('model cannot be null or undefined.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'v1/workflow/tasks';

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (model !== null && model !== undefined) {
      let requestModelMapper = new client.models['InsertTaskRequestModel']().mapper();
      requestModel = client.serialize(requestModelMapper, model, 'model');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(model, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 201 && statusCode !== 403 && statusCode !== 404 && statusCode !== 409) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 201) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = {
            required: false,
            serializedName: 'parsedResponse',
            type: {
              name: 'Object'
            }
          };
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets a single task based on its unique identifier.
 *
 * @param {number} id The identifier.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link TaskModel} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getTaskById(id, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (id === null || id === undefined || typeof id !== 'number') {
      throw new Error('id cannot be null or undefined and it must be of type number.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'v1/workflow/tasks/{id}';
  requestUrl = requestUrl.replace('{id}', encodeURIComponent(id.toString()));

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200 && statusCode !== 404) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['TaskModel']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Updates a specified task.
 *
 * @param {number} id The identifier.
 *
 * @param {object} model The task model.
 *
 * @param {number} [model.addressID] Gets or sets the address identifier.
 *
 * @param {string} [model.description] Gets or sets the description of the
 * task.
 *
 * @param {string} [model.message1] Gets or sets message 1.
 *
 * @param {string} [model.message2] Gets or sets message 2.
 *
 * @param {string} [model.message3] Gets or sets message 3.
 *
 * @param {string} [model.message4] Gets or sets message 4.
 *
 * @param {string} [model.message5] Gets or sets message5.
 *
 * @param {string} [model.message6] Gets or sets message 6.
 *
 * @param {string} [model.message7] Gets or sets message 7.
 *
 * @param {string} [model.message8] Gets or sets message 8.
 *
 * @param {string} [model.message9] Gets or sets message 9.
 *
 * @param {string} [model.message10] Gets or sets message 10.
 *
 * @param {string} [model.message11] Gets or sets message 11.
 *
 * @param {string} [model.message12] Gets or sets message 12.
 *
 * @param {string} [model.message13] Gets or sets message 13.
 *
 * @param {string} [model.message14] Gets or sets message 14.
 *
 * @param {string} [model.message15] Gets or sets message 15.
 *
 * @param {string} [model.message16] Gets or sets message 16.
 *
 * @param {number} [model.state] Gets or sets the task state.
 *
 * @param {number} [model.priority] Gets or sets the task priority.
 *
 * @param {date} [model.resolutionTime] Gets or sets the task resolution time.
 *
 * @param {string} [model.taskFileAttachment] Gets or sets the task file
 * attachment name.
 *
 * @param {number} [model.reservedInt1] Gets or sets reserved integer 1.
 *
 * @param {string} [model.reservedString1] Gets or sets reserved string 1.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _updateTask(id, model, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (id === null || id === undefined || typeof id !== 'number') {
      throw new Error('id cannot be null or undefined and it must be of type number.');
    }
    if (model === null || model === undefined) {
      throw new Error('model cannot be null or undefined.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'v1/workflow/tasks/{id}';
  requestUrl = requestUrl.replace('{id}', encodeURIComponent(id.toString()));

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'PUT';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (model !== null && model !== undefined) {
      let requestModelMapper = new client.models['TaskBase']().mapper();
      requestModel = client.serialize(requestModelMapper, model, 'model');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(model, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 204 && statusCode !== 403 && statusCode !== 404) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 204) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = {
            required: false,
            serializedName: 'parsedResponse',
            type: {
              name: 'Object'
            }
          };
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Deletes a specified task.
 *
 * @param {number} id The identifier.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _deleteTask(id, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (id === null || id === undefined || typeof id !== 'number') {
      throw new Error('id cannot be null or undefined and it must be of type number.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'v1/workflow/tasks/{id}';
  requestUrl = requestUrl.replace('{id}', encodeURIComponent(id.toString()));

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'DELETE';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 204 && statusCode !== 403 && statusCode !== 404) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 204) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = {
            required: false,
            serializedName: 'parsedResponse',
            type: {
              name: 'Object'
            }
          };
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets a single task based on user predefined queue assignment
 * criteria.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link TaskModel} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _fetchTaskFromQueueAssignment(options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'v1/workflow/tasks/fetch';

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200 && statusCode !== 404) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['TaskModel']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets a paged list of users.Gets a paged list of users.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {number} [options.iD] Gets or sets the identifier.
 *
 * @param {number} [options.primaryGroupID] Gets or sets the primary group
 * identifier.
 *
 * @param {number} [options.groupID] Gets or sets the group identifier.
 *
 * @param {string} [options.groupName] Gets or sets the name of the group.
 *
 * @param {string} [options.username] Gets or sets the username.
 *
 * @param {string} [options.type] Gets or sets the type. Possible values
 * include: 'ImageDesk', 'PublishDesk', 'FaxDesk', 'CaptureDesk',
 * 'RecognitionDesk', 'PortalUser', 'AdminDesk', 'WorkflowDesk', 'Benchmark',
 * 'ReportDesk', 'ColdDesk', 'PortalDesk', 'WorkflowArchitect', 'DocumentDesk',
 * 'Poweruser'
 *
 * @param {string} [options.state] Gets or sets the state. Possible values
 * include: 'Active', 'Inactive'
 *
 * @param {string} [options.fullName] Gets or sets the full name.
 *
 * @param {number} [options.page] Gets or sets the page number.
 *
 * @param {number} [options.pageSize] Gets or sets the size of the page.
 *
 * @param {string} [options.sortOrder] Gets or sets the order. Possible values
 * include: 'Unspecified', 'Ascending', 'Descending'
 *
 * @param {string} [options.sortBy] Gets or sets the column to order by.
 * Possible values include: 'ID', 'PrimaryGroupID', 'Username', 'UserFullName',
 * 'Type', 'State'
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {array} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getUsersByFilter(options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let iD = (options && options.iD !== undefined) ? options.iD : undefined;
  let primaryGroupID = (options && options.primaryGroupID !== undefined) ? options.primaryGroupID : undefined;
  let groupID = (options && options.groupID !== undefined) ? options.groupID : undefined;
  let groupName = (options && options.groupName !== undefined) ? options.groupName : undefined;
  let username = (options && options.username !== undefined) ? options.username : undefined;
  let type = (options && options.type !== undefined) ? options.type : undefined;
  let state = (options && options.state !== undefined) ? options.state : undefined;
  let fullName = (options && options.fullName !== undefined) ? options.fullName : undefined;
  let page = (options && options.page !== undefined) ? options.page : undefined;
  let pageSize = (options && options.pageSize !== undefined) ? options.pageSize : undefined;
  let sortOrder = (options && options.sortOrder !== undefined) ? options.sortOrder : undefined;
  let sortBy = (options && options.sortBy !== undefined) ? options.sortBy : undefined;
  // Validate
  try {
    if (iD !== null && iD !== undefined && typeof iD !== 'number') {
      throw new Error('iD must be of type number.');
    }
    if (primaryGroupID !== null && primaryGroupID !== undefined && typeof primaryGroupID !== 'number') {
      throw new Error('primaryGroupID must be of type number.');
    }
    if (groupID !== null && groupID !== undefined && typeof groupID !== 'number') {
      throw new Error('groupID must be of type number.');
    }
    if (groupName !== null && groupName !== undefined && typeof groupName.valueOf() !== 'string') {
      throw new Error('groupName must be of type string.');
    }
    if (username !== null && username !== undefined && typeof username.valueOf() !== 'string') {
      throw new Error('username must be of type string.');
    }
    if (type !== null && type !== undefined && typeof type.valueOf() !== 'string') {
      throw new Error('type must be of type string.');
    }
    if (state !== null && state !== undefined && typeof state.valueOf() !== 'string') {
      throw new Error('state must be of type string.');
    }
    if (fullName !== null && fullName !== undefined && typeof fullName.valueOf() !== 'string') {
      throw new Error('fullName must be of type string.');
    }
    if (page !== null && page !== undefined && typeof page !== 'number') {
      throw new Error('page must be of type number.');
    }
    if (page !== null && page !== undefined) {
      if (page > 2147483647)
      {
        throw new Error('"page" should satisfy the constraint - "InclusiveMaximum": 2147483647');
      }
      if (page < 1)
      {
        throw new Error('"page" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
    if (pageSize !== null && pageSize !== undefined && typeof pageSize !== 'number') {
      throw new Error('pageSize must be of type number.');
    }
    if (pageSize !== null && pageSize !== undefined) {
      if (pageSize > 1000)
      {
        throw new Error('"pageSize" should satisfy the constraint - "InclusiveMaximum": 1000');
      }
      if (pageSize < 1)
      {
        throw new Error('"pageSize" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
    if (sortOrder !== null && sortOrder !== undefined && typeof sortOrder.valueOf() !== 'string') {
      throw new Error('sortOrder must be of type string.');
    }
    if (sortBy !== null && sortBy !== undefined && typeof sortBy.valueOf() !== 'string') {
      throw new Error('sortBy must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'v1/directory/users';
  let queryParameters = [];
  if (iD !== null && iD !== undefined) {
    queryParameters.push('iD=' + encodeURIComponent(iD.toString()));
  }
  if (primaryGroupID !== null && primaryGroupID !== undefined) {
    queryParameters.push('primaryGroupID=' + encodeURIComponent(primaryGroupID.toString()));
  }
  if (groupID !== null && groupID !== undefined) {
    queryParameters.push('groupID=' + encodeURIComponent(groupID.toString()));
  }
  if (groupName !== null && groupName !== undefined) {
    queryParameters.push('groupName=' + encodeURIComponent(groupName));
  }
  if (username !== null && username !== undefined) {
    queryParameters.push('username=' + encodeURIComponent(username));
  }
  if (type !== null && type !== undefined) {
    queryParameters.push('type=' + encodeURIComponent(type));
  }
  if (state !== null && state !== undefined) {
    queryParameters.push('state=' + encodeURIComponent(state));
  }
  if (fullName !== null && fullName !== undefined) {
    queryParameters.push('fullName=' + encodeURIComponent(fullName));
  }
  if (page !== null && page !== undefined) {
    queryParameters.push('page=' + encodeURIComponent(page.toString()));
  }
  if (pageSize !== null && pageSize !== undefined) {
    queryParameters.push('pageSize=' + encodeURIComponent(pageSize.toString()));
  }
  if (sortOrder !== null && sortOrder !== undefined) {
    queryParameters.push('sortOrder=' + encodeURIComponent(sortOrder));
  }
  if (sortBy !== null && sortBy !== undefined) {
    queryParameters.push('sortBy=' + encodeURIComponent(sortBy));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200 && statusCode !== 403) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = {
            required: false,
            serializedName: 'parsedResponse',
            type: {
              name: 'Sequence',
              element: {
                  required: false,
                  serializedName: 'UserModelElementType',
                  type: {
                    name: 'Composite',
                    className: 'UserModel'
                  }
              }
            }
          };
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Creates a new user.
 *
 * @param {object} model The user model.
 *
 * @param {string} model.username Gets or sets the username.
 *
 * @param {string} [model.state] Gets or sets the state. Possible values
 * include: 'Active', 'Inactive'
 *
 * @param {string} [model.type] Gets or sets the type. Possible values include:
 * 'ImageDesk', 'PublishDesk', 'FaxDesk', 'CaptureDesk', 'RecognitionDesk',
 * 'PortalUser', 'AdminDesk', 'WorkflowDesk', 'Benchmark', 'ReportDesk',
 * 'ColdDesk', 'PortalDesk', 'WorkflowArchitect', 'DocumentDesk', 'Poweruser'
 *
 * @param {string} model.fullName Gets or sets the full name.
 *
 * @param {string} model.iPAddress Gets or sets the ip address.
 *
 * @param {number} [model.entityAcl] Gets or sets the entity acl.
 *
 * @param {number} [model.attachmentAcl] Gets or sets the attachment acl.
 *
 * @param {number} [model.noteAcl] Gets or sets the note acl.
 *
 * @param {number} [model.entityFeature] Gets or sets the entity feature.
 *
 * @param {number} [model.attachmentFeature] Gets or sets the attachment
 * feature.
 *
 * @param {number} [model.noteFeature] Gets or sets the note feature.
 *
 * @param {string} [model.adminMask] Gets or sets the admin mask. Possible
 * values include: 'None', 'CabinetAdmin', 'DrawerAdmin', 'GroupAdmin',
 * 'UserAdmin', 'WorkflowAdmin', 'VersionAdmin', 'TemplateAdmin',
 * 'ApplicationAdmin'
 *
 * @param {string} [model.address] Gets or sets the address.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link UserModel} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _createUser(model, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (model === null || model === undefined) {
      throw new Error('model cannot be null or undefined.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'v1/directory/users';

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (model !== null && model !== undefined) {
      let requestModelMapper = new client.models['InsertUserRequestModel']().mapper();
      requestModel = client.serialize(requestModelMapper, model, 'model');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(model, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 201 && statusCode !== 403 && statusCode !== 409) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 201) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['UserModel']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets a single user by its unique identifier.
 *
 * @param {number} id The user identifier.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link UserModel} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getUserById(id, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (id === null || id === undefined || typeof id !== 'number') {
      throw new Error('id cannot be null or undefined and it must be of type number.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'v1/directory/users/{id}';
  requestUrl = requestUrl.replace('{id}', encodeURIComponent(id.toString()));

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200 && statusCode !== 403 && statusCode !== 404) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['UserModel']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Updates a specified user.
 *
 * @param {number} id The user identifier.
 *
 * @param {object} model The user model.
 *
 * @param {number} [model.primaryGroupID] Gets or sets the primary group
 * identifier.
 *
 * @param {string} [model.type] Gets or sets the type. Possible values include:
 * 'ImageDesk', 'PublishDesk', 'FaxDesk', 'CaptureDesk', 'RecognitionDesk',
 * 'PortalUser', 'AdminDesk', 'WorkflowDesk', 'Benchmark', 'ReportDesk',
 * 'ColdDesk', 'PortalDesk', 'WorkflowArchitect', 'DocumentDesk', 'Poweruser'
 *
 * @param {string} [model.state] Gets or sets the state. Possible values
 * include: 'Active', 'Inactive'
 *
 * @param {string} [model.fullName] Gets or sets the full name.
 *
 * @param {number} [model.objectCount] Gets or sets the object count.
 *
 * @param {string} [model.iPAddress] Gets or sets the ip address.
 *
 * @param {number} [model.entityAcl] Gets or sets the entity acl.
 *
 * @param {number} [model.attachmentAcl] Gets or sets the attachment acl.
 *
 * @param {number} [model.noteAcl] Gets or sets the note acl.
 *
 * @param {number} [model.entityFeature] Gets or sets the entity feature.
 *
 * @param {number} [model.attachmentFeature] Gets or sets the attachment
 * feature.
 *
 * @param {number} [model.noteFeature] Gets or sets the note feature.
 *
 * @param {string} [model.adminMask] Gets or sets the admin mask. Possible
 * values include: 'None', 'CabinetAdmin', 'DrawerAdmin', 'GroupAdmin',
 * 'UserAdmin', 'WorkflowAdmin', 'VersionAdmin', 'TemplateAdmin',
 * 'ApplicationAdmin'
 *
 * @param {string} [model.address] Gets or sets the address.
 *
 * @param {number} [model.reservedInt1] Gets or sets the reserved int1.
 *
 * @param {number} [model.reservedInt2] Gets or sets the reserved int2.
 *
 * @param {number} [model.reservedDouble1] Gets or sets the reserved double1.
 *
 * @param {number} [model.reservedDouble2] Gets or sets the reserved double2.
 *
 * @param {string} [model.reservedString1] Gets or sets the reserved string1.
 *
 * @param {string} [model.reservedString2] Gets or sets the reserved string2.
 *
 * @param {date} [model.userExpiration] Gets or sets the user expiration.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _updateUser(id, model, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (id === null || id === undefined || typeof id !== 'number') {
      throw new Error('id cannot be null or undefined and it must be of type number.');
    }
    if (model === null || model === undefined) {
      throw new Error('model cannot be null or undefined.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'v1/directory/users/{id}';
  requestUrl = requestUrl.replace('{id}', encodeURIComponent(id.toString()));

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'PUT';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (model !== null && model !== undefined) {
      let requestModelMapper = new client.models['UserBase']().mapper();
      requestModel = client.serialize(requestModelMapper, model, 'model');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(model, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 204 && statusCode !== 403 && statusCode !== 404) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 204) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = {
            required: false,
            serializedName: 'parsedResponse',
            type: {
              name: 'Object'
            }
          };
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Deactivates a specified user and removes all user associations.
 *
 * @param {number} id The user identifier.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _deleteUser(id, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (id === null || id === undefined || typeof id !== 'number') {
      throw new Error('id cannot be null or undefined and it must be of type number.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'v1/directory/users/{id}';
  requestUrl = requestUrl.replace('{id}', encodeURIComponent(id.toString()));

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'DELETE';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 204 && statusCode !== 403 && statusCode !== 404) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 204) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = {
            required: false,
            serializedName: 'parsedResponse',
            type: {
              name: 'Object'
            }
          };
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets a paged list of workflows.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {number} [options.applicationID] Gets or sets the application
 * identifier.
 *
 * @param {number} [options.entityType] Gets or sets the type of the entity.
 *
 * @param {string} [options.name] Gets or sets the name.
 *
 * @param {number} [options.page] Gets or sets the page number.
 *
 * @param {number} [options.pageSize] Gets or sets the size of the page.
 *
 * @param {string} [options.sortOrder] Gets or sets the order. Possible values
 * include: 'Unspecified', 'Ascending', 'Descending'
 *
 * @param {number} [options.sortBy] Gets or sets the column to order by.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {array} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getWorkflowsByFilter(options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let applicationID = (options && options.applicationID !== undefined) ? options.applicationID : undefined;
  let entityType = (options && options.entityType !== undefined) ? options.entityType : undefined;
  let name = (options && options.name !== undefined) ? options.name : undefined;
  let page = (options && options.page !== undefined) ? options.page : undefined;
  let pageSize = (options && options.pageSize !== undefined) ? options.pageSize : undefined;
  let sortOrder = (options && options.sortOrder !== undefined) ? options.sortOrder : undefined;
  let sortBy = (options && options.sortBy !== undefined) ? options.sortBy : undefined;
  // Validate
  try {
    if (applicationID !== null && applicationID !== undefined && typeof applicationID !== 'number') {
      throw new Error('applicationID must be of type number.');
    }
    if (applicationID !== null && applicationID !== undefined) {
      if (applicationID > 2147483647)
      {
        throw new Error('"applicationID" should satisfy the constraint - "InclusiveMaximum": 2147483647');
      }
      if (applicationID < 1)
      {
        throw new Error('"applicationID" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
    if (entityType !== null && entityType !== undefined && typeof entityType !== 'number') {
      throw new Error('entityType must be of type number.');
    }
    if (entityType !== null && entityType !== undefined) {
      if (entityType > 2147483647)
      {
        throw new Error('"entityType" should satisfy the constraint - "InclusiveMaximum": 2147483647');
      }
      if (entityType < 1)
      {
        throw new Error('"entityType" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
    if (name !== null && name !== undefined && typeof name.valueOf() !== 'string') {
      throw new Error('name must be of type string.');
    }
    if (name !== null && name !== undefined) {
      if (name.length > 255)
      {
        throw new Error('"name" should satisfy the constraint - "MaxLength": 255');
      }
      if (name.length < 0)
      {
        throw new Error('"name" should satisfy the constraint - "MinLength": 0');
      }
    }
    if (page !== null && page !== undefined && typeof page !== 'number') {
      throw new Error('page must be of type number.');
    }
    if (page !== null && page !== undefined) {
      if (page > 2147483647)
      {
        throw new Error('"page" should satisfy the constraint - "InclusiveMaximum": 2147483647');
      }
      if (page < 1)
      {
        throw new Error('"page" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
    if (pageSize !== null && pageSize !== undefined && typeof pageSize !== 'number') {
      throw new Error('pageSize must be of type number.');
    }
    if (pageSize !== null && pageSize !== undefined) {
      if (pageSize > 1000)
      {
        throw new Error('"pageSize" should satisfy the constraint - "InclusiveMaximum": 1000');
      }
      if (pageSize < 1)
      {
        throw new Error('"pageSize" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
    if (sortOrder !== null && sortOrder !== undefined && typeof sortOrder.valueOf() !== 'string') {
      throw new Error('sortOrder must be of type string.');
    }
    if (sortBy !== null && sortBy !== undefined && typeof sortBy !== 'number') {
      throw new Error('sortBy must be of type number.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'v1/workflow/workflows';
  let queryParameters = [];
  if (applicationID !== null && applicationID !== undefined) {
    queryParameters.push('applicationID=' + encodeURIComponent(applicationID.toString()));
  }
  if (entityType !== null && entityType !== undefined) {
    queryParameters.push('entityType=' + encodeURIComponent(entityType.toString()));
  }
  if (name !== null && name !== undefined) {
    queryParameters.push('name=' + encodeURIComponent(name));
  }
  if (page !== null && page !== undefined) {
    queryParameters.push('page=' + encodeURIComponent(page.toString()));
  }
  if (pageSize !== null && pageSize !== undefined) {
    queryParameters.push('pageSize=' + encodeURIComponent(pageSize.toString()));
  }
  if (sortOrder !== null && sortOrder !== undefined) {
    queryParameters.push('sortOrder=' + encodeURIComponent(sortOrder));
  }
  if (sortBy !== null && sortBy !== undefined) {
    queryParameters.push('sortBy=' + encodeURIComponent(sortBy.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = {
            required: false,
            serializedName: 'parsedResponse',
            type: {
              name: 'Sequence',
              element: {
                  required: false,
                  serializedName: 'WorkflowModelElementType',
                  type: {
                    name: 'Composite',
                    className: 'WorkflowModel'
                  }
              }
            }
          };
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets a single workflow based on its unique identifier.
 *
 * @param {number} id The workflow identifier.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link WorkflowModel} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getWorkflowById(id, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (id === null || id === undefined || typeof id !== 'number') {
      throw new Error('id cannot be null or undefined and it must be of type number.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'v1/workflow/workflows/{id}';
  requestUrl = requestUrl.replace('{id}', encodeURIComponent(id.toString()));

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200 && statusCode !== 404) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['WorkflowModel']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets queues for a specific workflow.
 *
 * @param {number} id The workflow identifier.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {array} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getWorkflowQueuesById(id, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (id === null || id === undefined || typeof id !== 'number') {
      throw new Error('id cannot be null or undefined and it must be of type number.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'v1/workflow/workflows/{id}/queue';
  requestUrl = requestUrl.replace('{id}', encodeURIComponent(id.toString()));

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200 && statusCode !== 404) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = {
            required: false,
            serializedName: 'parsedResponse',
            type: {
              name: 'Sequence',
              element: {
                  required: false,
                  serializedName: 'WorkflowQueueModelElementType',
                  type: {
                    name: 'Composite',
                    className: 'WorkflowQueueModel'
                  }
              }
            }
          };
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets a single entity template definition completed with all
 * profiles definitions as XML entity definition.
 *
 * @param {number} type The unique template type.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {string} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getXMLTemplateByType(type, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (type === null || type === undefined || typeof type !== 'number') {
      throw new Error('type cannot be null or undefined and it must be of type number.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'v1/template/xml/{type}';
  requestUrl = requestUrl.replace('{type}', encodeURIComponent(type.toString()));

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200 && statusCode !== 404) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = {
            required: false,
            serializedName: 'parsedResponse',
            type: {
              name: 'String'
            }
          };
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Creates a new entity template definition.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {string} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _createXMLTemplate(options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'v1/template/xml';

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 201 && statusCode !== 400 && statusCode !== 403 && statusCode !== 409) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 201) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = {
            required: false,
            serializedName: 'parsedResponse',
            type: {
              name: 'String'
            }
          };
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/** Class representing a SoftheonEnterpriseAPI. */
class SoftheonEnterpriseAPI extends ServiceClient {
  /**
   * Create a SoftheonEnterpriseAPI.
   * @param {credentials} credentials - Subscription credentials which uniquely identify client subscription.
   * @param {string} [baseUri] - The base URI of the service.
   * @param {object} [options] - The parameter options
   * @param {Array} [options.filters] - Filters to be added to the request pipeline
   * @param {object} [options.requestOptions] - Options for the underlying request object
   * {@link https://github.com/request/request#requestoptions-callback Options doc}
   * @param {boolean} [options.noRetryPolicy] - If set to true, turn off default retry policy
   */
  constructor(credentials, baseUri, options) {
    if (credentials === null || credentials === undefined) {
      throw new Error('\'credentials\' cannot be null.');
    }

    if (!options) options = {};

    super(credentials, options);

    this.baseUri = baseUri;
    if (!this.baseUri) {
      this.baseUri = 'http://localhost:54963';
    }
    this.credentials = credentials;

    let packageInfo = this.getPackageJsonInfo(__dirname);
    this.addUserAgentInfo(`${packageInfo.name}/${packageInfo.version}`);
    this.models = models;
    this._acceptTask = _acceptTask;
    this._rejectTask = _rejectTask;
    this._suspendTask = _suspendTask;
    this._routeTask = _routeTask;
    this._overrideTask = _overrideTask;
    this._resetTask = _resetTask;
    this._initializeEntityWorkflow = _initializeEntityWorkflow;
    this._getAllApplications = _getAllApplications;
    this._getApplicationById = _getApplicationById;
    this._getApplicationByName = _getApplicationByName;
    this._getDrawerGroupAssociations = _getDrawerGroupAssociations;
    this._getGroupDrawerAssociations = _getGroupDrawerAssociations;
    this._createOrUpdateDrawerGroupAssociation = _createOrUpdateDrawerGroupAssociation;
    this._deleteDrawerGroupAssociation = _deleteDrawerGroupAssociation;
    this._createOrUpdateGroupDrawerAssociation = _createOrUpdateGroupDrawerAssociation;
    this._deleteGroupDrawerAssociation = _deleteGroupDrawerAssociation;
    this._getUserGroupAssociations = _getUserGroupAssociations;
    this._getGroupUserAssociations = _getGroupUserAssociations;
    this._createUserGroupAssociation = _createUserGroupAssociation;
    this._deleteUserGroupAssociation = _deleteUserGroupAssociation;
    this._createGroupUserAssociation = _createGroupUserAssociation;
    this._deleteGroupUserAssociation = _deleteGroupUserAssociation;
    this._getQueueGroupAssociations = _getQueueGroupAssociations;
    this._getGroupQueueAssociations = _getGroupQueueAssociations;
    this._createOrUpdateQueueGroupAssociation = _createOrUpdateQueueGroupAssociation;
    this._deleteQueueGroupAssociation = _deleteQueueGroupAssociation;
    this._createOrUpdateGroupQueueAssociation = _createOrUpdateGroupQueueAssociation;
    this._deleteGroupQueueAssociation = _deleteGroupQueueAssociation;
    this._getApplicationGroupAssociations = _getApplicationGroupAssociations;
    this._getGroupApplicationAssociations = _getGroupApplicationAssociations;
    this._createOrUpdateApplicationGroupAssociation = _createOrUpdateApplicationGroupAssociation;
    this._deleteApplicationGroupAssociation = _deleteApplicationGroupAssociation;
    this._createOrUpdateGroupApplicationAssociation = _createOrUpdateGroupApplicationAssociation;
    this._deleteGroupApplicationAssociation = _deleteGroupApplicationAssociation;
    this._getDrawerUserAssociations = _getDrawerUserAssociations;
    this._getUserDrawerAssociations = _getUserDrawerAssociations;
    this._createOrUpdateDrawerUserAssociation = _createOrUpdateDrawerUserAssociation;
    this._deleteDrawerUserAssociation = _deleteDrawerUserAssociation;
    this._createOrUpdateUserDrawerAssociation = _createOrUpdateUserDrawerAssociation;
    this._deleteUserDrawerAssociation = _deleteUserDrawerAssociation;
    this._getQueueUserAssociations = _getQueueUserAssociations;
    this._getUserQueueAssociations = _getUserQueueAssociations;
    this._createOrUpdateQueueUserAssociation = _createOrUpdateQueueUserAssociation;
    this._deleteQueueUserAssociation = _deleteQueueUserAssociation;
    this._createOrUpdateUserQueueAssociation = _createOrUpdateUserQueueAssociation;
    this._deleteUserQueueAssociation = _deleteUserQueueAssociation;
    this._getApplicationUserAssociations = _getApplicationUserAssociations;
    this._getUserApplicationAssociations = _getUserApplicationAssociations;
    this._createOrUpdateApplicationUserAssociation = _createOrUpdateApplicationUserAssociation;
    this._deleteApplicationUserAssociation = _deleteApplicationUserAssociation;
    this._createOrUpdateUserApplicationAssociation = _createOrUpdateUserApplicationAssociation;
    this._deleteUserApplicationAssociation = _deleteUserApplicationAssociation;
    this._getAttachmentsByFilter = _getAttachmentsByFilter;
    this._getAttachmentById = _getAttachmentById;
    this._updateAttachment = _updateAttachment;
    this._deleteAttachment = _deleteAttachment;
    this._getAttachmentFileContent = _getAttachmentFileContent;
    this._createAttachment = _createAttachment;
    this._archiveAttachment = _archiveAttachment;
    this._getAttachmentVersionsByFilter = _getAttachmentVersionsByFilter;
    this._getAttachmentVersionFileContent = _getAttachmentVersionFileContent;
    this._checkOutAttachment = _checkOutAttachment;
    this._undoCheckOutAttachment = _undoCheckOutAttachment;
    this._checkInAttachment = _checkInAttachment;
    this._rollbackAttachmentVersion = _rollbackAttachmentVersion;
    this._getAllDrawers = _getAllDrawers;
    this._getDrawerById = _getDrawerById;
    this._updateDrawer = _updateDrawer;
    this._getDrawerByName = _getDrawerByName;
    this._getEntitiesByFilter = _getEntitiesByFilter;
    this._getEntityById = _getEntityById;
    this._updateEntity = _updateEntity;
    this._deleteEntity = _deleteEntity;
    this._createEntity = _createEntity;
    this._copyEntity = _copyEntity;
    this._getEventsByFilter = _getEventsByFilter;
    this._getEventById = _getEventById;
    this._createEvent = _createEvent;
    this._getExtensionsByFilter = _getExtensionsByFilter;
    this._getFlowsByFilter = _getFlowsByFilter;
    this._getFlowById = _getFlowById;
    this._getTemplatesByFilter = _getTemplatesByFilter;
    this._createTemplate = _createTemplate;
    this._getTemplateByType = _getTemplateByType;
    this._updateTemplateByType = _updateTemplateByType;
    this._deleteTemplateByType = _deleteTemplateByType;
    this._getTemplateById = _getTemplateById;
    this._updateTemplateById = _updateTemplateById;
    this._deleteTemplateById = _deleteTemplateById;
    this._validateTemplateField = _validateTemplateField;
    this._getGroupsByFilter = _getGroupsByFilter;
    this._createGroup = _createGroup;
    this._getGroupById = _getGroupById;
    this._updateGroup = _updateGroup;
    this._deleteGroup = _deleteGroup;
    this._getLinksByFilter = _getLinksByFilter;
    this._getLinkById = _getLinkById;
    this._updateLink = _updateLink;
    this._deleteLink = _deleteLink;
    this._createLink = _createLink;
    this._getLocksByFilter = _getLocksByFilter;
    this._createOrUpdateLock = _createOrUpdateLock;
    this._deleteLock = _deleteLock;
    this._getNotesByFilter = _getNotesByFilter;
    this._getNoteById = _getNoteById;
    this._updateNote = _updateNote;
    this._deleteNote = _deleteNote;
    this._createNote = _createNote;
    this._getQueueAssignmentsByFilter = _getQueueAssignmentsByFilter;
    this._updateQueueAssignemnt = _updateQueueAssignemnt;
    this._createQueueAssignment = _createQueueAssignment;
    this._getQueueAssignmentsById = _getQueueAssignmentsById;
    this._deleteQueueAssignment = _deleteQueueAssignment;
    this._getQueuesByFilter = _getQueuesByFilter;
    this._createQueue = _createQueue;
    this._getQueueById = _getQueueById;
    this._updateQueue = _updateQueue;
    this._deleteQueue = _deleteQueue;
    this._getQueueByName = _getQueueByName;
    this._getTasksByFilter = _getTasksByFilter;
    this._createTask = _createTask;
    this._getTaskById = _getTaskById;
    this._updateTask = _updateTask;
    this._deleteTask = _deleteTask;
    this._fetchTaskFromQueueAssignment = _fetchTaskFromQueueAssignment;
    this._getUsersByFilter = _getUsersByFilter;
    this._createUser = _createUser;
    this._getUserById = _getUserById;
    this._updateUser = _updateUser;
    this._deleteUser = _deleteUser;
    this._getWorkflowsByFilter = _getWorkflowsByFilter;
    this._getWorkflowById = _getWorkflowById;
    this._getWorkflowQueuesById = _getWorkflowQueuesById;
    this._getXMLTemplateByType = _getXMLTemplateByType;
    this._createXMLTemplate = _createXMLTemplate;
    msRest.addSerializationMixin(this);
  }

  /**
   * @summary Accepts the task.
   *
   * @param {object} model The model.
   *
   * @param {number} [model.taskID] Gets or sets the task identifier.
   *
   * @param {number} [model.targetID] Gets or sets the target id.
   *
   * @param {string} [model.queueName] Gets or sets the name of the queue.
   *
   * @param {string} [model.source] Gets or sets the source.
   *
   * @param {string} [model.computer] Gets or sets the name of the computer.
   *
   * @param {string} [model.iPAddress] Gets or sets the IP address.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Object>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  acceptTaskWithHttpOperationResponse(model, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._acceptTask(model, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Accepts the task.
   *
   * @param {object} model The model.
   *
   * @param {number} [model.taskID] Gets or sets the task identifier.
   *
   * @param {number} [model.targetID] Gets or sets the target id.
   *
   * @param {string} [model.queueName] Gets or sets the name of the queue.
   *
   * @param {string} [model.source] Gets or sets the source.
   *
   * @param {string} [model.computer] Gets or sets the name of the computer.
   *
   * @param {string} [model.iPAddress] Gets or sets the IP address.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {Object} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  acceptTask(model, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._acceptTask(model, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._acceptTask(model, options, optionalCallback);
    }
  }

  /**
   * @summary Rejects the task.
   *
   * @param {object} model The model.
   *
   * @param {number} [model.taskID] Gets or sets the task identifier.
   *
   * @param {number} [model.targetID] Gets or sets the target id.
   *
   * @param {string} [model.queueName] Gets or sets the name of the queue.
   *
   * @param {string} [model.source] Gets or sets the source.
   *
   * @param {string} [model.computer] Gets or sets the name of the computer.
   *
   * @param {string} [model.iPAddress] Gets or sets the IP address.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Object>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  rejectTaskWithHttpOperationResponse(model, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._rejectTask(model, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Rejects the task.
   *
   * @param {object} model The model.
   *
   * @param {number} [model.taskID] Gets or sets the task identifier.
   *
   * @param {number} [model.targetID] Gets or sets the target id.
   *
   * @param {string} [model.queueName] Gets or sets the name of the queue.
   *
   * @param {string} [model.source] Gets or sets the source.
   *
   * @param {string} [model.computer] Gets or sets the name of the computer.
   *
   * @param {string} [model.iPAddress] Gets or sets the IP address.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {Object} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  rejectTask(model, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._rejectTask(model, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._rejectTask(model, options, optionalCallback);
    }
  }

  /**
   * @summary Suspends the task.
   *
   * @param {object} model The model.
   *
   * @param {number} [model.taskID] Gets or sets the task identifier.
   *
   * @param {number} [model.targetID] Gets or sets the target id.
   *
   * @param {string} [model.queueName] Gets or sets the name of the queue.
   *
   * @param {string} [model.source] Gets or sets the source.
   *
   * @param {string} [model.computer] Gets or sets the name of the computer.
   *
   * @param {string} [model.iPAddress] Gets or sets the IP address.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Object>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  suspendTaskWithHttpOperationResponse(model, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._suspendTask(model, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Suspends the task.
   *
   * @param {object} model The model.
   *
   * @param {number} [model.taskID] Gets or sets the task identifier.
   *
   * @param {number} [model.targetID] Gets or sets the target id.
   *
   * @param {string} [model.queueName] Gets or sets the name of the queue.
   *
   * @param {string} [model.source] Gets or sets the source.
   *
   * @param {string} [model.computer] Gets or sets the name of the computer.
   *
   * @param {string} [model.iPAddress] Gets or sets the IP address.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {Object} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  suspendTask(model, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._suspendTask(model, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._suspendTask(model, options, optionalCallback);
    }
  }

  /**
   * @summary Routes the task.
   *
   * @param {object} model The model.
   *
   * @param {number} [model.drawerID] Gets or sets the drawer identifier.
   *
   * @param {number} [model.entityID] Gets or sets the entity identifier.
   *
   * @param {boolean} [model.keepOriginalTask] Gets or sets a value indicating
   * whether [keep original task].
   *
   * @param {number} [model.taskID] Gets or sets the task identifier.
   *
   * @param {number} [model.targetID] Gets or sets the target id.
   *
   * @param {string} [model.queueName] Gets or sets the name of the queue.
   *
   * @param {string} [model.source] Gets or sets the source.
   *
   * @param {string} [model.computer] Gets or sets the name of the computer.
   *
   * @param {string} [model.iPAddress] Gets or sets the IP address.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Object>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  routeTaskWithHttpOperationResponse(model, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._routeTask(model, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Routes the task.
   *
   * @param {object} model The model.
   *
   * @param {number} [model.drawerID] Gets or sets the drawer identifier.
   *
   * @param {number} [model.entityID] Gets or sets the entity identifier.
   *
   * @param {boolean} [model.keepOriginalTask] Gets or sets a value indicating
   * whether [keep original task].
   *
   * @param {number} [model.taskID] Gets or sets the task identifier.
   *
   * @param {number} [model.targetID] Gets or sets the target id.
   *
   * @param {string} [model.queueName] Gets or sets the name of the queue.
   *
   * @param {string} [model.source] Gets or sets the source.
   *
   * @param {string} [model.computer] Gets or sets the name of the computer.
   *
   * @param {string} [model.iPAddress] Gets or sets the IP address.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {Object} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  routeTask(model, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._routeTask(model, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._routeTask(model, options, optionalCallback);
    }
  }

  /**
   * @summary Overrides the task.
   *
   * @param {object} model The model.
   *
   * @param {number} [model.taskID] Gets or sets the task identifier.
   *
   * @param {number} [model.targetID] Gets or sets the target id.
   *
   * @param {string} [model.queueName] Gets or sets the name of the queue.
   *
   * @param {string} [model.source] Gets or sets the source.
   *
   * @param {string} [model.computer] Gets or sets the name of the computer.
   *
   * @param {string} [model.iPAddress] Gets or sets the IP address.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Object>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  overrideTaskWithHttpOperationResponse(model, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._overrideTask(model, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Overrides the task.
   *
   * @param {object} model The model.
   *
   * @param {number} [model.taskID] Gets or sets the task identifier.
   *
   * @param {number} [model.targetID] Gets or sets the target id.
   *
   * @param {string} [model.queueName] Gets or sets the name of the queue.
   *
   * @param {string} [model.source] Gets or sets the source.
   *
   * @param {string} [model.computer] Gets or sets the name of the computer.
   *
   * @param {string} [model.iPAddress] Gets or sets the IP address.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {Object} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  overrideTask(model, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._overrideTask(model, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._overrideTask(model, options, optionalCallback);
    }
  }

  /**
   * @summary Resets the task.
   *
   * @param {object} model The model.
   *
   * @param {number} [model.taskID] Gets or sets the task identifier.
   *
   * @param {number} [model.targetID] Gets or sets the target id.
   *
   * @param {string} [model.queueName] Gets or sets the name of the queue.
   *
   * @param {string} [model.source] Gets or sets the source.
   *
   * @param {string} [model.computer] Gets or sets the name of the computer.
   *
   * @param {string} [model.iPAddress] Gets or sets the IP address.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Object>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  resetTaskWithHttpOperationResponse(model, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._resetTask(model, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Resets the task.
   *
   * @param {object} model The model.
   *
   * @param {number} [model.taskID] Gets or sets the task identifier.
   *
   * @param {number} [model.targetID] Gets or sets the target id.
   *
   * @param {string} [model.queueName] Gets or sets the name of the queue.
   *
   * @param {string} [model.source] Gets or sets the source.
   *
   * @param {string} [model.computer] Gets or sets the name of the computer.
   *
   * @param {string} [model.iPAddress] Gets or sets the IP address.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {Object} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  resetTask(model, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._resetTask(model, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._resetTask(model, options, optionalCallback);
    }
  }

  /**
   * @summary Initializes the Workflow.
   *
   * @param {object} model The model.
   *
   * @param {number} [model.drawerID] Gets or sets the drawer identifier.
   *
   * @param {number} [model.entityID] Gets or sets the entity identifier.
   *
   * @param {array} [model.queueID] Gets or sets the queue identifier.
   *
   * @param {array} [model.queueName] Gets or sets the name of the queue.
   *
   * @param {string} [model.source] Gets or sets the source.
   *
   * @param {string} [model.computer] Gets or sets the name of the computer.
   *
   * @param {string} [model.iPAddress] Gets or sets the IP address.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Object>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  initializeEntityWorkflowWithHttpOperationResponse(model, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._initializeEntityWorkflow(model, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Initializes the Workflow.
   *
   * @param {object} model The model.
   *
   * @param {number} [model.drawerID] Gets or sets the drawer identifier.
   *
   * @param {number} [model.entityID] Gets or sets the entity identifier.
   *
   * @param {array} [model.queueID] Gets or sets the queue identifier.
   *
   * @param {array} [model.queueName] Gets or sets the name of the queue.
   *
   * @param {string} [model.source] Gets or sets the source.
   *
   * @param {string} [model.computer] Gets or sets the name of the computer.
   *
   * @param {string} [model.iPAddress] Gets or sets the IP address.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {Object} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  initializeEntityWorkflow(model, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._initializeEntityWorkflow(model, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._initializeEntityWorkflow(model, options, optionalCallback);
    }
  }

  /**
   * @summary Gets a list of all available applications.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Array>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getAllApplicationsWithHttpOperationResponse(options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getAllApplications(options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets a list of all available applications.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {Array} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {array} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getAllApplications(options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getAllApplications(options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getAllApplications(options, optionalCallback);
    }
  }

  /**
   * @summary Gets a single application by its unique identifier.
   *
   * @param {number} id The unique application identifier.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<ApplicationModel>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getApplicationByIdWithHttpOperationResponse(id, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getApplicationById(id, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets a single application by its unique identifier.
   *
   * @param {number} id The unique application identifier.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {ApplicationModel} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link ApplicationModel} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getApplicationById(id, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getApplicationById(id, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getApplicationById(id, options, optionalCallback);
    }
  }

  /**
   * @summary Gets a single application by its name.
   *
   * @param {string} name The unique application name.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<ApplicationModel>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getApplicationByNameWithHttpOperationResponse(name, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getApplicationByName(name, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets a single application by its name.
   *
   * @param {string} name The unique application name.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {ApplicationModel} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link ApplicationModel} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getApplicationByName(name, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getApplicationByName(name, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getApplicationByName(name, options, optionalCallback);
    }
  }

  /**
   * @summary Gets a list of drawer group associations.
   *
   * @param {number} drawerID The drawer identifier.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.groupID] The group identifier.
   *
   * @param {number} [options.acl] Gets or sets the access control level
   * permissions.
   *
   * @param {number} [options.page] Gets or sets the page number.
   *
   * @param {number} [options.pageSize] Gets or sets the size of the page.
   *
   * @param {string} [options.sortOrder] Gets or sets the order. Possible values
   * include: 'Unspecified', 'Ascending', 'Descending'
   *
   * @param {string} [options.sortBy] Gets or sets the column to order by.
   * Possible values include: 'Unspecified', 'DrawerID', 'ApplicationID',
   * 'GroupID', 'UserID', 'QueueID', 'Acl'
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Array>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getDrawerGroupAssociationsWithHttpOperationResponse(drawerID, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getDrawerGroupAssociations(drawerID, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets a list of drawer group associations.
   *
   * @param {number} drawerID The drawer identifier.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.groupID] The group identifier.
   *
   * @param {number} [options.acl] Gets or sets the access control level
   * permissions.
   *
   * @param {number} [options.page] Gets or sets the page number.
   *
   * @param {number} [options.pageSize] Gets or sets the size of the page.
   *
   * @param {string} [options.sortOrder] Gets or sets the order. Possible values
   * include: 'Unspecified', 'Ascending', 'Descending'
   *
   * @param {string} [options.sortBy] Gets or sets the column to order by.
   * Possible values include: 'Unspecified', 'DrawerID', 'ApplicationID',
   * 'GroupID', 'UserID', 'QueueID', 'Acl'
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {Array} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {array} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getDrawerGroupAssociations(drawerID, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getDrawerGroupAssociations(drawerID, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getDrawerGroupAssociations(drawerID, options, optionalCallback);
    }
  }

  /**
   * @summary Gets a list of group drawer associations.
   *
   * @param {number} groupID The group identifier.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.drawerID] The drawer identifier.
   *
   * @param {number} [options.acl] Gets or sets the access control level
   * permissions.
   *
   * @param {number} [options.page] Gets or sets the page number.
   *
   * @param {number} [options.pageSize] Gets or sets the size of the page.
   *
   * @param {string} [options.sortOrder] Gets or sets the order. Possible values
   * include: 'Unspecified', 'Ascending', 'Descending'
   *
   * @param {string} [options.sortBy] Gets or sets the column to order by.
   * Possible values include: 'Unspecified', 'DrawerID', 'ApplicationID',
   * 'GroupID', 'UserID', 'QueueID', 'Acl'
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Array>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getGroupDrawerAssociationsWithHttpOperationResponse(groupID, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getGroupDrawerAssociations(groupID, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets a list of group drawer associations.
   *
   * @param {number} groupID The group identifier.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.drawerID] The drawer identifier.
   *
   * @param {number} [options.acl] Gets or sets the access control level
   * permissions.
   *
   * @param {number} [options.page] Gets or sets the page number.
   *
   * @param {number} [options.pageSize] Gets or sets the size of the page.
   *
   * @param {string} [options.sortOrder] Gets or sets the order. Possible values
   * include: 'Unspecified', 'Ascending', 'Descending'
   *
   * @param {string} [options.sortBy] Gets or sets the column to order by.
   * Possible values include: 'Unspecified', 'DrawerID', 'ApplicationID',
   * 'GroupID', 'UserID', 'QueueID', 'Acl'
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {Array} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {array} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getGroupDrawerAssociations(groupID, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getGroupDrawerAssociations(groupID, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getGroupDrawerAssociations(groupID, options, optionalCallback);
    }
  }

  /**
   * @summary Inserts/Updates the drawer group association.
   *
   * @param {number} groupID The group identifier.
   *
   * @param {number} drawerID The drawer identifier.
   *
   * @param {object} model The model.
   *
   * @param {number} [model.groupID] Gets or sets the group identifier.
   *
   * @param {string} [model.groupName] Gets or sets the name of the group.
   *
   * @param {number} [model.drawerID] Gets or sets the drawer identifier.
   *
   * @param {string} [model.drawerName] Gets or sets the name of the drawer.
   *
   * @param {number} [model.acl] Gets or sets the access control level
   * permissions.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Object>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  createOrUpdateDrawerGroupAssociationWithHttpOperationResponse(groupID, drawerID, model, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._createOrUpdateDrawerGroupAssociation(groupID, drawerID, model, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Inserts/Updates the drawer group association.
   *
   * @param {number} groupID The group identifier.
   *
   * @param {number} drawerID The drawer identifier.
   *
   * @param {object} model The model.
   *
   * @param {number} [model.groupID] Gets or sets the group identifier.
   *
   * @param {string} [model.groupName] Gets or sets the name of the group.
   *
   * @param {number} [model.drawerID] Gets or sets the drawer identifier.
   *
   * @param {string} [model.drawerName] Gets or sets the name of the drawer.
   *
   * @param {number} [model.acl] Gets or sets the access control level
   * permissions.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {Object} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  createOrUpdateDrawerGroupAssociation(groupID, drawerID, model, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._createOrUpdateDrawerGroupAssociation(groupID, drawerID, model, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._createOrUpdateDrawerGroupAssociation(groupID, drawerID, model, options, optionalCallback);
    }
  }

  /**
   * @summary Deletes a drawer group association;
   *
   * @param {number} groupID The group identifier.
   *
   * @param {number} drawerID The drawer identifier.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Object>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  deleteDrawerGroupAssociationWithHttpOperationResponse(groupID, drawerID, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._deleteDrawerGroupAssociation(groupID, drawerID, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Deletes a drawer group association;
   *
   * @param {number} groupID The group identifier.
   *
   * @param {number} drawerID The drawer identifier.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {Object} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  deleteDrawerGroupAssociation(groupID, drawerID, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._deleteDrawerGroupAssociation(groupID, drawerID, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._deleteDrawerGroupAssociation(groupID, drawerID, options, optionalCallback);
    }
  }

  /**
   * @summary Inserts/Updates the group drawer association.
   *
   * @param {number} groupID The group identifier.
   *
   * @param {number} drawerID The drawer identifier.
   *
   * @param {object} model The model.
   *
   * @param {number} [model.groupID] Gets or sets the group identifier.
   *
   * @param {string} [model.groupName] Gets or sets the name of the group.
   *
   * @param {number} [model.drawerID] Gets or sets the drawer identifier.
   *
   * @param {string} [model.drawerName] Gets or sets the name of the drawer.
   *
   * @param {number} [model.acl] Gets or sets the access control level
   * permissions.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Object>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  createOrUpdateGroupDrawerAssociationWithHttpOperationResponse(groupID, drawerID, model, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._createOrUpdateGroupDrawerAssociation(groupID, drawerID, model, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Inserts/Updates the group drawer association.
   *
   * @param {number} groupID The group identifier.
   *
   * @param {number} drawerID The drawer identifier.
   *
   * @param {object} model The model.
   *
   * @param {number} [model.groupID] Gets or sets the group identifier.
   *
   * @param {string} [model.groupName] Gets or sets the name of the group.
   *
   * @param {number} [model.drawerID] Gets or sets the drawer identifier.
   *
   * @param {string} [model.drawerName] Gets or sets the name of the drawer.
   *
   * @param {number} [model.acl] Gets or sets the access control level
   * permissions.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {Object} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  createOrUpdateGroupDrawerAssociation(groupID, drawerID, model, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._createOrUpdateGroupDrawerAssociation(groupID, drawerID, model, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._createOrUpdateGroupDrawerAssociation(groupID, drawerID, model, options, optionalCallback);
    }
  }

  /**
   * @summary Deletes a group drawer association;
   *
   * @param {number} groupID The group identifier.
   *
   * @param {number} drawerID The drawer identifier.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Object>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  deleteGroupDrawerAssociationWithHttpOperationResponse(groupID, drawerID, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._deleteGroupDrawerAssociation(groupID, drawerID, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Deletes a group drawer association;
   *
   * @param {number} groupID The group identifier.
   *
   * @param {number} drawerID The drawer identifier.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {Object} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  deleteGroupDrawerAssociation(groupID, drawerID, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._deleteGroupDrawerAssociation(groupID, drawerID, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._deleteGroupDrawerAssociation(groupID, drawerID, options, optionalCallback);
    }
  }

  /**
   * @summary Gets a list of user group associations.
   *
   * @param {number} userID The user identifier.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.groupID] The group identifier.
   *
   * @param {number} [options.acl] Gets or sets the access control level
   * permissions.
   *
   * @param {number} [options.page] Gets or sets the page number.
   *
   * @param {number} [options.pageSize] Gets or sets the size of the page.
   *
   * @param {string} [options.sortOrder] Gets or sets the order. Possible values
   * include: 'Unspecified', 'Ascending', 'Descending'
   *
   * @param {string} [options.sortBy] Gets or sets the column to order by.
   * Possible values include: 'Unspecified', 'DrawerID', 'ApplicationID',
   * 'GroupID', 'UserID', 'QueueID', 'Acl'
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Array>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getUserGroupAssociationsWithHttpOperationResponse(userID, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getUserGroupAssociations(userID, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets a list of user group associations.
   *
   * @param {number} userID The user identifier.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.groupID] The group identifier.
   *
   * @param {number} [options.acl] Gets or sets the access control level
   * permissions.
   *
   * @param {number} [options.page] Gets or sets the page number.
   *
   * @param {number} [options.pageSize] Gets or sets the size of the page.
   *
   * @param {string} [options.sortOrder] Gets or sets the order. Possible values
   * include: 'Unspecified', 'Ascending', 'Descending'
   *
   * @param {string} [options.sortBy] Gets or sets the column to order by.
   * Possible values include: 'Unspecified', 'DrawerID', 'ApplicationID',
   * 'GroupID', 'UserID', 'QueueID', 'Acl'
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {Array} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {array} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getUserGroupAssociations(userID, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getUserGroupAssociations(userID, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getUserGroupAssociations(userID, options, optionalCallback);
    }
  }

  /**
   * @summary Gets a list of group user associations.
   *
   * @param {number} groupID The group identifier.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.userID] The user identifier.
   *
   * @param {number} [options.acl] Gets or sets the access control level
   * permissions.
   *
   * @param {number} [options.page] Gets or sets the page number.
   *
   * @param {number} [options.pageSize] Gets or sets the size of the page.
   *
   * @param {string} [options.sortOrder] Gets or sets the order. Possible values
   * include: 'Unspecified', 'Ascending', 'Descending'
   *
   * @param {string} [options.sortBy] Gets or sets the column to order by.
   * Possible values include: 'Unspecified', 'DrawerID', 'ApplicationID',
   * 'GroupID', 'UserID', 'QueueID', 'Acl'
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Array>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getGroupUserAssociationsWithHttpOperationResponse(groupID, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getGroupUserAssociations(groupID, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets a list of group user associations.
   *
   * @param {number} groupID The group identifier.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.userID] The user identifier.
   *
   * @param {number} [options.acl] Gets or sets the access control level
   * permissions.
   *
   * @param {number} [options.page] Gets or sets the page number.
   *
   * @param {number} [options.pageSize] Gets or sets the size of the page.
   *
   * @param {string} [options.sortOrder] Gets or sets the order. Possible values
   * include: 'Unspecified', 'Ascending', 'Descending'
   *
   * @param {string} [options.sortBy] Gets or sets the column to order by.
   * Possible values include: 'Unspecified', 'DrawerID', 'ApplicationID',
   * 'GroupID', 'UserID', 'QueueID', 'Acl'
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {Array} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {array} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getGroupUserAssociations(groupID, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getGroupUserAssociations(groupID, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getGroupUserAssociations(groupID, options, optionalCallback);
    }
  }

  /**
   * @summary Inserts the user group association.
   *
   * @param {number} groupID The group identifier.
   *
   * @param {number} userID The user identifier.
   *
   * @param {object} model The model.
   *
   * @param {number} [model.groupID] Gets or sets the group identifier.
   *
   * @param {string} [model.groupName] Gets or sets the name of the group.
   *
   * @param {number} [model.userID] Gets or sets the user identifier.
   *
   * @param {string} [model.userFullName] Gets or sets the full name of the user.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Object>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  createUserGroupAssociationWithHttpOperationResponse(groupID, userID, model, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._createUserGroupAssociation(groupID, userID, model, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Inserts the user group association.
   *
   * @param {number} groupID The group identifier.
   *
   * @param {number} userID The user identifier.
   *
   * @param {object} model The model.
   *
   * @param {number} [model.groupID] Gets or sets the group identifier.
   *
   * @param {string} [model.groupName] Gets or sets the name of the group.
   *
   * @param {number} [model.userID] Gets or sets the user identifier.
   *
   * @param {string} [model.userFullName] Gets or sets the full name of the user.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {Object} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  createUserGroupAssociation(groupID, userID, model, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._createUserGroupAssociation(groupID, userID, model, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._createUserGroupAssociation(groupID, userID, model, options, optionalCallback);
    }
  }

  /**
   * @summary Deletes a user group association;
   *
   * @param {number} groupID The group identifier.
   *
   * @param {number} userID The user identifier.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Object>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  deleteUserGroupAssociationWithHttpOperationResponse(groupID, userID, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._deleteUserGroupAssociation(groupID, userID, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Deletes a user group association;
   *
   * @param {number} groupID The group identifier.
   *
   * @param {number} userID The user identifier.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {Object} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  deleteUserGroupAssociation(groupID, userID, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._deleteUserGroupAssociation(groupID, userID, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._deleteUserGroupAssociation(groupID, userID, options, optionalCallback);
    }
  }

  /**
   * @summary Inserts the group user association.
   *
   * @param {number} groupID The group identifier.
   *
   * @param {number} userID The user identifier.
   *
   * @param {object} model The model.
   *
   * @param {number} [model.groupID] Gets or sets the group identifier.
   *
   * @param {string} [model.groupName] Gets or sets the name of the group.
   *
   * @param {number} [model.userID] Gets or sets the user identifier.
   *
   * @param {string} [model.userFullName] Gets or sets the full name of the user.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Object>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  createGroupUserAssociationWithHttpOperationResponse(groupID, userID, model, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._createGroupUserAssociation(groupID, userID, model, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Inserts the group user association.
   *
   * @param {number} groupID The group identifier.
   *
   * @param {number} userID The user identifier.
   *
   * @param {object} model The model.
   *
   * @param {number} [model.groupID] Gets or sets the group identifier.
   *
   * @param {string} [model.groupName] Gets or sets the name of the group.
   *
   * @param {number} [model.userID] Gets or sets the user identifier.
   *
   * @param {string} [model.userFullName] Gets or sets the full name of the user.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {Object} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  createGroupUserAssociation(groupID, userID, model, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._createGroupUserAssociation(groupID, userID, model, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._createGroupUserAssociation(groupID, userID, model, options, optionalCallback);
    }
  }

  /**
   * @summary Deletes a group user association;
   *
   * @param {number} groupID The group identifier.
   *
   * @param {number} userID The user identifier.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Object>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  deleteGroupUserAssociationWithHttpOperationResponse(groupID, userID, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._deleteGroupUserAssociation(groupID, userID, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Deletes a group user association;
   *
   * @param {number} groupID The group identifier.
   *
   * @param {number} userID The user identifier.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {Object} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  deleteGroupUserAssociation(groupID, userID, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._deleteGroupUserAssociation(groupID, userID, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._deleteGroupUserAssociation(groupID, userID, options, optionalCallback);
    }
  }

  /**
   * @summary Gets a list of queue group associations.
   *
   * @param {number} queueID The queue identifier.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.groupID] The group identifier.
   *
   * @param {number} [options.acl] Gets or sets the access control level
   * permissions.
   *
   * @param {number} [options.page] Gets or sets the page number.
   *
   * @param {number} [options.pageSize] Gets or sets the size of the page.
   *
   * @param {string} [options.sortOrder] Gets or sets the order. Possible values
   * include: 'Unspecified', 'Ascending', 'Descending'
   *
   * @param {string} [options.sortBy] Gets or sets the column to order by.
   * Possible values include: 'Unspecified', 'DrawerID', 'ApplicationID',
   * 'GroupID', 'UserID', 'QueueID', 'Acl'
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Array>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getQueueGroupAssociationsWithHttpOperationResponse(queueID, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getQueueGroupAssociations(queueID, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets a list of queue group associations.
   *
   * @param {number} queueID The queue identifier.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.groupID] The group identifier.
   *
   * @param {number} [options.acl] Gets or sets the access control level
   * permissions.
   *
   * @param {number} [options.page] Gets or sets the page number.
   *
   * @param {number} [options.pageSize] Gets or sets the size of the page.
   *
   * @param {string} [options.sortOrder] Gets or sets the order. Possible values
   * include: 'Unspecified', 'Ascending', 'Descending'
   *
   * @param {string} [options.sortBy] Gets or sets the column to order by.
   * Possible values include: 'Unspecified', 'DrawerID', 'ApplicationID',
   * 'GroupID', 'UserID', 'QueueID', 'Acl'
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {Array} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {array} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getQueueGroupAssociations(queueID, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getQueueGroupAssociations(queueID, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getQueueGroupAssociations(queueID, options, optionalCallback);
    }
  }

  /**
   * @summary Gets a list of group queue associations.
   *
   * @param {number} groupID The group identifier.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.queueID] The queue identifier.
   *
   * @param {number} [options.acl] Gets or sets the access control level
   * permissions.
   *
   * @param {number} [options.page] Gets or sets the page number.
   *
   * @param {number} [options.pageSize] Gets or sets the size of the page.
   *
   * @param {string} [options.sortOrder] Gets or sets the order. Possible values
   * include: 'Unspecified', 'Ascending', 'Descending'
   *
   * @param {string} [options.sortBy] Gets or sets the column to order by.
   * Possible values include: 'Unspecified', 'DrawerID', 'ApplicationID',
   * 'GroupID', 'UserID', 'QueueID', 'Acl'
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Array>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getGroupQueueAssociationsWithHttpOperationResponse(groupID, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getGroupQueueAssociations(groupID, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets a list of group queue associations.
   *
   * @param {number} groupID The group identifier.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.queueID] The queue identifier.
   *
   * @param {number} [options.acl] Gets or sets the access control level
   * permissions.
   *
   * @param {number} [options.page] Gets or sets the page number.
   *
   * @param {number} [options.pageSize] Gets or sets the size of the page.
   *
   * @param {string} [options.sortOrder] Gets or sets the order. Possible values
   * include: 'Unspecified', 'Ascending', 'Descending'
   *
   * @param {string} [options.sortBy] Gets or sets the column to order by.
   * Possible values include: 'Unspecified', 'DrawerID', 'ApplicationID',
   * 'GroupID', 'UserID', 'QueueID', 'Acl'
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {Array} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {array} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getGroupQueueAssociations(groupID, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getGroupQueueAssociations(groupID, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getGroupQueueAssociations(groupID, options, optionalCallback);
    }
  }

  /**
   * @summary Inserts/Updates the queue group association.
   *
   * @param {number} groupID The group identifier.
   *
   * @param {number} queueID The queue identifier.
   *
   * @param {object} model The model.
   *
   * @param {number} [model.groupID] Gets or sets the group identifier.
   *
   * @param {string} [model.groupName] Gets or sets the name of the group.
   *
   * @param {number} [model.queueID] Gets or sets the queue identifier.
   *
   * @param {string} [model.queueName] Gets or sets the name of the queue.
   *
   * @param {number} [model.acl] Gets or sets the access control level
   * permissions.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Object>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  createOrUpdateQueueGroupAssociationWithHttpOperationResponse(groupID, queueID, model, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._createOrUpdateQueueGroupAssociation(groupID, queueID, model, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Inserts/Updates the queue group association.
   *
   * @param {number} groupID The group identifier.
   *
   * @param {number} queueID The queue identifier.
   *
   * @param {object} model The model.
   *
   * @param {number} [model.groupID] Gets or sets the group identifier.
   *
   * @param {string} [model.groupName] Gets or sets the name of the group.
   *
   * @param {number} [model.queueID] Gets or sets the queue identifier.
   *
   * @param {string} [model.queueName] Gets or sets the name of the queue.
   *
   * @param {number} [model.acl] Gets or sets the access control level
   * permissions.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {Object} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  createOrUpdateQueueGroupAssociation(groupID, queueID, model, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._createOrUpdateQueueGroupAssociation(groupID, queueID, model, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._createOrUpdateQueueGroupAssociation(groupID, queueID, model, options, optionalCallback);
    }
  }

  /**
   * @summary Deletes a queue group association;
   *
   * @param {number} groupID The group identifier.
   *
   * @param {number} queueID The queue identifier.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Object>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  deleteQueueGroupAssociationWithHttpOperationResponse(groupID, queueID, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._deleteQueueGroupAssociation(groupID, queueID, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Deletes a queue group association;
   *
   * @param {number} groupID The group identifier.
   *
   * @param {number} queueID The queue identifier.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {Object} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  deleteQueueGroupAssociation(groupID, queueID, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._deleteQueueGroupAssociation(groupID, queueID, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._deleteQueueGroupAssociation(groupID, queueID, options, optionalCallback);
    }
  }

  /**
   * @summary Inserts/Updates the group queue association.
   *
   * @param {number} groupID The group identifier.
   *
   * @param {number} queueID The queue identifier.
   *
   * @param {object} model The model.
   *
   * @param {number} [model.groupID] Gets or sets the group identifier.
   *
   * @param {string} [model.groupName] Gets or sets the name of the group.
   *
   * @param {number} [model.queueID] Gets or sets the queue identifier.
   *
   * @param {string} [model.queueName] Gets or sets the name of the queue.
   *
   * @param {number} [model.acl] Gets or sets the access control level
   * permissions.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Object>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  createOrUpdateGroupQueueAssociationWithHttpOperationResponse(groupID, queueID, model, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._createOrUpdateGroupQueueAssociation(groupID, queueID, model, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Inserts/Updates the group queue association.
   *
   * @param {number} groupID The group identifier.
   *
   * @param {number} queueID The queue identifier.
   *
   * @param {object} model The model.
   *
   * @param {number} [model.groupID] Gets or sets the group identifier.
   *
   * @param {string} [model.groupName] Gets or sets the name of the group.
   *
   * @param {number} [model.queueID] Gets or sets the queue identifier.
   *
   * @param {string} [model.queueName] Gets or sets the name of the queue.
   *
   * @param {number} [model.acl] Gets or sets the access control level
   * permissions.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {Object} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  createOrUpdateGroupQueueAssociation(groupID, queueID, model, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._createOrUpdateGroupQueueAssociation(groupID, queueID, model, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._createOrUpdateGroupQueueAssociation(groupID, queueID, model, options, optionalCallback);
    }
  }

  /**
   * @summary Deletes a group queue association;
   *
   * @param {number} groupID The group identifier.
   *
   * @param {number} queueID The queue identifier.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Object>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  deleteGroupQueueAssociationWithHttpOperationResponse(groupID, queueID, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._deleteGroupQueueAssociation(groupID, queueID, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Deletes a group queue association;
   *
   * @param {number} groupID The group identifier.
   *
   * @param {number} queueID The queue identifier.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {Object} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  deleteGroupQueueAssociation(groupID, queueID, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._deleteGroupQueueAssociation(groupID, queueID, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._deleteGroupQueueAssociation(groupID, queueID, options, optionalCallback);
    }
  }

  /**
   * @summary Gets a list of application group associations.
   *
   * @param {number} applicationID The application identifier.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.groupID] The group identifier.
   *
   * @param {number} [options.acl] Gets or sets the access control level
   * permissions.
   *
   * @param {number} [options.page] Gets or sets the page number.
   *
   * @param {number} [options.pageSize] Gets or sets the size of the page.
   *
   * @param {string} [options.sortOrder] Gets or sets the order. Possible values
   * include: 'Unspecified', 'Ascending', 'Descending'
   *
   * @param {string} [options.sortBy] Gets or sets the column to order by.
   * Possible values include: 'Unspecified', 'DrawerID', 'ApplicationID',
   * 'GroupID', 'UserID', 'QueueID', 'Acl'
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Array>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getApplicationGroupAssociationsWithHttpOperationResponse(applicationID, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getApplicationGroupAssociations(applicationID, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets a list of application group associations.
   *
   * @param {number} applicationID The application identifier.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.groupID] The group identifier.
   *
   * @param {number} [options.acl] Gets or sets the access control level
   * permissions.
   *
   * @param {number} [options.page] Gets or sets the page number.
   *
   * @param {number} [options.pageSize] Gets or sets the size of the page.
   *
   * @param {string} [options.sortOrder] Gets or sets the order. Possible values
   * include: 'Unspecified', 'Ascending', 'Descending'
   *
   * @param {string} [options.sortBy] Gets or sets the column to order by.
   * Possible values include: 'Unspecified', 'DrawerID', 'ApplicationID',
   * 'GroupID', 'UserID', 'QueueID', 'Acl'
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {Array} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {array} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getApplicationGroupAssociations(applicationID, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getApplicationGroupAssociations(applicationID, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getApplicationGroupAssociations(applicationID, options, optionalCallback);
    }
  }

  /**
   * @summary Gets a list of group application associations.
   *
   * @param {number} groupID The group identifier.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.applicationID] The application identifier.
   *
   * @param {number} [options.acl] Gets or sets the access control level
   * permissions.
   *
   * @param {number} [options.page] Gets or sets the page number.
   *
   * @param {number} [options.pageSize] Gets or sets the size of the page.
   *
   * @param {string} [options.sortOrder] Gets or sets the order. Possible values
   * include: 'Unspecified', 'Ascending', 'Descending'
   *
   * @param {string} [options.sortBy] Gets or sets the column to order by.
   * Possible values include: 'Unspecified', 'DrawerID', 'ApplicationID',
   * 'GroupID', 'UserID', 'QueueID', 'Acl'
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Array>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getGroupApplicationAssociationsWithHttpOperationResponse(groupID, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getGroupApplicationAssociations(groupID, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets a list of group application associations.
   *
   * @param {number} groupID The group identifier.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.applicationID] The application identifier.
   *
   * @param {number} [options.acl] Gets or sets the access control level
   * permissions.
   *
   * @param {number} [options.page] Gets or sets the page number.
   *
   * @param {number} [options.pageSize] Gets or sets the size of the page.
   *
   * @param {string} [options.sortOrder] Gets or sets the order. Possible values
   * include: 'Unspecified', 'Ascending', 'Descending'
   *
   * @param {string} [options.sortBy] Gets or sets the column to order by.
   * Possible values include: 'Unspecified', 'DrawerID', 'ApplicationID',
   * 'GroupID', 'UserID', 'QueueID', 'Acl'
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {Array} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {array} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getGroupApplicationAssociations(groupID, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getGroupApplicationAssociations(groupID, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getGroupApplicationAssociations(groupID, options, optionalCallback);
    }
  }

  /**
   * @summary Inserts/Updates the application group association.
   *
   * @param {number} groupID The group identifier.
   *
   * @param {number} applicationID The application identifier.
   *
   * @param {object} model The model.
   *
   * @param {number} [model.groupID] Gets or sets the group identifier.
   *
   * @param {string} [model.groupName] Gets or sets the name of the group.
   *
   * @param {number} [model.applicationID] Gets or sets the application
   * identifier.
   *
   * @param {string} [model.applicationName] Gets or sets the name of the
   * application.
   *
   * @param {number} [model.acl] Gets or sets the acl.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Object>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  createOrUpdateApplicationGroupAssociationWithHttpOperationResponse(groupID, applicationID, model, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._createOrUpdateApplicationGroupAssociation(groupID, applicationID, model, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Inserts/Updates the application group association.
   *
   * @param {number} groupID The group identifier.
   *
   * @param {number} applicationID The application identifier.
   *
   * @param {object} model The model.
   *
   * @param {number} [model.groupID] Gets or sets the group identifier.
   *
   * @param {string} [model.groupName] Gets or sets the name of the group.
   *
   * @param {number} [model.applicationID] Gets or sets the application
   * identifier.
   *
   * @param {string} [model.applicationName] Gets or sets the name of the
   * application.
   *
   * @param {number} [model.acl] Gets or sets the acl.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {Object} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  createOrUpdateApplicationGroupAssociation(groupID, applicationID, model, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._createOrUpdateApplicationGroupAssociation(groupID, applicationID, model, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._createOrUpdateApplicationGroupAssociation(groupID, applicationID, model, options, optionalCallback);
    }
  }

  /**
   * @summary Deletes a application group association;
   *
   * @param {number} groupID The group identifier.
   *
   * @param {number} applicationID The application identifier.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Object>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  deleteApplicationGroupAssociationWithHttpOperationResponse(groupID, applicationID, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._deleteApplicationGroupAssociation(groupID, applicationID, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Deletes a application group association;
   *
   * @param {number} groupID The group identifier.
   *
   * @param {number} applicationID The application identifier.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {Object} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  deleteApplicationGroupAssociation(groupID, applicationID, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._deleteApplicationGroupAssociation(groupID, applicationID, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._deleteApplicationGroupAssociation(groupID, applicationID, options, optionalCallback);
    }
  }

  /**
   * @summary Inserts/Updates the group application association.
   *
   * @param {number} groupID The group identifier.
   *
   * @param {number} applicationID The application identifier.
   *
   * @param {object} model The model.
   *
   * @param {number} [model.groupID] Gets or sets the group identifier.
   *
   * @param {string} [model.groupName] Gets or sets the name of the group.
   *
   * @param {number} [model.applicationID] Gets or sets the application
   * identifier.
   *
   * @param {string} [model.applicationName] Gets or sets the name of the
   * application.
   *
   * @param {number} [model.acl] Gets or sets the acl.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Object>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  createOrUpdateGroupApplicationAssociationWithHttpOperationResponse(groupID, applicationID, model, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._createOrUpdateGroupApplicationAssociation(groupID, applicationID, model, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Inserts/Updates the group application association.
   *
   * @param {number} groupID The group identifier.
   *
   * @param {number} applicationID The application identifier.
   *
   * @param {object} model The model.
   *
   * @param {number} [model.groupID] Gets or sets the group identifier.
   *
   * @param {string} [model.groupName] Gets or sets the name of the group.
   *
   * @param {number} [model.applicationID] Gets or sets the application
   * identifier.
   *
   * @param {string} [model.applicationName] Gets or sets the name of the
   * application.
   *
   * @param {number} [model.acl] Gets or sets the acl.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {Object} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  createOrUpdateGroupApplicationAssociation(groupID, applicationID, model, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._createOrUpdateGroupApplicationAssociation(groupID, applicationID, model, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._createOrUpdateGroupApplicationAssociation(groupID, applicationID, model, options, optionalCallback);
    }
  }

  /**
   * @summary Deletes a group application association;
   *
   * @param {number} groupID The group identifier.
   *
   * @param {number} applicationID The application identifier.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Object>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  deleteGroupApplicationAssociationWithHttpOperationResponse(groupID, applicationID, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._deleteGroupApplicationAssociation(groupID, applicationID, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Deletes a group application association;
   *
   * @param {number} groupID The group identifier.
   *
   * @param {number} applicationID The application identifier.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {Object} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  deleteGroupApplicationAssociation(groupID, applicationID, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._deleteGroupApplicationAssociation(groupID, applicationID, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._deleteGroupApplicationAssociation(groupID, applicationID, options, optionalCallback);
    }
  }

  /**
   * @summary Gets a list of drawer user associations.
   *
   * @param {number} drawerID The drawer identifier.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.userID] The user identifier.
   *
   * @param {number} [options.acl] Gets or sets the access control level
   * permissions.
   *
   * @param {number} [options.page] Gets or sets the page number.
   *
   * @param {number} [options.pageSize] Gets or sets the size of the page.
   *
   * @param {string} [options.sortOrder] Gets or sets the order. Possible values
   * include: 'Unspecified', 'Ascending', 'Descending'
   *
   * @param {string} [options.sortBy] Gets or sets the column to order by.
   * Possible values include: 'Unspecified', 'DrawerID', 'ApplicationID',
   * 'GroupID', 'UserID', 'QueueID', 'Acl'
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Array>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getDrawerUserAssociationsWithHttpOperationResponse(drawerID, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getDrawerUserAssociations(drawerID, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets a list of drawer user associations.
   *
   * @param {number} drawerID The drawer identifier.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.userID] The user identifier.
   *
   * @param {number} [options.acl] Gets or sets the access control level
   * permissions.
   *
   * @param {number} [options.page] Gets or sets the page number.
   *
   * @param {number} [options.pageSize] Gets or sets the size of the page.
   *
   * @param {string} [options.sortOrder] Gets or sets the order. Possible values
   * include: 'Unspecified', 'Ascending', 'Descending'
   *
   * @param {string} [options.sortBy] Gets or sets the column to order by.
   * Possible values include: 'Unspecified', 'DrawerID', 'ApplicationID',
   * 'GroupID', 'UserID', 'QueueID', 'Acl'
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {Array} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {array} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getDrawerUserAssociations(drawerID, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getDrawerUserAssociations(drawerID, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getDrawerUserAssociations(drawerID, options, optionalCallback);
    }
  }

  /**
   * @summary Gets a list of user drawer associations.
   *
   * @param {number} userID The user identifier.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.drawerID] The drawer identifier.
   *
   * @param {number} [options.acl] Gets or sets the access control level
   * permissions.
   *
   * @param {number} [options.page] Gets or sets the page number.
   *
   * @param {number} [options.pageSize] Gets or sets the size of the page.
   *
   * @param {string} [options.sortOrder] Gets or sets the order. Possible values
   * include: 'Unspecified', 'Ascending', 'Descending'
   *
   * @param {string} [options.sortBy] Gets or sets the column to order by.
   * Possible values include: 'Unspecified', 'DrawerID', 'ApplicationID',
   * 'GroupID', 'UserID', 'QueueID', 'Acl'
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Array>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getUserDrawerAssociationsWithHttpOperationResponse(userID, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getUserDrawerAssociations(userID, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets a list of user drawer associations.
   *
   * @param {number} userID The user identifier.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.drawerID] The drawer identifier.
   *
   * @param {number} [options.acl] Gets or sets the access control level
   * permissions.
   *
   * @param {number} [options.page] Gets or sets the page number.
   *
   * @param {number} [options.pageSize] Gets or sets the size of the page.
   *
   * @param {string} [options.sortOrder] Gets or sets the order. Possible values
   * include: 'Unspecified', 'Ascending', 'Descending'
   *
   * @param {string} [options.sortBy] Gets or sets the column to order by.
   * Possible values include: 'Unspecified', 'DrawerID', 'ApplicationID',
   * 'GroupID', 'UserID', 'QueueID', 'Acl'
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {Array} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {array} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getUserDrawerAssociations(userID, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getUserDrawerAssociations(userID, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getUserDrawerAssociations(userID, options, optionalCallback);
    }
  }

  /**
   * @summary Inserts/Updates the drawer user association.
   *
   * @param {number} userID The user identifier.
   *
   * @param {number} drawerID The drawer identifier.
   *
   * @param {object} model The model.
   *
   * @param {number} [model.userID] Gets or sets the user identifier.
   *
   * @param {string} [model.userFullName] Gets or sets the full name of the user.
   *
   * @param {number} [model.drawerID] Gets or sets the drawer identifier.
   *
   * @param {string} [model.drawerName] Gets or sets the name of the drawer.
   *
   * @param {number} [model.acl] Gets or sets the access control level
   * permissions.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Object>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  createOrUpdateDrawerUserAssociationWithHttpOperationResponse(userID, drawerID, model, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._createOrUpdateDrawerUserAssociation(userID, drawerID, model, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Inserts/Updates the drawer user association.
   *
   * @param {number} userID The user identifier.
   *
   * @param {number} drawerID The drawer identifier.
   *
   * @param {object} model The model.
   *
   * @param {number} [model.userID] Gets or sets the user identifier.
   *
   * @param {string} [model.userFullName] Gets or sets the full name of the user.
   *
   * @param {number} [model.drawerID] Gets or sets the drawer identifier.
   *
   * @param {string} [model.drawerName] Gets or sets the name of the drawer.
   *
   * @param {number} [model.acl] Gets or sets the access control level
   * permissions.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {Object} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  createOrUpdateDrawerUserAssociation(userID, drawerID, model, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._createOrUpdateDrawerUserAssociation(userID, drawerID, model, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._createOrUpdateDrawerUserAssociation(userID, drawerID, model, options, optionalCallback);
    }
  }

  /**
   * @summary Deletes a drawer user association;
   *
   * @param {number} userID The user identifier.
   *
   * @param {number} drawerID The drawer identifier.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Object>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  deleteDrawerUserAssociationWithHttpOperationResponse(userID, drawerID, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._deleteDrawerUserAssociation(userID, drawerID, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Deletes a drawer user association;
   *
   * @param {number} userID The user identifier.
   *
   * @param {number} drawerID The drawer identifier.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {Object} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  deleteDrawerUserAssociation(userID, drawerID, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._deleteDrawerUserAssociation(userID, drawerID, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._deleteDrawerUserAssociation(userID, drawerID, options, optionalCallback);
    }
  }

  /**
   * @summary Inserts/Updates the user drawer association.
   *
   * @param {number} userID The user identifier.
   *
   * @param {number} drawerID The drawer identifier.
   *
   * @param {object} model The model.
   *
   * @param {number} [model.userID] Gets or sets the user identifier.
   *
   * @param {string} [model.userFullName] Gets or sets the full name of the user.
   *
   * @param {number} [model.drawerID] Gets or sets the drawer identifier.
   *
   * @param {string} [model.drawerName] Gets or sets the name of the drawer.
   *
   * @param {number} [model.acl] Gets or sets the access control level
   * permissions.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Object>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  createOrUpdateUserDrawerAssociationWithHttpOperationResponse(userID, drawerID, model, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._createOrUpdateUserDrawerAssociation(userID, drawerID, model, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Inserts/Updates the user drawer association.
   *
   * @param {number} userID The user identifier.
   *
   * @param {number} drawerID The drawer identifier.
   *
   * @param {object} model The model.
   *
   * @param {number} [model.userID] Gets or sets the user identifier.
   *
   * @param {string} [model.userFullName] Gets or sets the full name of the user.
   *
   * @param {number} [model.drawerID] Gets or sets the drawer identifier.
   *
   * @param {string} [model.drawerName] Gets or sets the name of the drawer.
   *
   * @param {number} [model.acl] Gets or sets the access control level
   * permissions.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {Object} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  createOrUpdateUserDrawerAssociation(userID, drawerID, model, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._createOrUpdateUserDrawerAssociation(userID, drawerID, model, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._createOrUpdateUserDrawerAssociation(userID, drawerID, model, options, optionalCallback);
    }
  }

  /**
   * @summary Deletes a user drawer association;
   *
   * @param {number} userID The user identifier.
   *
   * @param {number} drawerID The drawer identifier.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Object>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  deleteUserDrawerAssociationWithHttpOperationResponse(userID, drawerID, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._deleteUserDrawerAssociation(userID, drawerID, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Deletes a user drawer association;
   *
   * @param {number} userID The user identifier.
   *
   * @param {number} drawerID The drawer identifier.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {Object} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  deleteUserDrawerAssociation(userID, drawerID, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._deleteUserDrawerAssociation(userID, drawerID, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._deleteUserDrawerAssociation(userID, drawerID, options, optionalCallback);
    }
  }

  /**
   * @summary Gets a list of queue user associations.
   *
   * @param {number} queueID The queue identifier.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.userID] The user identifier.
   *
   * @param {number} [options.acl] Gets or sets the access control level
   * permissions.
   *
   * @param {number} [options.page] Gets or sets the page number.
   *
   * @param {number} [options.pageSize] Gets or sets the size of the page.
   *
   * @param {string} [options.sortOrder] Gets or sets the order. Possible values
   * include: 'Unspecified', 'Ascending', 'Descending'
   *
   * @param {string} [options.sortBy] Gets or sets the column to order by.
   * Possible values include: 'Unspecified', 'DrawerID', 'ApplicationID',
   * 'GroupID', 'UserID', 'QueueID', 'Acl'
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Array>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getQueueUserAssociationsWithHttpOperationResponse(queueID, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getQueueUserAssociations(queueID, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets a list of queue user associations.
   *
   * @param {number} queueID The queue identifier.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.userID] The user identifier.
   *
   * @param {number} [options.acl] Gets or sets the access control level
   * permissions.
   *
   * @param {number} [options.page] Gets or sets the page number.
   *
   * @param {number} [options.pageSize] Gets or sets the size of the page.
   *
   * @param {string} [options.sortOrder] Gets or sets the order. Possible values
   * include: 'Unspecified', 'Ascending', 'Descending'
   *
   * @param {string} [options.sortBy] Gets or sets the column to order by.
   * Possible values include: 'Unspecified', 'DrawerID', 'ApplicationID',
   * 'GroupID', 'UserID', 'QueueID', 'Acl'
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {Array} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {array} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getQueueUserAssociations(queueID, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getQueueUserAssociations(queueID, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getQueueUserAssociations(queueID, options, optionalCallback);
    }
  }

  /**
   * @summary Gets a list of user queue associations.
   *
   * @param {number} userID The user identifier.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.queueID] The queue identifier.
   *
   * @param {number} [options.acl] Gets or sets the access control level
   * permissions.
   *
   * @param {number} [options.page] Gets or sets the page number.
   *
   * @param {number} [options.pageSize] Gets or sets the size of the page.
   *
   * @param {string} [options.sortOrder] Gets or sets the order. Possible values
   * include: 'Unspecified', 'Ascending', 'Descending'
   *
   * @param {string} [options.sortBy] Gets or sets the column to order by.
   * Possible values include: 'Unspecified', 'DrawerID', 'ApplicationID',
   * 'GroupID', 'UserID', 'QueueID', 'Acl'
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Array>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getUserQueueAssociationsWithHttpOperationResponse(userID, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getUserQueueAssociations(userID, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets a list of user queue associations.
   *
   * @param {number} userID The user identifier.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.queueID] The queue identifier.
   *
   * @param {number} [options.acl] Gets or sets the access control level
   * permissions.
   *
   * @param {number} [options.page] Gets or sets the page number.
   *
   * @param {number} [options.pageSize] Gets or sets the size of the page.
   *
   * @param {string} [options.sortOrder] Gets or sets the order. Possible values
   * include: 'Unspecified', 'Ascending', 'Descending'
   *
   * @param {string} [options.sortBy] Gets or sets the column to order by.
   * Possible values include: 'Unspecified', 'DrawerID', 'ApplicationID',
   * 'GroupID', 'UserID', 'QueueID', 'Acl'
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {Array} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {array} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getUserQueueAssociations(userID, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getUserQueueAssociations(userID, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getUserQueueAssociations(userID, options, optionalCallback);
    }
  }

  /**
   * @summary Inserts/Updates the queue user association.
   *
   * @param {number} userID The user identifier.
   *
   * @param {number} queueID The queue identifier.
   *
   * @param {object} model The model.
   *
   * @param {number} [model.userID] Gets or sets the user identifier.
   *
   * @param {string} [model.userFullName] Gets or sets the full name of the user.
   *
   * @param {number} [model.queueID] Gets or sets the queue identifier.
   *
   * @param {string} [model.queueName] Gets or sets the name of the queue.
   *
   * @param {number} [model.acl] Gets or sets the access control level
   * permissions.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Object>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  createOrUpdateQueueUserAssociationWithHttpOperationResponse(userID, queueID, model, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._createOrUpdateQueueUserAssociation(userID, queueID, model, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Inserts/Updates the queue user association.
   *
   * @param {number} userID The user identifier.
   *
   * @param {number} queueID The queue identifier.
   *
   * @param {object} model The model.
   *
   * @param {number} [model.userID] Gets or sets the user identifier.
   *
   * @param {string} [model.userFullName] Gets or sets the full name of the user.
   *
   * @param {number} [model.queueID] Gets or sets the queue identifier.
   *
   * @param {string} [model.queueName] Gets or sets the name of the queue.
   *
   * @param {number} [model.acl] Gets or sets the access control level
   * permissions.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {Object} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  createOrUpdateQueueUserAssociation(userID, queueID, model, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._createOrUpdateQueueUserAssociation(userID, queueID, model, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._createOrUpdateQueueUserAssociation(userID, queueID, model, options, optionalCallback);
    }
  }

  /**
   * @summary Deletes a queue user association;
   *
   * @param {number} userID The user identifier.
   *
   * @param {number} queueID The queue identifier.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Object>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  deleteQueueUserAssociationWithHttpOperationResponse(userID, queueID, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._deleteQueueUserAssociation(userID, queueID, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Deletes a queue user association;
   *
   * @param {number} userID The user identifier.
   *
   * @param {number} queueID The queue identifier.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {Object} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  deleteQueueUserAssociation(userID, queueID, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._deleteQueueUserAssociation(userID, queueID, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._deleteQueueUserAssociation(userID, queueID, options, optionalCallback);
    }
  }

  /**
   * @summary Inserts/Updates the user queue association.
   *
   * @param {number} userID The user identifier.
   *
   * @param {number} queueID The queue identifier.
   *
   * @param {object} model The model.
   *
   * @param {number} [model.userID] Gets or sets the user identifier.
   *
   * @param {string} [model.userFullName] Gets or sets the full name of the user.
   *
   * @param {number} [model.queueID] Gets or sets the queue identifier.
   *
   * @param {string} [model.queueName] Gets or sets the name of the queue.
   *
   * @param {number} [model.acl] Gets or sets the access control level
   * permissions.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Object>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  createOrUpdateUserQueueAssociationWithHttpOperationResponse(userID, queueID, model, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._createOrUpdateUserQueueAssociation(userID, queueID, model, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Inserts/Updates the user queue association.
   *
   * @param {number} userID The user identifier.
   *
   * @param {number} queueID The queue identifier.
   *
   * @param {object} model The model.
   *
   * @param {number} [model.userID] Gets or sets the user identifier.
   *
   * @param {string} [model.userFullName] Gets or sets the full name of the user.
   *
   * @param {number} [model.queueID] Gets or sets the queue identifier.
   *
   * @param {string} [model.queueName] Gets or sets the name of the queue.
   *
   * @param {number} [model.acl] Gets or sets the access control level
   * permissions.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {Object} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  createOrUpdateUserQueueAssociation(userID, queueID, model, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._createOrUpdateUserQueueAssociation(userID, queueID, model, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._createOrUpdateUserQueueAssociation(userID, queueID, model, options, optionalCallback);
    }
  }

  /**
   * @summary Deletes a user queue association;
   *
   * @param {number} userID The user identifier.
   *
   * @param {number} queueID The queue identifier.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Object>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  deleteUserQueueAssociationWithHttpOperationResponse(userID, queueID, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._deleteUserQueueAssociation(userID, queueID, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Deletes a user queue association;
   *
   * @param {number} userID The user identifier.
   *
   * @param {number} queueID The queue identifier.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {Object} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  deleteUserQueueAssociation(userID, queueID, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._deleteUserQueueAssociation(userID, queueID, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._deleteUserQueueAssociation(userID, queueID, options, optionalCallback);
    }
  }

  /**
   * @summary Gets a list of application user associations.
   *
   * @param {number} applicationID The application identifier.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.userID] The user identifier.
   *
   * @param {number} [options.acl] Gets or sets the access control level
   * permissions.
   *
   * @param {number} [options.page] Gets or sets the page number.
   *
   * @param {number} [options.pageSize] Gets or sets the size of the page.
   *
   * @param {string} [options.sortOrder] Gets or sets the order. Possible values
   * include: 'Unspecified', 'Ascending', 'Descending'
   *
   * @param {string} [options.sortBy] Gets or sets the column to order by.
   * Possible values include: 'Unspecified', 'DrawerID', 'ApplicationID',
   * 'GroupID', 'UserID', 'QueueID', 'Acl'
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Array>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getApplicationUserAssociationsWithHttpOperationResponse(applicationID, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getApplicationUserAssociations(applicationID, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets a list of application user associations.
   *
   * @param {number} applicationID The application identifier.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.userID] The user identifier.
   *
   * @param {number} [options.acl] Gets or sets the access control level
   * permissions.
   *
   * @param {number} [options.page] Gets or sets the page number.
   *
   * @param {number} [options.pageSize] Gets or sets the size of the page.
   *
   * @param {string} [options.sortOrder] Gets or sets the order. Possible values
   * include: 'Unspecified', 'Ascending', 'Descending'
   *
   * @param {string} [options.sortBy] Gets or sets the column to order by.
   * Possible values include: 'Unspecified', 'DrawerID', 'ApplicationID',
   * 'GroupID', 'UserID', 'QueueID', 'Acl'
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {Array} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {array} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getApplicationUserAssociations(applicationID, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getApplicationUserAssociations(applicationID, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getApplicationUserAssociations(applicationID, options, optionalCallback);
    }
  }

  /**
   * @summary Gets a list of user application associations.
   *
   * @param {number} userID The user identifier.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.applicationID] The application identifier.
   *
   * @param {number} [options.acl] Gets or sets the access control level
   * permissions.
   *
   * @param {number} [options.page] Gets or sets the page number.
   *
   * @param {number} [options.pageSize] Gets or sets the size of the page.
   *
   * @param {string} [options.sortOrder] Gets or sets the order. Possible values
   * include: 'Unspecified', 'Ascending', 'Descending'
   *
   * @param {string} [options.sortBy] Gets or sets the column to order by.
   * Possible values include: 'Unspecified', 'DrawerID', 'ApplicationID',
   * 'GroupID', 'UserID', 'QueueID', 'Acl'
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Array>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getUserApplicationAssociationsWithHttpOperationResponse(userID, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getUserApplicationAssociations(userID, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets a list of user application associations.
   *
   * @param {number} userID The user identifier.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.applicationID] The application identifier.
   *
   * @param {number} [options.acl] Gets or sets the access control level
   * permissions.
   *
   * @param {number} [options.page] Gets or sets the page number.
   *
   * @param {number} [options.pageSize] Gets or sets the size of the page.
   *
   * @param {string} [options.sortOrder] Gets or sets the order. Possible values
   * include: 'Unspecified', 'Ascending', 'Descending'
   *
   * @param {string} [options.sortBy] Gets or sets the column to order by.
   * Possible values include: 'Unspecified', 'DrawerID', 'ApplicationID',
   * 'GroupID', 'UserID', 'QueueID', 'Acl'
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {Array} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {array} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getUserApplicationAssociations(userID, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getUserApplicationAssociations(userID, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getUserApplicationAssociations(userID, options, optionalCallback);
    }
  }

  /**
   * @summary Inserts/Updates the application user association.
   *
   * @param {number} userID The user identifier.
   *
   * @param {number} applicationID The application identifier.
   *
   * @param {object} model The model.
   *
   * @param {number} [model.userID] Gets or sets the user identifier.
   *
   * @param {string} [model.userFullName] Gets or sets the full name of the user.
   *
   * @param {number} [model.applicationID] Gets or sets the application
   * identifier.
   *
   * @param {string} [model.applicationName] Gets or sets the name of the
   * application.
   *
   * @param {number} [model.acl] Gets or sets the access control level
   * permissions.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Object>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  createOrUpdateApplicationUserAssociationWithHttpOperationResponse(userID, applicationID, model, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._createOrUpdateApplicationUserAssociation(userID, applicationID, model, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Inserts/Updates the application user association.
   *
   * @param {number} userID The user identifier.
   *
   * @param {number} applicationID The application identifier.
   *
   * @param {object} model The model.
   *
   * @param {number} [model.userID] Gets or sets the user identifier.
   *
   * @param {string} [model.userFullName] Gets or sets the full name of the user.
   *
   * @param {number} [model.applicationID] Gets or sets the application
   * identifier.
   *
   * @param {string} [model.applicationName] Gets or sets the name of the
   * application.
   *
   * @param {number} [model.acl] Gets or sets the access control level
   * permissions.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {Object} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  createOrUpdateApplicationUserAssociation(userID, applicationID, model, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._createOrUpdateApplicationUserAssociation(userID, applicationID, model, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._createOrUpdateApplicationUserAssociation(userID, applicationID, model, options, optionalCallback);
    }
  }

  /**
   * @summary Deletes an application user association;
   *
   * @param {number} userID The user identifier.
   *
   * @param {number} applicationID The application identifier.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Object>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  deleteApplicationUserAssociationWithHttpOperationResponse(userID, applicationID, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._deleteApplicationUserAssociation(userID, applicationID, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Deletes an application user association;
   *
   * @param {number} userID The user identifier.
   *
   * @param {number} applicationID The application identifier.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {Object} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  deleteApplicationUserAssociation(userID, applicationID, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._deleteApplicationUserAssociation(userID, applicationID, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._deleteApplicationUserAssociation(userID, applicationID, options, optionalCallback);
    }
  }

  /**
   * @summary Inserts/Updates the user application association.
   *
   * @param {number} userID The user identifier.
   *
   * @param {number} applicationID The application identifier.
   *
   * @param {object} model The model.
   *
   * @param {number} [model.userID] Gets or sets the user identifier.
   *
   * @param {string} [model.userFullName] Gets or sets the full name of the user.
   *
   * @param {number} [model.applicationID] Gets or sets the application
   * identifier.
   *
   * @param {string} [model.applicationName] Gets or sets the name of the
   * application.
   *
   * @param {number} [model.acl] Gets or sets the access control level
   * permissions.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Object>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  createOrUpdateUserApplicationAssociationWithHttpOperationResponse(userID, applicationID, model, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._createOrUpdateUserApplicationAssociation(userID, applicationID, model, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Inserts/Updates the user application association.
   *
   * @param {number} userID The user identifier.
   *
   * @param {number} applicationID The application identifier.
   *
   * @param {object} model The model.
   *
   * @param {number} [model.userID] Gets or sets the user identifier.
   *
   * @param {string} [model.userFullName] Gets or sets the full name of the user.
   *
   * @param {number} [model.applicationID] Gets or sets the application
   * identifier.
   *
   * @param {string} [model.applicationName] Gets or sets the name of the
   * application.
   *
   * @param {number} [model.acl] Gets or sets the access control level
   * permissions.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {Object} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  createOrUpdateUserApplicationAssociation(userID, applicationID, model, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._createOrUpdateUserApplicationAssociation(userID, applicationID, model, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._createOrUpdateUserApplicationAssociation(userID, applicationID, model, options, optionalCallback);
    }
  }

  /**
   * @summary Deletes a user application association;
   *
   * @param {number} userID The user identifier.
   *
   * @param {number} applicationID The application identifier.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Object>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  deleteUserApplicationAssociationWithHttpOperationResponse(userID, applicationID, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._deleteUserApplicationAssociation(userID, applicationID, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Deletes a user application association;
   *
   * @param {number} userID The user identifier.
   *
   * @param {number} applicationID The application identifier.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {Object} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  deleteUserApplicationAssociation(userID, applicationID, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._deleteUserApplicationAssociation(userID, applicationID, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._deleteUserApplicationAssociation(userID, applicationID, options, optionalCallback);
    }
  }

  /**
   * @summary Gets a paged list of attachment metadata.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {string} [options.type] Gets or sets the type. Possible values
   * include: 'Standard', 'EntityLink', 'WebLink'
   *
   * @param {string} [options.extension] Gets or sets the extension.
   *
   * @param {number} [options.minSize] Gets or sets the minimum size.
   *
   * @param {number} [options.maxSize] Gets or sets the maximum size.
   *
   * @param {number} [options.acl] Gets or sets the access control list.
   *
   * @param {number} [options.entityID] Gets or sets the entity identifier.
   *
   * @param {number} [options.drawerID] Gets or sets the drawer identifier.
   *
   * @param {string} [options.name] Gets or sets the name.
   *
   * @param {number} [options.creatorUserID] Gets or sets the creator user
   * identifier.
   *
   * @param {number} [options.modifierUserID] Gets or sets the modifier user
   * identifier.
   *
   * @param {date} [options.minInsertionTime] Gets or sets the minimum insertion
   * time.
   *
   * @param {date} [options.maxInsertionTime] Gets or sets the maximum insertion
   * time.
   *
   * @param {date} [options.minModificationTime] Gets or sets the minimum
   * modification time.
   *
   * @param {date} [options.maxModificationTime] Gets or sets the maximum
   * modification time.
   *
   * @param {number} [options.page] Gets or sets the page number.
   *
   * @param {number} [options.pageSize] Gets or sets the size of the page.
   *
   * @param {string} [options.sortOrder] Gets or sets the order. Possible values
   * include: 'Unspecified', 'Ascending', 'Descending'
   *
   * @param {string} [options.sortBy] Gets or sets the column to order by.
   * Possible values include: 'PageNumber', 'ID', 'Type', 'InsertionTime',
   * 'ModificationTime', 'CrossReferenceID', 'SubType', 'Extension', 'Name'
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Array>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getAttachmentsByFilterWithHttpOperationResponse(options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getAttachmentsByFilter(options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets a paged list of attachment metadata.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {string} [options.type] Gets or sets the type. Possible values
   * include: 'Standard', 'EntityLink', 'WebLink'
   *
   * @param {string} [options.extension] Gets or sets the extension.
   *
   * @param {number} [options.minSize] Gets or sets the minimum size.
   *
   * @param {number} [options.maxSize] Gets or sets the maximum size.
   *
   * @param {number} [options.acl] Gets or sets the access control list.
   *
   * @param {number} [options.entityID] Gets or sets the entity identifier.
   *
   * @param {number} [options.drawerID] Gets or sets the drawer identifier.
   *
   * @param {string} [options.name] Gets or sets the name.
   *
   * @param {number} [options.creatorUserID] Gets or sets the creator user
   * identifier.
   *
   * @param {number} [options.modifierUserID] Gets or sets the modifier user
   * identifier.
   *
   * @param {date} [options.minInsertionTime] Gets or sets the minimum insertion
   * time.
   *
   * @param {date} [options.maxInsertionTime] Gets or sets the maximum insertion
   * time.
   *
   * @param {date} [options.minModificationTime] Gets or sets the minimum
   * modification time.
   *
   * @param {date} [options.maxModificationTime] Gets or sets the maximum
   * modification time.
   *
   * @param {number} [options.page] Gets or sets the page number.
   *
   * @param {number} [options.pageSize] Gets or sets the size of the page.
   *
   * @param {string} [options.sortOrder] Gets or sets the order. Possible values
   * include: 'Unspecified', 'Ascending', 'Descending'
   *
   * @param {string} [options.sortBy] Gets or sets the column to order by.
   * Possible values include: 'PageNumber', 'ID', 'Type', 'InsertionTime',
   * 'ModificationTime', 'CrossReferenceID', 'SubType', 'Extension', 'Name'
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {Array} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {array} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getAttachmentsByFilter(options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getAttachmentsByFilter(options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getAttachmentsByFilter(options, optionalCallback);
    }
  }

  /**
   * @summary Gets a single attachment metadata based on its unique identifier.
   *
   * @param {number} drawer The drawer identifier.
   *
   * @param {number} id The attachment identifier.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<AttachmentModel>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getAttachmentByIdWithHttpOperationResponse(drawer, id, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getAttachmentById(drawer, id, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets a single attachment metadata based on its unique identifier.
   *
   * @param {number} drawer The drawer identifier.
   *
   * @param {number} id The attachment identifier.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {AttachmentModel} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link AttachmentModel} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getAttachmentById(drawer, id, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getAttachmentById(drawer, id, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getAttachmentById(drawer, id, options, optionalCallback);
    }
  }

  /**
   * @summary Updates a specified attachment's metadata..
   *
   * @param {number} drawer The drawer identifier.
   *
   * @param {number} id The attachment identifier.
   *
   * @param {object} model The model.
   *
   * @param {number} [model.category] Gets or sets the category.
   *
   * @param {number} [model.classProperty] Gets or sets the class.
   *
   * @param {string} [model.name] Gets or sets the name.
   *
   * @param {number} [model.acl] Gets or sets the acl.
   *
   * @param {number} [model.pageNumber] Gets or sets the page number.
   *
   * @param {string} [model.state] Gets or sets the state. Possible values
   * include: 'Undefined', 'MaxStates', 'Reserved', 'UserDefined', 'Dynamic',
   * 'Static', 'New', 'CheckedOut', 'Internal', 'Statres5', 'Linked', 'Statres4',
   * 'Statres3', 'Statres2', 'Statres1', 'Locked', 'OnServerCache',
   * 'OnClientCache', 'Fetching', 'Dynres4', 'Dynres3', 'Dynres2', 'Dynres1',
   * 'User1', 'User2', 'User3', 'User4', 'User5', 'User6', 'User7', 'User8',
   * 'User9', 'User10', 'User11', 'User12', 'User13', 'User14', 'User15',
   * 'User16'
   *
   * @param {string} [model.note] Gets or sets the note.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Object>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  updateAttachmentWithHttpOperationResponse(drawer, id, model, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._updateAttachment(drawer, id, model, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Updates a specified attachment's metadata..
   *
   * @param {number} drawer The drawer identifier.
   *
   * @param {number} id The attachment identifier.
   *
   * @param {object} model The model.
   *
   * @param {number} [model.category] Gets or sets the category.
   *
   * @param {number} [model.classProperty] Gets or sets the class.
   *
   * @param {string} [model.name] Gets or sets the name.
   *
   * @param {number} [model.acl] Gets or sets the acl.
   *
   * @param {number} [model.pageNumber] Gets or sets the page number.
   *
   * @param {string} [model.state] Gets or sets the state. Possible values
   * include: 'Undefined', 'MaxStates', 'Reserved', 'UserDefined', 'Dynamic',
   * 'Static', 'New', 'CheckedOut', 'Internal', 'Statres5', 'Linked', 'Statres4',
   * 'Statres3', 'Statres2', 'Statres1', 'Locked', 'OnServerCache',
   * 'OnClientCache', 'Fetching', 'Dynres4', 'Dynres3', 'Dynres2', 'Dynres1',
   * 'User1', 'User2', 'User3', 'User4', 'User5', 'User6', 'User7', 'User8',
   * 'User9', 'User10', 'User11', 'User12', 'User13', 'User14', 'User15',
   * 'User16'
   *
   * @param {string} [model.note] Gets or sets the note.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {Object} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  updateAttachment(drawer, id, model, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._updateAttachment(drawer, id, model, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._updateAttachment(drawer, id, model, options, optionalCallback);
    }
  }

  /**
   * @summary Deletes an attachment
   *
   * @param {number} drawer The drawer identifier.
   *
   * @param {number} id The attachment identifier.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Object>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  deleteAttachmentWithHttpOperationResponse(drawer, id, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._deleteAttachment(drawer, id, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Deletes an attachment
   *
   * @param {number} drawer The drawer identifier.
   *
   * @param {number} id The attachment identifier.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {Object} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  deleteAttachment(drawer, id, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._deleteAttachment(drawer, id, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._deleteAttachment(drawer, id, options, optionalCallback);
    }
  }

  /**
   * @summary Gets an attachment's file content.
   *
   * @param {number} drawer The drawer identifier.
   *
   * @param {number} id The attachment identifier.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Object>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getAttachmentFileContentWithHttpOperationResponse(drawer, id, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getAttachmentFileContent(drawer, id, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets an attachment's file content.
   *
   * @param {number} drawer The drawer identifier.
   *
   * @param {number} id The attachment identifier.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {Object} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getAttachmentFileContent(drawer, id, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getAttachmentFileContent(drawer, id, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getAttachmentFileContent(drawer, id, options, optionalCallback);
    }
  }

  /**
   * @summary Inserts a new file attachment.
   *
   * @param {number} drawer The drawer identifier.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<AttachmentModel>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  createAttachmentWithHttpOperationResponse(drawer, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._createAttachment(drawer, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Inserts a new file attachment.
   *
   * @param {number} drawer The drawer identifier.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {AttachmentModel} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link AttachmentModel} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  createAttachment(drawer, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._createAttachment(drawer, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._createAttachment(drawer, options, optionalCallback);
    }
  }

  /**
   * @summary Archives an attachment
   *
   * @param {number} drawer The drawer identifier.
   *
   * @param {number} id The attachment identifier.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Object>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  archiveAttachmentWithHttpOperationResponse(drawer, id, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._archiveAttachment(drawer, id, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Archives an attachment
   *
   * @param {number} drawer The drawer identifier.
   *
   * @param {number} id The attachment identifier.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {Object} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  archiveAttachment(drawer, id, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._archiveAttachment(drawer, id, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._archiveAttachment(drawer, id, options, optionalCallback);
    }
  }

  /**
   * @summary Gets the paged list of attachment versions.
   *
   * @param {number} drawer The drawer identifier.
   *
   * @param {number} id The attachment identifier.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.version] Gets or sets the indexed version value.
   *
   * @param {number} [options.creatorUserID] Gets or sets the creator identifier.
   *
   * @param {number} [options.accessorUserID] Gets or sets the identifier of the
   * user who accessed the attachment version.
   *
   * @param {date} [options.minAccessTime] Gets or sets the min time the version
   * was last accessed.
   *
   * @param {date} [options.maxAccessTime] Gets or sets the max time the version
   * was last accessed.
   *
   * @param {date} [options.minCreationTime] Gets or sets the min creation time
   * of the attachment version.
   *
   * @param {date} [options.maxCreationTime] Gets or sets the max creation time
   * of the attachment version.
   *
   * @param {date} [options.minModificationTime] Gets or sets the min
   * modification time of the attachment version.
   *
   * @param {date} [options.maxModificationTime] Gets or sets the max
   * modification time of the attachment version.
   *
   * @param {number} [options.page] Gets or sets the page number.
   *
   * @param {number} [options.pageSize] Gets or sets the size of the page.
   *
   * @param {string} [options.sortOrder] Gets or sets the order. Possible values
   * include: 'Unspecified', 'Ascending', 'Descending'
   *
   * @param {string} [options.sortBy] Gets or sets the column to order by.
   * Possible values include: 'Version', 'CreatorUserID', 'AccessorUserID',
   * 'AccessTime', 'CreationTime', 'ModificationTime'
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Array>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getAttachmentVersionsByFilterWithHttpOperationResponse(drawer, id, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getAttachmentVersionsByFilter(drawer, id, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets the paged list of attachment versions.
   *
   * @param {number} drawer The drawer identifier.
   *
   * @param {number} id The attachment identifier.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.version] Gets or sets the indexed version value.
   *
   * @param {number} [options.creatorUserID] Gets or sets the creator identifier.
   *
   * @param {number} [options.accessorUserID] Gets or sets the identifier of the
   * user who accessed the attachment version.
   *
   * @param {date} [options.minAccessTime] Gets or sets the min time the version
   * was last accessed.
   *
   * @param {date} [options.maxAccessTime] Gets or sets the max time the version
   * was last accessed.
   *
   * @param {date} [options.minCreationTime] Gets or sets the min creation time
   * of the attachment version.
   *
   * @param {date} [options.maxCreationTime] Gets or sets the max creation time
   * of the attachment version.
   *
   * @param {date} [options.minModificationTime] Gets or sets the min
   * modification time of the attachment version.
   *
   * @param {date} [options.maxModificationTime] Gets or sets the max
   * modification time of the attachment version.
   *
   * @param {number} [options.page] Gets or sets the page number.
   *
   * @param {number} [options.pageSize] Gets or sets the size of the page.
   *
   * @param {string} [options.sortOrder] Gets or sets the order. Possible values
   * include: 'Unspecified', 'Ascending', 'Descending'
   *
   * @param {string} [options.sortBy] Gets or sets the column to order by.
   * Possible values include: 'Version', 'CreatorUserID', 'AccessorUserID',
   * 'AccessTime', 'CreationTime', 'ModificationTime'
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {Array} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {array} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getAttachmentVersionsByFilter(drawer, id, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getAttachmentVersionsByFilter(drawer, id, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getAttachmentVersionsByFilter(drawer, id, options, optionalCallback);
    }
  }

  /**
   * @summary Gets a file for a specified attachment version.
   *
   * @param {number} drawer The drawer identifier.
   *
   * @param {number} id The attachment identifier.
   *
   * @param {number} versionID The version identifier.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Object>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getAttachmentVersionFileContentWithHttpOperationResponse(drawer, id, versionID, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getAttachmentVersionFileContent(drawer, id, versionID, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets a file for a specified attachment version.
   *
   * @param {number} drawer The drawer identifier.
   *
   * @param {number} id The attachment identifier.
   *
   * @param {number} versionID The version identifier.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {Object} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getAttachmentVersionFileContent(drawer, id, versionID, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getAttachmentVersionFileContent(drawer, id, versionID, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getAttachmentVersionFileContent(drawer, id, versionID, options, optionalCallback);
    }
  }

  /**
   * @summary Checks out the attachment file.
   *
   * @param {number} drawer The drawer identifier.
   *
   * @param {number} id The attachment identifier.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Object>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  checkOutAttachmentWithHttpOperationResponse(drawer, id, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._checkOutAttachment(drawer, id, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Checks out the attachment file.
   *
   * @param {number} drawer The drawer identifier.
   *
   * @param {number} id The attachment identifier.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {Object} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  checkOutAttachment(drawer, id, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._checkOutAttachment(drawer, id, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._checkOutAttachment(drawer, id, options, optionalCallback);
    }
  }

  /**
   * @summary Undoes the attachment check out of the attachment file.
   *
   * @param {number} drawer The drawer identifier.
   *
   * @param {number} id The attachment identifier.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Object>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  undoCheckOutAttachmentWithHttpOperationResponse(drawer, id, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._undoCheckOutAttachment(drawer, id, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Undoes the attachment check out of the attachment file.
   *
   * @param {number} drawer The drawer identifier.
   *
   * @param {number} id The attachment identifier.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {Object} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  undoCheckOutAttachment(drawer, id, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._undoCheckOutAttachment(drawer, id, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._undoCheckOutAttachment(drawer, id, options, optionalCallback);
    }
  }

  /**
   * @summary Checks in the new version of attachment file.
   *
   * @param {number} drawer The drawer identifier.
   *
   * @param {number} id The attachment identifier.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Object>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  checkInAttachmentWithHttpOperationResponse(drawer, id, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._checkInAttachment(drawer, id, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Checks in the new version of attachment file.
   *
   * @param {number} drawer The drawer identifier.
   *
   * @param {number} id The attachment identifier.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {Object} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  checkInAttachment(drawer, id, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._checkInAttachment(drawer, id, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._checkInAttachment(drawer, id, options, optionalCallback);
    }
  }

  /**
   * @summary Rolls back to a specified version the attachment file.
   *
   * @param {number} drawer The drawer identifier.
   *
   * @param {number} id The attachment identifier.
   *
   * @param {number} versionID The version identifier.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Object>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  rollbackAttachmentVersionWithHttpOperationResponse(drawer, id, versionID, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._rollbackAttachmentVersion(drawer, id, versionID, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Rolls back to a specified version the attachment file.
   *
   * @param {number} drawer The drawer identifier.
   *
   * @param {number} id The attachment identifier.
   *
   * @param {number} versionID The version identifier.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {Object} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  rollbackAttachmentVersion(drawer, id, versionID, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._rollbackAttachmentVersion(drawer, id, versionID, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._rollbackAttachmentVersion(drawer, id, versionID, options, optionalCallback);
    }
  }

  /**
   * @summary Gets a list of all available drawers.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Array>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getAllDrawersWithHttpOperationResponse(options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getAllDrawers(options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets a list of all available drawers.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {Array} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {array} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getAllDrawers(options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getAllDrawers(options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getAllDrawers(options, optionalCallback);
    }
  }

  /**
   * @summary Gets a single drawer by its unique identifier.
   *
   * @param {number} id The drawer identifier.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<DrawerModel>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getDrawerByIdWithHttpOperationResponse(id, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getDrawerById(id, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets a single drawer by its unique identifier.
   *
   * @param {number} id The drawer identifier.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {DrawerModel} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link DrawerModel} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getDrawerById(id, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getDrawerById(id, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getDrawerById(id, options, optionalCallback);
    }
  }

  /**
   * @summary Updates a specified drawer.
   *
   * @param {number} id The drawer identifier.
   *
   * @param {object} model The model.
   *
   * @param {string} model.name Gets or sets the name.
   *
   * @param {number} [model.edition] Gets or sets the edition.
   *
   * @param {number} [model.state] Gets or sets the state.
   *
   * @param {number} [model.entityFeature] Gets or sets the entity feature.
   *
   * @param {number} [model.attachmentFeature] Gets or sets the attachment
   * feature.
   *
   * @param {number} [model.noteFeature] Gets or sets the note feature.
   *
   * @param {number} [model.reservedInt1] Gets or sets the reserved integer 1.
   *
   * @param {number} [model.reservedInt2] Gets or sets the reserved integer 2.
   *
   * @param {string} [model.reservedString1] Gets or sets the reserved string1.
   *
   * @param {string} [model.reservedString2] Gets or sets the reserved string2.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Object>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  updateDrawerWithHttpOperationResponse(id, model, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._updateDrawer(id, model, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Updates a specified drawer.
   *
   * @param {number} id The drawer identifier.
   *
   * @param {object} model The model.
   *
   * @param {string} model.name Gets or sets the name.
   *
   * @param {number} [model.edition] Gets or sets the edition.
   *
   * @param {number} [model.state] Gets or sets the state.
   *
   * @param {number} [model.entityFeature] Gets or sets the entity feature.
   *
   * @param {number} [model.attachmentFeature] Gets or sets the attachment
   * feature.
   *
   * @param {number} [model.noteFeature] Gets or sets the note feature.
   *
   * @param {number} [model.reservedInt1] Gets or sets the reserved integer 1.
   *
   * @param {number} [model.reservedInt2] Gets or sets the reserved integer 2.
   *
   * @param {string} [model.reservedString1] Gets or sets the reserved string1.
   *
   * @param {string} [model.reservedString2] Gets or sets the reserved string2.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {Object} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  updateDrawer(id, model, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._updateDrawer(id, model, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._updateDrawer(id, model, options, optionalCallback);
    }
  }

  /**
   * @summary Gets a single drawer by its name.
   *
   * @param {string} name The drawer name.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<DrawerModel>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getDrawerByNameWithHttpOperationResponse(name, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getDrawerByName(name, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets a single drawer by its name.
   *
   * @param {string} name The drawer name.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {DrawerModel} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link DrawerModel} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getDrawerByName(name, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getDrawerByName(name, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getDrawerByName(name, options, optionalCallback);
    }
  }

  /**
   * @summary Gets a paged list of entity summaries.
   *
   * @param {number} drawerID Gets or sets the drawer identifier.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.acl] Gets or sets the access control list.
   *
   * @param {number} [options.type] Gets or sets the type of the entity.
   *
   * @param {string} [options.name] Gets or sets the name.
   *
   * @param {string} [options.state] Gets or sets the state. Possible values
   * include: 'Undefined', 'Available', 'Locked', 'Suspended', 'Archived',
   * 'Deleted', 'Canceled', 'Complete', 'Reviewed', 'ReviewedSuspended',
   * 'ReviewedComplete', 'Rejected', 'RoutingSlipOpen', 'ReviewedRoutingSlipOpen'
   *
   * @param {number} [options.referenceCount] Gets or sets the reference count.
   *
   * @param {number} [options.attachCount] Gets or sets the attach count.
   *
   * @param {number} [options.noteCount] Gets or sets the note count.
   *
   * @param {number} [options.ownerUserID] Gets or sets the owner user
   * identifier.
   *
   * @param {number} [options.ownerGroupID] Gets or sets the owner group
   * identifier.
   *
   * @param {number} [options.creatorUserID] Gets or sets the creator user
   * identifier.
   *
   * @param {number} [options.creatorGroupID] Gets or sets the creator group
   * identifier.
   *
   * @param {number} [options.modifierUserID] Gets or sets the modifier user
   * identifier.
   *
   * @param {number} [options.modifierGroupID] Gets or sets the modifier group
   * identifier.
   *
   * @param {date} [options.minCreationTime] Gets or sets the minimum creation
   * time.
   *
   * @param {date} [options.maxCreationTime] Gets or sets the maximum creation
   * time.
   *
   * @param {date} [options.minModificationTime] Gets or sets the minimum
   * modification time.
   *
   * @param {date} [options.maxModificationTime] Gets or sets the maximum
   * modification time.
   *
   * @param {array} [options.metadata] Gets or sets the metadata.
   *
   * @param {number} [options.page] Gets or sets the page number.
   *
   * @param {number} [options.pageSize] Gets or sets the size of the page.
   *
   * @param {string} [options.sortOrder] Gets or sets the order. Possible values
   * include: 'Unspecified', 'Ascending', 'Descending'
   *
   * @param {string} [options.sortBy] Gets or sets the column to order by.
   * Possible values include: 'ID', 'Type', 'CreationTime', 'ModificationTime',
   * 'State', 'Name'
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Array>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getEntitiesByFilterWithHttpOperationResponse(drawerID, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getEntitiesByFilter(drawerID, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets a paged list of entity summaries.
   *
   * @param {number} drawerID Gets or sets the drawer identifier.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.acl] Gets or sets the access control list.
   *
   * @param {number} [options.type] Gets or sets the type of the entity.
   *
   * @param {string} [options.name] Gets or sets the name.
   *
   * @param {string} [options.state] Gets or sets the state. Possible values
   * include: 'Undefined', 'Available', 'Locked', 'Suspended', 'Archived',
   * 'Deleted', 'Canceled', 'Complete', 'Reviewed', 'ReviewedSuspended',
   * 'ReviewedComplete', 'Rejected', 'RoutingSlipOpen', 'ReviewedRoutingSlipOpen'
   *
   * @param {number} [options.referenceCount] Gets or sets the reference count.
   *
   * @param {number} [options.attachCount] Gets or sets the attach count.
   *
   * @param {number} [options.noteCount] Gets or sets the note count.
   *
   * @param {number} [options.ownerUserID] Gets or sets the owner user
   * identifier.
   *
   * @param {number} [options.ownerGroupID] Gets or sets the owner group
   * identifier.
   *
   * @param {number} [options.creatorUserID] Gets or sets the creator user
   * identifier.
   *
   * @param {number} [options.creatorGroupID] Gets or sets the creator group
   * identifier.
   *
   * @param {number} [options.modifierUserID] Gets or sets the modifier user
   * identifier.
   *
   * @param {number} [options.modifierGroupID] Gets or sets the modifier group
   * identifier.
   *
   * @param {date} [options.minCreationTime] Gets or sets the minimum creation
   * time.
   *
   * @param {date} [options.maxCreationTime] Gets or sets the maximum creation
   * time.
   *
   * @param {date} [options.minModificationTime] Gets or sets the minimum
   * modification time.
   *
   * @param {date} [options.maxModificationTime] Gets or sets the maximum
   * modification time.
   *
   * @param {array} [options.metadata] Gets or sets the metadata.
   *
   * @param {number} [options.page] Gets or sets the page number.
   *
   * @param {number} [options.pageSize] Gets or sets the size of the page.
   *
   * @param {string} [options.sortOrder] Gets or sets the order. Possible values
   * include: 'Unspecified', 'Ascending', 'Descending'
   *
   * @param {string} [options.sortBy] Gets or sets the column to order by.
   * Possible values include: 'ID', 'Type', 'CreationTime', 'ModificationTime',
   * 'State', 'Name'
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {Array} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {array} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getEntitiesByFilter(drawerID, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getEntitiesByFilter(drawerID, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getEntitiesByFilter(drawerID, options, optionalCallback);
    }
  }

  /**
   * @summary Gets a single entity complete with all profile metadata.
   *
   * @param {number} drawer The drawer identifier.
   *
   * @param {number} id The entity identifier.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<EntityModel>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getEntityByIdWithHttpOperationResponse(drawer, id, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getEntityById(drawer, id, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets a single entity complete with all profile metadata.
   *
   * @param {number} drawer The drawer identifier.
   *
   * @param {number} id The entity identifier.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {EntityModel} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link EntityModel} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getEntityById(drawer, id, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getEntityById(drawer, id, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getEntityById(drawer, id, options, optionalCallback);
    }
  }

  /**
   * @summary Updates a specified entity.
   *
   * @param {number} drawer The drawer identifier.
   *
   * @param {number} id The entity identifier.
   *
   * @param {object} model The entity model.
   *
   * @param {array} [model.profiles] Gets or sets the profiles.
   *
   * @param {string} [model.state] Gets or sets the state. Possible values
   * include: 'Undefined', 'Available', 'Locked', 'Suspended', 'Archived',
   * 'Deleted', 'Canceled', 'Complete', 'Reviewed', 'ReviewedSuspended',
   * 'ReviewedComplete', 'Rejected', 'RoutingSlipOpen', 'ReviewedRoutingSlipOpen'
   *
   * @param {string} [model.name] Gets or sets the name.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Object>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  updateEntityWithHttpOperationResponse(drawer, id, model, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._updateEntity(drawer, id, model, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Updates a specified entity.
   *
   * @param {number} drawer The drawer identifier.
   *
   * @param {number} id The entity identifier.
   *
   * @param {object} model The entity model.
   *
   * @param {array} [model.profiles] Gets or sets the profiles.
   *
   * @param {string} [model.state] Gets or sets the state. Possible values
   * include: 'Undefined', 'Available', 'Locked', 'Suspended', 'Archived',
   * 'Deleted', 'Canceled', 'Complete', 'Reviewed', 'ReviewedSuspended',
   * 'ReviewedComplete', 'Rejected', 'RoutingSlipOpen', 'ReviewedRoutingSlipOpen'
   *
   * @param {string} [model.name] Gets or sets the name.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {Object} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  updateEntity(drawer, id, model, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._updateEntity(drawer, id, model, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._updateEntity(drawer, id, model, options, optionalCallback);
    }
  }

  /**
   * @summary Deletes a specified entity.
   *
   * @param {number} drawer The drawer identifier.
   *
   * @param {number} id The entity identifier.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Object>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  deleteEntityWithHttpOperationResponse(drawer, id, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._deleteEntity(drawer, id, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Deletes a specified entity.
   *
   * @param {number} drawer The drawer identifier.
   *
   * @param {number} id The entity identifier.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {Object} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  deleteEntity(drawer, id, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._deleteEntity(drawer, id, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._deleteEntity(drawer, id, options, optionalCallback);
    }
  }

  /**
   * @summary Creates a new entity.
   *
   * @param {number} drawer The drawer identifier.
   *
   * @param {object} model The entity model.
   *
   * @param {array} [model.profiles] Gets or sets the profiles.
   *
   * @param {number} [model.acl] Gets or sets the access control list.
   *
   * @param {number} [model.type] Gets or sets the type.
   *
   * @param {string} model.name Gets or sets the Name.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<EntityModel>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  createEntityWithHttpOperationResponse(drawer, model, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._createEntity(drawer, model, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Creates a new entity.
   *
   * @param {number} drawer The drawer identifier.
   *
   * @param {object} model The entity model.
   *
   * @param {array} [model.profiles] Gets or sets the profiles.
   *
   * @param {number} [model.acl] Gets or sets the access control list.
   *
   * @param {number} [model.type] Gets or sets the type.
   *
   * @param {string} model.name Gets or sets the Name.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {EntityModel} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link EntityModel} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  createEntity(drawer, model, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._createEntity(drawer, model, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._createEntity(drawer, model, options, optionalCallback);
    }
  }

  /**
   * @summary Copies the contents of an entity.
   *
   * @param {number} drawer The drawer.
   *
   * @param {number} id The entity identifier.
   *
   * @param {object} model The model.
   *
   * @param {string} [model.entityContent] Gets or sets the content of the
   * entity. Possible values include: 'None', 'All', 'Profiles', 'Attachments',
   * 'Notes', 'Links', 'Events'
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<EntityModel>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  copyEntityWithHttpOperationResponse(drawer, id, model, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._copyEntity(drawer, id, model, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Copies the contents of an entity.
   *
   * @param {number} drawer The drawer.
   *
   * @param {number} id The entity identifier.
   *
   * @param {object} model The model.
   *
   * @param {string} [model.entityContent] Gets or sets the content of the
   * entity. Possible values include: 'None', 'All', 'Profiles', 'Attachments',
   * 'Notes', 'Links', 'Events'
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {EntityModel} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link EntityModel} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  copyEntity(drawer, id, model, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._copyEntity(drawer, id, model, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._copyEntity(drawer, id, model, options, optionalCallback);
    }
  }

  /**
   * @summary Gets a paged list of events.
   *
   * @param {number} drawerID Gets or sets the drawer identifier.
   *
   * @param {number} entityID Gets or sets the entity identifier.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {string} [options.type] Gets or sets the type. Possible values
   * include: 'Undefined', 'Fatal', 'Warning', 'Info', 'Debug', 'Process', 'RPC',
   * 'SQL', 'DDE'
   *
   * @param {date} [options.minEventTime] Gets or sets the minimum event time.
   *
   * @param {date} [options.maxEventTime] Gets or sets the maximum event time.
   *
   * @param {number} [options.eventUserID] Gets or sets the event user
   * identifier.
   *
   * @param {number} [options.eventGroupID] Gets or sets the event group
   * identifier.
   *
   * @param {string} [options.category] Gets or sets the category. Possible
   * values include: 'Undefined', 'Entity', 'Profile', 'Attachment',
   * 'Discussion', 'Field', 'Workflow'
   *
   * @param {string} [options.classProperty] Gets or sets the class. Possible
   * values include: 'Undefined', 'Application', 'Security', 'System'
   *
   * @param {string} [options.operation] Gets or sets the operation. Possible
   * values include: 'Undefined', 'Insert', 'Update', 'Delete', 'Copy', 'Lock',
   * 'Unlock', 'Open', 'Close', 'Checkout', 'Checkin', 'View', 'Merge', 'Split',
   * 'Classify', 'Null', 'OpenWF', 'Remove', 'ReturnToTop', 'ReturnToBottom',
   * 'Accept', 'Suspend', 'Reject', 'Route', 'Forward', 'Reply', 'Reassign',
   * 'Reset', 'Override', 'Rollback', 'Archive'
   *
   * @param {number} [options.minProcessingTime] Gets or sets the minimum
   * processing time.
   *
   * @param {number} [options.maxProcessingTime] Gets or sets the maximum
   * processing time.
   *
   * @param {number} [options.page] Gets or sets the page number.
   *
   * @param {number} [options.pageSize] Gets or sets the size of the page.
   *
   * @param {string} [options.sortOrder] Gets or sets the order. Possible values
   * include: 'Unspecified', 'Ascending', 'Descending'
   *
   * @param {string} [options.sortBy] Gets or sets the column to order by.
   * Possible values include: 'ID', 'Type', 'EventTime'
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Array>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getEventsByFilterWithHttpOperationResponse(drawerID, entityID, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getEventsByFilter(drawerID, entityID, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets a paged list of events.
   *
   * @param {number} drawerID Gets or sets the drawer identifier.
   *
   * @param {number} entityID Gets or sets the entity identifier.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {string} [options.type] Gets or sets the type. Possible values
   * include: 'Undefined', 'Fatal', 'Warning', 'Info', 'Debug', 'Process', 'RPC',
   * 'SQL', 'DDE'
   *
   * @param {date} [options.minEventTime] Gets or sets the minimum event time.
   *
   * @param {date} [options.maxEventTime] Gets or sets the maximum event time.
   *
   * @param {number} [options.eventUserID] Gets or sets the event user
   * identifier.
   *
   * @param {number} [options.eventGroupID] Gets or sets the event group
   * identifier.
   *
   * @param {string} [options.category] Gets or sets the category. Possible
   * values include: 'Undefined', 'Entity', 'Profile', 'Attachment',
   * 'Discussion', 'Field', 'Workflow'
   *
   * @param {string} [options.classProperty] Gets or sets the class. Possible
   * values include: 'Undefined', 'Application', 'Security', 'System'
   *
   * @param {string} [options.operation] Gets or sets the operation. Possible
   * values include: 'Undefined', 'Insert', 'Update', 'Delete', 'Copy', 'Lock',
   * 'Unlock', 'Open', 'Close', 'Checkout', 'Checkin', 'View', 'Merge', 'Split',
   * 'Classify', 'Null', 'OpenWF', 'Remove', 'ReturnToTop', 'ReturnToBottom',
   * 'Accept', 'Suspend', 'Reject', 'Route', 'Forward', 'Reply', 'Reassign',
   * 'Reset', 'Override', 'Rollback', 'Archive'
   *
   * @param {number} [options.minProcessingTime] Gets or sets the minimum
   * processing time.
   *
   * @param {number} [options.maxProcessingTime] Gets or sets the maximum
   * processing time.
   *
   * @param {number} [options.page] Gets or sets the page number.
   *
   * @param {number} [options.pageSize] Gets or sets the size of the page.
   *
   * @param {string} [options.sortOrder] Gets or sets the order. Possible values
   * include: 'Unspecified', 'Ascending', 'Descending'
   *
   * @param {string} [options.sortBy] Gets or sets the column to order by.
   * Possible values include: 'ID', 'Type', 'EventTime'
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {Array} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {array} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getEventsByFilter(drawerID, entityID, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getEventsByFilter(drawerID, entityID, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getEventsByFilter(drawerID, entityID, options, optionalCallback);
    }
  }

  /**
   * @summary Retrieves a single event based on its unique identifier.
   *
   * @param {number} drawer The drawer identifier.
   *
   * @param {number} id The event identifier.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<EventModel>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getEventByIdWithHttpOperationResponse(drawer, id, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getEventById(drawer, id, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Retrieves a single event based on its unique identifier.
   *
   * @param {number} drawer The drawer identifier.
   *
   * @param {number} id The event identifier.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {EventModel} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link EventModel} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getEventById(drawer, id, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getEventById(drawer, id, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getEventById(drawer, id, options, optionalCallback);
    }
  }

  /**
   * @summary Creates a new event.
   *
   * @param {number} drawer The drawer identifier.
   *
   * @param {object} model The event model.
   *
   * @param {number} [model.id] Gets or sets the identifier.
   *
   * @param {number} [model.drawerID] Gets or sets the drawer identifier.
   *
   * @param {number} [model.entityID] Gets or sets the entity identifier.
   *
   * @param {string} [model.type] Gets or sets the type. Possible values include:
   * 'Undefined', 'Fatal', 'Warning', 'Info', 'Debug', 'Process', 'RPC', 'SQL',
   * 'DDE'
   *
   * @param {date} [model.eventTime] Gets or sets the event time.
   *
   * @param {number} [model.eventUserID] Gets or sets the event user identifier.
   *
   * @param {string} [model.eventUserFullName] Gets or sets the full name of the
   * event user.
   *
   * @param {number} [model.eventGroupID] Gets or sets the event group
   * identifier.
   *
   * @param {string} [model.eventGroupName] Gets or sets the name of the event
   * group.
   *
   * @param {string} [model.category] Gets or sets the category. Possible values
   * include: 'Undefined', 'Entity', 'Profile', 'Attachment', 'Discussion',
   * 'Field', 'Workflow'
   *
   * @param {string} [model.classProperty] Gets or sets the class. Possible
   * values include: 'Undefined', 'Application', 'Security', 'System'
   *
   * @param {string} [model.operation] Gets or sets the operation. Possible
   * values include: 'Undefined', 'Insert', 'Update', 'Delete', 'Copy', 'Lock',
   * 'Unlock', 'Open', 'Close', 'Checkout', 'Checkin', 'View', 'Merge', 'Split',
   * 'Classify', 'Null', 'OpenWF', 'Remove', 'ReturnToTop', 'ReturnToBottom',
   * 'Accept', 'Suspend', 'Reject', 'Route', 'Forward', 'Reply', 'Reassign',
   * 'Reset', 'Override', 'Rollback', 'Archive'
   *
   * @param {string} [model.source] Gets or sets the source.
   *
   * @param {string} [model.computer] Gets or sets the computer.
   *
   * @param {string} [model.iPAddress] Gets or sets the ip address.
   *
   * @param {string} [model.description] Gets or sets the description.
   *
   * @param {number} [model.processTime] Gets or sets the process time.
   *
   * @param {object} [model.details] Gets or sets the details.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<EventModel>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  createEventWithHttpOperationResponse(drawer, model, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._createEvent(drawer, model, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Creates a new event.
   *
   * @param {number} drawer The drawer identifier.
   *
   * @param {object} model The event model.
   *
   * @param {number} [model.id] Gets or sets the identifier.
   *
   * @param {number} [model.drawerID] Gets or sets the drawer identifier.
   *
   * @param {number} [model.entityID] Gets or sets the entity identifier.
   *
   * @param {string} [model.type] Gets or sets the type. Possible values include:
   * 'Undefined', 'Fatal', 'Warning', 'Info', 'Debug', 'Process', 'RPC', 'SQL',
   * 'DDE'
   *
   * @param {date} [model.eventTime] Gets or sets the event time.
   *
   * @param {number} [model.eventUserID] Gets or sets the event user identifier.
   *
   * @param {string} [model.eventUserFullName] Gets or sets the full name of the
   * event user.
   *
   * @param {number} [model.eventGroupID] Gets or sets the event group
   * identifier.
   *
   * @param {string} [model.eventGroupName] Gets or sets the name of the event
   * group.
   *
   * @param {string} [model.category] Gets or sets the category. Possible values
   * include: 'Undefined', 'Entity', 'Profile', 'Attachment', 'Discussion',
   * 'Field', 'Workflow'
   *
   * @param {string} [model.classProperty] Gets or sets the class. Possible
   * values include: 'Undefined', 'Application', 'Security', 'System'
   *
   * @param {string} [model.operation] Gets or sets the operation. Possible
   * values include: 'Undefined', 'Insert', 'Update', 'Delete', 'Copy', 'Lock',
   * 'Unlock', 'Open', 'Close', 'Checkout', 'Checkin', 'View', 'Merge', 'Split',
   * 'Classify', 'Null', 'OpenWF', 'Remove', 'ReturnToTop', 'ReturnToBottom',
   * 'Accept', 'Suspend', 'Reject', 'Route', 'Forward', 'Reply', 'Reassign',
   * 'Reset', 'Override', 'Rollback', 'Archive'
   *
   * @param {string} [model.source] Gets or sets the source.
   *
   * @param {string} [model.computer] Gets or sets the computer.
   *
   * @param {string} [model.iPAddress] Gets or sets the ip address.
   *
   * @param {string} [model.description] Gets or sets the description.
   *
   * @param {number} [model.processTime] Gets or sets the process time.
   *
   * @param {object} [model.details] Gets or sets the details.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {EventModel} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link EventModel} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  createEvent(drawer, model, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._createEvent(drawer, model, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._createEvent(drawer, model, options, optionalCallback);
    }
  }

  /**
   * @summary Gets a paged list of extension rows
   *
   * @param {number} drawerID Gets or sets the drawer identifier.
   *
   * @param {number} entityID Gets or sets the entity identifier.
   *
   * @param {number} profileID Gets or sets the profile identifier.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.iD] Gets or sets the extension identifier.
   *
   * @param {number} [options.type] Gets or sets the type of the extension.
   *
   * @param {number} [options.page] Gets or sets the page number.
   *
   * @param {number} [options.pageSize] Gets or sets the size of the page.
   *
   * @param {string} [options.sortOrder] Gets or sets the order. Possible values
   * include: 'Unspecified', 'Ascending', 'Descending'
   *
   * @param {string} [options.sortBy] Gets or sets the column to order by.
   * Possible values include: 'RowNumber', 'ID', 'Type', 'String', 'Integer',
   * 'Double', 'Date'
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Array>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getExtensionsByFilterWithHttpOperationResponse(drawerID, entityID, profileID, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getExtensionsByFilter(drawerID, entityID, profileID, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets a paged list of extension rows
   *
   * @param {number} drawerID Gets or sets the drawer identifier.
   *
   * @param {number} entityID Gets or sets the entity identifier.
   *
   * @param {number} profileID Gets or sets the profile identifier.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.iD] Gets or sets the extension identifier.
   *
   * @param {number} [options.type] Gets or sets the type of the extension.
   *
   * @param {number} [options.page] Gets or sets the page number.
   *
   * @param {number} [options.pageSize] Gets or sets the size of the page.
   *
   * @param {string} [options.sortOrder] Gets or sets the order. Possible values
   * include: 'Unspecified', 'Ascending', 'Descending'
   *
   * @param {string} [options.sortBy] Gets or sets the column to order by.
   * Possible values include: 'RowNumber', 'ID', 'Type', 'String', 'Integer',
   * 'Double', 'Date'
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {Array} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {array} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getExtensionsByFilter(drawerID, entityID, profileID, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getExtensionsByFilter(drawerID, entityID, profileID, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getExtensionsByFilter(drawerID, entityID, profileID, options, optionalCallback);
    }
  }

  /**
   * @summary Gets a paged list of flows.
   *
   * @param {number} drawerID Gets or sets the drawer identifier.
   *
   * @param {number} entityID Gets or sets the entity identifier.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {string} [options.type] Gets or sets the type. Possible values
   * include: 'None', 'Workflow', 'Fatal', 'Warning', 'Info', 'Debug', 'Process',
   * 'Rpc', 'Sql', 'Dde'
   *
   * @param {number} [options.queueID] Gets or sets the queue identifier.
   *
   * @param {date} [options.minWorkflowTime] Gets or sets the minimum workflow
   * time.
   *
   * @param {date} [options.maxWorkflowTime] Gets or sets the maximum workflow
   * time.
   *
   * @param {date} [options.minInsertionTime] Gets or sets the minimum insertion
   * time.
   *
   * @param {date} [options.maxInsertionTime] Gets or sets the maximum insertion
   * time.
   *
   * @param {number} [options.workflowUserID] Gets or sets the workflow user
   * identifier.
   *
   * @param {number} [options.workflowGroupID] Gets or sets the workflow group
   * identifier.
   *
   * @param {string} [options.operation] Gets or sets the operation. Possible
   * values include: 'None', 'Update', 'Reset', 'Override', 'Null'
   *
   * @param {string} [options.category] Gets or sets the category. Possible
   * values include: 'None', 'Direct', 'AdHoc', 'Production', 'Review', 'Reset',
   * 'RoutingSlip', 'ReviewRoutingSlip', 'Override'
   *
   * @param {string} [options.status] Gets or sets the status. Possible values
   * include: 'None', 'Approved', 'Rejected', 'Suspended', 'ApprovedR', 'NoneR'
   *
   * @param {string} [options.state] Gets or sets the state. Possible values
   * include: 'None', 'Processed', 'Pending', 'Waiting', 'ProcessedR',
   * 'Override', 'OverrideR', 'WaitingR'
   *
   * @param {number} [options.minIndex1] Gets or sets the minimum index 1.
   *
   * @param {number} [options.maxIndex1] Gets or sets the maximum index 1.
   *
   * @param {number} [options.minIndex2] Gets or sets the minimum index 2.
   *
   * @param {number} [options.maxIndex2] Gets or sets the maximum index 2.
   *
   * @param {number} [options.page] Gets or sets the page number.
   *
   * @param {number} [options.pageSize] Gets or sets the size of the page.
   *
   * @param {string} [options.sortOrder] Gets or sets the order. Possible values
   * include: 'Unspecified', 'Ascending', 'Descending'
   *
   * @param {string} [options.sortBy] Gets or sets the column to order by.
   * Possible values include: 'ID', 'Type', 'QueueID', 'WorkflowTime',
   * 'InsertionTime', 'Index'
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Array>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getFlowsByFilterWithHttpOperationResponse(drawerID, entityID, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getFlowsByFilter(drawerID, entityID, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets a paged list of flows.
   *
   * @param {number} drawerID Gets or sets the drawer identifier.
   *
   * @param {number} entityID Gets or sets the entity identifier.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {string} [options.type] Gets or sets the type. Possible values
   * include: 'None', 'Workflow', 'Fatal', 'Warning', 'Info', 'Debug', 'Process',
   * 'Rpc', 'Sql', 'Dde'
   *
   * @param {number} [options.queueID] Gets or sets the queue identifier.
   *
   * @param {date} [options.minWorkflowTime] Gets or sets the minimum workflow
   * time.
   *
   * @param {date} [options.maxWorkflowTime] Gets or sets the maximum workflow
   * time.
   *
   * @param {date} [options.minInsertionTime] Gets or sets the minimum insertion
   * time.
   *
   * @param {date} [options.maxInsertionTime] Gets or sets the maximum insertion
   * time.
   *
   * @param {number} [options.workflowUserID] Gets or sets the workflow user
   * identifier.
   *
   * @param {number} [options.workflowGroupID] Gets or sets the workflow group
   * identifier.
   *
   * @param {string} [options.operation] Gets or sets the operation. Possible
   * values include: 'None', 'Update', 'Reset', 'Override', 'Null'
   *
   * @param {string} [options.category] Gets or sets the category. Possible
   * values include: 'None', 'Direct', 'AdHoc', 'Production', 'Review', 'Reset',
   * 'RoutingSlip', 'ReviewRoutingSlip', 'Override'
   *
   * @param {string} [options.status] Gets or sets the status. Possible values
   * include: 'None', 'Approved', 'Rejected', 'Suspended', 'ApprovedR', 'NoneR'
   *
   * @param {string} [options.state] Gets or sets the state. Possible values
   * include: 'None', 'Processed', 'Pending', 'Waiting', 'ProcessedR',
   * 'Override', 'OverrideR', 'WaitingR'
   *
   * @param {number} [options.minIndex1] Gets or sets the minimum index 1.
   *
   * @param {number} [options.maxIndex1] Gets or sets the maximum index 1.
   *
   * @param {number} [options.minIndex2] Gets or sets the minimum index 2.
   *
   * @param {number} [options.maxIndex2] Gets or sets the maximum index 2.
   *
   * @param {number} [options.page] Gets or sets the page number.
   *
   * @param {number} [options.pageSize] Gets or sets the size of the page.
   *
   * @param {string} [options.sortOrder] Gets or sets the order. Possible values
   * include: 'Unspecified', 'Ascending', 'Descending'
   *
   * @param {string} [options.sortBy] Gets or sets the column to order by.
   * Possible values include: 'ID', 'Type', 'QueueID', 'WorkflowTime',
   * 'InsertionTime', 'Index'
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {Array} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {array} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getFlowsByFilter(drawerID, entityID, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getFlowsByFilter(drawerID, entityID, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getFlowsByFilter(drawerID, entityID, options, optionalCallback);
    }
  }

  /**
   * @summary Gets a single flow based on its unique identifier.
   *
   * @param {number} drawer The drawer identifier.
   *
   * @param {number} id The flow identifier.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<FlowModel>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getFlowByIdWithHttpOperationResponse(drawer, id, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getFlowById(drawer, id, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets a single flow based on its unique identifier.
   *
   * @param {number} drawer The drawer identifier.
   *
   * @param {number} id The flow identifier.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {FlowModel} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link FlowModel} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getFlowById(drawer, id, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getFlowById(drawer, id, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getFlowById(drawer, id, options, optionalCallback);
    }
  }

  /**
   * @summary Gets a paged list of entity template definitions.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.drawerID] Gets or sets the drawer identifier.
   *
   * @param {string} [options.name] Gets or sets the name.
   *
   * @param {string} [options.category] Gets or sets the category.
   *
   * @param {number} [options.page] Gets or sets the page number.
   *
   * @param {number} [options.pageSize] Gets or sets the size of the page.
   *
   * @param {string} [options.sortOrder] Gets or sets the order. Possible values
   * include: 'Unspecified', 'Ascending', 'Descending'
   *
   * @param {number} [options.sortBy] Gets or sets the column to order by.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Array>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getTemplatesByFilterWithHttpOperationResponse(options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getTemplatesByFilter(options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets a paged list of entity template definitions.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.drawerID] Gets or sets the drawer identifier.
   *
   * @param {string} [options.name] Gets or sets the name.
   *
   * @param {string} [options.category] Gets or sets the category.
   *
   * @param {number} [options.page] Gets or sets the page number.
   *
   * @param {number} [options.pageSize] Gets or sets the size of the page.
   *
   * @param {string} [options.sortOrder] Gets or sets the order. Possible values
   * include: 'Unspecified', 'Ascending', 'Descending'
   *
   * @param {number} [options.sortBy] Gets or sets the column to order by.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {Array} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {array} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getTemplatesByFilter(options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getTemplatesByFilter(options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getTemplatesByFilter(options, optionalCallback);
    }
  }

  /**
   * @summary Creates a new entity template definition.
   *
   * @param {object} model The entity template model.
   *
   * @param {number} model.type Gets or sets the type of template.
   *
   * @param {string} model.category Gets or sets the category of template.
   *
   * @param {string} model.name Gets or sets the name of template.
   *
   * @param {boolean} [model.hasClass] Gets or sets if the template has classes.
   *
   * @param {boolean} [model.hasSecurity] Gets or sets if the template has
   * security.
   *
   * @param {boolean} [model.hasProfiles] Gets or sets if the template has
   * profiles.
   *
   * @param {boolean} [model.hasItems] Gets or sets the has items.
   *
   * @param {string} [model.smallImage] Gets or sets the small image.
   *
   * @param {string} [model.largeImage] Gets or sets the large image.
   *
   * @param {boolean} [model.hasAudit] Gets or sets if the template has auditing
   * enabled.
   *
   * @param {boolean} [model.allowsViewImages] Gets or sets if the template
   * allows viewing images.
   *
   * @param {boolean} [model.isReviewState] Gets or sets if the entity is created
   * in a review state.
   *
   * @param {string} [model.reservedString1] Gets or sets the reserved string1.
   *
   * @param {string} [model.reservedString2] Gets or sets the reserved string2.
   *
   * @param {number} [model.reservedInt1] Gets or sets the reserved int1.
   *
   * @param {number} [model.reservedInt2] Gets or sets the reserved int2.
   *
   * @param {array} [model.drawers] Gets or sets the drawers.
   *
   * @param {array} [model.profiles] Gets or sets the profiles.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<EntityDefinitionModel>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  createTemplateWithHttpOperationResponse(model, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._createTemplate(model, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Creates a new entity template definition.
   *
   * @param {object} model The entity template model.
   *
   * @param {number} model.type Gets or sets the type of template.
   *
   * @param {string} model.category Gets or sets the category of template.
   *
   * @param {string} model.name Gets or sets the name of template.
   *
   * @param {boolean} [model.hasClass] Gets or sets if the template has classes.
   *
   * @param {boolean} [model.hasSecurity] Gets or sets if the template has
   * security.
   *
   * @param {boolean} [model.hasProfiles] Gets or sets if the template has
   * profiles.
   *
   * @param {boolean} [model.hasItems] Gets or sets the has items.
   *
   * @param {string} [model.smallImage] Gets or sets the small image.
   *
   * @param {string} [model.largeImage] Gets or sets the large image.
   *
   * @param {boolean} [model.hasAudit] Gets or sets if the template has auditing
   * enabled.
   *
   * @param {boolean} [model.allowsViewImages] Gets or sets if the template
   * allows viewing images.
   *
   * @param {boolean} [model.isReviewState] Gets or sets if the entity is created
   * in a review state.
   *
   * @param {string} [model.reservedString1] Gets or sets the reserved string1.
   *
   * @param {string} [model.reservedString2] Gets or sets the reserved string2.
   *
   * @param {number} [model.reservedInt1] Gets or sets the reserved int1.
   *
   * @param {number} [model.reservedInt2] Gets or sets the reserved int2.
   *
   * @param {array} [model.drawers] Gets or sets the drawers.
   *
   * @param {array} [model.profiles] Gets or sets the profiles.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {EntityDefinitionModel} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link EntityDefinitionModel} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  createTemplate(model, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._createTemplate(model, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._createTemplate(model, options, optionalCallback);
    }
  }

  /**
   * @summary Gets a single entity template definition by its type.
   *
   * @param {number} type The unique template type.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<EntityDefinitionModel>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getTemplateByTypeWithHttpOperationResponse(type, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getTemplateByType(type, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets a single entity template definition by its type.
   *
   * @param {number} type The unique template type.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {EntityDefinitionModel} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link EntityDefinitionModel} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getTemplateByType(type, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getTemplateByType(type, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getTemplateByType(type, options, optionalCallback);
    }
  }

  /**
   * @summary Updates a specified entity template definition by type.
   *
   * @param {number} type The unique template type.
   *
   * @param {object} model The entity template model.
   *
   * @param {string} [model.category] Gets or sets the category of template.
   *
   * @param {string} [model.name] Gets or sets the name of templates.
   *
   * @param {string} [model.smallImage] Gets or sets the small image.
   *
   * @param {string} [model.largeImage] Gets or sets the large image.
   *
   * @param {boolean} [model.hasAudit] Gets or sets if the template has auditing
   * enabled.
   *
   * @param {boolean} [model.allowsViewImages] Gets or sets if the template
   * allows viewing images.
   *
   * @param {boolean} [model.isReviewState] Gets or sets if the entity is created
   * in a review state.
   *
   * @param {array} [model.profiles] Gets or sets the profiles.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Object>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  updateTemplateByTypeWithHttpOperationResponse(type, model, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._updateTemplateByType(type, model, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Updates a specified entity template definition by type.
   *
   * @param {number} type The unique template type.
   *
   * @param {object} model The entity template model.
   *
   * @param {string} [model.category] Gets or sets the category of template.
   *
   * @param {string} [model.name] Gets or sets the name of templates.
   *
   * @param {string} [model.smallImage] Gets or sets the small image.
   *
   * @param {string} [model.largeImage] Gets or sets the large image.
   *
   * @param {boolean} [model.hasAudit] Gets or sets if the template has auditing
   * enabled.
   *
   * @param {boolean} [model.allowsViewImages] Gets or sets if the template
   * allows viewing images.
   *
   * @param {boolean} [model.isReviewState] Gets or sets if the entity is created
   * in a review state.
   *
   * @param {array} [model.profiles] Gets or sets the profiles.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {Object} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  updateTemplateByType(type, model, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._updateTemplateByType(type, model, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._updateTemplateByType(type, model, options, optionalCallback);
    }
  }

  /**
   * @summary Deletes a specified entity template definition by type.
   *
   * @param {number} type The unique template type.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Object>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  deleteTemplateByTypeWithHttpOperationResponse(type, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._deleteTemplateByType(type, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Deletes a specified entity template definition by type.
   *
   * @param {number} type The unique template type.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {Object} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  deleteTemplateByType(type, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._deleteTemplateByType(type, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._deleteTemplateByType(type, options, optionalCallback);
    }
  }

  /**
   * @summary Gets a single entity template definition by its unique identifier.
   *
   * @param {string} id The template identifier.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<EntityDefinitionModel>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getTemplateByIdWithHttpOperationResponse(id, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getTemplateById(id, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets a single entity template definition by its unique identifier.
   *
   * @param {string} id The template identifier.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {EntityDefinitionModel} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link EntityDefinitionModel} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getTemplateById(id, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getTemplateById(id, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getTemplateById(id, options, optionalCallback);
    }
  }

  /**
   * @summary Updates a specified entity template definition by identifier.
   *
   * @param {string} id The unique template identifier.
   *
   * @param {object} model The entity template model.
   *
   * @param {string} [model.category] Gets or sets the category of template.
   *
   * @param {string} [model.name] Gets or sets the name of templates.
   *
   * @param {string} [model.smallImage] Gets or sets the small image.
   *
   * @param {string} [model.largeImage] Gets or sets the large image.
   *
   * @param {boolean} [model.hasAudit] Gets or sets if the template has auditing
   * enabled.
   *
   * @param {boolean} [model.allowsViewImages] Gets or sets if the template
   * allows viewing images.
   *
   * @param {boolean} [model.isReviewState] Gets or sets if the entity is created
   * in a review state.
   *
   * @param {array} [model.profiles] Gets or sets the profiles.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Object>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  updateTemplateByIdWithHttpOperationResponse(id, model, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._updateTemplateById(id, model, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Updates a specified entity template definition by identifier.
   *
   * @param {string} id The unique template identifier.
   *
   * @param {object} model The entity template model.
   *
   * @param {string} [model.category] Gets or sets the category of template.
   *
   * @param {string} [model.name] Gets or sets the name of templates.
   *
   * @param {string} [model.smallImage] Gets or sets the small image.
   *
   * @param {string} [model.largeImage] Gets or sets the large image.
   *
   * @param {boolean} [model.hasAudit] Gets or sets if the template has auditing
   * enabled.
   *
   * @param {boolean} [model.allowsViewImages] Gets or sets if the template
   * allows viewing images.
   *
   * @param {boolean} [model.isReviewState] Gets or sets if the entity is created
   * in a review state.
   *
   * @param {array} [model.profiles] Gets or sets the profiles.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {Object} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  updateTemplateById(id, model, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._updateTemplateById(id, model, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._updateTemplateById(id, model, options, optionalCallback);
    }
  }

  /**
   * @summary Deletes a specified entity template definition by identifier.
   *
   * @param {string} id The unique template identifier.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Object>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  deleteTemplateByIdWithHttpOperationResponse(id, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._deleteTemplateById(id, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Deletes a specified entity template definition by identifier.
   *
   * @param {string} id The unique template identifier.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {Object} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  deleteTemplateById(id, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._deleteTemplateById(id, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._deleteTemplateById(id, options, optionalCallback);
    }
  }

  /**
   * @summary Validates the specified template field.
   *
   * @param {number} type The template type.
   *
   * @param {string} fieldID The field name.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {string} [options.sortColumn] Gets or sets the sort column.
   *
   * @param {array} [options.metadata] Gets or sets the metadata search options.
   *
   * @param {number} [options.page] Gets or sets the page number.
   *
   * @param {number} [options.pageSize] Gets or sets the size of the page.
   *
   * @param {string} [options.sortOrder] Gets or sets the order. Possible values
   * include: 'Unspecified', 'Ascending', 'Descending'
   *
   * @param {number} [options.sortBy] Gets or sets the column to order by.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<FieldValidationModel>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  validateTemplateFieldWithHttpOperationResponse(type, fieldID, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._validateTemplateField(type, fieldID, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Validates the specified template field.
   *
   * @param {number} type The template type.
   *
   * @param {string} fieldID The field name.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {string} [options.sortColumn] Gets or sets the sort column.
   *
   * @param {array} [options.metadata] Gets or sets the metadata search options.
   *
   * @param {number} [options.page] Gets or sets the page number.
   *
   * @param {number} [options.pageSize] Gets or sets the size of the page.
   *
   * @param {string} [options.sortOrder] Gets or sets the order. Possible values
   * include: 'Unspecified', 'Ascending', 'Descending'
   *
   * @param {number} [options.sortBy] Gets or sets the column to order by.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {FieldValidationModel} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link FieldValidationModel} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  validateTemplateField(type, fieldID, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._validateTemplateField(type, fieldID, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._validateTemplateField(type, fieldID, options, optionalCallback);
    }
  }

  /**
   * @summary Gets a paged list of groups.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.iD] Gets or sets the group identifier.
   *
   * @param {number} [options.userID] Gets or sets the user identifier.
   *
   * @param {string} [options.name] Gets or sets the name.
   *
   * @param {string} [options.type] Gets or sets the type. Possible values
   * include: 'Generic', 'Access', 'Role'
   *
   * @param {string} [options.state] Gets or sets the state. Possible values
   * include: 'Inactive', 'Active'
   *
   * @param {number} [options.page] Gets or sets the page number.
   *
   * @param {number} [options.pageSize] Gets or sets the size of the page.
   *
   * @param {string} [options.sortOrder] Gets or sets the order. Possible values
   * include: 'Unspecified', 'Ascending', 'Descending'
   *
   * @param {string} [options.sortBy] Gets or sets the column to order by.
   * Possible values include: 'ID', 'Name', 'Type', 'State'
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Array>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getGroupsByFilterWithHttpOperationResponse(options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getGroupsByFilter(options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets a paged list of groups.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.iD] Gets or sets the group identifier.
   *
   * @param {number} [options.userID] Gets or sets the user identifier.
   *
   * @param {string} [options.name] Gets or sets the name.
   *
   * @param {string} [options.type] Gets or sets the type. Possible values
   * include: 'Generic', 'Access', 'Role'
   *
   * @param {string} [options.state] Gets or sets the state. Possible values
   * include: 'Inactive', 'Active'
   *
   * @param {number} [options.page] Gets or sets the page number.
   *
   * @param {number} [options.pageSize] Gets or sets the size of the page.
   *
   * @param {string} [options.sortOrder] Gets or sets the order. Possible values
   * include: 'Unspecified', 'Ascending', 'Descending'
   *
   * @param {string} [options.sortBy] Gets or sets the column to order by.
   * Possible values include: 'ID', 'Name', 'Type', 'State'
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {Array} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {array} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getGroupsByFilter(options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getGroupsByFilter(options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getGroupsByFilter(options, optionalCallback);
    }
  }

  /**
   * @summary Creates a new group.
   *
   * @param {object} model The group model.
   *
   * @param {string} model.name Gets or sets the name.
   *
   * @param {string} [model.type] Gets or sets the type. Possible values include:
   * 'Generic', 'Access', 'Role'
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<GroupModel>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  createGroupWithHttpOperationResponse(model, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._createGroup(model, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Creates a new group.
   *
   * @param {object} model The group model.
   *
   * @param {string} model.name Gets or sets the name.
   *
   * @param {string} [model.type] Gets or sets the type. Possible values include:
   * 'Generic', 'Access', 'Role'
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {GroupModel} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link GroupModel} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  createGroup(model, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._createGroup(model, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._createGroup(model, options, optionalCallback);
    }
  }

  /**
   * @summary Gets a single group by its unique identifier.
   *
   * @param {number} id The group identifier.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<GroupModel>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getGroupByIdWithHttpOperationResponse(id, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getGroupById(id, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets a single group by its unique identifier.
   *
   * @param {number} id The group identifier.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {GroupModel} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link GroupModel} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getGroupById(id, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getGroupById(id, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getGroupById(id, options, optionalCallback);
    }
  }

  /**
   * @summary Updates a specified group.
   *
   * @param {number} id The group identifier.
   *
   * @param {object} model The group model.
   *
   * @param {number} [model.userID] Gets or sets the user identifier.
   *
   * @param {string} model.name Gets or sets the name.
   *
   * @param {string} [model.type] Gets or sets the type. Possible values include:
   * 'Generic', 'Access', 'Role'
   *
   * @param {string} [model.state] Gets or sets the state. Possible values
   * include: 'Inactive', 'Active'
   *
   * @param {number} [model.reservedInt1] Gets or sets the reserved int1.
   *
   * @param {number} [model.reservedInt2] Gets or sets the reserved int2.
   *
   * @param {string} [model.reservedString1] Gets or sets the reserved string1.
   *
   * @param {string} [model.reservedString2] Gets or sets the reserved string2.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Object>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  updateGroupWithHttpOperationResponse(id, model, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._updateGroup(id, model, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Updates a specified group.
   *
   * @param {number} id The group identifier.
   *
   * @param {object} model The group model.
   *
   * @param {number} [model.userID] Gets or sets the user identifier.
   *
   * @param {string} model.name Gets or sets the name.
   *
   * @param {string} [model.type] Gets or sets the type. Possible values include:
   * 'Generic', 'Access', 'Role'
   *
   * @param {string} [model.state] Gets or sets the state. Possible values
   * include: 'Inactive', 'Active'
   *
   * @param {number} [model.reservedInt1] Gets or sets the reserved int1.
   *
   * @param {number} [model.reservedInt2] Gets or sets the reserved int2.
   *
   * @param {string} [model.reservedString1] Gets or sets the reserved string1.
   *
   * @param {string} [model.reservedString2] Gets or sets the reserved string2.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {Object} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  updateGroup(id, model, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._updateGroup(id, model, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._updateGroup(id, model, options, optionalCallback);
    }
  }

  /**
   * @summary Deactivates a group and removes all group associations.
   *
   * @param {number} id The group identifier.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Object>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  deleteGroupWithHttpOperationResponse(id, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._deleteGroup(id, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Deactivates a group and removes all group associations.
   *
   * @param {number} id The group identifier.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {Object} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  deleteGroup(id, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._deleteGroup(id, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._deleteGroup(id, options, optionalCallback);
    }
  }

  /**
   * @summary Gets a paged list of entity links
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.childEntityID] Gets or sets the child entity
   * identifier.
   *
   * @param {number} [options.childDrawerID] Gets or sets the child drawer
   * identifier.
   *
   * @param {number} [options.childType] Gets or sets the type of the child.
   *
   * @param {number} [options.acl] Gets or sets the access control list.
   *
   * @param {number} [options.entityID] Gets or sets the entity identifier.
   *
   * @param {number} [options.drawerID] Gets or sets the drawer identifier.
   *
   * @param {string} [options.name] Gets or sets the name.
   *
   * @param {number} [options.creatorUserID] Gets or sets the creator user
   * identifier.
   *
   * @param {number} [options.modifierUserID] Gets or sets the modifier user
   * identifier.
   *
   * @param {date} [options.minInsertionTime] Gets or sets the minimum insertion
   * time.
   *
   * @param {date} [options.maxInsertionTime] Gets or sets the maximum insertion
   * time.
   *
   * @param {date} [options.minModificationTime] Gets or sets the minimum
   * modification time.
   *
   * @param {date} [options.maxModificationTime] Gets or sets the maximum
   * modification time.
   *
   * @param {number} [options.page] Gets or sets the page number.
   *
   * @param {number} [options.pageSize] Gets or sets the size of the page.
   *
   * @param {string} [options.sortOrder] Gets or sets the order. Possible values
   * include: 'Unspecified', 'Ascending', 'Descending'
   *
   * @param {string} [options.sortBy] Gets or sets the column to order by.
   * Possible values include: 'PageNumber', 'ID', 'Type', 'InsertionTime',
   * 'ModificationTime', 'CrossReferenceID', 'SubType', 'Extension', 'Name'
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Array>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getLinksByFilterWithHttpOperationResponse(options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getLinksByFilter(options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets a paged list of entity links
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.childEntityID] Gets or sets the child entity
   * identifier.
   *
   * @param {number} [options.childDrawerID] Gets or sets the child drawer
   * identifier.
   *
   * @param {number} [options.childType] Gets or sets the type of the child.
   *
   * @param {number} [options.acl] Gets or sets the access control list.
   *
   * @param {number} [options.entityID] Gets or sets the entity identifier.
   *
   * @param {number} [options.drawerID] Gets or sets the drawer identifier.
   *
   * @param {string} [options.name] Gets or sets the name.
   *
   * @param {number} [options.creatorUserID] Gets or sets the creator user
   * identifier.
   *
   * @param {number} [options.modifierUserID] Gets or sets the modifier user
   * identifier.
   *
   * @param {date} [options.minInsertionTime] Gets or sets the minimum insertion
   * time.
   *
   * @param {date} [options.maxInsertionTime] Gets or sets the maximum insertion
   * time.
   *
   * @param {date} [options.minModificationTime] Gets or sets the minimum
   * modification time.
   *
   * @param {date} [options.maxModificationTime] Gets or sets the maximum
   * modification time.
   *
   * @param {number} [options.page] Gets or sets the page number.
   *
   * @param {number} [options.pageSize] Gets or sets the size of the page.
   *
   * @param {string} [options.sortOrder] Gets or sets the order. Possible values
   * include: 'Unspecified', 'Ascending', 'Descending'
   *
   * @param {string} [options.sortBy] Gets or sets the column to order by.
   * Possible values include: 'PageNumber', 'ID', 'Type', 'InsertionTime',
   * 'ModificationTime', 'CrossReferenceID', 'SubType', 'Extension', 'Name'
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {Array} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {array} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getLinksByFilter(options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getLinksByFilter(options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getLinksByFilter(options, optionalCallback);
    }
  }

  /**
   * @summary Gets a link based on its unique identifier.
   *
   * @param {number} drawer The drawer identifier.
   *
   * @param {number} id The link identifier.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<EntityLinkModel>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getLinkByIdWithHttpOperationResponse(drawer, id, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getLinkById(drawer, id, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets a link based on its unique identifier.
   *
   * @param {number} drawer The drawer identifier.
   *
   * @param {number} id The link identifier.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {EntityLinkModel} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link EntityLinkModel} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getLinkById(drawer, id, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getLinkById(drawer, id, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getLinkById(drawer, id, options, optionalCallback);
    }
  }

  /**
   * @summary Updates a specified link.
   *
   * @param {number} drawer The drawer identifier.
   *
   * @param {number} id The link identifier.
   *
   * @param {object} model The model.
   *
   * @param {string} [model.virtualName] Gets or sets the name of the virtual.
   *
   * @param {number} [model.classProperty] Gets or sets the class.
   *
   * @param {string} [model.name] Gets or sets the name.
   *
   * @param {number} [model.acl] Gets or sets the acl.
   *
   * @param {number} [model.pageNumber] Gets or sets the page number.
   *
   * @param {string} [model.state] Gets or sets the state. Possible values
   * include: 'Undefined', 'MaxStates', 'Reserved', 'UserDefined', 'Dynamic',
   * 'Static', 'New', 'CheckedOut', 'Internal', 'Statres5', 'Linked', 'Statres4',
   * 'Statres3', 'Statres2', 'Statres1', 'Locked', 'OnServerCache',
   * 'OnClientCache', 'Fetching', 'Dynres4', 'Dynres3', 'Dynres2', 'Dynres1',
   * 'User1', 'User2', 'User3', 'User4', 'User5', 'User6', 'User7', 'User8',
   * 'User9', 'User10', 'User11', 'User12', 'User13', 'User14', 'User15',
   * 'User16'
   *
   * @param {string} [model.note] Gets or sets the note.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Object>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  updateLinkWithHttpOperationResponse(drawer, id, model, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._updateLink(drawer, id, model, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Updates a specified link.
   *
   * @param {number} drawer The drawer identifier.
   *
   * @param {number} id The link identifier.
   *
   * @param {object} model The model.
   *
   * @param {string} [model.virtualName] Gets or sets the name of the virtual.
   *
   * @param {number} [model.classProperty] Gets or sets the class.
   *
   * @param {string} [model.name] Gets or sets the name.
   *
   * @param {number} [model.acl] Gets or sets the acl.
   *
   * @param {number} [model.pageNumber] Gets or sets the page number.
   *
   * @param {string} [model.state] Gets or sets the state. Possible values
   * include: 'Undefined', 'MaxStates', 'Reserved', 'UserDefined', 'Dynamic',
   * 'Static', 'New', 'CheckedOut', 'Internal', 'Statres5', 'Linked', 'Statres4',
   * 'Statres3', 'Statres2', 'Statres1', 'Locked', 'OnServerCache',
   * 'OnClientCache', 'Fetching', 'Dynres4', 'Dynres3', 'Dynres2', 'Dynres1',
   * 'User1', 'User2', 'User3', 'User4', 'User5', 'User6', 'User7', 'User8',
   * 'User9', 'User10', 'User11', 'User12', 'User13', 'User14', 'User15',
   * 'User16'
   *
   * @param {string} [model.note] Gets or sets the note.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {Object} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  updateLink(drawer, id, model, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._updateLink(drawer, id, model, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._updateLink(drawer, id, model, options, optionalCallback);
    }
  }

  /**
   * @summary Deletes a specified link.
   *
   * @param {number} drawer The drawer identifier.
   *
   * @param {number} id The link identifier.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Object>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  deleteLinkWithHttpOperationResponse(drawer, id, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._deleteLink(drawer, id, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Deletes a specified link.
   *
   * @param {number} drawer The drawer identifier.
   *
   * @param {number} id The link identifier.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {Object} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  deleteLink(drawer, id, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._deleteLink(drawer, id, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._deleteLink(drawer, id, options, optionalCallback);
    }
  }

  /**
   * @summary Creates a new link.
   *
   * @param {number} drawer The drawer identifier.
   *
   * @param {object} model The link model.
   *
   * @param {number} [model.classProperty] Gets or sets the class.
   *
   * @param {string} model.name Gets or sets the name.
   *
   * @param {number} [model.acl] Gets or sets the acl.
   *
   * @param {number} [model.pageNumber] Gets or sets the page number.
   *
   * @param {string} [model.note] Gets or sets the note.
   *
   * @param {number} [model.childDrawerID] Gets or sets the child drawer
   * identifier.
   *
   * @param {number} [model.childEntityID] Gets or sets the child entity
   * identifier.
   *
   * @param {number} [model.childType] Gets or sets the type of the child.
   *
   * @param {number} [model.entityID] Gets or sets the entity identifier.
   *
   * @param {string} [model.virtualName] Gets or sets the name of the virtual.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<EntityLinkModel>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  createLinkWithHttpOperationResponse(drawer, model, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._createLink(drawer, model, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Creates a new link.
   *
   * @param {number} drawer The drawer identifier.
   *
   * @param {object} model The link model.
   *
   * @param {number} [model.classProperty] Gets or sets the class.
   *
   * @param {string} model.name Gets or sets the name.
   *
   * @param {number} [model.acl] Gets or sets the acl.
   *
   * @param {number} [model.pageNumber] Gets or sets the page number.
   *
   * @param {string} [model.note] Gets or sets the note.
   *
   * @param {number} [model.childDrawerID] Gets or sets the child drawer
   * identifier.
   *
   * @param {number} [model.childEntityID] Gets or sets the child entity
   * identifier.
   *
   * @param {number} [model.childType] Gets or sets the type of the child.
   *
   * @param {number} [model.entityID] Gets or sets the entity identifier.
   *
   * @param {string} [model.virtualName] Gets or sets the name of the virtual.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {EntityLinkModel} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link EntityLinkModel} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  createLink(drawer, model, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._createLink(drawer, model, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._createLink(drawer, model, options, optionalCallback);
    }
  }

  /**
   * @summary Gets a lock for a single entity based on its unique identifier.
   *
   * @param {number} drawer The drawer identifier.
   *
   * @param {number} id The entity identifier.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<LockModel>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getLocksByFilterWithHttpOperationResponse(drawer, id, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getLocksByFilter(drawer, id, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets a lock for a single entity based on its unique identifier.
   *
   * @param {number} drawer The drawer identifier.
   *
   * @param {number} id The entity identifier.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {LockModel} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link LockModel} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getLocksByFilter(drawer, id, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getLocksByFilter(drawer, id, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getLocksByFilter(drawer, id, options, optionalCallback);
    }
  }

  /**
   * @summary Inserts or updates lock on a specified entity.
   *
   * @param {number} drawer The drawer identifier.
   *
   * @param {number} id The entity identifier.
   *
   * @param {object} model The lock model.
   *
   * @param {number} [model.expirationDuration] Gets or sets the expiration
   * duration of the lock in minutes.
   *
   * @param {number} [model.acl] Gets or sets the access control level
   * permissions of the lock.
   *
   * @param {string} [model.applicationName] Gets or sets the name of the
   * application creating the lock.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Object>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  createOrUpdateLockWithHttpOperationResponse(drawer, id, model, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._createOrUpdateLock(drawer, id, model, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Inserts or updates lock on a specified entity.
   *
   * @param {number} drawer The drawer identifier.
   *
   * @param {number} id The entity identifier.
   *
   * @param {object} model The lock model.
   *
   * @param {number} [model.expirationDuration] Gets or sets the expiration
   * duration of the lock in minutes.
   *
   * @param {number} [model.acl] Gets or sets the access control level
   * permissions of the lock.
   *
   * @param {string} [model.applicationName] Gets or sets the name of the
   * application creating the lock.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {Object} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  createOrUpdateLock(drawer, id, model, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._createOrUpdateLock(drawer, id, model, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._createOrUpdateLock(drawer, id, model, options, optionalCallback);
    }
  }

  /**
   * @summary Deletes a lock on a specified entity.
   *
   * @param {number} drawer The drawer identifier.
   *
   * @param {number} id The entity identifier.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Object>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  deleteLockWithHttpOperationResponse(drawer, id, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._deleteLock(drawer, id, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Deletes a lock on a specified entity.
   *
   * @param {number} drawer The drawer identifier.
   *
   * @param {number} id The entity identifier.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {Object} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  deleteLock(drawer, id, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._deleteLock(drawer, id, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._deleteLock(drawer, id, options, optionalCallback);
    }
  }

  /**
   * @summary Gets a paged list of notes.
   *
   * @param {number} drawerID Gets or sets the drawer identifier.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.entityID] Gets or sets the entity identifier.
   *
   * @param {string} [options.name] Gets or sets the name.
   *
   * @param {number} [options.creatorUserID] Gets or sets the creator user
   * identifier.
   *
   * @param {number} [options.modifierUserID] Gets or sets the modifier user
   * identifier.
   *
   * @param {date} [options.minCreationTime] Gets or sets the minimum creation
   * time.
   *
   * @param {date} [options.maxCreationTime] Gets or sets the maximum creation
   * time.
   *
   * @param {date} [options.minModificationTime] Gets or sets the minimum
   * modification time.
   *
   * @param {date} [options.maxModificationTime] Gets or sets the maximum
   * modification time.
   *
   * @param {number} [options.parentID] Gets or sets the parent note identifier.
   *
   * @param {number} [options.page] Gets or sets the page number.
   *
   * @param {number} [options.pageSize] Gets or sets the size of the page.
   *
   * @param {string} [options.sortOrder] Gets or sets the order. Possible values
   * include: 'Unspecified', 'Ascending', 'Descending'
   *
   * @param {string} [options.sortBy] Gets or sets the column to order by.
   * Possible values include: 'ID', 'EntityID', 'Name', 'CreationTime',
   * 'ModificationTime'
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Array>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getNotesByFilterWithHttpOperationResponse(drawerID, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getNotesByFilter(drawerID, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets a paged list of notes.
   *
   * @param {number} drawerID Gets or sets the drawer identifier.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.entityID] Gets or sets the entity identifier.
   *
   * @param {string} [options.name] Gets or sets the name.
   *
   * @param {number} [options.creatorUserID] Gets or sets the creator user
   * identifier.
   *
   * @param {number} [options.modifierUserID] Gets or sets the modifier user
   * identifier.
   *
   * @param {date} [options.minCreationTime] Gets or sets the minimum creation
   * time.
   *
   * @param {date} [options.maxCreationTime] Gets or sets the maximum creation
   * time.
   *
   * @param {date} [options.minModificationTime] Gets or sets the minimum
   * modification time.
   *
   * @param {date} [options.maxModificationTime] Gets or sets the maximum
   * modification time.
   *
   * @param {number} [options.parentID] Gets or sets the parent note identifier.
   *
   * @param {number} [options.page] Gets or sets the page number.
   *
   * @param {number} [options.pageSize] Gets or sets the size of the page.
   *
   * @param {string} [options.sortOrder] Gets or sets the order. Possible values
   * include: 'Unspecified', 'Ascending', 'Descending'
   *
   * @param {string} [options.sortBy] Gets or sets the column to order by.
   * Possible values include: 'ID', 'EntityID', 'Name', 'CreationTime',
   * 'ModificationTime'
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {Array} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {array} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getNotesByFilter(drawerID, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getNotesByFilter(drawerID, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getNotesByFilter(drawerID, options, optionalCallback);
    }
  }

  /**
   * @summary Gets a note by its unique identifier.
   *
   * @param {number} drawer The drawer identifier.
   *
   * @param {number} id The note identifier.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<NoteModel>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getNoteByIdWithHttpOperationResponse(drawer, id, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getNoteById(drawer, id, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets a note by its unique identifier.
   *
   * @param {number} drawer The drawer identifier.
   *
   * @param {number} id The note identifier.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {NoteModel} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link NoteModel} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getNoteById(drawer, id, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getNoteById(drawer, id, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getNoteById(drawer, id, options, optionalCallback);
    }
  }

  /**
   * @summary Updates a specified note.
   *
   * @param {number} drawer The drawer identifier.
   *
   * @param {number} id The note identifier.
   *
   * @param {object} model The note model.
   *
   * @param {number} [model.acl] Gets or sets the acl.
   *
   * @param {string} [model.name] Gets or sets the name.
   *
   * @param {string} [model.note] Gets or sets the note.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Object>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  updateNoteWithHttpOperationResponse(drawer, id, model, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._updateNote(drawer, id, model, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Updates a specified note.
   *
   * @param {number} drawer The drawer identifier.
   *
   * @param {number} id The note identifier.
   *
   * @param {object} model The note model.
   *
   * @param {number} [model.acl] Gets or sets the acl.
   *
   * @param {string} [model.name] Gets or sets the name.
   *
   * @param {string} [model.note] Gets or sets the note.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {Object} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  updateNote(drawer, id, model, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._updateNote(drawer, id, model, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._updateNote(drawer, id, model, options, optionalCallback);
    }
  }

  /**
   * @summary Deletes a specified note.
   *
   * @param {number} drawer The drawer identifier.
   *
   * @param {number} id The note identifier.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Object>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  deleteNoteWithHttpOperationResponse(drawer, id, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._deleteNote(drawer, id, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Deletes a specified note.
   *
   * @param {number} drawer The drawer identifier.
   *
   * @param {number} id The note identifier.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {Object} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  deleteNote(drawer, id, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._deleteNote(drawer, id, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._deleteNote(drawer, id, options, optionalCallback);
    }
  }

  /**
   * @summary Creates a new note.
   *
   * @param {number} drawer The drawer identifier.
   *
   * @param {object} model The note model.
   *
   * @param {number} [model.acl] Gets or sets the acl.
   *
   * @param {number} [model.entityID] Gets or sets the entity identifier.
   *
   * @param {string} model.name Gets or sets the name.
   *
   * @param {string} model.note Gets or sets the note.
   *
   * @param {number} [model.parentID] Gets or sets the parent identifier.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<NoteModel>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  createNoteWithHttpOperationResponse(drawer, model, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._createNote(drawer, model, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Creates a new note.
   *
   * @param {number} drawer The drawer identifier.
   *
   * @param {object} model The note model.
   *
   * @param {number} [model.acl] Gets or sets the acl.
   *
   * @param {number} [model.entityID] Gets or sets the entity identifier.
   *
   * @param {string} model.name Gets or sets the name.
   *
   * @param {string} model.note Gets or sets the note.
   *
   * @param {number} [model.parentID] Gets or sets the parent identifier.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {NoteModel} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link NoteModel} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  createNote(drawer, model, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._createNote(drawer, model, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._createNote(drawer, model, options, optionalCallback);
    }
  }

  /**
   * @summary Gets a paged list of queue assignments.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.queueID] Gets or sets the unique queue identifier.
   *
   * @param {number} [options.userID] Gets or sets the user identifier.
   *
   * @param {number} [options.groupID] Gets or sets the group identifier.
   *
   * @param {string} [options.type] Gets or sets the queue assignment type.
   * Possible values include: 'Unspecified', 'Primary', 'Secondary'
   *
   * @param {number} [options.order] Gets or sets the sort order.
   *
   * @param {string} [options.taskSortColumn] Gets or sets the task sort column.
   * Possible values include: 'TaskID', 'QueueID', 'DrawerID', 'AddressID',
   * 'ObjectID', 'ObjectType', 'State', 'Priority', 'Description', 'Message1',
   * 'Message2', 'Message3', 'Message4', 'Message5', 'OwnerUserID',
   * 'OwnerGroupID', 'EffectiveUserID', 'EffectiveGroupID', 'PreviousQueueID',
   * 'NextQueueID', 'InsertionTime', 'ResolutionTime', 'TaskFileAttachment',
   * 'ReservedInt1', 'ReservedString1'
   *
   * @param {string} [options.state] Gets or sets the state. Possible values
   * include: 'Unspecified', 'Inactive', 'Active'
   *
   * @param {string} [options.fetchType] Gets or sets the type of the fetch.
   * Possible values include: 'Unspecified', 'Manual', 'Push'
   *
   * @param {number} [options.page] Gets or sets the page number.
   *
   * @param {number} [options.pageSize] Gets or sets the size of the page.
   *
   * @param {string} [options.sortOrder] Gets or sets the order. Possible values
   * include: 'Unspecified', 'Ascending', 'Descending'
   *
   * @param {string} [options.sortBy] Gets or sets the column to order by.
   * Possible values include: 'QueueID', 'UserID', 'GroupID', 'Type', 'State',
   * 'Order', 'FetchType'
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Array>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getQueueAssignmentsByFilterWithHttpOperationResponse(options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getQueueAssignmentsByFilter(options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets a paged list of queue assignments.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.queueID] Gets or sets the unique queue identifier.
   *
   * @param {number} [options.userID] Gets or sets the user identifier.
   *
   * @param {number} [options.groupID] Gets or sets the group identifier.
   *
   * @param {string} [options.type] Gets or sets the queue assignment type.
   * Possible values include: 'Unspecified', 'Primary', 'Secondary'
   *
   * @param {number} [options.order] Gets or sets the sort order.
   *
   * @param {string} [options.taskSortColumn] Gets or sets the task sort column.
   * Possible values include: 'TaskID', 'QueueID', 'DrawerID', 'AddressID',
   * 'ObjectID', 'ObjectType', 'State', 'Priority', 'Description', 'Message1',
   * 'Message2', 'Message3', 'Message4', 'Message5', 'OwnerUserID',
   * 'OwnerGroupID', 'EffectiveUserID', 'EffectiveGroupID', 'PreviousQueueID',
   * 'NextQueueID', 'InsertionTime', 'ResolutionTime', 'TaskFileAttachment',
   * 'ReservedInt1', 'ReservedString1'
   *
   * @param {string} [options.state] Gets or sets the state. Possible values
   * include: 'Unspecified', 'Inactive', 'Active'
   *
   * @param {string} [options.fetchType] Gets or sets the type of the fetch.
   * Possible values include: 'Unspecified', 'Manual', 'Push'
   *
   * @param {number} [options.page] Gets or sets the page number.
   *
   * @param {number} [options.pageSize] Gets or sets the size of the page.
   *
   * @param {string} [options.sortOrder] Gets or sets the order. Possible values
   * include: 'Unspecified', 'Ascending', 'Descending'
   *
   * @param {string} [options.sortBy] Gets or sets the column to order by.
   * Possible values include: 'QueueID', 'UserID', 'GroupID', 'Type', 'State',
   * 'Order', 'FetchType'
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {Array} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {array} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getQueueAssignmentsByFilter(options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getQueueAssignmentsByFilter(options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getQueueAssignmentsByFilter(options, optionalCallback);
    }
  }

  /**
   * @summary Updates the specified queue assignment.
   *
   * @param {object} model The model.
   *
   * @param {number} [model.queueID] Gets or sets the unique queue identifier.
   *
   * @param {number} [model.userID] Gets or sets the user identifier.
   *
   * @param {number} [model.groupID] Gets or sets the group identifier.
   *
   * @param {string} [model.type] Gets or sets the queue assignment type.
   * Possible values include: 'Unspecified', 'Primary', 'Secondary'
   *
   * @param {number} [model.order] Gets or sets the sort order.
   *
   * @param {string} [model.taskSortColumn] Gets or sets the task sort column.
   * Possible values include: 'TaskID', 'QueueID', 'DrawerID', 'AddressID',
   * 'ObjectID', 'ObjectType', 'State', 'Priority', 'Description', 'Message1',
   * 'Message2', 'Message3', 'Message4', 'Message5', 'OwnerUserID',
   * 'OwnerGroupID', 'EffectiveUserID', 'EffectiveGroupID', 'PreviousQueueID',
   * 'NextQueueID', 'InsertionTime', 'ResolutionTime', 'TaskFileAttachment',
   * 'ReservedInt1', 'ReservedString1'
   *
   * @param {string} [model.state] Gets or sets the state. Possible values
   * include: 'Unspecified', 'Inactive', 'Active'
   *
   * @param {string} [model.fetchType] Gets or sets the type of the fetch.
   * Possible values include: 'Unspecified', 'Manual', 'Push'
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Object>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  updateQueueAssignemntWithHttpOperationResponse(model, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._updateQueueAssignemnt(model, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Updates the specified queue assignment.
   *
   * @param {object} model The model.
   *
   * @param {number} [model.queueID] Gets or sets the unique queue identifier.
   *
   * @param {number} [model.userID] Gets or sets the user identifier.
   *
   * @param {number} [model.groupID] Gets or sets the group identifier.
   *
   * @param {string} [model.type] Gets or sets the queue assignment type.
   * Possible values include: 'Unspecified', 'Primary', 'Secondary'
   *
   * @param {number} [model.order] Gets or sets the sort order.
   *
   * @param {string} [model.taskSortColumn] Gets or sets the task sort column.
   * Possible values include: 'TaskID', 'QueueID', 'DrawerID', 'AddressID',
   * 'ObjectID', 'ObjectType', 'State', 'Priority', 'Description', 'Message1',
   * 'Message2', 'Message3', 'Message4', 'Message5', 'OwnerUserID',
   * 'OwnerGroupID', 'EffectiveUserID', 'EffectiveGroupID', 'PreviousQueueID',
   * 'NextQueueID', 'InsertionTime', 'ResolutionTime', 'TaskFileAttachment',
   * 'ReservedInt1', 'ReservedString1'
   *
   * @param {string} [model.state] Gets or sets the state. Possible values
   * include: 'Unspecified', 'Inactive', 'Active'
   *
   * @param {string} [model.fetchType] Gets or sets the type of the fetch.
   * Possible values include: 'Unspecified', 'Manual', 'Push'
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {Object} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  updateQueueAssignemnt(model, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._updateQueueAssignemnt(model, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._updateQueueAssignemnt(model, options, optionalCallback);
    }
  }

  /**
   * @summary Creates a new queue assignment.
   *
   * @param {object} model The model.
   *
   * @param {number} [model.queueID] Gets or sets the unique queue identifier.
   *
   * @param {number} [model.userID] Gets or sets the user identifier.
   *
   * @param {string} [model.type] Gets or sets the queue assignment type.
   * Possible values include: 'Unspecified', 'Primary', 'Secondary'
   *
   * @param {number} [model.order] Gets or sets the sort order.
   *
   * @param {string} [model.taskSortColumn] Gets or sets the task sort column.
   * Possible values include: 'TaskID', 'QueueID', 'DrawerID', 'AddressID',
   * 'ObjectID', 'ObjectType', 'State', 'Priority', 'Description', 'Message1',
   * 'Message2', 'Message3', 'Message4', 'Message5', 'OwnerUserID',
   * 'OwnerGroupID', 'EffectiveUserID', 'EffectiveGroupID', 'PreviousQueueID',
   * 'NextQueueID', 'InsertionTime', 'ResolutionTime', 'TaskFileAttachment',
   * 'ReservedInt1', 'ReservedString1'
   *
   * @param {string} [model.fetchType] Gets or sets the type of the fetch.
   * Possible values include: 'Unspecified', 'Manual', 'Push'
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<QueueAssignmentModel>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  createQueueAssignmentWithHttpOperationResponse(model, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._createQueueAssignment(model, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Creates a new queue assignment.
   *
   * @param {object} model The model.
   *
   * @param {number} [model.queueID] Gets or sets the unique queue identifier.
   *
   * @param {number} [model.userID] Gets or sets the user identifier.
   *
   * @param {string} [model.type] Gets or sets the queue assignment type.
   * Possible values include: 'Unspecified', 'Primary', 'Secondary'
   *
   * @param {number} [model.order] Gets or sets the sort order.
   *
   * @param {string} [model.taskSortColumn] Gets or sets the task sort column.
   * Possible values include: 'TaskID', 'QueueID', 'DrawerID', 'AddressID',
   * 'ObjectID', 'ObjectType', 'State', 'Priority', 'Description', 'Message1',
   * 'Message2', 'Message3', 'Message4', 'Message5', 'OwnerUserID',
   * 'OwnerGroupID', 'EffectiveUserID', 'EffectiveGroupID', 'PreviousQueueID',
   * 'NextQueueID', 'InsertionTime', 'ResolutionTime', 'TaskFileAttachment',
   * 'ReservedInt1', 'ReservedString1'
   *
   * @param {string} [model.fetchType] Gets or sets the type of the fetch.
   * Possible values include: 'Unspecified', 'Manual', 'Push'
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {QueueAssignmentModel} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link QueueAssignmentModel} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  createQueueAssignment(model, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._createQueueAssignment(model, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._createQueueAssignment(model, options, optionalCallback);
    }
  }

  /**
   * @summary Gets a single queue assignment based on user and queue identifiers.
   *
   * @param {number} userId The user identifier.
   *
   * @param {number} queueId The queue identifier.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<QueueAssignmentModel>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getQueueAssignmentsByIdWithHttpOperationResponse(userId, queueId, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getQueueAssignmentsById(userId, queueId, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets a single queue assignment based on user and queue identifiers.
   *
   * @param {number} userId The user identifier.
   *
   * @param {number} queueId The queue identifier.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {QueueAssignmentModel} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link QueueAssignmentModel} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getQueueAssignmentsById(userId, queueId, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getQueueAssignmentsById(userId, queueId, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getQueueAssignmentsById(userId, queueId, options, optionalCallback);
    }
  }

  /**
   * @summary Deletes the specified queue assignment.
   *
   * @param {number} userId The user identifier.
   *
   * @param {number} queueId The queue identifier.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Object>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  deleteQueueAssignmentWithHttpOperationResponse(userId, queueId, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._deleteQueueAssignment(userId, queueId, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Deletes the specified queue assignment.
   *
   * @param {number} userId The user identifier.
   *
   * @param {number} queueId The queue identifier.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {Object} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  deleteQueueAssignment(userId, queueId, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._deleteQueueAssignment(userId, queueId, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._deleteQueueAssignment(userId, queueId, options, optionalCallback);
    }
  }

  /**
   * @summary Gets a paged list of queues.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.iD] Gets or sets the queue identifier.
   *
   * @param {string} [options.name] Gets or sets the name.
   *
   * @param {string} [options.alias] Gets or sets the alias.
   *
   * @param {string} [options.type] Gets or sets the type. Possible values
   * include: 'Inbound', 'Outbound', 'Access', 'Any', 'Shared', 'Public',
   * 'Recycle', 'Fax', 'Print', 'Scan', 'Ocr', 'Workflow', 'Schedule', 'System',
   * 'Other', 'CdoInfostore', 'CdoFolder'
   *
   * @param {number} [options.access] Gets or sets the access level.
   *
   * @param {boolean} [options.bypassSecurity] Gets or sets a value indicating
   * whether to bypass security checks.
   *
   * @param {number} [options.page] Gets or sets the page number.
   *
   * @param {number} [options.pageSize] Gets or sets the size of the page.
   *
   * @param {string} [options.sortOrder] Gets or sets the order. Possible values
   * include: 'Unspecified', 'Ascending', 'Descending'
   *
   * @param {string} [options.sortBy] Gets or sets the column to order by.
   * Possible values include: 'ID', 'Type', 'Name', 'Alias'
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Array>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getQueuesByFilterWithHttpOperationResponse(options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getQueuesByFilter(options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets a paged list of queues.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.iD] Gets or sets the queue identifier.
   *
   * @param {string} [options.name] Gets or sets the name.
   *
   * @param {string} [options.alias] Gets or sets the alias.
   *
   * @param {string} [options.type] Gets or sets the type. Possible values
   * include: 'Inbound', 'Outbound', 'Access', 'Any', 'Shared', 'Public',
   * 'Recycle', 'Fax', 'Print', 'Scan', 'Ocr', 'Workflow', 'Schedule', 'System',
   * 'Other', 'CdoInfostore', 'CdoFolder'
   *
   * @param {number} [options.access] Gets or sets the access level.
   *
   * @param {boolean} [options.bypassSecurity] Gets or sets a value indicating
   * whether to bypass security checks.
   *
   * @param {number} [options.page] Gets or sets the page number.
   *
   * @param {number} [options.pageSize] Gets or sets the size of the page.
   *
   * @param {string} [options.sortOrder] Gets or sets the order. Possible values
   * include: 'Unspecified', 'Ascending', 'Descending'
   *
   * @param {string} [options.sortBy] Gets or sets the column to order by.
   * Possible values include: 'ID', 'Type', 'Name', 'Alias'
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {Array} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {array} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getQueuesByFilter(options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getQueuesByFilter(options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getQueuesByFilter(options, optionalCallback);
    }
  }

  /**
   * @summary Creates a new queue.
   *
   * @param {object} model The queue model.
   *
   * @param {string} model.name Gets or sets the name.
   *
   * @param {string} model.alias Gets or sets the alias.
   *
   * @param {string} model.type Gets or sets the type. Possible values include:
   * 'Inbound', 'Outbound', 'Access', 'Any', 'Shared', 'Public', 'Recycle',
   * 'Fax', 'Print', 'Scan', 'Ocr', 'Workflow', 'Schedule', 'System', 'Other',
   * 'CdoInfostore', 'CdoFolder'
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<QueueModel>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  createQueueWithHttpOperationResponse(model, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._createQueue(model, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Creates a new queue.
   *
   * @param {object} model The queue model.
   *
   * @param {string} model.name Gets or sets the name.
   *
   * @param {string} model.alias Gets or sets the alias.
   *
   * @param {string} model.type Gets or sets the type. Possible values include:
   * 'Inbound', 'Outbound', 'Access', 'Any', 'Shared', 'Public', 'Recycle',
   * 'Fax', 'Print', 'Scan', 'Ocr', 'Workflow', 'Schedule', 'System', 'Other',
   * 'CdoInfostore', 'CdoFolder'
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {QueueModel} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link QueueModel} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  createQueue(model, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._createQueue(model, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._createQueue(model, options, optionalCallback);
    }
  }

  /**
   * @summary Gets a single queue by its unique identifier.
   *
   * @param {number} id The queue identifier.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<QueueModel>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getQueueByIdWithHttpOperationResponse(id, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getQueueById(id, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets a single queue by its unique identifier.
   *
   * @param {number} id The queue identifier.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {QueueModel} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link QueueModel} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getQueueById(id, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getQueueById(id, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getQueueById(id, options, optionalCallback);
    }
  }

  /**
   * @summary Updates a specified queue.
   *
   * @param {number} id The unique queue identifier.
   *
   * @param {object} model The queue model.
   *
   * @param {string} [model.name] Gets or sets the name.
   *
   * @param {string} [model.alias] Gets or sets the alias.
   *
   * @param {string} [model.state] Gets or sets the state. Possible values
   * include: 'Inactive', 'Active'
   *
   * @param {string} [model.type] Gets or sets the type. Possible values include:
   * 'Inbound', 'Outbound', 'Access', 'Any', 'Shared', 'Public', 'Recycle',
   * 'Fax', 'Print', 'Scan', 'Ocr', 'Workflow', 'Schedule', 'System', 'Other',
   * 'CdoInfostore', 'CdoFolder'
   *
   * @param {string} [model.category] Gets or sets the category.
   *
   * @param {string} [model.description] Gets or sets the description.
   *
   * @param {number} [model.reservedInt1] Gets or sets the reserved integer 1.
   *
   * @param {number} [model.reservedInt2] Gets or sets the reserved integer 2.
   *
   * @param {string} [model.reservedString1] Gets or sets the reserved string 1.
   *
   * @param {string} [model.reservedString2] Gets or sets the reserved string 2.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Object>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  updateQueueWithHttpOperationResponse(id, model, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._updateQueue(id, model, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Updates a specified queue.
   *
   * @param {number} id The unique queue identifier.
   *
   * @param {object} model The queue model.
   *
   * @param {string} [model.name] Gets or sets the name.
   *
   * @param {string} [model.alias] Gets or sets the alias.
   *
   * @param {string} [model.state] Gets or sets the state. Possible values
   * include: 'Inactive', 'Active'
   *
   * @param {string} [model.type] Gets or sets the type. Possible values include:
   * 'Inbound', 'Outbound', 'Access', 'Any', 'Shared', 'Public', 'Recycle',
   * 'Fax', 'Print', 'Scan', 'Ocr', 'Workflow', 'Schedule', 'System', 'Other',
   * 'CdoInfostore', 'CdoFolder'
   *
   * @param {string} [model.category] Gets or sets the category.
   *
   * @param {string} [model.description] Gets or sets the description.
   *
   * @param {number} [model.reservedInt1] Gets or sets the reserved integer 1.
   *
   * @param {number} [model.reservedInt2] Gets or sets the reserved integer 2.
   *
   * @param {string} [model.reservedString1] Gets or sets the reserved string 1.
   *
   * @param {string} [model.reservedString2] Gets or sets the reserved string 2.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {Object} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  updateQueue(id, model, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._updateQueue(id, model, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._updateQueue(id, model, options, optionalCallback);
    }
  }

  /**
   * @summary Deletes a specified queue.
   *
   * @param {number} id The queue identifier.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Object>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  deleteQueueWithHttpOperationResponse(id, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._deleteQueue(id, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Deletes a specified queue.
   *
   * @param {number} id The queue identifier.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {Object} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  deleteQueue(id, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._deleteQueue(id, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._deleteQueue(id, options, optionalCallback);
    }
  }

  /**
   * @summary Gets a single queue by its name.
   *
   * @param {string} name The queue name.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<QueueModel>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getQueueByNameWithHttpOperationResponse(name, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getQueueByName(name, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets a single queue by its name.
   *
   * @param {string} name The queue name.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {QueueModel} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link QueueModel} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getQueueByName(name, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getQueueByName(name, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getQueueByName(name, options, optionalCallback);
    }
  }

  /**
   * @summary Gets a paged list of tasks.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.lastTaskID] Gets or sets the last task identifier.
   *
   * @param {number} [options.iD] Gets or sets the entity identifier.
   *
   * @param {number} [options.type] Gets or sets the type of the entity.
   *
   * @param {number} [options.queueID] Gets or sets the queue identifier.
   *
   * @param {number} [options.queueType] Gets or sets the type of the queue.
   *
   * @param {number} [options.drawerID] Gets or sets the drawer identifier.
   *
   * @param {string} [options.description] Gets or sets the task description.
   *
   * @param {number} [options.taskID] Gets or sets the task identifier.
   *
   * @param {number} [options.page] Gets or sets the page number.
   *
   * @param {number} [options.pageSize] Gets or sets the size of the page.
   *
   * @param {string} [options.sortOrder] Gets or sets the order. Possible values
   * include: 'Unspecified', 'Ascending', 'Descending'
   *
   * @param {string} [options.sortBy] Gets or sets the column to order by.
   * Possible values include: 'TaskID', 'QueueID', 'ObjectID', 'Priority',
   * 'Description', 'InsertionTime', 'ResolutionTime', 'ReservedInt1'
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Array>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getTasksByFilterWithHttpOperationResponse(options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getTasksByFilter(options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets a paged list of tasks.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.lastTaskID] Gets or sets the last task identifier.
   *
   * @param {number} [options.iD] Gets or sets the entity identifier.
   *
   * @param {number} [options.type] Gets or sets the type of the entity.
   *
   * @param {number} [options.queueID] Gets or sets the queue identifier.
   *
   * @param {number} [options.queueType] Gets or sets the type of the queue.
   *
   * @param {number} [options.drawerID] Gets or sets the drawer identifier.
   *
   * @param {string} [options.description] Gets or sets the task description.
   *
   * @param {number} [options.taskID] Gets or sets the task identifier.
   *
   * @param {number} [options.page] Gets or sets the page number.
   *
   * @param {number} [options.pageSize] Gets or sets the size of the page.
   *
   * @param {string} [options.sortOrder] Gets or sets the order. Possible values
   * include: 'Unspecified', 'Ascending', 'Descending'
   *
   * @param {string} [options.sortBy] Gets or sets the column to order by.
   * Possible values include: 'TaskID', 'QueueID', 'ObjectID', 'Priority',
   * 'Description', 'InsertionTime', 'ResolutionTime', 'ReservedInt1'
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {Array} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {array} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getTasksByFilter(options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getTasksByFilter(options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getTasksByFilter(options, optionalCallback);
    }
  }

  /**
   * @summary Creates a new task.
   *
   * @param {object} model The task model.
   *
   * @param {number} [model.queueID] Gets or sets the queue identifier.
   *
   * @param {number} [model.drawerID] Gets or sets the drawer identifier.
   *
   * @param {number} [model.objectID] Gets or sets the object identifier
   * (entity).
   *
   * @param {number} [model.objectType] Gets or sets the type of the object
   * (entity).
   *
   * @param {number} [model.prevQueueID] Gets or sets the previous queue
   * identifier.
   *
   * @param {number} [model.nextQueueID] Gets or sets the next queue identifier.
   *
   * @param {number} [model.addressID] Gets or sets the address identifier.
   *
   * @param {string} [model.description] Gets or sets the description of the
   * task.
   *
   * @param {string} [model.message1] Gets or sets message 1.
   *
   * @param {string} [model.message2] Gets or sets message 2.
   *
   * @param {string} [model.message3] Gets or sets message 3.
   *
   * @param {string} [model.message4] Gets or sets message 4.
   *
   * @param {string} [model.message5] Gets or sets message5.
   *
   * @param {string} [model.message6] Gets or sets message 6.
   *
   * @param {string} [model.message7] Gets or sets message 7.
   *
   * @param {string} [model.message8] Gets or sets message 8.
   *
   * @param {string} [model.message9] Gets or sets message 9.
   *
   * @param {string} [model.message10] Gets or sets message 10.
   *
   * @param {string} [model.message11] Gets or sets message 11.
   *
   * @param {string} [model.message12] Gets or sets message 12.
   *
   * @param {string} [model.message13] Gets or sets message 13.
   *
   * @param {string} [model.message14] Gets or sets message 14.
   *
   * @param {string} [model.message15] Gets or sets message 15.
   *
   * @param {string} [model.message16] Gets or sets message 16.
   *
   * @param {number} [model.state] Gets or sets the task state.
   *
   * @param {number} [model.priority] Gets or sets the task priority.
   *
   * @param {date} [model.resolutionTime] Gets or sets the task resolution time.
   *
   * @param {string} [model.taskFileAttachment] Gets or sets the task file
   * attachment name.
   *
   * @param {number} [model.reservedInt1] Gets or sets reserved integer 1.
   *
   * @param {string} [model.reservedString1] Gets or sets reserved string 1.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Object>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  createTaskWithHttpOperationResponse(model, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._createTask(model, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Creates a new task.
   *
   * @param {object} model The task model.
   *
   * @param {number} [model.queueID] Gets or sets the queue identifier.
   *
   * @param {number} [model.drawerID] Gets or sets the drawer identifier.
   *
   * @param {number} [model.objectID] Gets or sets the object identifier
   * (entity).
   *
   * @param {number} [model.objectType] Gets or sets the type of the object
   * (entity).
   *
   * @param {number} [model.prevQueueID] Gets or sets the previous queue
   * identifier.
   *
   * @param {number} [model.nextQueueID] Gets or sets the next queue identifier.
   *
   * @param {number} [model.addressID] Gets or sets the address identifier.
   *
   * @param {string} [model.description] Gets or sets the description of the
   * task.
   *
   * @param {string} [model.message1] Gets or sets message 1.
   *
   * @param {string} [model.message2] Gets or sets message 2.
   *
   * @param {string} [model.message3] Gets or sets message 3.
   *
   * @param {string} [model.message4] Gets or sets message 4.
   *
   * @param {string} [model.message5] Gets or sets message5.
   *
   * @param {string} [model.message6] Gets or sets message 6.
   *
   * @param {string} [model.message7] Gets or sets message 7.
   *
   * @param {string} [model.message8] Gets or sets message 8.
   *
   * @param {string} [model.message9] Gets or sets message 9.
   *
   * @param {string} [model.message10] Gets or sets message 10.
   *
   * @param {string} [model.message11] Gets or sets message 11.
   *
   * @param {string} [model.message12] Gets or sets message 12.
   *
   * @param {string} [model.message13] Gets or sets message 13.
   *
   * @param {string} [model.message14] Gets or sets message 14.
   *
   * @param {string} [model.message15] Gets or sets message 15.
   *
   * @param {string} [model.message16] Gets or sets message 16.
   *
   * @param {number} [model.state] Gets or sets the task state.
   *
   * @param {number} [model.priority] Gets or sets the task priority.
   *
   * @param {date} [model.resolutionTime] Gets or sets the task resolution time.
   *
   * @param {string} [model.taskFileAttachment] Gets or sets the task file
   * attachment name.
   *
   * @param {number} [model.reservedInt1] Gets or sets reserved integer 1.
   *
   * @param {string} [model.reservedString1] Gets or sets reserved string 1.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {Object} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  createTask(model, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._createTask(model, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._createTask(model, options, optionalCallback);
    }
  }

  /**
   * @summary Gets a single task based on its unique identifier.
   *
   * @param {number} id The identifier.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<TaskModel>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getTaskByIdWithHttpOperationResponse(id, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getTaskById(id, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets a single task based on its unique identifier.
   *
   * @param {number} id The identifier.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {TaskModel} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link TaskModel} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getTaskById(id, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getTaskById(id, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getTaskById(id, options, optionalCallback);
    }
  }

  /**
   * @summary Updates a specified task.
   *
   * @param {number} id The identifier.
   *
   * @param {object} model The task model.
   *
   * @param {number} [model.addressID] Gets or sets the address identifier.
   *
   * @param {string} [model.description] Gets or sets the description of the
   * task.
   *
   * @param {string} [model.message1] Gets or sets message 1.
   *
   * @param {string} [model.message2] Gets or sets message 2.
   *
   * @param {string} [model.message3] Gets or sets message 3.
   *
   * @param {string} [model.message4] Gets or sets message 4.
   *
   * @param {string} [model.message5] Gets or sets message5.
   *
   * @param {string} [model.message6] Gets or sets message 6.
   *
   * @param {string} [model.message7] Gets or sets message 7.
   *
   * @param {string} [model.message8] Gets or sets message 8.
   *
   * @param {string} [model.message9] Gets or sets message 9.
   *
   * @param {string} [model.message10] Gets or sets message 10.
   *
   * @param {string} [model.message11] Gets or sets message 11.
   *
   * @param {string} [model.message12] Gets or sets message 12.
   *
   * @param {string} [model.message13] Gets or sets message 13.
   *
   * @param {string} [model.message14] Gets or sets message 14.
   *
   * @param {string} [model.message15] Gets or sets message 15.
   *
   * @param {string} [model.message16] Gets or sets message 16.
   *
   * @param {number} [model.state] Gets or sets the task state.
   *
   * @param {number} [model.priority] Gets or sets the task priority.
   *
   * @param {date} [model.resolutionTime] Gets or sets the task resolution time.
   *
   * @param {string} [model.taskFileAttachment] Gets or sets the task file
   * attachment name.
   *
   * @param {number} [model.reservedInt1] Gets or sets reserved integer 1.
   *
   * @param {string} [model.reservedString1] Gets or sets reserved string 1.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Object>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  updateTaskWithHttpOperationResponse(id, model, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._updateTask(id, model, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Updates a specified task.
   *
   * @param {number} id The identifier.
   *
   * @param {object} model The task model.
   *
   * @param {number} [model.addressID] Gets or sets the address identifier.
   *
   * @param {string} [model.description] Gets or sets the description of the
   * task.
   *
   * @param {string} [model.message1] Gets or sets message 1.
   *
   * @param {string} [model.message2] Gets or sets message 2.
   *
   * @param {string} [model.message3] Gets or sets message 3.
   *
   * @param {string} [model.message4] Gets or sets message 4.
   *
   * @param {string} [model.message5] Gets or sets message5.
   *
   * @param {string} [model.message6] Gets or sets message 6.
   *
   * @param {string} [model.message7] Gets or sets message 7.
   *
   * @param {string} [model.message8] Gets or sets message 8.
   *
   * @param {string} [model.message9] Gets or sets message 9.
   *
   * @param {string} [model.message10] Gets or sets message 10.
   *
   * @param {string} [model.message11] Gets or sets message 11.
   *
   * @param {string} [model.message12] Gets or sets message 12.
   *
   * @param {string} [model.message13] Gets or sets message 13.
   *
   * @param {string} [model.message14] Gets or sets message 14.
   *
   * @param {string} [model.message15] Gets or sets message 15.
   *
   * @param {string} [model.message16] Gets or sets message 16.
   *
   * @param {number} [model.state] Gets or sets the task state.
   *
   * @param {number} [model.priority] Gets or sets the task priority.
   *
   * @param {date} [model.resolutionTime] Gets or sets the task resolution time.
   *
   * @param {string} [model.taskFileAttachment] Gets or sets the task file
   * attachment name.
   *
   * @param {number} [model.reservedInt1] Gets or sets reserved integer 1.
   *
   * @param {string} [model.reservedString1] Gets or sets reserved string 1.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {Object} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  updateTask(id, model, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._updateTask(id, model, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._updateTask(id, model, options, optionalCallback);
    }
  }

  /**
   * @summary Deletes a specified task.
   *
   * @param {number} id The identifier.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Object>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  deleteTaskWithHttpOperationResponse(id, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._deleteTask(id, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Deletes a specified task.
   *
   * @param {number} id The identifier.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {Object} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  deleteTask(id, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._deleteTask(id, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._deleteTask(id, options, optionalCallback);
    }
  }

  /**
   * @summary Gets a single task based on user predefined queue assignment
   * criteria.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<TaskModel>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  fetchTaskFromQueueAssignmentWithHttpOperationResponse(options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._fetchTaskFromQueueAssignment(options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets a single task based on user predefined queue assignment
   * criteria.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {TaskModel} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link TaskModel} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  fetchTaskFromQueueAssignment(options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._fetchTaskFromQueueAssignment(options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._fetchTaskFromQueueAssignment(options, optionalCallback);
    }
  }

  /**
   * @summary Gets a paged list of users.Gets a paged list of users.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.iD] Gets or sets the identifier.
   *
   * @param {number} [options.primaryGroupID] Gets or sets the primary group
   * identifier.
   *
   * @param {number} [options.groupID] Gets or sets the group identifier.
   *
   * @param {string} [options.groupName] Gets or sets the name of the group.
   *
   * @param {string} [options.username] Gets or sets the username.
   *
   * @param {string} [options.type] Gets or sets the type. Possible values
   * include: 'ImageDesk', 'PublishDesk', 'FaxDesk', 'CaptureDesk',
   * 'RecognitionDesk', 'PortalUser', 'AdminDesk', 'WorkflowDesk', 'Benchmark',
   * 'ReportDesk', 'ColdDesk', 'PortalDesk', 'WorkflowArchitect', 'DocumentDesk',
   * 'Poweruser'
   *
   * @param {string} [options.state] Gets or sets the state. Possible values
   * include: 'Active', 'Inactive'
   *
   * @param {string} [options.fullName] Gets or sets the full name.
   *
   * @param {number} [options.page] Gets or sets the page number.
   *
   * @param {number} [options.pageSize] Gets or sets the size of the page.
   *
   * @param {string} [options.sortOrder] Gets or sets the order. Possible values
   * include: 'Unspecified', 'Ascending', 'Descending'
   *
   * @param {string} [options.sortBy] Gets or sets the column to order by.
   * Possible values include: 'ID', 'PrimaryGroupID', 'Username', 'UserFullName',
   * 'Type', 'State'
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Array>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getUsersByFilterWithHttpOperationResponse(options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getUsersByFilter(options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets a paged list of users.Gets a paged list of users.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.iD] Gets or sets the identifier.
   *
   * @param {number} [options.primaryGroupID] Gets or sets the primary group
   * identifier.
   *
   * @param {number} [options.groupID] Gets or sets the group identifier.
   *
   * @param {string} [options.groupName] Gets or sets the name of the group.
   *
   * @param {string} [options.username] Gets or sets the username.
   *
   * @param {string} [options.type] Gets or sets the type. Possible values
   * include: 'ImageDesk', 'PublishDesk', 'FaxDesk', 'CaptureDesk',
   * 'RecognitionDesk', 'PortalUser', 'AdminDesk', 'WorkflowDesk', 'Benchmark',
   * 'ReportDesk', 'ColdDesk', 'PortalDesk', 'WorkflowArchitect', 'DocumentDesk',
   * 'Poweruser'
   *
   * @param {string} [options.state] Gets or sets the state. Possible values
   * include: 'Active', 'Inactive'
   *
   * @param {string} [options.fullName] Gets or sets the full name.
   *
   * @param {number} [options.page] Gets or sets the page number.
   *
   * @param {number} [options.pageSize] Gets or sets the size of the page.
   *
   * @param {string} [options.sortOrder] Gets or sets the order. Possible values
   * include: 'Unspecified', 'Ascending', 'Descending'
   *
   * @param {string} [options.sortBy] Gets or sets the column to order by.
   * Possible values include: 'ID', 'PrimaryGroupID', 'Username', 'UserFullName',
   * 'Type', 'State'
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {Array} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {array} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getUsersByFilter(options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getUsersByFilter(options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getUsersByFilter(options, optionalCallback);
    }
  }

  /**
   * @summary Creates a new user.
   *
   * @param {object} model The user model.
   *
   * @param {string} model.username Gets or sets the username.
   *
   * @param {string} [model.state] Gets or sets the state. Possible values
   * include: 'Active', 'Inactive'
   *
   * @param {string} [model.type] Gets or sets the type. Possible values include:
   * 'ImageDesk', 'PublishDesk', 'FaxDesk', 'CaptureDesk', 'RecognitionDesk',
   * 'PortalUser', 'AdminDesk', 'WorkflowDesk', 'Benchmark', 'ReportDesk',
   * 'ColdDesk', 'PortalDesk', 'WorkflowArchitect', 'DocumentDesk', 'Poweruser'
   *
   * @param {string} model.fullName Gets or sets the full name.
   *
   * @param {string} model.iPAddress Gets or sets the ip address.
   *
   * @param {number} [model.entityAcl] Gets or sets the entity acl.
   *
   * @param {number} [model.attachmentAcl] Gets or sets the attachment acl.
   *
   * @param {number} [model.noteAcl] Gets or sets the note acl.
   *
   * @param {number} [model.entityFeature] Gets or sets the entity feature.
   *
   * @param {number} [model.attachmentFeature] Gets or sets the attachment
   * feature.
   *
   * @param {number} [model.noteFeature] Gets or sets the note feature.
   *
   * @param {string} [model.adminMask] Gets or sets the admin mask. Possible
   * values include: 'None', 'CabinetAdmin', 'DrawerAdmin', 'GroupAdmin',
   * 'UserAdmin', 'WorkflowAdmin', 'VersionAdmin', 'TemplateAdmin',
   * 'ApplicationAdmin'
   *
   * @param {string} [model.address] Gets or sets the address.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<UserModel>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  createUserWithHttpOperationResponse(model, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._createUser(model, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Creates a new user.
   *
   * @param {object} model The user model.
   *
   * @param {string} model.username Gets or sets the username.
   *
   * @param {string} [model.state] Gets or sets the state. Possible values
   * include: 'Active', 'Inactive'
   *
   * @param {string} [model.type] Gets or sets the type. Possible values include:
   * 'ImageDesk', 'PublishDesk', 'FaxDesk', 'CaptureDesk', 'RecognitionDesk',
   * 'PortalUser', 'AdminDesk', 'WorkflowDesk', 'Benchmark', 'ReportDesk',
   * 'ColdDesk', 'PortalDesk', 'WorkflowArchitect', 'DocumentDesk', 'Poweruser'
   *
   * @param {string} model.fullName Gets or sets the full name.
   *
   * @param {string} model.iPAddress Gets or sets the ip address.
   *
   * @param {number} [model.entityAcl] Gets or sets the entity acl.
   *
   * @param {number} [model.attachmentAcl] Gets or sets the attachment acl.
   *
   * @param {number} [model.noteAcl] Gets or sets the note acl.
   *
   * @param {number} [model.entityFeature] Gets or sets the entity feature.
   *
   * @param {number} [model.attachmentFeature] Gets or sets the attachment
   * feature.
   *
   * @param {number} [model.noteFeature] Gets or sets the note feature.
   *
   * @param {string} [model.adminMask] Gets or sets the admin mask. Possible
   * values include: 'None', 'CabinetAdmin', 'DrawerAdmin', 'GroupAdmin',
   * 'UserAdmin', 'WorkflowAdmin', 'VersionAdmin', 'TemplateAdmin',
   * 'ApplicationAdmin'
   *
   * @param {string} [model.address] Gets or sets the address.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {UserModel} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link UserModel} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  createUser(model, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._createUser(model, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._createUser(model, options, optionalCallback);
    }
  }

  /**
   * @summary Gets a single user by its unique identifier.
   *
   * @param {number} id The user identifier.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<UserModel>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getUserByIdWithHttpOperationResponse(id, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getUserById(id, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets a single user by its unique identifier.
   *
   * @param {number} id The user identifier.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {UserModel} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link UserModel} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getUserById(id, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getUserById(id, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getUserById(id, options, optionalCallback);
    }
  }

  /**
   * @summary Updates a specified user.
   *
   * @param {number} id The user identifier.
   *
   * @param {object} model The user model.
   *
   * @param {number} [model.primaryGroupID] Gets or sets the primary group
   * identifier.
   *
   * @param {string} [model.type] Gets or sets the type. Possible values include:
   * 'ImageDesk', 'PublishDesk', 'FaxDesk', 'CaptureDesk', 'RecognitionDesk',
   * 'PortalUser', 'AdminDesk', 'WorkflowDesk', 'Benchmark', 'ReportDesk',
   * 'ColdDesk', 'PortalDesk', 'WorkflowArchitect', 'DocumentDesk', 'Poweruser'
   *
   * @param {string} [model.state] Gets or sets the state. Possible values
   * include: 'Active', 'Inactive'
   *
   * @param {string} [model.fullName] Gets or sets the full name.
   *
   * @param {number} [model.objectCount] Gets or sets the object count.
   *
   * @param {string} [model.iPAddress] Gets or sets the ip address.
   *
   * @param {number} [model.entityAcl] Gets or sets the entity acl.
   *
   * @param {number} [model.attachmentAcl] Gets or sets the attachment acl.
   *
   * @param {number} [model.noteAcl] Gets or sets the note acl.
   *
   * @param {number} [model.entityFeature] Gets or sets the entity feature.
   *
   * @param {number} [model.attachmentFeature] Gets or sets the attachment
   * feature.
   *
   * @param {number} [model.noteFeature] Gets or sets the note feature.
   *
   * @param {string} [model.adminMask] Gets or sets the admin mask. Possible
   * values include: 'None', 'CabinetAdmin', 'DrawerAdmin', 'GroupAdmin',
   * 'UserAdmin', 'WorkflowAdmin', 'VersionAdmin', 'TemplateAdmin',
   * 'ApplicationAdmin'
   *
   * @param {string} [model.address] Gets or sets the address.
   *
   * @param {number} [model.reservedInt1] Gets or sets the reserved int1.
   *
   * @param {number} [model.reservedInt2] Gets or sets the reserved int2.
   *
   * @param {number} [model.reservedDouble1] Gets or sets the reserved double1.
   *
   * @param {number} [model.reservedDouble2] Gets or sets the reserved double2.
   *
   * @param {string} [model.reservedString1] Gets or sets the reserved string1.
   *
   * @param {string} [model.reservedString2] Gets or sets the reserved string2.
   *
   * @param {date} [model.userExpiration] Gets or sets the user expiration.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Object>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  updateUserWithHttpOperationResponse(id, model, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._updateUser(id, model, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Updates a specified user.
   *
   * @param {number} id The user identifier.
   *
   * @param {object} model The user model.
   *
   * @param {number} [model.primaryGroupID] Gets or sets the primary group
   * identifier.
   *
   * @param {string} [model.type] Gets or sets the type. Possible values include:
   * 'ImageDesk', 'PublishDesk', 'FaxDesk', 'CaptureDesk', 'RecognitionDesk',
   * 'PortalUser', 'AdminDesk', 'WorkflowDesk', 'Benchmark', 'ReportDesk',
   * 'ColdDesk', 'PortalDesk', 'WorkflowArchitect', 'DocumentDesk', 'Poweruser'
   *
   * @param {string} [model.state] Gets or sets the state. Possible values
   * include: 'Active', 'Inactive'
   *
   * @param {string} [model.fullName] Gets or sets the full name.
   *
   * @param {number} [model.objectCount] Gets or sets the object count.
   *
   * @param {string} [model.iPAddress] Gets or sets the ip address.
   *
   * @param {number} [model.entityAcl] Gets or sets the entity acl.
   *
   * @param {number} [model.attachmentAcl] Gets or sets the attachment acl.
   *
   * @param {number} [model.noteAcl] Gets or sets the note acl.
   *
   * @param {number} [model.entityFeature] Gets or sets the entity feature.
   *
   * @param {number} [model.attachmentFeature] Gets or sets the attachment
   * feature.
   *
   * @param {number} [model.noteFeature] Gets or sets the note feature.
   *
   * @param {string} [model.adminMask] Gets or sets the admin mask. Possible
   * values include: 'None', 'CabinetAdmin', 'DrawerAdmin', 'GroupAdmin',
   * 'UserAdmin', 'WorkflowAdmin', 'VersionAdmin', 'TemplateAdmin',
   * 'ApplicationAdmin'
   *
   * @param {string} [model.address] Gets or sets the address.
   *
   * @param {number} [model.reservedInt1] Gets or sets the reserved int1.
   *
   * @param {number} [model.reservedInt2] Gets or sets the reserved int2.
   *
   * @param {number} [model.reservedDouble1] Gets or sets the reserved double1.
   *
   * @param {number} [model.reservedDouble2] Gets or sets the reserved double2.
   *
   * @param {string} [model.reservedString1] Gets or sets the reserved string1.
   *
   * @param {string} [model.reservedString2] Gets or sets the reserved string2.
   *
   * @param {date} [model.userExpiration] Gets or sets the user expiration.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {Object} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  updateUser(id, model, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._updateUser(id, model, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._updateUser(id, model, options, optionalCallback);
    }
  }

  /**
   * @summary Deactivates a specified user and removes all user associations.
   *
   * @param {number} id The user identifier.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Object>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  deleteUserWithHttpOperationResponse(id, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._deleteUser(id, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Deactivates a specified user and removes all user associations.
   *
   * @param {number} id The user identifier.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {Object} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  deleteUser(id, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._deleteUser(id, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._deleteUser(id, options, optionalCallback);
    }
  }

  /**
   * @summary Gets a paged list of workflows.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.applicationID] Gets or sets the application
   * identifier.
   *
   * @param {number} [options.entityType] Gets or sets the type of the entity.
   *
   * @param {string} [options.name] Gets or sets the name.
   *
   * @param {number} [options.page] Gets or sets the page number.
   *
   * @param {number} [options.pageSize] Gets or sets the size of the page.
   *
   * @param {string} [options.sortOrder] Gets or sets the order. Possible values
   * include: 'Unspecified', 'Ascending', 'Descending'
   *
   * @param {number} [options.sortBy] Gets or sets the column to order by.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Array>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getWorkflowsByFilterWithHttpOperationResponse(options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getWorkflowsByFilter(options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets a paged list of workflows.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.applicationID] Gets or sets the application
   * identifier.
   *
   * @param {number} [options.entityType] Gets or sets the type of the entity.
   *
   * @param {string} [options.name] Gets or sets the name.
   *
   * @param {number} [options.page] Gets or sets the page number.
   *
   * @param {number} [options.pageSize] Gets or sets the size of the page.
   *
   * @param {string} [options.sortOrder] Gets or sets the order. Possible values
   * include: 'Unspecified', 'Ascending', 'Descending'
   *
   * @param {number} [options.sortBy] Gets or sets the column to order by.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {Array} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {array} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getWorkflowsByFilter(options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getWorkflowsByFilter(options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getWorkflowsByFilter(options, optionalCallback);
    }
  }

  /**
   * @summary Gets a single workflow based on its unique identifier.
   *
   * @param {number} id The workflow identifier.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<WorkflowModel>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getWorkflowByIdWithHttpOperationResponse(id, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getWorkflowById(id, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets a single workflow based on its unique identifier.
   *
   * @param {number} id The workflow identifier.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {WorkflowModel} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link WorkflowModel} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getWorkflowById(id, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getWorkflowById(id, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getWorkflowById(id, options, optionalCallback);
    }
  }

  /**
   * @summary Gets queues for a specific workflow.
   *
   * @param {number} id The workflow identifier.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Array>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getWorkflowQueuesByIdWithHttpOperationResponse(id, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getWorkflowQueuesById(id, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets queues for a specific workflow.
   *
   * @param {number} id The workflow identifier.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {Array} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {array} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getWorkflowQueuesById(id, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getWorkflowQueuesById(id, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getWorkflowQueuesById(id, options, optionalCallback);
    }
  }

  /**
   * @summary Gets a single entity template definition completed with all
   * profiles definitions as XML entity definition.
   *
   * @param {number} type The unique template type.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<String>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getXMLTemplateByTypeWithHttpOperationResponse(type, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getXMLTemplateByType(type, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets a single entity template definition completed with all
   * profiles definitions as XML entity definition.
   *
   * @param {number} type The unique template type.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {String} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {string} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getXMLTemplateByType(type, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getXMLTemplateByType(type, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getXMLTemplateByType(type, options, optionalCallback);
    }
  }

  /**
   * @summary Creates a new entity template definition.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<String>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  createXMLTemplateWithHttpOperationResponse(options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._createXMLTemplate(options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Creates a new entity template definition.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {String} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {string} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  createXMLTemplate(options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._createXMLTemplate(options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._createXMLTemplate(options, optionalCallback);
    }
  }

}

module.exports = SoftheonEnterpriseAPI;
