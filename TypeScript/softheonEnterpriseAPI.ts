/*
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is
 * regenerated.
 */

import * as msRest from "ms-rest-js";
import * as Models from "./models";
import * as Mappers from "./models/mappers";
const WebResource = msRest.WebResource;

const packageName = "Softheon.Enterprise.Api.Client";
const packageVersion = "";

class SoftheonEnterpriseAPI extends msRest.ServiceClient {
  credentials: msRest.ServiceClientCredentials;
  baseUri: string;
  serializer: msRest.Serializer;

  /**
   * @class
   * Initializes a new instance of the SoftheonEnterpriseAPI class.
   * @constructor
   *
   * @param {msRest.ServiceClientCredentials} credentials - Subscription credentials which uniquely identify client subscription.
   *
   * @param {string} [baseUri] - The base URI of the service.
   *
   * @param {object} [options] - The parameter options
   *
   * @param {Array} [options.filters] - Filters to be added to the request pipeline
   *
   * @param {object} [options.requestOptions] - The request options. Detailed info can be found at
   * {@link https://github.github.io/fetch/#Request Options doc}
   *
   * @param {boolean} [options.noRetryPolicy] - If set to true, turn off default retry policy
   *
   */
  constructor(credentials: msRest.ServiceClientCredentials, baseUri?: string, options?: msRest.ServiceClientOptions) {
    if (credentials === null || credentials === undefined) {
      throw new Error('\'credentials\' cannot be null.');
    }

    if (!options) options = {};

    super(credentials, options);

    this.baseUri = baseUri as string;
    if (!this.baseUri) {
      this.baseUri = 'http://localhost:54963';
    }
    this.credentials = credentials;

    this.addUserAgentInfo(`${packageName}/${packageVersion}`);
    this.serializer = new msRest.Serializer(Mappers);
  }
  // methods on the client.

  /**
   * @summary Accepts the task.
   *
   * @param {WorkflowActionModel} model The model.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  async acceptTaskWithHttpOperationResponse(model: Models.WorkflowActionModel, options?: msRest.RequestOptionsBase): Promise<msRest.HttpOperationResponse> {
    let client = this;
    // Validate
    try {
      if (model === null || model === undefined) {
        throw new Error('model cannot be null or undefined.');
      }
    } catch (error) {
      return Promise.reject(error);
    }

    // Construct URL
    let baseUrl = this.baseUri;
    let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'v1/workflow/actions/accept';

    // Create HTTP transport objects
    let httpRequest = new WebResource();
    httpRequest.method = 'POST';
    httpRequest.url = requestUrl;
    httpRequest.headers = {};
    // Set Headers
    httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
    if(options && options.customHeaders) {
      for(let headerName in options.customHeaders) {
        if (options.customHeaders.hasOwnProperty(headerName)) {
          httpRequest.headers[headerName] = options.customHeaders[headerName];
        }
      }
    }
    // Serialize Request
    let requestContent = null;
    let requestModel = null;
    try {
      if (model !== null && model !== undefined) {
        let requestModelMapper = Mappers.WorkflowActionModel;
        requestModel = client.serializer.serialize(requestModelMapper, model, 'model');
        requestContent = JSON.stringify(requestModel);
      }
    } catch (error) {
      let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
          `payload - ${JSON.stringify(model, null, 2)}.`);
      return Promise.reject(serializationError);
    }
    httpRequest.body = requestContent;
    // Send Request
    let operationRes: msRest.HttpOperationResponse;
    try {
      operationRes = await client.pipeline(httpRequest);
      let response = operationRes.response;
      let statusCode = response.status;
      if (statusCode !== 204 && statusCode !== 403 && statusCode !== 404) {
        let error = new msRest.RestError(operationRes.bodyAsText as string);
        error.statusCode = response.status;
        error.request = msRest.stripRequest(httpRequest);
        error.response = msRest.stripResponse(response);
        let parsedErrorResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedErrorResponse) {
            let internalError = null;
            if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
            error.code = internalError ? internalError.code : parsedErrorResponse.code;
            error.message = internalError ? internalError.message : parsedErrorResponse.message;
          }
        } catch (defaultError) {
          error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                           `- "${operationRes.bodyAsText}" for the default response.`;
          return Promise.reject(error);
        }
        return Promise.reject(error);
      }
      // Deserialize Response
      if (statusCode === 204) {
        let parsedResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedResponse !== null && parsedResponse !== undefined) {
            let resultMapper = {
              required: false,
              serializedName: 'parsedResponse',
              type: {
                name: 'Object'
              }
            };
            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
          }
        } catch (error) {
          let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
          deserializationError.request = msRest.stripRequest(httpRequest);
          deserializationError.response = msRest.stripResponse(response);
          return Promise.reject(deserializationError);
        }
      }

    } catch(err) {
      return Promise.reject(err);
    }

    return Promise.resolve(operationRes);
  }
  // methods on the client.

  /**
   * @summary Rejects the task.
   *
   * @param {WorkflowActionModel} model The model.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  async rejectTaskWithHttpOperationResponse(model: Models.WorkflowActionModel, options?: msRest.RequestOptionsBase): Promise<msRest.HttpOperationResponse> {
    let client = this;
    // Validate
    try {
      if (model === null || model === undefined) {
        throw new Error('model cannot be null or undefined.');
      }
    } catch (error) {
      return Promise.reject(error);
    }

    // Construct URL
    let baseUrl = this.baseUri;
    let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'v1/workflow/actions/reject';

    // Create HTTP transport objects
    let httpRequest = new WebResource();
    httpRequest.method = 'POST';
    httpRequest.url = requestUrl;
    httpRequest.headers = {};
    // Set Headers
    httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
    if(options && options.customHeaders) {
      for(let headerName in options.customHeaders) {
        if (options.customHeaders.hasOwnProperty(headerName)) {
          httpRequest.headers[headerName] = options.customHeaders[headerName];
        }
      }
    }
    // Serialize Request
    let requestContent = null;
    let requestModel = null;
    try {
      if (model !== null && model !== undefined) {
        let requestModelMapper = Mappers.WorkflowActionModel;
        requestModel = client.serializer.serialize(requestModelMapper, model, 'model');
        requestContent = JSON.stringify(requestModel);
      }
    } catch (error) {
      let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
          `payload - ${JSON.stringify(model, null, 2)}.`);
      return Promise.reject(serializationError);
    }
    httpRequest.body = requestContent;
    // Send Request
    let operationRes: msRest.HttpOperationResponse;
    try {
      operationRes = await client.pipeline(httpRequest);
      let response = operationRes.response;
      let statusCode = response.status;
      if (statusCode !== 204 && statusCode !== 403 && statusCode !== 404) {
        let error = new msRest.RestError(operationRes.bodyAsText as string);
        error.statusCode = response.status;
        error.request = msRest.stripRequest(httpRequest);
        error.response = msRest.stripResponse(response);
        let parsedErrorResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedErrorResponse) {
            let internalError = null;
            if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
            error.code = internalError ? internalError.code : parsedErrorResponse.code;
            error.message = internalError ? internalError.message : parsedErrorResponse.message;
          }
        } catch (defaultError) {
          error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                           `- "${operationRes.bodyAsText}" for the default response.`;
          return Promise.reject(error);
        }
        return Promise.reject(error);
      }
      // Deserialize Response
      if (statusCode === 204) {
        let parsedResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedResponse !== null && parsedResponse !== undefined) {
            let resultMapper = {
              required: false,
              serializedName: 'parsedResponse',
              type: {
                name: 'Object'
              }
            };
            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
          }
        } catch (error) {
          let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
          deserializationError.request = msRest.stripRequest(httpRequest);
          deserializationError.response = msRest.stripResponse(response);
          return Promise.reject(deserializationError);
        }
      }

    } catch(err) {
      return Promise.reject(err);
    }

    return Promise.resolve(operationRes);
  }
  // methods on the client.

  /**
   * @summary Suspends the task.
   *
   * @param {WorkflowActionModel} model The model.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  async suspendTaskWithHttpOperationResponse(model: Models.WorkflowActionModel, options?: msRest.RequestOptionsBase): Promise<msRest.HttpOperationResponse> {
    let client = this;
    // Validate
    try {
      if (model === null || model === undefined) {
        throw new Error('model cannot be null or undefined.');
      }
    } catch (error) {
      return Promise.reject(error);
    }

    // Construct URL
    let baseUrl = this.baseUri;
    let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'v1/workflow/actions/suspend';

    // Create HTTP transport objects
    let httpRequest = new WebResource();
    httpRequest.method = 'POST';
    httpRequest.url = requestUrl;
    httpRequest.headers = {};
    // Set Headers
    httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
    if(options && options.customHeaders) {
      for(let headerName in options.customHeaders) {
        if (options.customHeaders.hasOwnProperty(headerName)) {
          httpRequest.headers[headerName] = options.customHeaders[headerName];
        }
      }
    }
    // Serialize Request
    let requestContent = null;
    let requestModel = null;
    try {
      if (model !== null && model !== undefined) {
        let requestModelMapper = Mappers.WorkflowActionModel;
        requestModel = client.serializer.serialize(requestModelMapper, model, 'model');
        requestContent = JSON.stringify(requestModel);
      }
    } catch (error) {
      let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
          `payload - ${JSON.stringify(model, null, 2)}.`);
      return Promise.reject(serializationError);
    }
    httpRequest.body = requestContent;
    // Send Request
    let operationRes: msRest.HttpOperationResponse;
    try {
      operationRes = await client.pipeline(httpRequest);
      let response = operationRes.response;
      let statusCode = response.status;
      if (statusCode !== 204 && statusCode !== 403 && statusCode !== 404) {
        let error = new msRest.RestError(operationRes.bodyAsText as string);
        error.statusCode = response.status;
        error.request = msRest.stripRequest(httpRequest);
        error.response = msRest.stripResponse(response);
        let parsedErrorResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedErrorResponse) {
            let internalError = null;
            if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
            error.code = internalError ? internalError.code : parsedErrorResponse.code;
            error.message = internalError ? internalError.message : parsedErrorResponse.message;
          }
        } catch (defaultError) {
          error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                           `- "${operationRes.bodyAsText}" for the default response.`;
          return Promise.reject(error);
        }
        return Promise.reject(error);
      }
      // Deserialize Response
      if (statusCode === 204) {
        let parsedResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedResponse !== null && parsedResponse !== undefined) {
            let resultMapper = {
              required: false,
              serializedName: 'parsedResponse',
              type: {
                name: 'Object'
              }
            };
            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
          }
        } catch (error) {
          let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
          deserializationError.request = msRest.stripRequest(httpRequest);
          deserializationError.response = msRest.stripResponse(response);
          return Promise.reject(deserializationError);
        }
      }

    } catch(err) {
      return Promise.reject(err);
    }

    return Promise.resolve(operationRes);
  }
  // methods on the client.

  /**
   * @summary Routes the task.
   *
   * @param {WorkflowActionRouteModel} model The model.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  async routeTaskWithHttpOperationResponse(model: Models.WorkflowActionRouteModel, options?: msRest.RequestOptionsBase): Promise<msRest.HttpOperationResponse> {
    let client = this;
    // Validate
    try {
      if (model === null || model === undefined) {
        throw new Error('model cannot be null or undefined.');
      }
    } catch (error) {
      return Promise.reject(error);
    }

    // Construct URL
    let baseUrl = this.baseUri;
    let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'v1/workflow/actions/route';

    // Create HTTP transport objects
    let httpRequest = new WebResource();
    httpRequest.method = 'POST';
    httpRequest.url = requestUrl;
    httpRequest.headers = {};
    // Set Headers
    httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
    if(options && options.customHeaders) {
      for(let headerName in options.customHeaders) {
        if (options.customHeaders.hasOwnProperty(headerName)) {
          httpRequest.headers[headerName] = options.customHeaders[headerName];
        }
      }
    }
    // Serialize Request
    let requestContent = null;
    let requestModel = null;
    try {
      if (model !== null && model !== undefined) {
        let requestModelMapper = Mappers.WorkflowActionRouteModel;
        requestModel = client.serializer.serialize(requestModelMapper, model, 'model');
        requestContent = JSON.stringify(requestModel);
      }
    } catch (error) {
      let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
          `payload - ${JSON.stringify(model, null, 2)}.`);
      return Promise.reject(serializationError);
    }
    httpRequest.body = requestContent;
    // Send Request
    let operationRes: msRest.HttpOperationResponse;
    try {
      operationRes = await client.pipeline(httpRequest);
      let response = operationRes.response;
      let statusCode = response.status;
      if (statusCode !== 204 && statusCode !== 403 && statusCode !== 404) {
        let error = new msRest.RestError(operationRes.bodyAsText as string);
        error.statusCode = response.status;
        error.request = msRest.stripRequest(httpRequest);
        error.response = msRest.stripResponse(response);
        let parsedErrorResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedErrorResponse) {
            let internalError = null;
            if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
            error.code = internalError ? internalError.code : parsedErrorResponse.code;
            error.message = internalError ? internalError.message : parsedErrorResponse.message;
          }
        } catch (defaultError) {
          error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                           `- "${operationRes.bodyAsText}" for the default response.`;
          return Promise.reject(error);
        }
        return Promise.reject(error);
      }
      // Deserialize Response
      if (statusCode === 204) {
        let parsedResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedResponse !== null && parsedResponse !== undefined) {
            let resultMapper = {
              required: false,
              serializedName: 'parsedResponse',
              type: {
                name: 'Object'
              }
            };
            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
          }
        } catch (error) {
          let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
          deserializationError.request = msRest.stripRequest(httpRequest);
          deserializationError.response = msRest.stripResponse(response);
          return Promise.reject(deserializationError);
        }
      }

    } catch(err) {
      return Promise.reject(err);
    }

    return Promise.resolve(operationRes);
  }
  // methods on the client.

  /**
   * @summary Overrides the task.
   *
   * @param {WorkflowActionModel} model The model.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  async overrideTaskWithHttpOperationResponse(model: Models.WorkflowActionModel, options?: msRest.RequestOptionsBase): Promise<msRest.HttpOperationResponse> {
    let client = this;
    // Validate
    try {
      if (model === null || model === undefined) {
        throw new Error('model cannot be null or undefined.');
      }
    } catch (error) {
      return Promise.reject(error);
    }

    // Construct URL
    let baseUrl = this.baseUri;
    let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'v1/workflow/actions/override';

    // Create HTTP transport objects
    let httpRequest = new WebResource();
    httpRequest.method = 'POST';
    httpRequest.url = requestUrl;
    httpRequest.headers = {};
    // Set Headers
    httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
    if(options && options.customHeaders) {
      for(let headerName in options.customHeaders) {
        if (options.customHeaders.hasOwnProperty(headerName)) {
          httpRequest.headers[headerName] = options.customHeaders[headerName];
        }
      }
    }
    // Serialize Request
    let requestContent = null;
    let requestModel = null;
    try {
      if (model !== null && model !== undefined) {
        let requestModelMapper = Mappers.WorkflowActionModel;
        requestModel = client.serializer.serialize(requestModelMapper, model, 'model');
        requestContent = JSON.stringify(requestModel);
      }
    } catch (error) {
      let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
          `payload - ${JSON.stringify(model, null, 2)}.`);
      return Promise.reject(serializationError);
    }
    httpRequest.body = requestContent;
    // Send Request
    let operationRes: msRest.HttpOperationResponse;
    try {
      operationRes = await client.pipeline(httpRequest);
      let response = operationRes.response;
      let statusCode = response.status;
      if (statusCode !== 204 && statusCode !== 403 && statusCode !== 404) {
        let error = new msRest.RestError(operationRes.bodyAsText as string);
        error.statusCode = response.status;
        error.request = msRest.stripRequest(httpRequest);
        error.response = msRest.stripResponse(response);
        let parsedErrorResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedErrorResponse) {
            let internalError = null;
            if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
            error.code = internalError ? internalError.code : parsedErrorResponse.code;
            error.message = internalError ? internalError.message : parsedErrorResponse.message;
          }
        } catch (defaultError) {
          error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                           `- "${operationRes.bodyAsText}" for the default response.`;
          return Promise.reject(error);
        }
        return Promise.reject(error);
      }
      // Deserialize Response
      if (statusCode === 204) {
        let parsedResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedResponse !== null && parsedResponse !== undefined) {
            let resultMapper = {
              required: false,
              serializedName: 'parsedResponse',
              type: {
                name: 'Object'
              }
            };
            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
          }
        } catch (error) {
          let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
          deserializationError.request = msRest.stripRequest(httpRequest);
          deserializationError.response = msRest.stripResponse(response);
          return Promise.reject(deserializationError);
        }
      }

    } catch(err) {
      return Promise.reject(err);
    }

    return Promise.resolve(operationRes);
  }
  // methods on the client.

  /**
   * @summary Resets the task.
   *
   * @param {WorkflowActionModel} model The model.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  async resetTaskWithHttpOperationResponse(model: Models.WorkflowActionModel, options?: msRest.RequestOptionsBase): Promise<msRest.HttpOperationResponse> {
    let client = this;
    // Validate
    try {
      if (model === null || model === undefined) {
        throw new Error('model cannot be null or undefined.');
      }
    } catch (error) {
      return Promise.reject(error);
    }

    // Construct URL
    let baseUrl = this.baseUri;
    let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'v1/workflow/actions/reset';

    // Create HTTP transport objects
    let httpRequest = new WebResource();
    httpRequest.method = 'POST';
    httpRequest.url = requestUrl;
    httpRequest.headers = {};
    // Set Headers
    httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
    if(options && options.customHeaders) {
      for(let headerName in options.customHeaders) {
        if (options.customHeaders.hasOwnProperty(headerName)) {
          httpRequest.headers[headerName] = options.customHeaders[headerName];
        }
      }
    }
    // Serialize Request
    let requestContent = null;
    let requestModel = null;
    try {
      if (model !== null && model !== undefined) {
        let requestModelMapper = Mappers.WorkflowActionModel;
        requestModel = client.serializer.serialize(requestModelMapper, model, 'model');
        requestContent = JSON.stringify(requestModel);
      }
    } catch (error) {
      let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
          `payload - ${JSON.stringify(model, null, 2)}.`);
      return Promise.reject(serializationError);
    }
    httpRequest.body = requestContent;
    // Send Request
    let operationRes: msRest.HttpOperationResponse;
    try {
      operationRes = await client.pipeline(httpRequest);
      let response = operationRes.response;
      let statusCode = response.status;
      if (statusCode !== 204 && statusCode !== 403 && statusCode !== 404) {
        let error = new msRest.RestError(operationRes.bodyAsText as string);
        error.statusCode = response.status;
        error.request = msRest.stripRequest(httpRequest);
        error.response = msRest.stripResponse(response);
        let parsedErrorResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedErrorResponse) {
            let internalError = null;
            if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
            error.code = internalError ? internalError.code : parsedErrorResponse.code;
            error.message = internalError ? internalError.message : parsedErrorResponse.message;
          }
        } catch (defaultError) {
          error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                           `- "${operationRes.bodyAsText}" for the default response.`;
          return Promise.reject(error);
        }
        return Promise.reject(error);
      }
      // Deserialize Response
      if (statusCode === 204) {
        let parsedResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedResponse !== null && parsedResponse !== undefined) {
            let resultMapper = {
              required: false,
              serializedName: 'parsedResponse',
              type: {
                name: 'Object'
              }
            };
            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
          }
        } catch (error) {
          let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
          deserializationError.request = msRest.stripRequest(httpRequest);
          deserializationError.response = msRest.stripResponse(response);
          return Promise.reject(deserializationError);
        }
      }

    } catch(err) {
      return Promise.reject(err);
    }

    return Promise.resolve(operationRes);
  }
  // methods on the client.

  /**
   * @summary Initializes the Workflow.
   *
   * @param {WorkflowActionInitializeModel} model The model.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  async initializeEntityWorkflowWithHttpOperationResponse(model: Models.WorkflowActionInitializeModel, options?: msRest.RequestOptionsBase): Promise<msRest.HttpOperationResponse> {
    let client = this;
    // Validate
    try {
      if (model === null || model === undefined) {
        throw new Error('model cannot be null or undefined.');
      }
    } catch (error) {
      return Promise.reject(error);
    }

    // Construct URL
    let baseUrl = this.baseUri;
    let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'v1/workflow/actions/initialize';

    // Create HTTP transport objects
    let httpRequest = new WebResource();
    httpRequest.method = 'POST';
    httpRequest.url = requestUrl;
    httpRequest.headers = {};
    // Set Headers
    httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
    if(options && options.customHeaders) {
      for(let headerName in options.customHeaders) {
        if (options.customHeaders.hasOwnProperty(headerName)) {
          httpRequest.headers[headerName] = options.customHeaders[headerName];
        }
      }
    }
    // Serialize Request
    let requestContent = null;
    let requestModel = null;
    try {
      if (model !== null && model !== undefined) {
        let requestModelMapper = Mappers.WorkflowActionInitializeModel;
        requestModel = client.serializer.serialize(requestModelMapper, model, 'model');
        requestContent = JSON.stringify(requestModel);
      }
    } catch (error) {
      let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
          `payload - ${JSON.stringify(model, null, 2)}.`);
      return Promise.reject(serializationError);
    }
    httpRequest.body = requestContent;
    // Send Request
    let operationRes: msRest.HttpOperationResponse;
    try {
      operationRes = await client.pipeline(httpRequest);
      let response = operationRes.response;
      let statusCode = response.status;
      if (statusCode !== 204 && statusCode !== 403 && statusCode !== 404) {
        let error = new msRest.RestError(operationRes.bodyAsText as string);
        error.statusCode = response.status;
        error.request = msRest.stripRequest(httpRequest);
        error.response = msRest.stripResponse(response);
        let parsedErrorResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedErrorResponse) {
            let internalError = null;
            if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
            error.code = internalError ? internalError.code : parsedErrorResponse.code;
            error.message = internalError ? internalError.message : parsedErrorResponse.message;
          }
        } catch (defaultError) {
          error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                           `- "${operationRes.bodyAsText}" for the default response.`;
          return Promise.reject(error);
        }
        return Promise.reject(error);
      }
      // Deserialize Response
      if (statusCode === 204) {
        let parsedResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedResponse !== null && parsedResponse !== undefined) {
            let resultMapper = {
              required: false,
              serializedName: 'parsedResponse',
              type: {
                name: 'Object'
              }
            };
            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
          }
        } catch (error) {
          let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
          deserializationError.request = msRest.stripRequest(httpRequest);
          deserializationError.response = msRest.stripResponse(response);
          return Promise.reject(deserializationError);
        }
      }

    } catch(err) {
      return Promise.reject(err);
    }

    return Promise.resolve(operationRes);
  }
  // methods on the client.

  /**
   * @summary Gets a list of all available applications.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  async getAllApplicationsWithHttpOperationResponse(options?: msRest.RequestOptionsBase): Promise<msRest.HttpOperationResponse> {
    let client = this;

    // Construct URL
    let baseUrl = this.baseUri;
    let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'v1/directory/applications';

    // Create HTTP transport objects
    let httpRequest = new WebResource();
    httpRequest.method = 'GET';
    httpRequest.url = requestUrl;
    httpRequest.headers = {};
    // Set Headers
    httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
    if(options && options.customHeaders) {
      for(let headerName in options.customHeaders) {
        if (options.customHeaders.hasOwnProperty(headerName)) {
          httpRequest.headers[headerName] = options.customHeaders[headerName];
        }
      }
    }
    // Send Request
    let operationRes: msRest.HttpOperationResponse;
    try {
      operationRes = await client.pipeline(httpRequest);
      let response = operationRes.response;
      let statusCode = response.status;
      if (statusCode !== 200) {
        let error = new msRest.RestError(operationRes.bodyAsText as string);
        error.statusCode = response.status;
        error.request = msRest.stripRequest(httpRequest);
        error.response = msRest.stripResponse(response);
        let parsedErrorResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedErrorResponse) {
            let internalError = null;
            if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
            error.code = internalError ? internalError.code : parsedErrorResponse.code;
            error.message = internalError ? internalError.message : parsedErrorResponse.message;
          }
        } catch (defaultError) {
          error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                           `- "${operationRes.bodyAsText}" for the default response.`;
          return Promise.reject(error);
        }
        return Promise.reject(error);
      }
      // Deserialize Response
      if (statusCode === 200) {
        let parsedResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedResponse !== null && parsedResponse !== undefined) {
            let resultMapper = {
              required: false,
              serializedName: 'parsedResponse',
              type: {
                name: 'Sequence',
                element: {
                    required: false,
                    serializedName: 'ApplicationModelElementType',
                    type: {
                      name: 'Composite',
                      className: 'ApplicationModel'
                    }
                }
              }
            };
            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
          }
        } catch (error) {
          let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
          deserializationError.request = msRest.stripRequest(httpRequest);
          deserializationError.response = msRest.stripResponse(response);
          return Promise.reject(deserializationError);
        }
      }

    } catch(err) {
      return Promise.reject(err);
    }

    return Promise.resolve(operationRes);
  }
  // methods on the client.

  /**
   * @summary Gets a single application by its unique identifier.
   *
   * @param {number} id The unique application identifier.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  async getApplicationByIdWithHttpOperationResponse(id: number, options?: msRest.RequestOptionsBase): Promise<msRest.HttpOperationResponse> {
    let client = this;
    // Validate
    try {
      if (id === null || id === undefined || typeof id !== 'number') {
        throw new Error('id cannot be null or undefined and it must be of type number.');
      }
    } catch (error) {
      return Promise.reject(error);
    }

    // Construct URL
    let baseUrl = this.baseUri;
    let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'v1/directory/applications/{id}';
    requestUrl = requestUrl.replace('{id}', encodeURIComponent(id.toString()));

    // Create HTTP transport objects
    let httpRequest = new WebResource();
    httpRequest.method = 'GET';
    httpRequest.url = requestUrl;
    httpRequest.headers = {};
    // Set Headers
    httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
    if(options && options.customHeaders) {
      for(let headerName in options.customHeaders) {
        if (options.customHeaders.hasOwnProperty(headerName)) {
          httpRequest.headers[headerName] = options.customHeaders[headerName];
        }
      }
    }
    // Send Request
    let operationRes: msRest.HttpOperationResponse;
    try {
      operationRes = await client.pipeline(httpRequest);
      let response = operationRes.response;
      let statusCode = response.status;
      if (statusCode !== 200 && statusCode !== 404) {
        let error = new msRest.RestError(operationRes.bodyAsText as string);
        error.statusCode = response.status;
        error.request = msRest.stripRequest(httpRequest);
        error.response = msRest.stripResponse(response);
        let parsedErrorResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedErrorResponse) {
            let internalError = null;
            if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
            error.code = internalError ? internalError.code : parsedErrorResponse.code;
            error.message = internalError ? internalError.message : parsedErrorResponse.message;
          }
        } catch (defaultError) {
          error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                           `- "${operationRes.bodyAsText}" for the default response.`;
          return Promise.reject(error);
        }
        return Promise.reject(error);
      }
      // Deserialize Response
      if (statusCode === 200) {
        let parsedResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedResponse !== null && parsedResponse !== undefined) {
            let resultMapper = Mappers.ApplicationModel;
            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
          }
        } catch (error) {
          let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
          deserializationError.request = msRest.stripRequest(httpRequest);
          deserializationError.response = msRest.stripResponse(response);
          return Promise.reject(deserializationError);
        }
      }

    } catch(err) {
      return Promise.reject(err);
    }

    return Promise.resolve(operationRes);
  }
  // methods on the client.

  /**
   * @summary Gets a single application by its name.
   *
   * @param {string} name The unique application name.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  async getApplicationByNameWithHttpOperationResponse(name: string, options?: msRest.RequestOptionsBase): Promise<msRest.HttpOperationResponse> {
    let client = this;
    // Validate
    try {
      if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
        throw new Error('name cannot be null or undefined and it must be of type string.');
      }
    } catch (error) {
      return Promise.reject(error);
    }

    // Construct URL
    let baseUrl = this.baseUri;
    let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'v1/directory/applications/{name}';
    requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));

    // Create HTTP transport objects
    let httpRequest = new WebResource();
    httpRequest.method = 'GET';
    httpRequest.url = requestUrl;
    httpRequest.headers = {};
    // Set Headers
    httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
    if(options && options.customHeaders) {
      for(let headerName in options.customHeaders) {
        if (options.customHeaders.hasOwnProperty(headerName)) {
          httpRequest.headers[headerName] = options.customHeaders[headerName];
        }
      }
    }
    // Send Request
    let operationRes: msRest.HttpOperationResponse;
    try {
      operationRes = await client.pipeline(httpRequest);
      let response = operationRes.response;
      let statusCode = response.status;
      if (statusCode !== 200 && statusCode !== 404) {
        let error = new msRest.RestError(operationRes.bodyAsText as string);
        error.statusCode = response.status;
        error.request = msRest.stripRequest(httpRequest);
        error.response = msRest.stripResponse(response);
        let parsedErrorResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedErrorResponse) {
            let internalError = null;
            if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
            error.code = internalError ? internalError.code : parsedErrorResponse.code;
            error.message = internalError ? internalError.message : parsedErrorResponse.message;
          }
        } catch (defaultError) {
          error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                           `- "${operationRes.bodyAsText}" for the default response.`;
          return Promise.reject(error);
        }
        return Promise.reject(error);
      }
      // Deserialize Response
      if (statusCode === 200) {
        let parsedResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedResponse !== null && parsedResponse !== undefined) {
            let resultMapper = Mappers.ApplicationModel;
            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
          }
        } catch (error) {
          let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
          deserializationError.request = msRest.stripRequest(httpRequest);
          deserializationError.response = msRest.stripResponse(response);
          return Promise.reject(deserializationError);
        }
      }

    } catch(err) {
      return Promise.reject(err);
    }

    return Promise.resolve(operationRes);
  }
  // methods on the client.

  /**
   * @summary Gets a list of drawer group associations.
   *
   * @param {number} drawerID The drawer identifier.
   *
   * @param {SoftheonEnterpriseAPIGetDrawerGroupAssociationsOptionalParams}
   * [options] Optional Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  async getDrawerGroupAssociationsWithHttpOperationResponse(drawerID: number, options?: Models.SoftheonEnterpriseAPIGetDrawerGroupAssociationsOptionalParams): Promise<msRest.HttpOperationResponse> {
    let client = this;
    let groupID = (options && options.groupID !== undefined) ? options.groupID : undefined;
    let acl = (options && options.acl !== undefined) ? options.acl : undefined;
    let page = (options && options.page !== undefined) ? options.page : undefined;
    let pageSize = (options && options.pageSize !== undefined) ? options.pageSize : undefined;
    let sortOrder = (options && options.sortOrder !== undefined) ? options.sortOrder : undefined;
    let sortBy = (options && options.sortBy !== undefined) ? options.sortBy : undefined;
    // Validate
    try {
      if (groupID !== null && groupID !== undefined && typeof groupID !== 'number') {
        throw new Error('groupID must be of type number.');
      }
      if (drawerID === null || drawerID === undefined || typeof drawerID !== 'number') {
        throw new Error('drawerID cannot be null or undefined and it must be of type number.');
      }
      if (acl !== null && acl !== undefined && typeof acl !== 'number') {
        throw new Error('acl must be of type number.');
      }
      if (page !== null && page !== undefined && typeof page !== 'number') {
        throw new Error('page must be of type number.');
      }
      if (page !== null && page !== undefined) {
        if (page > 2147483647)
        {
          throw new Error('"page" should satisfy the constraint - "InclusiveMaximum": 2147483647');
        }
        if (page < 1)
        {
          throw new Error('"page" should satisfy the constraint - "InclusiveMinimum": 1');
        }
      }
      if (pageSize !== null && pageSize !== undefined && typeof pageSize !== 'number') {
        throw new Error('pageSize must be of type number.');
      }
      if (pageSize !== null && pageSize !== undefined) {
        if (pageSize > 1000)
        {
          throw new Error('"pageSize" should satisfy the constraint - "InclusiveMaximum": 1000');
        }
        if (pageSize < 1)
        {
          throw new Error('"pageSize" should satisfy the constraint - "InclusiveMinimum": 1');
        }
      }
      if (sortOrder !== null && sortOrder !== undefined && typeof sortOrder.valueOf() !== 'string') {
        throw new Error('sortOrder must be of type string.');
      }
      if (sortBy !== null && sortBy !== undefined && typeof sortBy.valueOf() !== 'string') {
        throw new Error('sortBy must be of type string.');
      }
    } catch (error) {
      return Promise.reject(error);
    }

    // Construct URL
    let baseUrl = this.baseUri;
    let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'v1/directory/drawers/{drawerID}/groups';
    requestUrl = requestUrl.replace('{drawerID}', encodeURIComponent(drawerID.toString()));
    let queryParamsArray: Array<any> = [];
    if (groupID !== null && groupID !== undefined) {
      queryParamsArray.push('groupID=' + encodeURIComponent(groupID.toString()));
    }
    if (acl !== null && acl !== undefined) {
      queryParamsArray.push('acl=' + encodeURIComponent(acl.toString()));
    }
    if (page !== null && page !== undefined) {
      queryParamsArray.push('page=' + encodeURIComponent(page.toString()));
    }
    if (pageSize !== null && pageSize !== undefined) {
      queryParamsArray.push('pageSize=' + encodeURIComponent(pageSize.toString()));
    }
    if (sortOrder !== null && sortOrder !== undefined) {
      queryParamsArray.push('sortOrder=' + encodeURIComponent(sortOrder));
    }
    if (sortBy !== null && sortBy !== undefined) {
      queryParamsArray.push('sortBy=' + encodeURIComponent(sortBy));
    }
    if (queryParamsArray.length > 0) {
      requestUrl += '?' + queryParamsArray.join('&');
    }

    // Create HTTP transport objects
    let httpRequest = new WebResource();
    httpRequest.method = 'GET';
    httpRequest.url = requestUrl;
    httpRequest.headers = {};
    // Set Headers
    httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
    if(options && options.customHeaders) {
      for(let headerName in options.customHeaders) {
        if (options.customHeaders.hasOwnProperty(headerName)) {
          httpRequest.headers[headerName] = options.customHeaders[headerName];
        }
      }
    }
    // Send Request
    let operationRes: msRest.HttpOperationResponse;
    try {
      operationRes = await client.pipeline(httpRequest);
      let response = operationRes.response;
      let statusCode = response.status;
      if (statusCode !== 200 && statusCode !== 403) {
        let error = new msRest.RestError(operationRes.bodyAsText as string);
        error.statusCode = response.status;
        error.request = msRest.stripRequest(httpRequest);
        error.response = msRest.stripResponse(response);
        let parsedErrorResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedErrorResponse) {
            let internalError = null;
            if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
            error.code = internalError ? internalError.code : parsedErrorResponse.code;
            error.message = internalError ? internalError.message : parsedErrorResponse.message;
          }
        } catch (defaultError) {
          error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                           `- "${operationRes.bodyAsText}" for the default response.`;
          return Promise.reject(error);
        }
        return Promise.reject(error);
      }
      // Deserialize Response
      if (statusCode === 200) {
        let parsedResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedResponse !== null && parsedResponse !== undefined) {
            let resultMapper = {
              required: false,
              serializedName: 'parsedResponse',
              type: {
                name: 'Sequence',
                element: {
                    required: false,
                    serializedName: 'GroupDrawerModelElementType',
                    type: {
                      name: 'Composite',
                      className: 'GroupDrawerModel'
                    }
                }
              }
            };
            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
          }
        } catch (error) {
          let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
          deserializationError.request = msRest.stripRequest(httpRequest);
          deserializationError.response = msRest.stripResponse(response);
          return Promise.reject(deserializationError);
        }
      }

    } catch(err) {
      return Promise.reject(err);
    }

    return Promise.resolve(operationRes);
  }
  // methods on the client.

  /**
   * @summary Gets a list of group drawer associations.
   *
   * @param {number} groupID The group identifier.
   *
   * @param {SoftheonEnterpriseAPIGetGroupDrawerAssociationsOptionalParams}
   * [options] Optional Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  async getGroupDrawerAssociationsWithHttpOperationResponse(groupID: number, options?: Models.SoftheonEnterpriseAPIGetGroupDrawerAssociationsOptionalParams): Promise<msRest.HttpOperationResponse> {
    let client = this;
    let drawerID = (options && options.drawerID !== undefined) ? options.drawerID : undefined;
    let acl = (options && options.acl !== undefined) ? options.acl : undefined;
    let page = (options && options.page !== undefined) ? options.page : undefined;
    let pageSize = (options && options.pageSize !== undefined) ? options.pageSize : undefined;
    let sortOrder = (options && options.sortOrder !== undefined) ? options.sortOrder : undefined;
    let sortBy = (options && options.sortBy !== undefined) ? options.sortBy : undefined;
    // Validate
    try {
      if (groupID === null || groupID === undefined || typeof groupID !== 'number') {
        throw new Error('groupID cannot be null or undefined and it must be of type number.');
      }
      if (drawerID !== null && drawerID !== undefined && typeof drawerID !== 'number') {
        throw new Error('drawerID must be of type number.');
      }
      if (acl !== null && acl !== undefined && typeof acl !== 'number') {
        throw new Error('acl must be of type number.');
      }
      if (page !== null && page !== undefined && typeof page !== 'number') {
        throw new Error('page must be of type number.');
      }
      if (page !== null && page !== undefined) {
        if (page > 2147483647)
        {
          throw new Error('"page" should satisfy the constraint - "InclusiveMaximum": 2147483647');
        }
        if (page < 1)
        {
          throw new Error('"page" should satisfy the constraint - "InclusiveMinimum": 1');
        }
      }
      if (pageSize !== null && pageSize !== undefined && typeof pageSize !== 'number') {
        throw new Error('pageSize must be of type number.');
      }
      if (pageSize !== null && pageSize !== undefined) {
        if (pageSize > 1000)
        {
          throw new Error('"pageSize" should satisfy the constraint - "InclusiveMaximum": 1000');
        }
        if (pageSize < 1)
        {
          throw new Error('"pageSize" should satisfy the constraint - "InclusiveMinimum": 1');
        }
      }
      if (sortOrder !== null && sortOrder !== undefined && typeof sortOrder.valueOf() !== 'string') {
        throw new Error('sortOrder must be of type string.');
      }
      if (sortBy !== null && sortBy !== undefined && typeof sortBy.valueOf() !== 'string') {
        throw new Error('sortBy must be of type string.');
      }
    } catch (error) {
      return Promise.reject(error);
    }

    // Construct URL
    let baseUrl = this.baseUri;
    let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'v1/directory/groups/{groupID}/drawers';
    requestUrl = requestUrl.replace('{groupID}', encodeURIComponent(groupID.toString()));
    let queryParamsArray: Array<any> = [];
    if (drawerID !== null && drawerID !== undefined) {
      queryParamsArray.push('drawerID=' + encodeURIComponent(drawerID.toString()));
    }
    if (acl !== null && acl !== undefined) {
      queryParamsArray.push('acl=' + encodeURIComponent(acl.toString()));
    }
    if (page !== null && page !== undefined) {
      queryParamsArray.push('page=' + encodeURIComponent(page.toString()));
    }
    if (pageSize !== null && pageSize !== undefined) {
      queryParamsArray.push('pageSize=' + encodeURIComponent(pageSize.toString()));
    }
    if (sortOrder !== null && sortOrder !== undefined) {
      queryParamsArray.push('sortOrder=' + encodeURIComponent(sortOrder));
    }
    if (sortBy !== null && sortBy !== undefined) {
      queryParamsArray.push('sortBy=' + encodeURIComponent(sortBy));
    }
    if (queryParamsArray.length > 0) {
      requestUrl += '?' + queryParamsArray.join('&');
    }

    // Create HTTP transport objects
    let httpRequest = new WebResource();
    httpRequest.method = 'GET';
    httpRequest.url = requestUrl;
    httpRequest.headers = {};
    // Set Headers
    httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
    if(options && options.customHeaders) {
      for(let headerName in options.customHeaders) {
        if (options.customHeaders.hasOwnProperty(headerName)) {
          httpRequest.headers[headerName] = options.customHeaders[headerName];
        }
      }
    }
    // Send Request
    let operationRes: msRest.HttpOperationResponse;
    try {
      operationRes = await client.pipeline(httpRequest);
      let response = operationRes.response;
      let statusCode = response.status;
      if (statusCode !== 200 && statusCode !== 403) {
        let error = new msRest.RestError(operationRes.bodyAsText as string);
        error.statusCode = response.status;
        error.request = msRest.stripRequest(httpRequest);
        error.response = msRest.stripResponse(response);
        let parsedErrorResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedErrorResponse) {
            let internalError = null;
            if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
            error.code = internalError ? internalError.code : parsedErrorResponse.code;
            error.message = internalError ? internalError.message : parsedErrorResponse.message;
          }
        } catch (defaultError) {
          error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                           `- "${operationRes.bodyAsText}" for the default response.`;
          return Promise.reject(error);
        }
        return Promise.reject(error);
      }
      // Deserialize Response
      if (statusCode === 200) {
        let parsedResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedResponse !== null && parsedResponse !== undefined) {
            let resultMapper = {
              required: false,
              serializedName: 'parsedResponse',
              type: {
                name: 'Sequence',
                element: {
                    required: false,
                    serializedName: 'GroupDrawerModelElementType',
                    type: {
                      name: 'Composite',
                      className: 'GroupDrawerModel'
                    }
                }
              }
            };
            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
          }
        } catch (error) {
          let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
          deserializationError.request = msRest.stripRequest(httpRequest);
          deserializationError.response = msRest.stripResponse(response);
          return Promise.reject(deserializationError);
        }
      }

    } catch(err) {
      return Promise.reject(err);
    }

    return Promise.resolve(operationRes);
  }
  // methods on the client.

  /**
   * @summary Inserts/Updates the drawer group association.
   *
   * @param {number} groupID The group identifier.
   *
   * @param {number} drawerID The drawer identifier.
   *
   * @param {GroupDrawerModel} model The model.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  async createOrUpdateDrawerGroupAssociationWithHttpOperationResponse(groupID: number, drawerID: number, model: Models.GroupDrawerModel, options?: msRest.RequestOptionsBase): Promise<msRest.HttpOperationResponse> {
    let client = this;
    // Validate
    try {
      if (groupID === null || groupID === undefined || typeof groupID !== 'number') {
        throw new Error('groupID cannot be null or undefined and it must be of type number.');
      }
      if (drawerID === null || drawerID === undefined || typeof drawerID !== 'number') {
        throw new Error('drawerID cannot be null or undefined and it must be of type number.');
      }
      if (model === null || model === undefined) {
        throw new Error('model cannot be null or undefined.');
      }
    } catch (error) {
      return Promise.reject(error);
    }

    // Construct URL
    let baseUrl = this.baseUri;
    let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'v1/directory/drawers/{drawerID}/groups/{groupID}';
    requestUrl = requestUrl.replace('{groupID}', encodeURIComponent(groupID.toString()));
    requestUrl = requestUrl.replace('{drawerID}', encodeURIComponent(drawerID.toString()));

    // Create HTTP transport objects
    let httpRequest = new WebResource();
    httpRequest.method = 'PUT';
    httpRequest.url = requestUrl;
    httpRequest.headers = {};
    // Set Headers
    httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
    if(options && options.customHeaders) {
      for(let headerName in options.customHeaders) {
        if (options.customHeaders.hasOwnProperty(headerName)) {
          httpRequest.headers[headerName] = options.customHeaders[headerName];
        }
      }
    }
    // Serialize Request
    let requestContent = null;
    let requestModel = null;
    try {
      if (model !== null && model !== undefined) {
        let requestModelMapper = Mappers.GroupDrawerModel;
        requestModel = client.serializer.serialize(requestModelMapper, model, 'model');
        requestContent = JSON.stringify(requestModel);
      }
    } catch (error) {
      let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
          `payload - ${JSON.stringify(model, null, 2)}.`);
      return Promise.reject(serializationError);
    }
    httpRequest.body = requestContent;
    // Send Request
    let operationRes: msRest.HttpOperationResponse;
    try {
      operationRes = await client.pipeline(httpRequest);
      let response = operationRes.response;
      let statusCode = response.status;
      if (statusCode !== 204 && statusCode !== 403) {
        let error = new msRest.RestError(operationRes.bodyAsText as string);
        error.statusCode = response.status;
        error.request = msRest.stripRequest(httpRequest);
        error.response = msRest.stripResponse(response);
        let parsedErrorResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedErrorResponse) {
            let internalError = null;
            if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
            error.code = internalError ? internalError.code : parsedErrorResponse.code;
            error.message = internalError ? internalError.message : parsedErrorResponse.message;
          }
        } catch (defaultError) {
          error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                           `- "${operationRes.bodyAsText}" for the default response.`;
          return Promise.reject(error);
        }
        return Promise.reject(error);
      }
      // Deserialize Response
      if (statusCode === 204) {
        let parsedResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedResponse !== null && parsedResponse !== undefined) {
            let resultMapper = {
              required: false,
              serializedName: 'parsedResponse',
              type: {
                name: 'Object'
              }
            };
            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
          }
        } catch (error) {
          let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
          deserializationError.request = msRest.stripRequest(httpRequest);
          deserializationError.response = msRest.stripResponse(response);
          return Promise.reject(deserializationError);
        }
      }

    } catch(err) {
      return Promise.reject(err);
    }

    return Promise.resolve(operationRes);
  }
  // methods on the client.

  /**
   * @summary Deletes a drawer group association;
   *
   * @param {number} groupID The group identifier.
   *
   * @param {number} drawerID The drawer identifier.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  async deleteDrawerGroupAssociationWithHttpOperationResponse(groupID: number, drawerID: number, options?: msRest.RequestOptionsBase): Promise<msRest.HttpOperationResponse> {
    let client = this;
    // Validate
    try {
      if (groupID === null || groupID === undefined || typeof groupID !== 'number') {
        throw new Error('groupID cannot be null or undefined and it must be of type number.');
      }
      if (drawerID === null || drawerID === undefined || typeof drawerID !== 'number') {
        throw new Error('drawerID cannot be null or undefined and it must be of type number.');
      }
    } catch (error) {
      return Promise.reject(error);
    }

    // Construct URL
    let baseUrl = this.baseUri;
    let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'v1/directory/drawers/{drawerID}/groups/{groupID}';
    requestUrl = requestUrl.replace('{groupID}', encodeURIComponent(groupID.toString()));
    requestUrl = requestUrl.replace('{drawerID}', encodeURIComponent(drawerID.toString()));

    // Create HTTP transport objects
    let httpRequest = new WebResource();
    httpRequest.method = 'DELETE';
    httpRequest.url = requestUrl;
    httpRequest.headers = {};
    // Set Headers
    httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
    if(options && options.customHeaders) {
      for(let headerName in options.customHeaders) {
        if (options.customHeaders.hasOwnProperty(headerName)) {
          httpRequest.headers[headerName] = options.customHeaders[headerName];
        }
      }
    }
    // Send Request
    let operationRes: msRest.HttpOperationResponse;
    try {
      operationRes = await client.pipeline(httpRequest);
      let response = operationRes.response;
      let statusCode = response.status;
      if (statusCode !== 204 && statusCode !== 403 && statusCode !== 404) {
        let error = new msRest.RestError(operationRes.bodyAsText as string);
        error.statusCode = response.status;
        error.request = msRest.stripRequest(httpRequest);
        error.response = msRest.stripResponse(response);
        let parsedErrorResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedErrorResponse) {
            let internalError = null;
            if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
            error.code = internalError ? internalError.code : parsedErrorResponse.code;
            error.message = internalError ? internalError.message : parsedErrorResponse.message;
          }
        } catch (defaultError) {
          error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                           `- "${operationRes.bodyAsText}" for the default response.`;
          return Promise.reject(error);
        }
        return Promise.reject(error);
      }
      // Deserialize Response
      if (statusCode === 204) {
        let parsedResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedResponse !== null && parsedResponse !== undefined) {
            let resultMapper = {
              required: false,
              serializedName: 'parsedResponse',
              type: {
                name: 'Object'
              }
            };
            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
          }
        } catch (error) {
          let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
          deserializationError.request = msRest.stripRequest(httpRequest);
          deserializationError.response = msRest.stripResponse(response);
          return Promise.reject(deserializationError);
        }
      }

    } catch(err) {
      return Promise.reject(err);
    }

    return Promise.resolve(operationRes);
  }
  // methods on the client.

  /**
   * @summary Inserts/Updates the group drawer association.
   *
   * @param {number} groupID The group identifier.
   *
   * @param {number} drawerID The drawer identifier.
   *
   * @param {GroupDrawerModel} model The model.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  async createOrUpdateGroupDrawerAssociationWithHttpOperationResponse(groupID: number, drawerID: number, model: Models.GroupDrawerModel, options?: msRest.RequestOptionsBase): Promise<msRest.HttpOperationResponse> {
    let client = this;
    // Validate
    try {
      if (groupID === null || groupID === undefined || typeof groupID !== 'number') {
        throw new Error('groupID cannot be null or undefined and it must be of type number.');
      }
      if (drawerID === null || drawerID === undefined || typeof drawerID !== 'number') {
        throw new Error('drawerID cannot be null or undefined and it must be of type number.');
      }
      if (model === null || model === undefined) {
        throw new Error('model cannot be null or undefined.');
      }
    } catch (error) {
      return Promise.reject(error);
    }

    // Construct URL
    let baseUrl = this.baseUri;
    let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'v1/directory/groups/{groupID}/drawers/{drawerID}';
    requestUrl = requestUrl.replace('{groupID}', encodeURIComponent(groupID.toString()));
    requestUrl = requestUrl.replace('{drawerID}', encodeURIComponent(drawerID.toString()));

    // Create HTTP transport objects
    let httpRequest = new WebResource();
    httpRequest.method = 'PUT';
    httpRequest.url = requestUrl;
    httpRequest.headers = {};
    // Set Headers
    httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
    if(options && options.customHeaders) {
      for(let headerName in options.customHeaders) {
        if (options.customHeaders.hasOwnProperty(headerName)) {
          httpRequest.headers[headerName] = options.customHeaders[headerName];
        }
      }
    }
    // Serialize Request
    let requestContent = null;
    let requestModel = null;
    try {
      if (model !== null && model !== undefined) {
        let requestModelMapper = Mappers.GroupDrawerModel;
        requestModel = client.serializer.serialize(requestModelMapper, model, 'model');
        requestContent = JSON.stringify(requestModel);
      }
    } catch (error) {
      let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
          `payload - ${JSON.stringify(model, null, 2)}.`);
      return Promise.reject(serializationError);
    }
    httpRequest.body = requestContent;
    // Send Request
    let operationRes: msRest.HttpOperationResponse;
    try {
      operationRes = await client.pipeline(httpRequest);
      let response = operationRes.response;
      let statusCode = response.status;
      if (statusCode !== 204 && statusCode !== 403) {
        let error = new msRest.RestError(operationRes.bodyAsText as string);
        error.statusCode = response.status;
        error.request = msRest.stripRequest(httpRequest);
        error.response = msRest.stripResponse(response);
        let parsedErrorResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedErrorResponse) {
            let internalError = null;
            if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
            error.code = internalError ? internalError.code : parsedErrorResponse.code;
            error.message = internalError ? internalError.message : parsedErrorResponse.message;
          }
        } catch (defaultError) {
          error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                           `- "${operationRes.bodyAsText}" for the default response.`;
          return Promise.reject(error);
        }
        return Promise.reject(error);
      }
      // Deserialize Response
      if (statusCode === 204) {
        let parsedResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedResponse !== null && parsedResponse !== undefined) {
            let resultMapper = {
              required: false,
              serializedName: 'parsedResponse',
              type: {
                name: 'Object'
              }
            };
            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
          }
        } catch (error) {
          let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
          deserializationError.request = msRest.stripRequest(httpRequest);
          deserializationError.response = msRest.stripResponse(response);
          return Promise.reject(deserializationError);
        }
      }

    } catch(err) {
      return Promise.reject(err);
    }

    return Promise.resolve(operationRes);
  }
  // methods on the client.

  /**
   * @summary Deletes a group drawer association;
   *
   * @param {number} groupID The group identifier.
   *
   * @param {number} drawerID The drawer identifier.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  async deleteGroupDrawerAssociationWithHttpOperationResponse(groupID: number, drawerID: number, options?: msRest.RequestOptionsBase): Promise<msRest.HttpOperationResponse> {
    let client = this;
    // Validate
    try {
      if (groupID === null || groupID === undefined || typeof groupID !== 'number') {
        throw new Error('groupID cannot be null or undefined and it must be of type number.');
      }
      if (drawerID === null || drawerID === undefined || typeof drawerID !== 'number') {
        throw new Error('drawerID cannot be null or undefined and it must be of type number.');
      }
    } catch (error) {
      return Promise.reject(error);
    }

    // Construct URL
    let baseUrl = this.baseUri;
    let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'v1/directory/groups/{groupID}/drawers/{drawerID}';
    requestUrl = requestUrl.replace('{groupID}', encodeURIComponent(groupID.toString()));
    requestUrl = requestUrl.replace('{drawerID}', encodeURIComponent(drawerID.toString()));

    // Create HTTP transport objects
    let httpRequest = new WebResource();
    httpRequest.method = 'DELETE';
    httpRequest.url = requestUrl;
    httpRequest.headers = {};
    // Set Headers
    httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
    if(options && options.customHeaders) {
      for(let headerName in options.customHeaders) {
        if (options.customHeaders.hasOwnProperty(headerName)) {
          httpRequest.headers[headerName] = options.customHeaders[headerName];
        }
      }
    }
    // Send Request
    let operationRes: msRest.HttpOperationResponse;
    try {
      operationRes = await client.pipeline(httpRequest);
      let response = operationRes.response;
      let statusCode = response.status;
      if (statusCode !== 204 && statusCode !== 403 && statusCode !== 404) {
        let error = new msRest.RestError(operationRes.bodyAsText as string);
        error.statusCode = response.status;
        error.request = msRest.stripRequest(httpRequest);
        error.response = msRest.stripResponse(response);
        let parsedErrorResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedErrorResponse) {
            let internalError = null;
            if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
            error.code = internalError ? internalError.code : parsedErrorResponse.code;
            error.message = internalError ? internalError.message : parsedErrorResponse.message;
          }
        } catch (defaultError) {
          error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                           `- "${operationRes.bodyAsText}" for the default response.`;
          return Promise.reject(error);
        }
        return Promise.reject(error);
      }
      // Deserialize Response
      if (statusCode === 204) {
        let parsedResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedResponse !== null && parsedResponse !== undefined) {
            let resultMapper = {
              required: false,
              serializedName: 'parsedResponse',
              type: {
                name: 'Object'
              }
            };
            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
          }
        } catch (error) {
          let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
          deserializationError.request = msRest.stripRequest(httpRequest);
          deserializationError.response = msRest.stripResponse(response);
          return Promise.reject(deserializationError);
        }
      }

    } catch(err) {
      return Promise.reject(err);
    }

    return Promise.resolve(operationRes);
  }
  // methods on the client.

  /**
   * @summary Gets a list of user group associations.
   *
   * @param {number} userID The user identifier.
   *
   * @param {SoftheonEnterpriseAPIGetUserGroupAssociationsOptionalParams}
   * [options] Optional Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  async getUserGroupAssociationsWithHttpOperationResponse(userID: number, options?: Models.SoftheonEnterpriseAPIGetUserGroupAssociationsOptionalParams): Promise<msRest.HttpOperationResponse> {
    let client = this;
    let groupID = (options && options.groupID !== undefined) ? options.groupID : undefined;
    let acl = (options && options.acl !== undefined) ? options.acl : undefined;
    let page = (options && options.page !== undefined) ? options.page : undefined;
    let pageSize = (options && options.pageSize !== undefined) ? options.pageSize : undefined;
    let sortOrder = (options && options.sortOrder !== undefined) ? options.sortOrder : undefined;
    let sortBy = (options && options.sortBy !== undefined) ? options.sortBy : undefined;
    // Validate
    try {
      if (groupID !== null && groupID !== undefined && typeof groupID !== 'number') {
        throw new Error('groupID must be of type number.');
      }
      if (userID === null || userID === undefined || typeof userID !== 'number') {
        throw new Error('userID cannot be null or undefined and it must be of type number.');
      }
      if (acl !== null && acl !== undefined && typeof acl !== 'number') {
        throw new Error('acl must be of type number.');
      }
      if (page !== null && page !== undefined && typeof page !== 'number') {
        throw new Error('page must be of type number.');
      }
      if (page !== null && page !== undefined) {
        if (page > 2147483647)
        {
          throw new Error('"page" should satisfy the constraint - "InclusiveMaximum": 2147483647');
        }
        if (page < 1)
        {
          throw new Error('"page" should satisfy the constraint - "InclusiveMinimum": 1');
        }
      }
      if (pageSize !== null && pageSize !== undefined && typeof pageSize !== 'number') {
        throw new Error('pageSize must be of type number.');
      }
      if (pageSize !== null && pageSize !== undefined) {
        if (pageSize > 1000)
        {
          throw new Error('"pageSize" should satisfy the constraint - "InclusiveMaximum": 1000');
        }
        if (pageSize < 1)
        {
          throw new Error('"pageSize" should satisfy the constraint - "InclusiveMinimum": 1');
        }
      }
      if (sortOrder !== null && sortOrder !== undefined && typeof sortOrder.valueOf() !== 'string') {
        throw new Error('sortOrder must be of type string.');
      }
      if (sortBy !== null && sortBy !== undefined && typeof sortBy.valueOf() !== 'string') {
        throw new Error('sortBy must be of type string.');
      }
    } catch (error) {
      return Promise.reject(error);
    }

    // Construct URL
    let baseUrl = this.baseUri;
    let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'v1/directory/users/{userID}/groups';
    requestUrl = requestUrl.replace('{userID}', encodeURIComponent(userID.toString()));
    let queryParamsArray: Array<any> = [];
    if (groupID !== null && groupID !== undefined) {
      queryParamsArray.push('groupID=' + encodeURIComponent(groupID.toString()));
    }
    if (acl !== null && acl !== undefined) {
      queryParamsArray.push('acl=' + encodeURIComponent(acl.toString()));
    }
    if (page !== null && page !== undefined) {
      queryParamsArray.push('page=' + encodeURIComponent(page.toString()));
    }
    if (pageSize !== null && pageSize !== undefined) {
      queryParamsArray.push('pageSize=' + encodeURIComponent(pageSize.toString()));
    }
    if (sortOrder !== null && sortOrder !== undefined) {
      queryParamsArray.push('sortOrder=' + encodeURIComponent(sortOrder));
    }
    if (sortBy !== null && sortBy !== undefined) {
      queryParamsArray.push('sortBy=' + encodeURIComponent(sortBy));
    }
    if (queryParamsArray.length > 0) {
      requestUrl += '?' + queryParamsArray.join('&');
    }

    // Create HTTP transport objects
    let httpRequest = new WebResource();
    httpRequest.method = 'GET';
    httpRequest.url = requestUrl;
    httpRequest.headers = {};
    // Set Headers
    httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
    if(options && options.customHeaders) {
      for(let headerName in options.customHeaders) {
        if (options.customHeaders.hasOwnProperty(headerName)) {
          httpRequest.headers[headerName] = options.customHeaders[headerName];
        }
      }
    }
    // Send Request
    let operationRes: msRest.HttpOperationResponse;
    try {
      operationRes = await client.pipeline(httpRequest);
      let response = operationRes.response;
      let statusCode = response.status;
      if (statusCode !== 200 && statusCode !== 403) {
        let error = new msRest.RestError(operationRes.bodyAsText as string);
        error.statusCode = response.status;
        error.request = msRest.stripRequest(httpRequest);
        error.response = msRest.stripResponse(response);
        let parsedErrorResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedErrorResponse) {
            let internalError = null;
            if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
            error.code = internalError ? internalError.code : parsedErrorResponse.code;
            error.message = internalError ? internalError.message : parsedErrorResponse.message;
          }
        } catch (defaultError) {
          error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                           `- "${operationRes.bodyAsText}" for the default response.`;
          return Promise.reject(error);
        }
        return Promise.reject(error);
      }
      // Deserialize Response
      if (statusCode === 200) {
        let parsedResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedResponse !== null && parsedResponse !== undefined) {
            let resultMapper = {
              required: false,
              serializedName: 'parsedResponse',
              type: {
                name: 'Sequence',
                element: {
                    required: false,
                    serializedName: 'GroupUserModelElementType',
                    type: {
                      name: 'Composite',
                      className: 'GroupUserModel'
                    }
                }
              }
            };
            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
          }
        } catch (error) {
          let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
          deserializationError.request = msRest.stripRequest(httpRequest);
          deserializationError.response = msRest.stripResponse(response);
          return Promise.reject(deserializationError);
        }
      }

    } catch(err) {
      return Promise.reject(err);
    }

    return Promise.resolve(operationRes);
  }
  // methods on the client.

  /**
   * @summary Gets a list of group user associations.
   *
   * @param {number} groupID The group identifier.
   *
   * @param {SoftheonEnterpriseAPIGetGroupUserAssociationsOptionalParams}
   * [options] Optional Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  async getGroupUserAssociationsWithHttpOperationResponse(groupID: number, options?: Models.SoftheonEnterpriseAPIGetGroupUserAssociationsOptionalParams): Promise<msRest.HttpOperationResponse> {
    let client = this;
    let userID = (options && options.userID !== undefined) ? options.userID : undefined;
    let acl = (options && options.acl !== undefined) ? options.acl : undefined;
    let page = (options && options.page !== undefined) ? options.page : undefined;
    let pageSize = (options && options.pageSize !== undefined) ? options.pageSize : undefined;
    let sortOrder = (options && options.sortOrder !== undefined) ? options.sortOrder : undefined;
    let sortBy = (options && options.sortBy !== undefined) ? options.sortBy : undefined;
    // Validate
    try {
      if (groupID === null || groupID === undefined || typeof groupID !== 'number') {
        throw new Error('groupID cannot be null or undefined and it must be of type number.');
      }
      if (userID !== null && userID !== undefined && typeof userID !== 'number') {
        throw new Error('userID must be of type number.');
      }
      if (acl !== null && acl !== undefined && typeof acl !== 'number') {
        throw new Error('acl must be of type number.');
      }
      if (page !== null && page !== undefined && typeof page !== 'number') {
        throw new Error('page must be of type number.');
      }
      if (page !== null && page !== undefined) {
        if (page > 2147483647)
        {
          throw new Error('"page" should satisfy the constraint - "InclusiveMaximum": 2147483647');
        }
        if (page < 1)
        {
          throw new Error('"page" should satisfy the constraint - "InclusiveMinimum": 1');
        }
      }
      if (pageSize !== null && pageSize !== undefined && typeof pageSize !== 'number') {
        throw new Error('pageSize must be of type number.');
      }
      if (pageSize !== null && pageSize !== undefined) {
        if (pageSize > 1000)
        {
          throw new Error('"pageSize" should satisfy the constraint - "InclusiveMaximum": 1000');
        }
        if (pageSize < 1)
        {
          throw new Error('"pageSize" should satisfy the constraint - "InclusiveMinimum": 1');
        }
      }
      if (sortOrder !== null && sortOrder !== undefined && typeof sortOrder.valueOf() !== 'string') {
        throw new Error('sortOrder must be of type string.');
      }
      if (sortBy !== null && sortBy !== undefined && typeof sortBy.valueOf() !== 'string') {
        throw new Error('sortBy must be of type string.');
      }
    } catch (error) {
      return Promise.reject(error);
    }

    // Construct URL
    let baseUrl = this.baseUri;
    let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'v1/directory/groups/{groupID}/users';
    requestUrl = requestUrl.replace('{groupID}', encodeURIComponent(groupID.toString()));
    let queryParamsArray: Array<any> = [];
    if (userID !== null && userID !== undefined) {
      queryParamsArray.push('userID=' + encodeURIComponent(userID.toString()));
    }
    if (acl !== null && acl !== undefined) {
      queryParamsArray.push('acl=' + encodeURIComponent(acl.toString()));
    }
    if (page !== null && page !== undefined) {
      queryParamsArray.push('page=' + encodeURIComponent(page.toString()));
    }
    if (pageSize !== null && pageSize !== undefined) {
      queryParamsArray.push('pageSize=' + encodeURIComponent(pageSize.toString()));
    }
    if (sortOrder !== null && sortOrder !== undefined) {
      queryParamsArray.push('sortOrder=' + encodeURIComponent(sortOrder));
    }
    if (sortBy !== null && sortBy !== undefined) {
      queryParamsArray.push('sortBy=' + encodeURIComponent(sortBy));
    }
    if (queryParamsArray.length > 0) {
      requestUrl += '?' + queryParamsArray.join('&');
    }

    // Create HTTP transport objects
    let httpRequest = new WebResource();
    httpRequest.method = 'GET';
    httpRequest.url = requestUrl;
    httpRequest.headers = {};
    // Set Headers
    httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
    if(options && options.customHeaders) {
      for(let headerName in options.customHeaders) {
        if (options.customHeaders.hasOwnProperty(headerName)) {
          httpRequest.headers[headerName] = options.customHeaders[headerName];
        }
      }
    }
    // Send Request
    let operationRes: msRest.HttpOperationResponse;
    try {
      operationRes = await client.pipeline(httpRequest);
      let response = operationRes.response;
      let statusCode = response.status;
      if (statusCode !== 200 && statusCode !== 403) {
        let error = new msRest.RestError(operationRes.bodyAsText as string);
        error.statusCode = response.status;
        error.request = msRest.stripRequest(httpRequest);
        error.response = msRest.stripResponse(response);
        let parsedErrorResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedErrorResponse) {
            let internalError = null;
            if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
            error.code = internalError ? internalError.code : parsedErrorResponse.code;
            error.message = internalError ? internalError.message : parsedErrorResponse.message;
          }
        } catch (defaultError) {
          error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                           `- "${operationRes.bodyAsText}" for the default response.`;
          return Promise.reject(error);
        }
        return Promise.reject(error);
      }
      // Deserialize Response
      if (statusCode === 200) {
        let parsedResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedResponse !== null && parsedResponse !== undefined) {
            let resultMapper = {
              required: false,
              serializedName: 'parsedResponse',
              type: {
                name: 'Sequence',
                element: {
                    required: false,
                    serializedName: 'GroupUserModelElementType',
                    type: {
                      name: 'Composite',
                      className: 'GroupUserModel'
                    }
                }
              }
            };
            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
          }
        } catch (error) {
          let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
          deserializationError.request = msRest.stripRequest(httpRequest);
          deserializationError.response = msRest.stripResponse(response);
          return Promise.reject(deserializationError);
        }
      }

    } catch(err) {
      return Promise.reject(err);
    }

    return Promise.resolve(operationRes);
  }
  // methods on the client.

  /**
   * @summary Inserts the user group association.
   *
   * @param {number} groupID The group identifier.
   *
   * @param {number} userID The user identifier.
   *
   * @param {GroupUserModel} model The model.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  async createUserGroupAssociationWithHttpOperationResponse(groupID: number, userID: number, model: Models.GroupUserModel, options?: msRest.RequestOptionsBase): Promise<msRest.HttpOperationResponse> {
    let client = this;
    // Validate
    try {
      if (groupID === null || groupID === undefined || typeof groupID !== 'number') {
        throw new Error('groupID cannot be null or undefined and it must be of type number.');
      }
      if (userID === null || userID === undefined || typeof userID !== 'number') {
        throw new Error('userID cannot be null or undefined and it must be of type number.');
      }
      if (model === null || model === undefined) {
        throw new Error('model cannot be null or undefined.');
      }
    } catch (error) {
      return Promise.reject(error);
    }

    // Construct URL
    let baseUrl = this.baseUri;
    let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'v1/directory/users/{userID}/groups/{groupID}';
    requestUrl = requestUrl.replace('{groupID}', encodeURIComponent(groupID.toString()));
    requestUrl = requestUrl.replace('{userID}', encodeURIComponent(userID.toString()));

    // Create HTTP transport objects
    let httpRequest = new WebResource();
    httpRequest.method = 'POST';
    httpRequest.url = requestUrl;
    httpRequest.headers = {};
    // Set Headers
    httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
    if(options && options.customHeaders) {
      for(let headerName in options.customHeaders) {
        if (options.customHeaders.hasOwnProperty(headerName)) {
          httpRequest.headers[headerName] = options.customHeaders[headerName];
        }
      }
    }
    // Serialize Request
    let requestContent = null;
    let requestModel = null;
    try {
      if (model !== null && model !== undefined) {
        let requestModelMapper = Mappers.GroupUserModel;
        requestModel = client.serializer.serialize(requestModelMapper, model, 'model');
        requestContent = JSON.stringify(requestModel);
      }
    } catch (error) {
      let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
          `payload - ${JSON.stringify(model, null, 2)}.`);
      return Promise.reject(serializationError);
    }
    httpRequest.body = requestContent;
    // Send Request
    let operationRes: msRest.HttpOperationResponse;
    try {
      operationRes = await client.pipeline(httpRequest);
      let response = operationRes.response;
      let statusCode = response.status;
      if (statusCode !== 200 && statusCode !== 403 && statusCode !== 409) {
        let error = new msRest.RestError(operationRes.bodyAsText as string);
        error.statusCode = response.status;
        error.request = msRest.stripRequest(httpRequest);
        error.response = msRest.stripResponse(response);
        let parsedErrorResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedErrorResponse) {
            let internalError = null;
            if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
            error.code = internalError ? internalError.code : parsedErrorResponse.code;
            error.message = internalError ? internalError.message : parsedErrorResponse.message;
          }
        } catch (defaultError) {
          error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                           `- "${operationRes.bodyAsText}" for the default response.`;
          return Promise.reject(error);
        }
        return Promise.reject(error);
      }
      // Deserialize Response
      if (statusCode === 200) {
        let parsedResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedResponse !== null && parsedResponse !== undefined) {
            let resultMapper = {
              required: false,
              serializedName: 'parsedResponse',
              type: {
                name: 'Object'
              }
            };
            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
          }
        } catch (error) {
          let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
          deserializationError.request = msRest.stripRequest(httpRequest);
          deserializationError.response = msRest.stripResponse(response);
          return Promise.reject(deserializationError);
        }
      }

    } catch(err) {
      return Promise.reject(err);
    }

    return Promise.resolve(operationRes);
  }
  // methods on the client.

  /**
   * @summary Deletes a user group association;
   *
   * @param {number} groupID The group identifier.
   *
   * @param {number} userID The user identifier.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  async deleteUserGroupAssociationWithHttpOperationResponse(groupID: number, userID: number, options?: msRest.RequestOptionsBase): Promise<msRest.HttpOperationResponse> {
    let client = this;
    // Validate
    try {
      if (groupID === null || groupID === undefined || typeof groupID !== 'number') {
        throw new Error('groupID cannot be null or undefined and it must be of type number.');
      }
      if (userID === null || userID === undefined || typeof userID !== 'number') {
        throw new Error('userID cannot be null or undefined and it must be of type number.');
      }
    } catch (error) {
      return Promise.reject(error);
    }

    // Construct URL
    let baseUrl = this.baseUri;
    let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'v1/directory/users/{userID}/groups/{groupID}';
    requestUrl = requestUrl.replace('{groupID}', encodeURIComponent(groupID.toString()));
    requestUrl = requestUrl.replace('{userID}', encodeURIComponent(userID.toString()));

    // Create HTTP transport objects
    let httpRequest = new WebResource();
    httpRequest.method = 'DELETE';
    httpRequest.url = requestUrl;
    httpRequest.headers = {};
    // Set Headers
    httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
    if(options && options.customHeaders) {
      for(let headerName in options.customHeaders) {
        if (options.customHeaders.hasOwnProperty(headerName)) {
          httpRequest.headers[headerName] = options.customHeaders[headerName];
        }
      }
    }
    // Send Request
    let operationRes: msRest.HttpOperationResponse;
    try {
      operationRes = await client.pipeline(httpRequest);
      let response = operationRes.response;
      let statusCode = response.status;
      if (statusCode !== 204 && statusCode !== 403 && statusCode !== 404) {
        let error = new msRest.RestError(operationRes.bodyAsText as string);
        error.statusCode = response.status;
        error.request = msRest.stripRequest(httpRequest);
        error.response = msRest.stripResponse(response);
        let parsedErrorResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedErrorResponse) {
            let internalError = null;
            if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
            error.code = internalError ? internalError.code : parsedErrorResponse.code;
            error.message = internalError ? internalError.message : parsedErrorResponse.message;
          }
        } catch (defaultError) {
          error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                           `- "${operationRes.bodyAsText}" for the default response.`;
          return Promise.reject(error);
        }
        return Promise.reject(error);
      }
      // Deserialize Response
      if (statusCode === 204) {
        let parsedResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedResponse !== null && parsedResponse !== undefined) {
            let resultMapper = {
              required: false,
              serializedName: 'parsedResponse',
              type: {
                name: 'Object'
              }
            };
            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
          }
        } catch (error) {
          let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
          deserializationError.request = msRest.stripRequest(httpRequest);
          deserializationError.response = msRest.stripResponse(response);
          return Promise.reject(deserializationError);
        }
      }

    } catch(err) {
      return Promise.reject(err);
    }

    return Promise.resolve(operationRes);
  }
  // methods on the client.

  /**
   * @summary Inserts the group user association.
   *
   * @param {number} groupID The group identifier.
   *
   * @param {number} userID The user identifier.
   *
   * @param {GroupUserModel} model The model.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  async createGroupUserAssociationWithHttpOperationResponse(groupID: number, userID: number, model: Models.GroupUserModel, options?: msRest.RequestOptionsBase): Promise<msRest.HttpOperationResponse> {
    let client = this;
    // Validate
    try {
      if (groupID === null || groupID === undefined || typeof groupID !== 'number') {
        throw new Error('groupID cannot be null or undefined and it must be of type number.');
      }
      if (userID === null || userID === undefined || typeof userID !== 'number') {
        throw new Error('userID cannot be null or undefined and it must be of type number.');
      }
      if (model === null || model === undefined) {
        throw new Error('model cannot be null or undefined.');
      }
    } catch (error) {
      return Promise.reject(error);
    }

    // Construct URL
    let baseUrl = this.baseUri;
    let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'v1/directory/groups/{groupID}/users/{userID}';
    requestUrl = requestUrl.replace('{groupID}', encodeURIComponent(groupID.toString()));
    requestUrl = requestUrl.replace('{userID}', encodeURIComponent(userID.toString()));

    // Create HTTP transport objects
    let httpRequest = new WebResource();
    httpRequest.method = 'POST';
    httpRequest.url = requestUrl;
    httpRequest.headers = {};
    // Set Headers
    httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
    if(options && options.customHeaders) {
      for(let headerName in options.customHeaders) {
        if (options.customHeaders.hasOwnProperty(headerName)) {
          httpRequest.headers[headerName] = options.customHeaders[headerName];
        }
      }
    }
    // Serialize Request
    let requestContent = null;
    let requestModel = null;
    try {
      if (model !== null && model !== undefined) {
        let requestModelMapper = Mappers.GroupUserModel;
        requestModel = client.serializer.serialize(requestModelMapper, model, 'model');
        requestContent = JSON.stringify(requestModel);
      }
    } catch (error) {
      let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
          `payload - ${JSON.stringify(model, null, 2)}.`);
      return Promise.reject(serializationError);
    }
    httpRequest.body = requestContent;
    // Send Request
    let operationRes: msRest.HttpOperationResponse;
    try {
      operationRes = await client.pipeline(httpRequest);
      let response = operationRes.response;
      let statusCode = response.status;
      if (statusCode !== 200 && statusCode !== 403 && statusCode !== 409) {
        let error = new msRest.RestError(operationRes.bodyAsText as string);
        error.statusCode = response.status;
        error.request = msRest.stripRequest(httpRequest);
        error.response = msRest.stripResponse(response);
        let parsedErrorResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedErrorResponse) {
            let internalError = null;
            if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
            error.code = internalError ? internalError.code : parsedErrorResponse.code;
            error.message = internalError ? internalError.message : parsedErrorResponse.message;
          }
        } catch (defaultError) {
          error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                           `- "${operationRes.bodyAsText}" for the default response.`;
          return Promise.reject(error);
        }
        return Promise.reject(error);
      }
      // Deserialize Response
      if (statusCode === 200) {
        let parsedResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedResponse !== null && parsedResponse !== undefined) {
            let resultMapper = {
              required: false,
              serializedName: 'parsedResponse',
              type: {
                name: 'Object'
              }
            };
            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
          }
        } catch (error) {
          let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
          deserializationError.request = msRest.stripRequest(httpRequest);
          deserializationError.response = msRest.stripResponse(response);
          return Promise.reject(deserializationError);
        }
      }

    } catch(err) {
      return Promise.reject(err);
    }

    return Promise.resolve(operationRes);
  }
  // methods on the client.

  /**
   * @summary Deletes a group user association;
   *
   * @param {number} groupID The group identifier.
   *
   * @param {number} userID The user identifier.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  async deleteGroupUserAssociationWithHttpOperationResponse(groupID: number, userID: number, options?: msRest.RequestOptionsBase): Promise<msRest.HttpOperationResponse> {
    let client = this;
    // Validate
    try {
      if (groupID === null || groupID === undefined || typeof groupID !== 'number') {
        throw new Error('groupID cannot be null or undefined and it must be of type number.');
      }
      if (userID === null || userID === undefined || typeof userID !== 'number') {
        throw new Error('userID cannot be null or undefined and it must be of type number.');
      }
    } catch (error) {
      return Promise.reject(error);
    }

    // Construct URL
    let baseUrl = this.baseUri;
    let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'v1/directory/groups/{groupID}/users/{userID}';
    requestUrl = requestUrl.replace('{groupID}', encodeURIComponent(groupID.toString()));
    requestUrl = requestUrl.replace('{userID}', encodeURIComponent(userID.toString()));

    // Create HTTP transport objects
    let httpRequest = new WebResource();
    httpRequest.method = 'DELETE';
    httpRequest.url = requestUrl;
    httpRequest.headers = {};
    // Set Headers
    httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
    if(options && options.customHeaders) {
      for(let headerName in options.customHeaders) {
        if (options.customHeaders.hasOwnProperty(headerName)) {
          httpRequest.headers[headerName] = options.customHeaders[headerName];
        }
      }
    }
    // Send Request
    let operationRes: msRest.HttpOperationResponse;
    try {
      operationRes = await client.pipeline(httpRequest);
      let response = operationRes.response;
      let statusCode = response.status;
      if (statusCode !== 204 && statusCode !== 403 && statusCode !== 404) {
        let error = new msRest.RestError(operationRes.bodyAsText as string);
        error.statusCode = response.status;
        error.request = msRest.stripRequest(httpRequest);
        error.response = msRest.stripResponse(response);
        let parsedErrorResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedErrorResponse) {
            let internalError = null;
            if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
            error.code = internalError ? internalError.code : parsedErrorResponse.code;
            error.message = internalError ? internalError.message : parsedErrorResponse.message;
          }
        } catch (defaultError) {
          error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                           `- "${operationRes.bodyAsText}" for the default response.`;
          return Promise.reject(error);
        }
        return Promise.reject(error);
      }
      // Deserialize Response
      if (statusCode === 204) {
        let parsedResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedResponse !== null && parsedResponse !== undefined) {
            let resultMapper = {
              required: false,
              serializedName: 'parsedResponse',
              type: {
                name: 'Object'
              }
            };
            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
          }
        } catch (error) {
          let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
          deserializationError.request = msRest.stripRequest(httpRequest);
          deserializationError.response = msRest.stripResponse(response);
          return Promise.reject(deserializationError);
        }
      }

    } catch(err) {
      return Promise.reject(err);
    }

    return Promise.resolve(operationRes);
  }
  // methods on the client.

  /**
   * @summary Gets a list of queue group associations.
   *
   * @param {number} queueID The queue identifier.
   *
   * @param {SoftheonEnterpriseAPIGetQueueGroupAssociationsOptionalParams}
   * [options] Optional Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  async getQueueGroupAssociationsWithHttpOperationResponse(queueID: number, options?: Models.SoftheonEnterpriseAPIGetQueueGroupAssociationsOptionalParams): Promise<msRest.HttpOperationResponse> {
    let client = this;
    let groupID = (options && options.groupID !== undefined) ? options.groupID : undefined;
    let acl = (options && options.acl !== undefined) ? options.acl : undefined;
    let page = (options && options.page !== undefined) ? options.page : undefined;
    let pageSize = (options && options.pageSize !== undefined) ? options.pageSize : undefined;
    let sortOrder = (options && options.sortOrder !== undefined) ? options.sortOrder : undefined;
    let sortBy = (options && options.sortBy !== undefined) ? options.sortBy : undefined;
    // Validate
    try {
      if (groupID !== null && groupID !== undefined && typeof groupID !== 'number') {
        throw new Error('groupID must be of type number.');
      }
      if (queueID === null || queueID === undefined || typeof queueID !== 'number') {
        throw new Error('queueID cannot be null or undefined and it must be of type number.');
      }
      if (acl !== null && acl !== undefined && typeof acl !== 'number') {
        throw new Error('acl must be of type number.');
      }
      if (page !== null && page !== undefined && typeof page !== 'number') {
        throw new Error('page must be of type number.');
      }
      if (page !== null && page !== undefined) {
        if (page > 2147483647)
        {
          throw new Error('"page" should satisfy the constraint - "InclusiveMaximum": 2147483647');
        }
        if (page < 1)
        {
          throw new Error('"page" should satisfy the constraint - "InclusiveMinimum": 1');
        }
      }
      if (pageSize !== null && pageSize !== undefined && typeof pageSize !== 'number') {
        throw new Error('pageSize must be of type number.');
      }
      if (pageSize !== null && pageSize !== undefined) {
        if (pageSize > 1000)
        {
          throw new Error('"pageSize" should satisfy the constraint - "InclusiveMaximum": 1000');
        }
        if (pageSize < 1)
        {
          throw new Error('"pageSize" should satisfy the constraint - "InclusiveMinimum": 1');
        }
      }
      if (sortOrder !== null && sortOrder !== undefined && typeof sortOrder.valueOf() !== 'string') {
        throw new Error('sortOrder must be of type string.');
      }
      if (sortBy !== null && sortBy !== undefined && typeof sortBy.valueOf() !== 'string') {
        throw new Error('sortBy must be of type string.');
      }
    } catch (error) {
      return Promise.reject(error);
    }

    // Construct URL
    let baseUrl = this.baseUri;
    let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'v1/workflow/queues/{queueID}/groups';
    requestUrl = requestUrl.replace('{queueID}', encodeURIComponent(queueID.toString()));
    let queryParamsArray: Array<any> = [];
    if (groupID !== null && groupID !== undefined) {
      queryParamsArray.push('groupID=' + encodeURIComponent(groupID.toString()));
    }
    if (acl !== null && acl !== undefined) {
      queryParamsArray.push('acl=' + encodeURIComponent(acl.toString()));
    }
    if (page !== null && page !== undefined) {
      queryParamsArray.push('page=' + encodeURIComponent(page.toString()));
    }
    if (pageSize !== null && pageSize !== undefined) {
      queryParamsArray.push('pageSize=' + encodeURIComponent(pageSize.toString()));
    }
    if (sortOrder !== null && sortOrder !== undefined) {
      queryParamsArray.push('sortOrder=' + encodeURIComponent(sortOrder));
    }
    if (sortBy !== null && sortBy !== undefined) {
      queryParamsArray.push('sortBy=' + encodeURIComponent(sortBy));
    }
    if (queryParamsArray.length > 0) {
      requestUrl += '?' + queryParamsArray.join('&');
    }

    // Create HTTP transport objects
    let httpRequest = new WebResource();
    httpRequest.method = 'GET';
    httpRequest.url = requestUrl;
    httpRequest.headers = {};
    // Set Headers
    httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
    if(options && options.customHeaders) {
      for(let headerName in options.customHeaders) {
        if (options.customHeaders.hasOwnProperty(headerName)) {
          httpRequest.headers[headerName] = options.customHeaders[headerName];
        }
      }
    }
    // Send Request
    let operationRes: msRest.HttpOperationResponse;
    try {
      operationRes = await client.pipeline(httpRequest);
      let response = operationRes.response;
      let statusCode = response.status;
      if (statusCode !== 200 && statusCode !== 403) {
        let error = new msRest.RestError(operationRes.bodyAsText as string);
        error.statusCode = response.status;
        error.request = msRest.stripRequest(httpRequest);
        error.response = msRest.stripResponse(response);
        let parsedErrorResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedErrorResponse) {
            let internalError = null;
            if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
            error.code = internalError ? internalError.code : parsedErrorResponse.code;
            error.message = internalError ? internalError.message : parsedErrorResponse.message;
          }
        } catch (defaultError) {
          error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                           `- "${operationRes.bodyAsText}" for the default response.`;
          return Promise.reject(error);
        }
        return Promise.reject(error);
      }
      // Deserialize Response
      if (statusCode === 200) {
        let parsedResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedResponse !== null && parsedResponse !== undefined) {
            let resultMapper = {
              required: false,
              serializedName: 'parsedResponse',
              type: {
                name: 'Sequence',
                element: {
                    required: false,
                    serializedName: 'GroupQueueModelElementType',
                    type: {
                      name: 'Composite',
                      className: 'GroupQueueModel'
                    }
                }
              }
            };
            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
          }
        } catch (error) {
          let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
          deserializationError.request = msRest.stripRequest(httpRequest);
          deserializationError.response = msRest.stripResponse(response);
          return Promise.reject(deserializationError);
        }
      }

    } catch(err) {
      return Promise.reject(err);
    }

    return Promise.resolve(operationRes);
  }
  // methods on the client.

  /**
   * @summary Gets a list of group queue associations.
   *
   * @param {number} groupID The group identifier.
   *
   * @param {SoftheonEnterpriseAPIGetGroupQueueAssociationsOptionalParams}
   * [options] Optional Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  async getGroupQueueAssociationsWithHttpOperationResponse(groupID: number, options?: Models.SoftheonEnterpriseAPIGetGroupQueueAssociationsOptionalParams): Promise<msRest.HttpOperationResponse> {
    let client = this;
    let queueID = (options && options.queueID !== undefined) ? options.queueID : undefined;
    let acl = (options && options.acl !== undefined) ? options.acl : undefined;
    let page = (options && options.page !== undefined) ? options.page : undefined;
    let pageSize = (options && options.pageSize !== undefined) ? options.pageSize : undefined;
    let sortOrder = (options && options.sortOrder !== undefined) ? options.sortOrder : undefined;
    let sortBy = (options && options.sortBy !== undefined) ? options.sortBy : undefined;
    // Validate
    try {
      if (groupID === null || groupID === undefined || typeof groupID !== 'number') {
        throw new Error('groupID cannot be null or undefined and it must be of type number.');
      }
      if (queueID !== null && queueID !== undefined && typeof queueID !== 'number') {
        throw new Error('queueID must be of type number.');
      }
      if (acl !== null && acl !== undefined && typeof acl !== 'number') {
        throw new Error('acl must be of type number.');
      }
      if (page !== null && page !== undefined && typeof page !== 'number') {
        throw new Error('page must be of type number.');
      }
      if (page !== null && page !== undefined) {
        if (page > 2147483647)
        {
          throw new Error('"page" should satisfy the constraint - "InclusiveMaximum": 2147483647');
        }
        if (page < 1)
        {
          throw new Error('"page" should satisfy the constraint - "InclusiveMinimum": 1');
        }
      }
      if (pageSize !== null && pageSize !== undefined && typeof pageSize !== 'number') {
        throw new Error('pageSize must be of type number.');
      }
      if (pageSize !== null && pageSize !== undefined) {
        if (pageSize > 1000)
        {
          throw new Error('"pageSize" should satisfy the constraint - "InclusiveMaximum": 1000');
        }
        if (pageSize < 1)
        {
          throw new Error('"pageSize" should satisfy the constraint - "InclusiveMinimum": 1');
        }
      }
      if (sortOrder !== null && sortOrder !== undefined && typeof sortOrder.valueOf() !== 'string') {
        throw new Error('sortOrder must be of type string.');
      }
      if (sortBy !== null && sortBy !== undefined && typeof sortBy.valueOf() !== 'string') {
        throw new Error('sortBy must be of type string.');
      }
    } catch (error) {
      return Promise.reject(error);
    }

    // Construct URL
    let baseUrl = this.baseUri;
    let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'v1/directory/groups/{groupID}/queues';
    requestUrl = requestUrl.replace('{groupID}', encodeURIComponent(groupID.toString()));
    let queryParamsArray: Array<any> = [];
    if (queueID !== null && queueID !== undefined) {
      queryParamsArray.push('queueID=' + encodeURIComponent(queueID.toString()));
    }
    if (acl !== null && acl !== undefined) {
      queryParamsArray.push('acl=' + encodeURIComponent(acl.toString()));
    }
    if (page !== null && page !== undefined) {
      queryParamsArray.push('page=' + encodeURIComponent(page.toString()));
    }
    if (pageSize !== null && pageSize !== undefined) {
      queryParamsArray.push('pageSize=' + encodeURIComponent(pageSize.toString()));
    }
    if (sortOrder !== null && sortOrder !== undefined) {
      queryParamsArray.push('sortOrder=' + encodeURIComponent(sortOrder));
    }
    if (sortBy !== null && sortBy !== undefined) {
      queryParamsArray.push('sortBy=' + encodeURIComponent(sortBy));
    }
    if (queryParamsArray.length > 0) {
      requestUrl += '?' + queryParamsArray.join('&');
    }

    // Create HTTP transport objects
    let httpRequest = new WebResource();
    httpRequest.method = 'GET';
    httpRequest.url = requestUrl;
    httpRequest.headers = {};
    // Set Headers
    httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
    if(options && options.customHeaders) {
      for(let headerName in options.customHeaders) {
        if (options.customHeaders.hasOwnProperty(headerName)) {
          httpRequest.headers[headerName] = options.customHeaders[headerName];
        }
      }
    }
    // Send Request
    let operationRes: msRest.HttpOperationResponse;
    try {
      operationRes = await client.pipeline(httpRequest);
      let response = operationRes.response;
      let statusCode = response.status;
      if (statusCode !== 200 && statusCode !== 403) {
        let error = new msRest.RestError(operationRes.bodyAsText as string);
        error.statusCode = response.status;
        error.request = msRest.stripRequest(httpRequest);
        error.response = msRest.stripResponse(response);
        let parsedErrorResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedErrorResponse) {
            let internalError = null;
            if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
            error.code = internalError ? internalError.code : parsedErrorResponse.code;
            error.message = internalError ? internalError.message : parsedErrorResponse.message;
          }
        } catch (defaultError) {
          error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                           `- "${operationRes.bodyAsText}" for the default response.`;
          return Promise.reject(error);
        }
        return Promise.reject(error);
      }
      // Deserialize Response
      if (statusCode === 200) {
        let parsedResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedResponse !== null && parsedResponse !== undefined) {
            let resultMapper = {
              required: false,
              serializedName: 'parsedResponse',
              type: {
                name: 'Sequence',
                element: {
                    required: false,
                    serializedName: 'GroupQueueModelElementType',
                    type: {
                      name: 'Composite',
                      className: 'GroupQueueModel'
                    }
                }
              }
            };
            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
          }
        } catch (error) {
          let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
          deserializationError.request = msRest.stripRequest(httpRequest);
          deserializationError.response = msRest.stripResponse(response);
          return Promise.reject(deserializationError);
        }
      }

    } catch(err) {
      return Promise.reject(err);
    }

    return Promise.resolve(operationRes);
  }
  // methods on the client.

  /**
   * @summary Inserts/Updates the queue group association.
   *
   * @param {number} groupID The group identifier.
   *
   * @param {number} queueID The queue identifier.
   *
   * @param {GroupQueueModel} model The model.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  async createOrUpdateQueueGroupAssociationWithHttpOperationResponse(groupID: number, queueID: number, model: Models.GroupQueueModel, options?: msRest.RequestOptionsBase): Promise<msRest.HttpOperationResponse> {
    let client = this;
    // Validate
    try {
      if (groupID === null || groupID === undefined || typeof groupID !== 'number') {
        throw new Error('groupID cannot be null or undefined and it must be of type number.');
      }
      if (queueID === null || queueID === undefined || typeof queueID !== 'number') {
        throw new Error('queueID cannot be null or undefined and it must be of type number.');
      }
      if (model === null || model === undefined) {
        throw new Error('model cannot be null or undefined.');
      }
    } catch (error) {
      return Promise.reject(error);
    }

    // Construct URL
    let baseUrl = this.baseUri;
    let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'v1/workflow/queues/{queueID}/groups/{groupID}';
    requestUrl = requestUrl.replace('{groupID}', encodeURIComponent(groupID.toString()));
    requestUrl = requestUrl.replace('{queueID}', encodeURIComponent(queueID.toString()));

    // Create HTTP transport objects
    let httpRequest = new WebResource();
    httpRequest.method = 'PUT';
    httpRequest.url = requestUrl;
    httpRequest.headers = {};
    // Set Headers
    httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
    if(options && options.customHeaders) {
      for(let headerName in options.customHeaders) {
        if (options.customHeaders.hasOwnProperty(headerName)) {
          httpRequest.headers[headerName] = options.customHeaders[headerName];
        }
      }
    }
    // Serialize Request
    let requestContent = null;
    let requestModel = null;
    try {
      if (model !== null && model !== undefined) {
        let requestModelMapper = Mappers.GroupQueueModel;
        requestModel = client.serializer.serialize(requestModelMapper, model, 'model');
        requestContent = JSON.stringify(requestModel);
      }
    } catch (error) {
      let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
          `payload - ${JSON.stringify(model, null, 2)}.`);
      return Promise.reject(serializationError);
    }
    httpRequest.body = requestContent;
    // Send Request
    let operationRes: msRest.HttpOperationResponse;
    try {
      operationRes = await client.pipeline(httpRequest);
      let response = operationRes.response;
      let statusCode = response.status;
      if (statusCode !== 204 && statusCode !== 403) {
        let error = new msRest.RestError(operationRes.bodyAsText as string);
        error.statusCode = response.status;
        error.request = msRest.stripRequest(httpRequest);
        error.response = msRest.stripResponse(response);
        let parsedErrorResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedErrorResponse) {
            let internalError = null;
            if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
            error.code = internalError ? internalError.code : parsedErrorResponse.code;
            error.message = internalError ? internalError.message : parsedErrorResponse.message;
          }
        } catch (defaultError) {
          error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                           `- "${operationRes.bodyAsText}" for the default response.`;
          return Promise.reject(error);
        }
        return Promise.reject(error);
      }
      // Deserialize Response
      if (statusCode === 204) {
        let parsedResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedResponse !== null && parsedResponse !== undefined) {
            let resultMapper = {
              required: false,
              serializedName: 'parsedResponse',
              type: {
                name: 'Object'
              }
            };
            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
          }
        } catch (error) {
          let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
          deserializationError.request = msRest.stripRequest(httpRequest);
          deserializationError.response = msRest.stripResponse(response);
          return Promise.reject(deserializationError);
        }
      }

    } catch(err) {
      return Promise.reject(err);
    }

    return Promise.resolve(operationRes);
  }
  // methods on the client.

  /**
   * @summary Deletes a queue group association;
   *
   * @param {number} groupID The group identifier.
   *
   * @param {number} queueID The queue identifier.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  async deleteQueueGroupAssociationWithHttpOperationResponse(groupID: number, queueID: number, options?: msRest.RequestOptionsBase): Promise<msRest.HttpOperationResponse> {
    let client = this;
    // Validate
    try {
      if (groupID === null || groupID === undefined || typeof groupID !== 'number') {
        throw new Error('groupID cannot be null or undefined and it must be of type number.');
      }
      if (queueID === null || queueID === undefined || typeof queueID !== 'number') {
        throw new Error('queueID cannot be null or undefined and it must be of type number.');
      }
    } catch (error) {
      return Promise.reject(error);
    }

    // Construct URL
    let baseUrl = this.baseUri;
    let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'v1/workflow/queues/{queueID}/groups/{groupID}';
    requestUrl = requestUrl.replace('{groupID}', encodeURIComponent(groupID.toString()));
    requestUrl = requestUrl.replace('{queueID}', encodeURIComponent(queueID.toString()));

    // Create HTTP transport objects
    let httpRequest = new WebResource();
    httpRequest.method = 'DELETE';
    httpRequest.url = requestUrl;
    httpRequest.headers = {};
    // Set Headers
    httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
    if(options && options.customHeaders) {
      for(let headerName in options.customHeaders) {
        if (options.customHeaders.hasOwnProperty(headerName)) {
          httpRequest.headers[headerName] = options.customHeaders[headerName];
        }
      }
    }
    // Send Request
    let operationRes: msRest.HttpOperationResponse;
    try {
      operationRes = await client.pipeline(httpRequest);
      let response = operationRes.response;
      let statusCode = response.status;
      if (statusCode !== 204 && statusCode !== 403 && statusCode !== 404) {
        let error = new msRest.RestError(operationRes.bodyAsText as string);
        error.statusCode = response.status;
        error.request = msRest.stripRequest(httpRequest);
        error.response = msRest.stripResponse(response);
        let parsedErrorResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedErrorResponse) {
            let internalError = null;
            if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
            error.code = internalError ? internalError.code : parsedErrorResponse.code;
            error.message = internalError ? internalError.message : parsedErrorResponse.message;
          }
        } catch (defaultError) {
          error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                           `- "${operationRes.bodyAsText}" for the default response.`;
          return Promise.reject(error);
        }
        return Promise.reject(error);
      }
      // Deserialize Response
      if (statusCode === 204) {
        let parsedResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedResponse !== null && parsedResponse !== undefined) {
            let resultMapper = {
              required: false,
              serializedName: 'parsedResponse',
              type: {
                name: 'Object'
              }
            };
            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
          }
        } catch (error) {
          let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
          deserializationError.request = msRest.stripRequest(httpRequest);
          deserializationError.response = msRest.stripResponse(response);
          return Promise.reject(deserializationError);
        }
      }

    } catch(err) {
      return Promise.reject(err);
    }

    return Promise.resolve(operationRes);
  }
  // methods on the client.

  /**
   * @summary Inserts/Updates the group queue association.
   *
   * @param {number} groupID The group identifier.
   *
   * @param {number} queueID The queue identifier.
   *
   * @param {GroupQueueModel} model The model.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  async createOrUpdateGroupQueueAssociationWithHttpOperationResponse(groupID: number, queueID: number, model: Models.GroupQueueModel, options?: msRest.RequestOptionsBase): Promise<msRest.HttpOperationResponse> {
    let client = this;
    // Validate
    try {
      if (groupID === null || groupID === undefined || typeof groupID !== 'number') {
        throw new Error('groupID cannot be null or undefined and it must be of type number.');
      }
      if (queueID === null || queueID === undefined || typeof queueID !== 'number') {
        throw new Error('queueID cannot be null or undefined and it must be of type number.');
      }
      if (model === null || model === undefined) {
        throw new Error('model cannot be null or undefined.');
      }
    } catch (error) {
      return Promise.reject(error);
    }

    // Construct URL
    let baseUrl = this.baseUri;
    let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'v1/directory/groups/{groupID}/queues/{queueID}';
    requestUrl = requestUrl.replace('{groupID}', encodeURIComponent(groupID.toString()));
    requestUrl = requestUrl.replace('{queueID}', encodeURIComponent(queueID.toString()));

    // Create HTTP transport objects
    let httpRequest = new WebResource();
    httpRequest.method = 'PUT';
    httpRequest.url = requestUrl;
    httpRequest.headers = {};
    // Set Headers
    httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
    if(options && options.customHeaders) {
      for(let headerName in options.customHeaders) {
        if (options.customHeaders.hasOwnProperty(headerName)) {
          httpRequest.headers[headerName] = options.customHeaders[headerName];
        }
      }
    }
    // Serialize Request
    let requestContent = null;
    let requestModel = null;
    try {
      if (model !== null && model !== undefined) {
        let requestModelMapper = Mappers.GroupQueueModel;
        requestModel = client.serializer.serialize(requestModelMapper, model, 'model');
        requestContent = JSON.stringify(requestModel);
      }
    } catch (error) {
      let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
          `payload - ${JSON.stringify(model, null, 2)}.`);
      return Promise.reject(serializationError);
    }
    httpRequest.body = requestContent;
    // Send Request
    let operationRes: msRest.HttpOperationResponse;
    try {
      operationRes = await client.pipeline(httpRequest);
      let response = operationRes.response;
      let statusCode = response.status;
      if (statusCode !== 204 && statusCode !== 403) {
        let error = new msRest.RestError(operationRes.bodyAsText as string);
        error.statusCode = response.status;
        error.request = msRest.stripRequest(httpRequest);
        error.response = msRest.stripResponse(response);
        let parsedErrorResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedErrorResponse) {
            let internalError = null;
            if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
            error.code = internalError ? internalError.code : parsedErrorResponse.code;
            error.message = internalError ? internalError.message : parsedErrorResponse.message;
          }
        } catch (defaultError) {
          error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                           `- "${operationRes.bodyAsText}" for the default response.`;
          return Promise.reject(error);
        }
        return Promise.reject(error);
      }
      // Deserialize Response
      if (statusCode === 204) {
        let parsedResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedResponse !== null && parsedResponse !== undefined) {
            let resultMapper = {
              required: false,
              serializedName: 'parsedResponse',
              type: {
                name: 'Object'
              }
            };
            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
          }
        } catch (error) {
          let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
          deserializationError.request = msRest.stripRequest(httpRequest);
          deserializationError.response = msRest.stripResponse(response);
          return Promise.reject(deserializationError);
        }
      }

    } catch(err) {
      return Promise.reject(err);
    }

    return Promise.resolve(operationRes);
  }
  // methods on the client.

  /**
   * @summary Deletes a group queue association;
   *
   * @param {number} groupID The group identifier.
   *
   * @param {number} queueID The queue identifier.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  async deleteGroupQueueAssociationWithHttpOperationResponse(groupID: number, queueID: number, options?: msRest.RequestOptionsBase): Promise<msRest.HttpOperationResponse> {
    let client = this;
    // Validate
    try {
      if (groupID === null || groupID === undefined || typeof groupID !== 'number') {
        throw new Error('groupID cannot be null or undefined and it must be of type number.');
      }
      if (queueID === null || queueID === undefined || typeof queueID !== 'number') {
        throw new Error('queueID cannot be null or undefined and it must be of type number.');
      }
    } catch (error) {
      return Promise.reject(error);
    }

    // Construct URL
    let baseUrl = this.baseUri;
    let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'v1/directory/groups/{groupID}/queues/{queueID}';
    requestUrl = requestUrl.replace('{groupID}', encodeURIComponent(groupID.toString()));
    requestUrl = requestUrl.replace('{queueID}', encodeURIComponent(queueID.toString()));

    // Create HTTP transport objects
    let httpRequest = new WebResource();
    httpRequest.method = 'DELETE';
    httpRequest.url = requestUrl;
    httpRequest.headers = {};
    // Set Headers
    httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
    if(options && options.customHeaders) {
      for(let headerName in options.customHeaders) {
        if (options.customHeaders.hasOwnProperty(headerName)) {
          httpRequest.headers[headerName] = options.customHeaders[headerName];
        }
      }
    }
    // Send Request
    let operationRes: msRest.HttpOperationResponse;
    try {
      operationRes = await client.pipeline(httpRequest);
      let response = operationRes.response;
      let statusCode = response.status;
      if (statusCode !== 204 && statusCode !== 403 && statusCode !== 404) {
        let error = new msRest.RestError(operationRes.bodyAsText as string);
        error.statusCode = response.status;
        error.request = msRest.stripRequest(httpRequest);
        error.response = msRest.stripResponse(response);
        let parsedErrorResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedErrorResponse) {
            let internalError = null;
            if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
            error.code = internalError ? internalError.code : parsedErrorResponse.code;
            error.message = internalError ? internalError.message : parsedErrorResponse.message;
          }
        } catch (defaultError) {
          error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                           `- "${operationRes.bodyAsText}" for the default response.`;
          return Promise.reject(error);
        }
        return Promise.reject(error);
      }
      // Deserialize Response
      if (statusCode === 204) {
        let parsedResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedResponse !== null && parsedResponse !== undefined) {
            let resultMapper = {
              required: false,
              serializedName: 'parsedResponse',
              type: {
                name: 'Object'
              }
            };
            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
          }
        } catch (error) {
          let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
          deserializationError.request = msRest.stripRequest(httpRequest);
          deserializationError.response = msRest.stripResponse(response);
          return Promise.reject(deserializationError);
        }
      }

    } catch(err) {
      return Promise.reject(err);
    }

    return Promise.resolve(operationRes);
  }
  // methods on the client.

  /**
   * @summary Gets a list of application group associations.
   *
   * @param {number} applicationID The application identifier.
   *
   * @param {SoftheonEnterpriseAPIGetApplicationGroupAssociationsOptionalParams}
   * [options] Optional Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  async getApplicationGroupAssociationsWithHttpOperationResponse(applicationID: number, options?: Models.SoftheonEnterpriseAPIGetApplicationGroupAssociationsOptionalParams): Promise<msRest.HttpOperationResponse> {
    let client = this;
    let groupID = (options && options.groupID !== undefined) ? options.groupID : undefined;
    let acl = (options && options.acl !== undefined) ? options.acl : undefined;
    let page = (options && options.page !== undefined) ? options.page : undefined;
    let pageSize = (options && options.pageSize !== undefined) ? options.pageSize : undefined;
    let sortOrder = (options && options.sortOrder !== undefined) ? options.sortOrder : undefined;
    let sortBy = (options && options.sortBy !== undefined) ? options.sortBy : undefined;
    // Validate
    try {
      if (groupID !== null && groupID !== undefined && typeof groupID !== 'number') {
        throw new Error('groupID must be of type number.');
      }
      if (applicationID === null || applicationID === undefined || typeof applicationID !== 'number') {
        throw new Error('applicationID cannot be null or undefined and it must be of type number.');
      }
      if (acl !== null && acl !== undefined && typeof acl !== 'number') {
        throw new Error('acl must be of type number.');
      }
      if (page !== null && page !== undefined && typeof page !== 'number') {
        throw new Error('page must be of type number.');
      }
      if (page !== null && page !== undefined) {
        if (page > 2147483647)
        {
          throw new Error('"page" should satisfy the constraint - "InclusiveMaximum": 2147483647');
        }
        if (page < 1)
        {
          throw new Error('"page" should satisfy the constraint - "InclusiveMinimum": 1');
        }
      }
      if (pageSize !== null && pageSize !== undefined && typeof pageSize !== 'number') {
        throw new Error('pageSize must be of type number.');
      }
      if (pageSize !== null && pageSize !== undefined) {
        if (pageSize > 1000)
        {
          throw new Error('"pageSize" should satisfy the constraint - "InclusiveMaximum": 1000');
        }
        if (pageSize < 1)
        {
          throw new Error('"pageSize" should satisfy the constraint - "InclusiveMinimum": 1');
        }
      }
      if (sortOrder !== null && sortOrder !== undefined && typeof sortOrder.valueOf() !== 'string') {
        throw new Error('sortOrder must be of type string.');
      }
      if (sortBy !== null && sortBy !== undefined && typeof sortBy.valueOf() !== 'string') {
        throw new Error('sortBy must be of type string.');
      }
    } catch (error) {
      return Promise.reject(error);
    }

    // Construct URL
    let baseUrl = this.baseUri;
    let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'v1/directory/applications/{applicationID}/groups';
    requestUrl = requestUrl.replace('{applicationID}', encodeURIComponent(applicationID.toString()));
    let queryParamsArray: Array<any> = [];
    if (groupID !== null && groupID !== undefined) {
      queryParamsArray.push('groupID=' + encodeURIComponent(groupID.toString()));
    }
    if (acl !== null && acl !== undefined) {
      queryParamsArray.push('acl=' + encodeURIComponent(acl.toString()));
    }
    if (page !== null && page !== undefined) {
      queryParamsArray.push('page=' + encodeURIComponent(page.toString()));
    }
    if (pageSize !== null && pageSize !== undefined) {
      queryParamsArray.push('pageSize=' + encodeURIComponent(pageSize.toString()));
    }
    if (sortOrder !== null && sortOrder !== undefined) {
      queryParamsArray.push('sortOrder=' + encodeURIComponent(sortOrder));
    }
    if (sortBy !== null && sortBy !== undefined) {
      queryParamsArray.push('sortBy=' + encodeURIComponent(sortBy));
    }
    if (queryParamsArray.length > 0) {
      requestUrl += '?' + queryParamsArray.join('&');
    }

    // Create HTTP transport objects
    let httpRequest = new WebResource();
    httpRequest.method = 'GET';
    httpRequest.url = requestUrl;
    httpRequest.headers = {};
    // Set Headers
    httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
    if(options && options.customHeaders) {
      for(let headerName in options.customHeaders) {
        if (options.customHeaders.hasOwnProperty(headerName)) {
          httpRequest.headers[headerName] = options.customHeaders[headerName];
        }
      }
    }
    // Send Request
    let operationRes: msRest.HttpOperationResponse;
    try {
      operationRes = await client.pipeline(httpRequest);
      let response = operationRes.response;
      let statusCode = response.status;
      if (statusCode !== 200 && statusCode !== 403) {
        let error = new msRest.RestError(operationRes.bodyAsText as string);
        error.statusCode = response.status;
        error.request = msRest.stripRequest(httpRequest);
        error.response = msRest.stripResponse(response);
        let parsedErrorResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedErrorResponse) {
            let internalError = null;
            if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
            error.code = internalError ? internalError.code : parsedErrorResponse.code;
            error.message = internalError ? internalError.message : parsedErrorResponse.message;
          }
        } catch (defaultError) {
          error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                           `- "${operationRes.bodyAsText}" for the default response.`;
          return Promise.reject(error);
        }
        return Promise.reject(error);
      }
      // Deserialize Response
      if (statusCode === 200) {
        let parsedResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedResponse !== null && parsedResponse !== undefined) {
            let resultMapper = {
              required: false,
              serializedName: 'parsedResponse',
              type: {
                name: 'Sequence',
                element: {
                    required: false,
                    serializedName: 'GroupApplicationModelElementType',
                    type: {
                      name: 'Composite',
                      className: 'GroupApplicationModel'
                    }
                }
              }
            };
            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
          }
        } catch (error) {
          let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
          deserializationError.request = msRest.stripRequest(httpRequest);
          deserializationError.response = msRest.stripResponse(response);
          return Promise.reject(deserializationError);
        }
      }

    } catch(err) {
      return Promise.reject(err);
    }

    return Promise.resolve(operationRes);
  }
  // methods on the client.

  /**
   * @summary Gets a list of group application associations.
   *
   * @param {number} groupID The group identifier.
   *
   * @param {SoftheonEnterpriseAPIGetGroupApplicationAssociationsOptionalParams}
   * [options] Optional Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  async getGroupApplicationAssociationsWithHttpOperationResponse(groupID: number, options?: Models.SoftheonEnterpriseAPIGetGroupApplicationAssociationsOptionalParams): Promise<msRest.HttpOperationResponse> {
    let client = this;
    let applicationID = (options && options.applicationID !== undefined) ? options.applicationID : undefined;
    let acl = (options && options.acl !== undefined) ? options.acl : undefined;
    let page = (options && options.page !== undefined) ? options.page : undefined;
    let pageSize = (options && options.pageSize !== undefined) ? options.pageSize : undefined;
    let sortOrder = (options && options.sortOrder !== undefined) ? options.sortOrder : undefined;
    let sortBy = (options && options.sortBy !== undefined) ? options.sortBy : undefined;
    // Validate
    try {
      if (groupID === null || groupID === undefined || typeof groupID !== 'number') {
        throw new Error('groupID cannot be null or undefined and it must be of type number.');
      }
      if (applicationID !== null && applicationID !== undefined && typeof applicationID !== 'number') {
        throw new Error('applicationID must be of type number.');
      }
      if (acl !== null && acl !== undefined && typeof acl !== 'number') {
        throw new Error('acl must be of type number.');
      }
      if (page !== null && page !== undefined && typeof page !== 'number') {
        throw new Error('page must be of type number.');
      }
      if (page !== null && page !== undefined) {
        if (page > 2147483647)
        {
          throw new Error('"page" should satisfy the constraint - "InclusiveMaximum": 2147483647');
        }
        if (page < 1)
        {
          throw new Error('"page" should satisfy the constraint - "InclusiveMinimum": 1');
        }
      }
      if (pageSize !== null && pageSize !== undefined && typeof pageSize !== 'number') {
        throw new Error('pageSize must be of type number.');
      }
      if (pageSize !== null && pageSize !== undefined) {
        if (pageSize > 1000)
        {
          throw new Error('"pageSize" should satisfy the constraint - "InclusiveMaximum": 1000');
        }
        if (pageSize < 1)
        {
          throw new Error('"pageSize" should satisfy the constraint - "InclusiveMinimum": 1');
        }
      }
      if (sortOrder !== null && sortOrder !== undefined && typeof sortOrder.valueOf() !== 'string') {
        throw new Error('sortOrder must be of type string.');
      }
      if (sortBy !== null && sortBy !== undefined && typeof sortBy.valueOf() !== 'string') {
        throw new Error('sortBy must be of type string.');
      }
    } catch (error) {
      return Promise.reject(error);
    }

    // Construct URL
    let baseUrl = this.baseUri;
    let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'v1/directory/groups/{groupID}/applications';
    requestUrl = requestUrl.replace('{groupID}', encodeURIComponent(groupID.toString()));
    let queryParamsArray: Array<any> = [];
    if (applicationID !== null && applicationID !== undefined) {
      queryParamsArray.push('applicationID=' + encodeURIComponent(applicationID.toString()));
    }
    if (acl !== null && acl !== undefined) {
      queryParamsArray.push('acl=' + encodeURIComponent(acl.toString()));
    }
    if (page !== null && page !== undefined) {
      queryParamsArray.push('page=' + encodeURIComponent(page.toString()));
    }
    if (pageSize !== null && pageSize !== undefined) {
      queryParamsArray.push('pageSize=' + encodeURIComponent(pageSize.toString()));
    }
    if (sortOrder !== null && sortOrder !== undefined) {
      queryParamsArray.push('sortOrder=' + encodeURIComponent(sortOrder));
    }
    if (sortBy !== null && sortBy !== undefined) {
      queryParamsArray.push('sortBy=' + encodeURIComponent(sortBy));
    }
    if (queryParamsArray.length > 0) {
      requestUrl += '?' + queryParamsArray.join('&');
    }

    // Create HTTP transport objects
    let httpRequest = new WebResource();
    httpRequest.method = 'GET';
    httpRequest.url = requestUrl;
    httpRequest.headers = {};
    // Set Headers
    httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
    if(options && options.customHeaders) {
      for(let headerName in options.customHeaders) {
        if (options.customHeaders.hasOwnProperty(headerName)) {
          httpRequest.headers[headerName] = options.customHeaders[headerName];
        }
      }
    }
    // Send Request
    let operationRes: msRest.HttpOperationResponse;
    try {
      operationRes = await client.pipeline(httpRequest);
      let response = operationRes.response;
      let statusCode = response.status;
      if (statusCode !== 200 && statusCode !== 403) {
        let error = new msRest.RestError(operationRes.bodyAsText as string);
        error.statusCode = response.status;
        error.request = msRest.stripRequest(httpRequest);
        error.response = msRest.stripResponse(response);
        let parsedErrorResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedErrorResponse) {
            let internalError = null;
            if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
            error.code = internalError ? internalError.code : parsedErrorResponse.code;
            error.message = internalError ? internalError.message : parsedErrorResponse.message;
          }
        } catch (defaultError) {
          error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                           `- "${operationRes.bodyAsText}" for the default response.`;
          return Promise.reject(error);
        }
        return Promise.reject(error);
      }
      // Deserialize Response
      if (statusCode === 200) {
        let parsedResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedResponse !== null && parsedResponse !== undefined) {
            let resultMapper = {
              required: false,
              serializedName: 'parsedResponse',
              type: {
                name: 'Sequence',
                element: {
                    required: false,
                    serializedName: 'GroupApplicationModelElementType',
                    type: {
                      name: 'Composite',
                      className: 'GroupApplicationModel'
                    }
                }
              }
            };
            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
          }
        } catch (error) {
          let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
          deserializationError.request = msRest.stripRequest(httpRequest);
          deserializationError.response = msRest.stripResponse(response);
          return Promise.reject(deserializationError);
        }
      }

    } catch(err) {
      return Promise.reject(err);
    }

    return Promise.resolve(operationRes);
  }
  // methods on the client.

  /**
   * @summary Inserts/Updates the application group association.
   *
   * @param {number} groupID The group identifier.
   *
   * @param {number} applicationID The application identifier.
   *
   * @param {GroupApplicationModel} model The model.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  async createOrUpdateApplicationGroupAssociationWithHttpOperationResponse(groupID: number, applicationID: number, model: Models.GroupApplicationModel, options?: msRest.RequestOptionsBase): Promise<msRest.HttpOperationResponse> {
    let client = this;
    // Validate
    try {
      if (groupID === null || groupID === undefined || typeof groupID !== 'number') {
        throw new Error('groupID cannot be null or undefined and it must be of type number.');
      }
      if (applicationID === null || applicationID === undefined || typeof applicationID !== 'number') {
        throw new Error('applicationID cannot be null or undefined and it must be of type number.');
      }
      if (model === null || model === undefined) {
        throw new Error('model cannot be null or undefined.');
      }
    } catch (error) {
      return Promise.reject(error);
    }

    // Construct URL
    let baseUrl = this.baseUri;
    let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'v1/directory/applications/{applicationID}/groups/{groupID}';
    requestUrl = requestUrl.replace('{groupID}', encodeURIComponent(groupID.toString()));
    requestUrl = requestUrl.replace('{applicationID}', encodeURIComponent(applicationID.toString()));

    // Create HTTP transport objects
    let httpRequest = new WebResource();
    httpRequest.method = 'PUT';
    httpRequest.url = requestUrl;
    httpRequest.headers = {};
    // Set Headers
    httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
    if(options && options.customHeaders) {
      for(let headerName in options.customHeaders) {
        if (options.customHeaders.hasOwnProperty(headerName)) {
          httpRequest.headers[headerName] = options.customHeaders[headerName];
        }
      }
    }
    // Serialize Request
    let requestContent = null;
    let requestModel = null;
    try {
      if (model !== null && model !== undefined) {
        let requestModelMapper = Mappers.GroupApplicationModel;
        requestModel = client.serializer.serialize(requestModelMapper, model, 'model');
        requestContent = JSON.stringify(requestModel);
      }
    } catch (error) {
      let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
          `payload - ${JSON.stringify(model, null, 2)}.`);
      return Promise.reject(serializationError);
    }
    httpRequest.body = requestContent;
    // Send Request
    let operationRes: msRest.HttpOperationResponse;
    try {
      operationRes = await client.pipeline(httpRequest);
      let response = operationRes.response;
      let statusCode = response.status;
      if (statusCode !== 204 && statusCode !== 403) {
        let error = new msRest.RestError(operationRes.bodyAsText as string);
        error.statusCode = response.status;
        error.request = msRest.stripRequest(httpRequest);
        error.response = msRest.stripResponse(response);
        let parsedErrorResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedErrorResponse) {
            let internalError = null;
            if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
            error.code = internalError ? internalError.code : parsedErrorResponse.code;
            error.message = internalError ? internalError.message : parsedErrorResponse.message;
          }
        } catch (defaultError) {
          error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                           `- "${operationRes.bodyAsText}" for the default response.`;
          return Promise.reject(error);
        }
        return Promise.reject(error);
      }
      // Deserialize Response
      if (statusCode === 204) {
        let parsedResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedResponse !== null && parsedResponse !== undefined) {
            let resultMapper = {
              required: false,
              serializedName: 'parsedResponse',
              type: {
                name: 'Object'
              }
            };
            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
          }
        } catch (error) {
          let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
          deserializationError.request = msRest.stripRequest(httpRequest);
          deserializationError.response = msRest.stripResponse(response);
          return Promise.reject(deserializationError);
        }
      }

    } catch(err) {
      return Promise.reject(err);
    }

    return Promise.resolve(operationRes);
  }
  // methods on the client.

  /**
   * @summary Deletes a application group association;
   *
   * @param {number} groupID The group identifier.
   *
   * @param {number} applicationID The application identifier.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  async deleteApplicationGroupAssociationWithHttpOperationResponse(groupID: number, applicationID: number, options?: msRest.RequestOptionsBase): Promise<msRest.HttpOperationResponse> {
    let client = this;
    // Validate
    try {
      if (groupID === null || groupID === undefined || typeof groupID !== 'number') {
        throw new Error('groupID cannot be null or undefined and it must be of type number.');
      }
      if (applicationID === null || applicationID === undefined || typeof applicationID !== 'number') {
        throw new Error('applicationID cannot be null or undefined and it must be of type number.');
      }
    } catch (error) {
      return Promise.reject(error);
    }

    // Construct URL
    let baseUrl = this.baseUri;
    let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'v1/directory/applications/{applicationID}/groups/{groupID}';
    requestUrl = requestUrl.replace('{groupID}', encodeURIComponent(groupID.toString()));
    requestUrl = requestUrl.replace('{applicationID}', encodeURIComponent(applicationID.toString()));

    // Create HTTP transport objects
    let httpRequest = new WebResource();
    httpRequest.method = 'DELETE';
    httpRequest.url = requestUrl;
    httpRequest.headers = {};
    // Set Headers
    httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
    if(options && options.customHeaders) {
      for(let headerName in options.customHeaders) {
        if (options.customHeaders.hasOwnProperty(headerName)) {
          httpRequest.headers[headerName] = options.customHeaders[headerName];
        }
      }
    }
    // Send Request
    let operationRes: msRest.HttpOperationResponse;
    try {
      operationRes = await client.pipeline(httpRequest);
      let response = operationRes.response;
      let statusCode = response.status;
      if (statusCode !== 204 && statusCode !== 403 && statusCode !== 404 && statusCode !== 500) {
        let error = new msRest.RestError(operationRes.bodyAsText as string);
        error.statusCode = response.status;
        error.request = msRest.stripRequest(httpRequest);
        error.response = msRest.stripResponse(response);
        let parsedErrorResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedErrorResponse) {
            let internalError = null;
            if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
            error.code = internalError ? internalError.code : parsedErrorResponse.code;
            error.message = internalError ? internalError.message : parsedErrorResponse.message;
          }
        } catch (defaultError) {
          error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                           `- "${operationRes.bodyAsText}" for the default response.`;
          return Promise.reject(error);
        }
        return Promise.reject(error);
      }
      // Deserialize Response
      if (statusCode === 204) {
        let parsedResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedResponse !== null && parsedResponse !== undefined) {
            let resultMapper = {
              required: false,
              serializedName: 'parsedResponse',
              type: {
                name: 'Object'
              }
            };
            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
          }
        } catch (error) {
          let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
          deserializationError.request = msRest.stripRequest(httpRequest);
          deserializationError.response = msRest.stripResponse(response);
          return Promise.reject(deserializationError);
        }
      }

    } catch(err) {
      return Promise.reject(err);
    }

    return Promise.resolve(operationRes);
  }
  // methods on the client.

  /**
   * @summary Inserts/Updates the group application association.
   *
   * @param {number} groupID The group identifier.
   *
   * @param {number} applicationID The application identifier.
   *
   * @param {GroupApplicationModel} model The model.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  async createOrUpdateGroupApplicationAssociationWithHttpOperationResponse(groupID: number, applicationID: number, model: Models.GroupApplicationModel, options?: msRest.RequestOptionsBase): Promise<msRest.HttpOperationResponse> {
    let client = this;
    // Validate
    try {
      if (groupID === null || groupID === undefined || typeof groupID !== 'number') {
        throw new Error('groupID cannot be null or undefined and it must be of type number.');
      }
      if (applicationID === null || applicationID === undefined || typeof applicationID !== 'number') {
        throw new Error('applicationID cannot be null or undefined and it must be of type number.');
      }
      if (model === null || model === undefined) {
        throw new Error('model cannot be null or undefined.');
      }
    } catch (error) {
      return Promise.reject(error);
    }

    // Construct URL
    let baseUrl = this.baseUri;
    let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'v1/directory/groups/{groupID}/applications/{applicationID}';
    requestUrl = requestUrl.replace('{groupID}', encodeURIComponent(groupID.toString()));
    requestUrl = requestUrl.replace('{applicationID}', encodeURIComponent(applicationID.toString()));

    // Create HTTP transport objects
    let httpRequest = new WebResource();
    httpRequest.method = 'PUT';
    httpRequest.url = requestUrl;
    httpRequest.headers = {};
    // Set Headers
    httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
    if(options && options.customHeaders) {
      for(let headerName in options.customHeaders) {
        if (options.customHeaders.hasOwnProperty(headerName)) {
          httpRequest.headers[headerName] = options.customHeaders[headerName];
        }
      }
    }
    // Serialize Request
    let requestContent = null;
    let requestModel = null;
    try {
      if (model !== null && model !== undefined) {
        let requestModelMapper = Mappers.GroupApplicationModel;
        requestModel = client.serializer.serialize(requestModelMapper, model, 'model');
        requestContent = JSON.stringify(requestModel);
      }
    } catch (error) {
      let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
          `payload - ${JSON.stringify(model, null, 2)}.`);
      return Promise.reject(serializationError);
    }
    httpRequest.body = requestContent;
    // Send Request
    let operationRes: msRest.HttpOperationResponse;
    try {
      operationRes = await client.pipeline(httpRequest);
      let response = operationRes.response;
      let statusCode = response.status;
      if (statusCode !== 204 && statusCode !== 403) {
        let error = new msRest.RestError(operationRes.bodyAsText as string);
        error.statusCode = response.status;
        error.request = msRest.stripRequest(httpRequest);
        error.response = msRest.stripResponse(response);
        let parsedErrorResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedErrorResponse) {
            let internalError = null;
            if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
            error.code = internalError ? internalError.code : parsedErrorResponse.code;
            error.message = internalError ? internalError.message : parsedErrorResponse.message;
          }
        } catch (defaultError) {
          error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                           `- "${operationRes.bodyAsText}" for the default response.`;
          return Promise.reject(error);
        }
        return Promise.reject(error);
      }
      // Deserialize Response
      if (statusCode === 204) {
        let parsedResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedResponse !== null && parsedResponse !== undefined) {
            let resultMapper = {
              required: false,
              serializedName: 'parsedResponse',
              type: {
                name: 'Object'
              }
            };
            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
          }
        } catch (error) {
          let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
          deserializationError.request = msRest.stripRequest(httpRequest);
          deserializationError.response = msRest.stripResponse(response);
          return Promise.reject(deserializationError);
        }
      }

    } catch(err) {
      return Promise.reject(err);
    }

    return Promise.resolve(operationRes);
  }
  // methods on the client.

  /**
   * @summary Deletes a group application association;
   *
   * @param {number} groupID The group identifier.
   *
   * @param {number} applicationID The application identifier.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  async deleteGroupApplicationAssociationWithHttpOperationResponse(groupID: number, applicationID: number, options?: msRest.RequestOptionsBase): Promise<msRest.HttpOperationResponse> {
    let client = this;
    // Validate
    try {
      if (groupID === null || groupID === undefined || typeof groupID !== 'number') {
        throw new Error('groupID cannot be null or undefined and it must be of type number.');
      }
      if (applicationID === null || applicationID === undefined || typeof applicationID !== 'number') {
        throw new Error('applicationID cannot be null or undefined and it must be of type number.');
      }
    } catch (error) {
      return Promise.reject(error);
    }

    // Construct URL
    let baseUrl = this.baseUri;
    let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'v1/directory/groups/{groupID}/applications/{applicationID}';
    requestUrl = requestUrl.replace('{groupID}', encodeURIComponent(groupID.toString()));
    requestUrl = requestUrl.replace('{applicationID}', encodeURIComponent(applicationID.toString()));

    // Create HTTP transport objects
    let httpRequest = new WebResource();
    httpRequest.method = 'DELETE';
    httpRequest.url = requestUrl;
    httpRequest.headers = {};
    // Set Headers
    httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
    if(options && options.customHeaders) {
      for(let headerName in options.customHeaders) {
        if (options.customHeaders.hasOwnProperty(headerName)) {
          httpRequest.headers[headerName] = options.customHeaders[headerName];
        }
      }
    }
    // Send Request
    let operationRes: msRest.HttpOperationResponse;
    try {
      operationRes = await client.pipeline(httpRequest);
      let response = operationRes.response;
      let statusCode = response.status;
      if (statusCode !== 204 && statusCode !== 403 && statusCode !== 404 && statusCode !== 500) {
        let error = new msRest.RestError(operationRes.bodyAsText as string);
        error.statusCode = response.status;
        error.request = msRest.stripRequest(httpRequest);
        error.response = msRest.stripResponse(response);
        let parsedErrorResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedErrorResponse) {
            let internalError = null;
            if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
            error.code = internalError ? internalError.code : parsedErrorResponse.code;
            error.message = internalError ? internalError.message : parsedErrorResponse.message;
          }
        } catch (defaultError) {
          error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                           `- "${operationRes.bodyAsText}" for the default response.`;
          return Promise.reject(error);
        }
        return Promise.reject(error);
      }
      // Deserialize Response
      if (statusCode === 204) {
        let parsedResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedResponse !== null && parsedResponse !== undefined) {
            let resultMapper = {
              required: false,
              serializedName: 'parsedResponse',
              type: {
                name: 'Object'
              }
            };
            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
          }
        } catch (error) {
          let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
          deserializationError.request = msRest.stripRequest(httpRequest);
          deserializationError.response = msRest.stripResponse(response);
          return Promise.reject(deserializationError);
        }
      }

    } catch(err) {
      return Promise.reject(err);
    }

    return Promise.resolve(operationRes);
  }
  // methods on the client.

  /**
   * @summary Gets a list of drawer user associations.
   *
   * @param {number} drawerID The drawer identifier.
   *
   * @param {SoftheonEnterpriseAPIGetDrawerUserAssociationsOptionalParams}
   * [options] Optional Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  async getDrawerUserAssociationsWithHttpOperationResponse(drawerID: number, options?: Models.SoftheonEnterpriseAPIGetDrawerUserAssociationsOptionalParams): Promise<msRest.HttpOperationResponse> {
    let client = this;
    let userID = (options && options.userID !== undefined) ? options.userID : undefined;
    let acl = (options && options.acl !== undefined) ? options.acl : undefined;
    let page = (options && options.page !== undefined) ? options.page : undefined;
    let pageSize = (options && options.pageSize !== undefined) ? options.pageSize : undefined;
    let sortOrder = (options && options.sortOrder !== undefined) ? options.sortOrder : undefined;
    let sortBy = (options && options.sortBy !== undefined) ? options.sortBy : undefined;
    // Validate
    try {
      if (userID !== null && userID !== undefined && typeof userID !== 'number') {
        throw new Error('userID must be of type number.');
      }
      if (drawerID === null || drawerID === undefined || typeof drawerID !== 'number') {
        throw new Error('drawerID cannot be null or undefined and it must be of type number.');
      }
      if (acl !== null && acl !== undefined && typeof acl !== 'number') {
        throw new Error('acl must be of type number.');
      }
      if (page !== null && page !== undefined && typeof page !== 'number') {
        throw new Error('page must be of type number.');
      }
      if (page !== null && page !== undefined) {
        if (page > 2147483647)
        {
          throw new Error('"page" should satisfy the constraint - "InclusiveMaximum": 2147483647');
        }
        if (page < 1)
        {
          throw new Error('"page" should satisfy the constraint - "InclusiveMinimum": 1');
        }
      }
      if (pageSize !== null && pageSize !== undefined && typeof pageSize !== 'number') {
        throw new Error('pageSize must be of type number.');
      }
      if (pageSize !== null && pageSize !== undefined) {
        if (pageSize > 1000)
        {
          throw new Error('"pageSize" should satisfy the constraint - "InclusiveMaximum": 1000');
        }
        if (pageSize < 1)
        {
          throw new Error('"pageSize" should satisfy the constraint - "InclusiveMinimum": 1');
        }
      }
      if (sortOrder !== null && sortOrder !== undefined && typeof sortOrder.valueOf() !== 'string') {
        throw new Error('sortOrder must be of type string.');
      }
      if (sortBy !== null && sortBy !== undefined && typeof sortBy.valueOf() !== 'string') {
        throw new Error('sortBy must be of type string.');
      }
    } catch (error) {
      return Promise.reject(error);
    }

    // Construct URL
    let baseUrl = this.baseUri;
    let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'v1/directory/drawers/{drawerID}/users';
    requestUrl = requestUrl.replace('{drawerID}', encodeURIComponent(drawerID.toString()));
    let queryParamsArray: Array<any> = [];
    if (userID !== null && userID !== undefined) {
      queryParamsArray.push('userID=' + encodeURIComponent(userID.toString()));
    }
    if (acl !== null && acl !== undefined) {
      queryParamsArray.push('acl=' + encodeURIComponent(acl.toString()));
    }
    if (page !== null && page !== undefined) {
      queryParamsArray.push('page=' + encodeURIComponent(page.toString()));
    }
    if (pageSize !== null && pageSize !== undefined) {
      queryParamsArray.push('pageSize=' + encodeURIComponent(pageSize.toString()));
    }
    if (sortOrder !== null && sortOrder !== undefined) {
      queryParamsArray.push('sortOrder=' + encodeURIComponent(sortOrder));
    }
    if (sortBy !== null && sortBy !== undefined) {
      queryParamsArray.push('sortBy=' + encodeURIComponent(sortBy));
    }
    if (queryParamsArray.length > 0) {
      requestUrl += '?' + queryParamsArray.join('&');
    }

    // Create HTTP transport objects
    let httpRequest = new WebResource();
    httpRequest.method = 'GET';
    httpRequest.url = requestUrl;
    httpRequest.headers = {};
    // Set Headers
    httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
    if(options && options.customHeaders) {
      for(let headerName in options.customHeaders) {
        if (options.customHeaders.hasOwnProperty(headerName)) {
          httpRequest.headers[headerName] = options.customHeaders[headerName];
        }
      }
    }
    // Send Request
    let operationRes: msRest.HttpOperationResponse;
    try {
      operationRes = await client.pipeline(httpRequest);
      let response = operationRes.response;
      let statusCode = response.status;
      if (statusCode !== 200 && statusCode !== 403) {
        let error = new msRest.RestError(operationRes.bodyAsText as string);
        error.statusCode = response.status;
        error.request = msRest.stripRequest(httpRequest);
        error.response = msRest.stripResponse(response);
        let parsedErrorResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedErrorResponse) {
            let internalError = null;
            if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
            error.code = internalError ? internalError.code : parsedErrorResponse.code;
            error.message = internalError ? internalError.message : parsedErrorResponse.message;
          }
        } catch (defaultError) {
          error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                           `- "${operationRes.bodyAsText}" for the default response.`;
          return Promise.reject(error);
        }
        return Promise.reject(error);
      }
      // Deserialize Response
      if (statusCode === 200) {
        let parsedResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedResponse !== null && parsedResponse !== undefined) {
            let resultMapper = {
              required: false,
              serializedName: 'parsedResponse',
              type: {
                name: 'Sequence',
                element: {
                    required: false,
                    serializedName: 'UserDrawerModelElementType',
                    type: {
                      name: 'Composite',
                      className: 'UserDrawerModel'
                    }
                }
              }
            };
            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
          }
        } catch (error) {
          let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
          deserializationError.request = msRest.stripRequest(httpRequest);
          deserializationError.response = msRest.stripResponse(response);
          return Promise.reject(deserializationError);
        }
      }

    } catch(err) {
      return Promise.reject(err);
    }

    return Promise.resolve(operationRes);
  }
  // methods on the client.

  /**
   * @summary Gets a list of user drawer associations.
   *
   * @param {number} userID The user identifier.
   *
   * @param {SoftheonEnterpriseAPIGetUserDrawerAssociationsOptionalParams}
   * [options] Optional Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  async getUserDrawerAssociationsWithHttpOperationResponse(userID: number, options?: Models.SoftheonEnterpriseAPIGetUserDrawerAssociationsOptionalParams): Promise<msRest.HttpOperationResponse> {
    let client = this;
    let drawerID = (options && options.drawerID !== undefined) ? options.drawerID : undefined;
    let acl = (options && options.acl !== undefined) ? options.acl : undefined;
    let page = (options && options.page !== undefined) ? options.page : undefined;
    let pageSize = (options && options.pageSize !== undefined) ? options.pageSize : undefined;
    let sortOrder = (options && options.sortOrder !== undefined) ? options.sortOrder : undefined;
    let sortBy = (options && options.sortBy !== undefined) ? options.sortBy : undefined;
    // Validate
    try {
      if (userID === null || userID === undefined || typeof userID !== 'number') {
        throw new Error('userID cannot be null or undefined and it must be of type number.');
      }
      if (drawerID !== null && drawerID !== undefined && typeof drawerID !== 'number') {
        throw new Error('drawerID must be of type number.');
      }
      if (acl !== null && acl !== undefined && typeof acl !== 'number') {
        throw new Error('acl must be of type number.');
      }
      if (page !== null && page !== undefined && typeof page !== 'number') {
        throw new Error('page must be of type number.');
      }
      if (page !== null && page !== undefined) {
        if (page > 2147483647)
        {
          throw new Error('"page" should satisfy the constraint - "InclusiveMaximum": 2147483647');
        }
        if (page < 1)
        {
          throw new Error('"page" should satisfy the constraint - "InclusiveMinimum": 1');
        }
      }
      if (pageSize !== null && pageSize !== undefined && typeof pageSize !== 'number') {
        throw new Error('pageSize must be of type number.');
      }
      if (pageSize !== null && pageSize !== undefined) {
        if (pageSize > 1000)
        {
          throw new Error('"pageSize" should satisfy the constraint - "InclusiveMaximum": 1000');
        }
        if (pageSize < 1)
        {
          throw new Error('"pageSize" should satisfy the constraint - "InclusiveMinimum": 1');
        }
      }
      if (sortOrder !== null && sortOrder !== undefined && typeof sortOrder.valueOf() !== 'string') {
        throw new Error('sortOrder must be of type string.');
      }
      if (sortBy !== null && sortBy !== undefined && typeof sortBy.valueOf() !== 'string') {
        throw new Error('sortBy must be of type string.');
      }
    } catch (error) {
      return Promise.reject(error);
    }

    // Construct URL
    let baseUrl = this.baseUri;
    let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'v1/directory/users/{userID}/drawers';
    requestUrl = requestUrl.replace('{userID}', encodeURIComponent(userID.toString()));
    let queryParamsArray: Array<any> = [];
    if (drawerID !== null && drawerID !== undefined) {
      queryParamsArray.push('drawerID=' + encodeURIComponent(drawerID.toString()));
    }
    if (acl !== null && acl !== undefined) {
      queryParamsArray.push('acl=' + encodeURIComponent(acl.toString()));
    }
    if (page !== null && page !== undefined) {
      queryParamsArray.push('page=' + encodeURIComponent(page.toString()));
    }
    if (pageSize !== null && pageSize !== undefined) {
      queryParamsArray.push('pageSize=' + encodeURIComponent(pageSize.toString()));
    }
    if (sortOrder !== null && sortOrder !== undefined) {
      queryParamsArray.push('sortOrder=' + encodeURIComponent(sortOrder));
    }
    if (sortBy !== null && sortBy !== undefined) {
      queryParamsArray.push('sortBy=' + encodeURIComponent(sortBy));
    }
    if (queryParamsArray.length > 0) {
      requestUrl += '?' + queryParamsArray.join('&');
    }

    // Create HTTP transport objects
    let httpRequest = new WebResource();
    httpRequest.method = 'GET';
    httpRequest.url = requestUrl;
    httpRequest.headers = {};
    // Set Headers
    httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
    if(options && options.customHeaders) {
      for(let headerName in options.customHeaders) {
        if (options.customHeaders.hasOwnProperty(headerName)) {
          httpRequest.headers[headerName] = options.customHeaders[headerName];
        }
      }
    }
    // Send Request
    let operationRes: msRest.HttpOperationResponse;
    try {
      operationRes = await client.pipeline(httpRequest);
      let response = operationRes.response;
      let statusCode = response.status;
      if (statusCode !== 200 && statusCode !== 403) {
        let error = new msRest.RestError(operationRes.bodyAsText as string);
        error.statusCode = response.status;
        error.request = msRest.stripRequest(httpRequest);
        error.response = msRest.stripResponse(response);
        let parsedErrorResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedErrorResponse) {
            let internalError = null;
            if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
            error.code = internalError ? internalError.code : parsedErrorResponse.code;
            error.message = internalError ? internalError.message : parsedErrorResponse.message;
          }
        } catch (defaultError) {
          error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                           `- "${operationRes.bodyAsText}" for the default response.`;
          return Promise.reject(error);
        }
        return Promise.reject(error);
      }
      // Deserialize Response
      if (statusCode === 200) {
        let parsedResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedResponse !== null && parsedResponse !== undefined) {
            let resultMapper = {
              required: false,
              serializedName: 'parsedResponse',
              type: {
                name: 'Sequence',
                element: {
                    required: false,
                    serializedName: 'UserDrawerModelElementType',
                    type: {
                      name: 'Composite',
                      className: 'UserDrawerModel'
                    }
                }
              }
            };
            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
          }
        } catch (error) {
          let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
          deserializationError.request = msRest.stripRequest(httpRequest);
          deserializationError.response = msRest.stripResponse(response);
          return Promise.reject(deserializationError);
        }
      }

    } catch(err) {
      return Promise.reject(err);
    }

    return Promise.resolve(operationRes);
  }
  // methods on the client.

  /**
   * @summary Inserts/Updates the drawer user association.
   *
   * @param {number} userID The user identifier.
   *
   * @param {number} drawerID The drawer identifier.
   *
   * @param {UserDrawerModel} model The model.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  async createOrUpdateDrawerUserAssociationWithHttpOperationResponse(userID: number, drawerID: number, model: Models.UserDrawerModel, options?: msRest.RequestOptionsBase): Promise<msRest.HttpOperationResponse> {
    let client = this;
    // Validate
    try {
      if (userID === null || userID === undefined || typeof userID !== 'number') {
        throw new Error('userID cannot be null or undefined and it must be of type number.');
      }
      if (drawerID === null || drawerID === undefined || typeof drawerID !== 'number') {
        throw new Error('drawerID cannot be null or undefined and it must be of type number.');
      }
      if (model === null || model === undefined) {
        throw new Error('model cannot be null or undefined.');
      }
    } catch (error) {
      return Promise.reject(error);
    }

    // Construct URL
    let baseUrl = this.baseUri;
    let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'v1/directory/drawers/{drawerID}/users/{userID}';
    requestUrl = requestUrl.replace('{userID}', encodeURIComponent(userID.toString()));
    requestUrl = requestUrl.replace('{drawerID}', encodeURIComponent(drawerID.toString()));

    // Create HTTP transport objects
    let httpRequest = new WebResource();
    httpRequest.method = 'PUT';
    httpRequest.url = requestUrl;
    httpRequest.headers = {};
    // Set Headers
    httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
    if(options && options.customHeaders) {
      for(let headerName in options.customHeaders) {
        if (options.customHeaders.hasOwnProperty(headerName)) {
          httpRequest.headers[headerName] = options.customHeaders[headerName];
        }
      }
    }
    // Serialize Request
    let requestContent = null;
    let requestModel = null;
    try {
      if (model !== null && model !== undefined) {
        let requestModelMapper = Mappers.UserDrawerModel;
        requestModel = client.serializer.serialize(requestModelMapper, model, 'model');
        requestContent = JSON.stringify(requestModel);
      }
    } catch (error) {
      let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
          `payload - ${JSON.stringify(model, null, 2)}.`);
      return Promise.reject(serializationError);
    }
    httpRequest.body = requestContent;
    // Send Request
    let operationRes: msRest.HttpOperationResponse;
    try {
      operationRes = await client.pipeline(httpRequest);
      let response = operationRes.response;
      let statusCode = response.status;
      if (statusCode !== 204 && statusCode !== 403) {
        let error = new msRest.RestError(operationRes.bodyAsText as string);
        error.statusCode = response.status;
        error.request = msRest.stripRequest(httpRequest);
        error.response = msRest.stripResponse(response);
        let parsedErrorResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedErrorResponse) {
            let internalError = null;
            if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
            error.code = internalError ? internalError.code : parsedErrorResponse.code;
            error.message = internalError ? internalError.message : parsedErrorResponse.message;
          }
        } catch (defaultError) {
          error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                           `- "${operationRes.bodyAsText}" for the default response.`;
          return Promise.reject(error);
        }
        return Promise.reject(error);
      }
      // Deserialize Response
      if (statusCode === 204) {
        let parsedResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedResponse !== null && parsedResponse !== undefined) {
            let resultMapper = {
              required: false,
              serializedName: 'parsedResponse',
              type: {
                name: 'Object'
              }
            };
            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
          }
        } catch (error) {
          let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
          deserializationError.request = msRest.stripRequest(httpRequest);
          deserializationError.response = msRest.stripResponse(response);
          return Promise.reject(deserializationError);
        }
      }

    } catch(err) {
      return Promise.reject(err);
    }

    return Promise.resolve(operationRes);
  }
  // methods on the client.

  /**
   * @summary Deletes a drawer user association;
   *
   * @param {number} userID The user identifier.
   *
   * @param {number} drawerID The drawer identifier.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  async deleteDrawerUserAssociationWithHttpOperationResponse(userID: number, drawerID: number, options?: msRest.RequestOptionsBase): Promise<msRest.HttpOperationResponse> {
    let client = this;
    // Validate
    try {
      if (userID === null || userID === undefined || typeof userID !== 'number') {
        throw new Error('userID cannot be null or undefined and it must be of type number.');
      }
      if (drawerID === null || drawerID === undefined || typeof drawerID !== 'number') {
        throw new Error('drawerID cannot be null or undefined and it must be of type number.');
      }
    } catch (error) {
      return Promise.reject(error);
    }

    // Construct URL
    let baseUrl = this.baseUri;
    let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'v1/directory/drawers/{drawerID}/users/{userID}';
    requestUrl = requestUrl.replace('{userID}', encodeURIComponent(userID.toString()));
    requestUrl = requestUrl.replace('{drawerID}', encodeURIComponent(drawerID.toString()));

    // Create HTTP transport objects
    let httpRequest = new WebResource();
    httpRequest.method = 'DELETE';
    httpRequest.url = requestUrl;
    httpRequest.headers = {};
    // Set Headers
    httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
    if(options && options.customHeaders) {
      for(let headerName in options.customHeaders) {
        if (options.customHeaders.hasOwnProperty(headerName)) {
          httpRequest.headers[headerName] = options.customHeaders[headerName];
        }
      }
    }
    // Send Request
    let operationRes: msRest.HttpOperationResponse;
    try {
      operationRes = await client.pipeline(httpRequest);
      let response = operationRes.response;
      let statusCode = response.status;
      if (statusCode !== 204 && statusCode !== 403 && statusCode !== 404) {
        let error = new msRest.RestError(operationRes.bodyAsText as string);
        error.statusCode = response.status;
        error.request = msRest.stripRequest(httpRequest);
        error.response = msRest.stripResponse(response);
        let parsedErrorResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedErrorResponse) {
            let internalError = null;
            if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
            error.code = internalError ? internalError.code : parsedErrorResponse.code;
            error.message = internalError ? internalError.message : parsedErrorResponse.message;
          }
        } catch (defaultError) {
          error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                           `- "${operationRes.bodyAsText}" for the default response.`;
          return Promise.reject(error);
        }
        return Promise.reject(error);
      }
      // Deserialize Response
      if (statusCode === 204) {
        let parsedResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedResponse !== null && parsedResponse !== undefined) {
            let resultMapper = {
              required: false,
              serializedName: 'parsedResponse',
              type: {
                name: 'Object'
              }
            };
            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
          }
        } catch (error) {
          let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
          deserializationError.request = msRest.stripRequest(httpRequest);
          deserializationError.response = msRest.stripResponse(response);
          return Promise.reject(deserializationError);
        }
      }

    } catch(err) {
      return Promise.reject(err);
    }

    return Promise.resolve(operationRes);
  }
  // methods on the client.

  /**
   * @summary Inserts/Updates the user drawer association.
   *
   * @param {number} userID The user identifier.
   *
   * @param {number} drawerID The drawer identifier.
   *
   * @param {UserDrawerModel} model The model.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  async createOrUpdateUserDrawerAssociationWithHttpOperationResponse(userID: number, drawerID: number, model: Models.UserDrawerModel, options?: msRest.RequestOptionsBase): Promise<msRest.HttpOperationResponse> {
    let client = this;
    // Validate
    try {
      if (userID === null || userID === undefined || typeof userID !== 'number') {
        throw new Error('userID cannot be null or undefined and it must be of type number.');
      }
      if (drawerID === null || drawerID === undefined || typeof drawerID !== 'number') {
        throw new Error('drawerID cannot be null or undefined and it must be of type number.');
      }
      if (model === null || model === undefined) {
        throw new Error('model cannot be null or undefined.');
      }
    } catch (error) {
      return Promise.reject(error);
    }

    // Construct URL
    let baseUrl = this.baseUri;
    let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'v1/directory/users/{userID}/drawers/{drawerID}';
    requestUrl = requestUrl.replace('{userID}', encodeURIComponent(userID.toString()));
    requestUrl = requestUrl.replace('{drawerID}', encodeURIComponent(drawerID.toString()));

    // Create HTTP transport objects
    let httpRequest = new WebResource();
    httpRequest.method = 'PUT';
    httpRequest.url = requestUrl;
    httpRequest.headers = {};
    // Set Headers
    httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
    if(options && options.customHeaders) {
      for(let headerName in options.customHeaders) {
        if (options.customHeaders.hasOwnProperty(headerName)) {
          httpRequest.headers[headerName] = options.customHeaders[headerName];
        }
      }
    }
    // Serialize Request
    let requestContent = null;
    let requestModel = null;
    try {
      if (model !== null && model !== undefined) {
        let requestModelMapper = Mappers.UserDrawerModel;
        requestModel = client.serializer.serialize(requestModelMapper, model, 'model');
        requestContent = JSON.stringify(requestModel);
      }
    } catch (error) {
      let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
          `payload - ${JSON.stringify(model, null, 2)}.`);
      return Promise.reject(serializationError);
    }
    httpRequest.body = requestContent;
    // Send Request
    let operationRes: msRest.HttpOperationResponse;
    try {
      operationRes = await client.pipeline(httpRequest);
      let response = operationRes.response;
      let statusCode = response.status;
      if (statusCode !== 204 && statusCode !== 403) {
        let error = new msRest.RestError(operationRes.bodyAsText as string);
        error.statusCode = response.status;
        error.request = msRest.stripRequest(httpRequest);
        error.response = msRest.stripResponse(response);
        let parsedErrorResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedErrorResponse) {
            let internalError = null;
            if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
            error.code = internalError ? internalError.code : parsedErrorResponse.code;
            error.message = internalError ? internalError.message : parsedErrorResponse.message;
          }
        } catch (defaultError) {
          error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                           `- "${operationRes.bodyAsText}" for the default response.`;
          return Promise.reject(error);
        }
        return Promise.reject(error);
      }
      // Deserialize Response
      if (statusCode === 204) {
        let parsedResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedResponse !== null && parsedResponse !== undefined) {
            let resultMapper = {
              required: false,
              serializedName: 'parsedResponse',
              type: {
                name: 'Object'
              }
            };
            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
          }
        } catch (error) {
          let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
          deserializationError.request = msRest.stripRequest(httpRequest);
          deserializationError.response = msRest.stripResponse(response);
          return Promise.reject(deserializationError);
        }
      }

    } catch(err) {
      return Promise.reject(err);
    }

    return Promise.resolve(operationRes);
  }
  // methods on the client.

  /**
   * @summary Deletes a user drawer association;
   *
   * @param {number} userID The user identifier.
   *
   * @param {number} drawerID The drawer identifier.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  async deleteUserDrawerAssociationWithHttpOperationResponse(userID: number, drawerID: number, options?: msRest.RequestOptionsBase): Promise<msRest.HttpOperationResponse> {
    let client = this;
    // Validate
    try {
      if (userID === null || userID === undefined || typeof userID !== 'number') {
        throw new Error('userID cannot be null or undefined and it must be of type number.');
      }
      if (drawerID === null || drawerID === undefined || typeof drawerID !== 'number') {
        throw new Error('drawerID cannot be null or undefined and it must be of type number.');
      }
    } catch (error) {
      return Promise.reject(error);
    }

    // Construct URL
    let baseUrl = this.baseUri;
    let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'v1/directory/users/{userID}/drawers/{drawerID}';
    requestUrl = requestUrl.replace('{userID}', encodeURIComponent(userID.toString()));
    requestUrl = requestUrl.replace('{drawerID}', encodeURIComponent(drawerID.toString()));

    // Create HTTP transport objects
    let httpRequest = new WebResource();
    httpRequest.method = 'DELETE';
    httpRequest.url = requestUrl;
    httpRequest.headers = {};
    // Set Headers
    httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
    if(options && options.customHeaders) {
      for(let headerName in options.customHeaders) {
        if (options.customHeaders.hasOwnProperty(headerName)) {
          httpRequest.headers[headerName] = options.customHeaders[headerName];
        }
      }
    }
    // Send Request
    let operationRes: msRest.HttpOperationResponse;
    try {
      operationRes = await client.pipeline(httpRequest);
      let response = operationRes.response;
      let statusCode = response.status;
      if (statusCode !== 204 && statusCode !== 403 && statusCode !== 404) {
        let error = new msRest.RestError(operationRes.bodyAsText as string);
        error.statusCode = response.status;
        error.request = msRest.stripRequest(httpRequest);
        error.response = msRest.stripResponse(response);
        let parsedErrorResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedErrorResponse) {
            let internalError = null;
            if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
            error.code = internalError ? internalError.code : parsedErrorResponse.code;
            error.message = internalError ? internalError.message : parsedErrorResponse.message;
          }
        } catch (defaultError) {
          error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                           `- "${operationRes.bodyAsText}" for the default response.`;
          return Promise.reject(error);
        }
        return Promise.reject(error);
      }
      // Deserialize Response
      if (statusCode === 204) {
        let parsedResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedResponse !== null && parsedResponse !== undefined) {
            let resultMapper = {
              required: false,
              serializedName: 'parsedResponse',
              type: {
                name: 'Object'
              }
            };
            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
          }
        } catch (error) {
          let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
          deserializationError.request = msRest.stripRequest(httpRequest);
          deserializationError.response = msRest.stripResponse(response);
          return Promise.reject(deserializationError);
        }
      }

    } catch(err) {
      return Promise.reject(err);
    }

    return Promise.resolve(operationRes);
  }
  // methods on the client.

  /**
   * @summary Gets a list of queue user associations.
   *
   * @param {number} queueID The queue identifier.
   *
   * @param {SoftheonEnterpriseAPIGetQueueUserAssociationsOptionalParams}
   * [options] Optional Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  async getQueueUserAssociationsWithHttpOperationResponse(queueID: number, options?: Models.SoftheonEnterpriseAPIGetQueueUserAssociationsOptionalParams): Promise<msRest.HttpOperationResponse> {
    let client = this;
    let userID = (options && options.userID !== undefined) ? options.userID : undefined;
    let acl = (options && options.acl !== undefined) ? options.acl : undefined;
    let page = (options && options.page !== undefined) ? options.page : undefined;
    let pageSize = (options && options.pageSize !== undefined) ? options.pageSize : undefined;
    let sortOrder = (options && options.sortOrder !== undefined) ? options.sortOrder : undefined;
    let sortBy = (options && options.sortBy !== undefined) ? options.sortBy : undefined;
    // Validate
    try {
      if (userID !== null && userID !== undefined && typeof userID !== 'number') {
        throw new Error('userID must be of type number.');
      }
      if (queueID === null || queueID === undefined || typeof queueID !== 'number') {
        throw new Error('queueID cannot be null or undefined and it must be of type number.');
      }
      if (acl !== null && acl !== undefined && typeof acl !== 'number') {
        throw new Error('acl must be of type number.');
      }
      if (page !== null && page !== undefined && typeof page !== 'number') {
        throw new Error('page must be of type number.');
      }
      if (page !== null && page !== undefined) {
        if (page > 2147483647)
        {
          throw new Error('"page" should satisfy the constraint - "InclusiveMaximum": 2147483647');
        }
        if (page < 1)
        {
          throw new Error('"page" should satisfy the constraint - "InclusiveMinimum": 1');
        }
      }
      if (pageSize !== null && pageSize !== undefined && typeof pageSize !== 'number') {
        throw new Error('pageSize must be of type number.');
      }
      if (pageSize !== null && pageSize !== undefined) {
        if (pageSize > 1000)
        {
          throw new Error('"pageSize" should satisfy the constraint - "InclusiveMaximum": 1000');
        }
        if (pageSize < 1)
        {
          throw new Error('"pageSize" should satisfy the constraint - "InclusiveMinimum": 1');
        }
      }
      if (sortOrder !== null && sortOrder !== undefined && typeof sortOrder.valueOf() !== 'string') {
        throw new Error('sortOrder must be of type string.');
      }
      if (sortBy !== null && sortBy !== undefined && typeof sortBy.valueOf() !== 'string') {
        throw new Error('sortBy must be of type string.');
      }
    } catch (error) {
      return Promise.reject(error);
    }

    // Construct URL
    let baseUrl = this.baseUri;
    let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'v1/workflow/queues/{queueID}/users';
    requestUrl = requestUrl.replace('{queueID}', encodeURIComponent(queueID.toString()));
    let queryParamsArray: Array<any> = [];
    if (userID !== null && userID !== undefined) {
      queryParamsArray.push('userID=' + encodeURIComponent(userID.toString()));
    }
    if (acl !== null && acl !== undefined) {
      queryParamsArray.push('acl=' + encodeURIComponent(acl.toString()));
    }
    if (page !== null && page !== undefined) {
      queryParamsArray.push('page=' + encodeURIComponent(page.toString()));
    }
    if (pageSize !== null && pageSize !== undefined) {
      queryParamsArray.push('pageSize=' + encodeURIComponent(pageSize.toString()));
    }
    if (sortOrder !== null && sortOrder !== undefined) {
      queryParamsArray.push('sortOrder=' + encodeURIComponent(sortOrder));
    }
    if (sortBy !== null && sortBy !== undefined) {
      queryParamsArray.push('sortBy=' + encodeURIComponent(sortBy));
    }
    if (queryParamsArray.length > 0) {
      requestUrl += '?' + queryParamsArray.join('&');
    }

    // Create HTTP transport objects
    let httpRequest = new WebResource();
    httpRequest.method = 'GET';
    httpRequest.url = requestUrl;
    httpRequest.headers = {};
    // Set Headers
    httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
    if(options && options.customHeaders) {
      for(let headerName in options.customHeaders) {
        if (options.customHeaders.hasOwnProperty(headerName)) {
          httpRequest.headers[headerName] = options.customHeaders[headerName];
        }
      }
    }
    // Send Request
    let operationRes: msRest.HttpOperationResponse;
    try {
      operationRes = await client.pipeline(httpRequest);
      let response = operationRes.response;
      let statusCode = response.status;
      if (statusCode !== 200 && statusCode !== 403) {
        let error = new msRest.RestError(operationRes.bodyAsText as string);
        error.statusCode = response.status;
        error.request = msRest.stripRequest(httpRequest);
        error.response = msRest.stripResponse(response);
        let parsedErrorResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedErrorResponse) {
            let internalError = null;
            if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
            error.code = internalError ? internalError.code : parsedErrorResponse.code;
            error.message = internalError ? internalError.message : parsedErrorResponse.message;
          }
        } catch (defaultError) {
          error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                           `- "${operationRes.bodyAsText}" for the default response.`;
          return Promise.reject(error);
        }
        return Promise.reject(error);
      }
      // Deserialize Response
      if (statusCode === 200) {
        let parsedResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedResponse !== null && parsedResponse !== undefined) {
            let resultMapper = {
              required: false,
              serializedName: 'parsedResponse',
              type: {
                name: 'Sequence',
                element: {
                    required: false,
                    serializedName: 'UserQueueModelElementType',
                    type: {
                      name: 'Composite',
                      className: 'UserQueueModel'
                    }
                }
              }
            };
            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
          }
        } catch (error) {
          let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
          deserializationError.request = msRest.stripRequest(httpRequest);
          deserializationError.response = msRest.stripResponse(response);
          return Promise.reject(deserializationError);
        }
      }

    } catch(err) {
      return Promise.reject(err);
    }

    return Promise.resolve(operationRes);
  }
  // methods on the client.

  /**
   * @summary Gets a list of user queue associations.
   *
   * @param {number} userID The user identifier.
   *
   * @param {SoftheonEnterpriseAPIGetUserQueueAssociationsOptionalParams}
   * [options] Optional Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  async getUserQueueAssociationsWithHttpOperationResponse(userID: number, options?: Models.SoftheonEnterpriseAPIGetUserQueueAssociationsOptionalParams): Promise<msRest.HttpOperationResponse> {
    let client = this;
    let queueID = (options && options.queueID !== undefined) ? options.queueID : undefined;
    let acl = (options && options.acl !== undefined) ? options.acl : undefined;
    let page = (options && options.page !== undefined) ? options.page : undefined;
    let pageSize = (options && options.pageSize !== undefined) ? options.pageSize : undefined;
    let sortOrder = (options && options.sortOrder !== undefined) ? options.sortOrder : undefined;
    let sortBy = (options && options.sortBy !== undefined) ? options.sortBy : undefined;
    // Validate
    try {
      if (userID === null || userID === undefined || typeof userID !== 'number') {
        throw new Error('userID cannot be null or undefined and it must be of type number.');
      }
      if (queueID !== null && queueID !== undefined && typeof queueID !== 'number') {
        throw new Error('queueID must be of type number.');
      }
      if (acl !== null && acl !== undefined && typeof acl !== 'number') {
        throw new Error('acl must be of type number.');
      }
      if (page !== null && page !== undefined && typeof page !== 'number') {
        throw new Error('page must be of type number.');
      }
      if (page !== null && page !== undefined) {
        if (page > 2147483647)
        {
          throw new Error('"page" should satisfy the constraint - "InclusiveMaximum": 2147483647');
        }
        if (page < 1)
        {
          throw new Error('"page" should satisfy the constraint - "InclusiveMinimum": 1');
        }
      }
      if (pageSize !== null && pageSize !== undefined && typeof pageSize !== 'number') {
        throw new Error('pageSize must be of type number.');
      }
      if (pageSize !== null && pageSize !== undefined) {
        if (pageSize > 1000)
        {
          throw new Error('"pageSize" should satisfy the constraint - "InclusiveMaximum": 1000');
        }
        if (pageSize < 1)
        {
          throw new Error('"pageSize" should satisfy the constraint - "InclusiveMinimum": 1');
        }
      }
      if (sortOrder !== null && sortOrder !== undefined && typeof sortOrder.valueOf() !== 'string') {
        throw new Error('sortOrder must be of type string.');
      }
      if (sortBy !== null && sortBy !== undefined && typeof sortBy.valueOf() !== 'string') {
        throw new Error('sortBy must be of type string.');
      }
    } catch (error) {
      return Promise.reject(error);
    }

    // Construct URL
    let baseUrl = this.baseUri;
    let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'v1/directory/users/{userID}/queues';
    requestUrl = requestUrl.replace('{userID}', encodeURIComponent(userID.toString()));
    let queryParamsArray: Array<any> = [];
    if (queueID !== null && queueID !== undefined) {
      queryParamsArray.push('queueID=' + encodeURIComponent(queueID.toString()));
    }
    if (acl !== null && acl !== undefined) {
      queryParamsArray.push('acl=' + encodeURIComponent(acl.toString()));
    }
    if (page !== null && page !== undefined) {
      queryParamsArray.push('page=' + encodeURIComponent(page.toString()));
    }
    if (pageSize !== null && pageSize !== undefined) {
      queryParamsArray.push('pageSize=' + encodeURIComponent(pageSize.toString()));
    }
    if (sortOrder !== null && sortOrder !== undefined) {
      queryParamsArray.push('sortOrder=' + encodeURIComponent(sortOrder));
    }
    if (sortBy !== null && sortBy !== undefined) {
      queryParamsArray.push('sortBy=' + encodeURIComponent(sortBy));
    }
    if (queryParamsArray.length > 0) {
      requestUrl += '?' + queryParamsArray.join('&');
    }

    // Create HTTP transport objects
    let httpRequest = new WebResource();
    httpRequest.method = 'GET';
    httpRequest.url = requestUrl;
    httpRequest.headers = {};
    // Set Headers
    httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
    if(options && options.customHeaders) {
      for(let headerName in options.customHeaders) {
        if (options.customHeaders.hasOwnProperty(headerName)) {
          httpRequest.headers[headerName] = options.customHeaders[headerName];
        }
      }
    }
    // Send Request
    let operationRes: msRest.HttpOperationResponse;
    try {
      operationRes = await client.pipeline(httpRequest);
      let response = operationRes.response;
      let statusCode = response.status;
      if (statusCode !== 200 && statusCode !== 403) {
        let error = new msRest.RestError(operationRes.bodyAsText as string);
        error.statusCode = response.status;
        error.request = msRest.stripRequest(httpRequest);
        error.response = msRest.stripResponse(response);
        let parsedErrorResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedErrorResponse) {
            let internalError = null;
            if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
            error.code = internalError ? internalError.code : parsedErrorResponse.code;
            error.message = internalError ? internalError.message : parsedErrorResponse.message;
          }
        } catch (defaultError) {
          error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                           `- "${operationRes.bodyAsText}" for the default response.`;
          return Promise.reject(error);
        }
        return Promise.reject(error);
      }
      // Deserialize Response
      if (statusCode === 200) {
        let parsedResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedResponse !== null && parsedResponse !== undefined) {
            let resultMapper = {
              required: false,
              serializedName: 'parsedResponse',
              type: {
                name: 'Sequence',
                element: {
                    required: false,
                    serializedName: 'UserQueueModelElementType',
                    type: {
                      name: 'Composite',
                      className: 'UserQueueModel'
                    }
                }
              }
            };
            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
          }
        } catch (error) {
          let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
          deserializationError.request = msRest.stripRequest(httpRequest);
          deserializationError.response = msRest.stripResponse(response);
          return Promise.reject(deserializationError);
        }
      }

    } catch(err) {
      return Promise.reject(err);
    }

    return Promise.resolve(operationRes);
  }
  // methods on the client.

  /**
   * @summary Inserts/Updates the queue user association.
   *
   * @param {number} userID The user identifier.
   *
   * @param {number} queueID The queue identifier.
   *
   * @param {UserQueueModel} model The model.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  async createOrUpdateQueueUserAssociationWithHttpOperationResponse(userID: number, queueID: number, model: Models.UserQueueModel, options?: msRest.RequestOptionsBase): Promise<msRest.HttpOperationResponse> {
    let client = this;
    // Validate
    try {
      if (userID === null || userID === undefined || typeof userID !== 'number') {
        throw new Error('userID cannot be null or undefined and it must be of type number.');
      }
      if (queueID === null || queueID === undefined || typeof queueID !== 'number') {
        throw new Error('queueID cannot be null or undefined and it must be of type number.');
      }
      if (model === null || model === undefined) {
        throw new Error('model cannot be null or undefined.');
      }
    } catch (error) {
      return Promise.reject(error);
    }

    // Construct URL
    let baseUrl = this.baseUri;
    let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'v1/workflow/queues/{queueID}/users/{userID}';
    requestUrl = requestUrl.replace('{userID}', encodeURIComponent(userID.toString()));
    requestUrl = requestUrl.replace('{queueID}', encodeURIComponent(queueID.toString()));

    // Create HTTP transport objects
    let httpRequest = new WebResource();
    httpRequest.method = 'PUT';
    httpRequest.url = requestUrl;
    httpRequest.headers = {};
    // Set Headers
    httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
    if(options && options.customHeaders) {
      for(let headerName in options.customHeaders) {
        if (options.customHeaders.hasOwnProperty(headerName)) {
          httpRequest.headers[headerName] = options.customHeaders[headerName];
        }
      }
    }
    // Serialize Request
    let requestContent = null;
    let requestModel = null;
    try {
      if (model !== null && model !== undefined) {
        let requestModelMapper = Mappers.UserQueueModel;
        requestModel = client.serializer.serialize(requestModelMapper, model, 'model');
        requestContent = JSON.stringify(requestModel);
      }
    } catch (error) {
      let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
          `payload - ${JSON.stringify(model, null, 2)}.`);
      return Promise.reject(serializationError);
    }
    httpRequest.body = requestContent;
    // Send Request
    let operationRes: msRest.HttpOperationResponse;
    try {
      operationRes = await client.pipeline(httpRequest);
      let response = operationRes.response;
      let statusCode = response.status;
      if (statusCode !== 204 && statusCode !== 403) {
        let error = new msRest.RestError(operationRes.bodyAsText as string);
        error.statusCode = response.status;
        error.request = msRest.stripRequest(httpRequest);
        error.response = msRest.stripResponse(response);
        let parsedErrorResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedErrorResponse) {
            let internalError = null;
            if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
            error.code = internalError ? internalError.code : parsedErrorResponse.code;
            error.message = internalError ? internalError.message : parsedErrorResponse.message;
          }
        } catch (defaultError) {
          error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                           `- "${operationRes.bodyAsText}" for the default response.`;
          return Promise.reject(error);
        }
        return Promise.reject(error);
      }
      // Deserialize Response
      if (statusCode === 204) {
        let parsedResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedResponse !== null && parsedResponse !== undefined) {
            let resultMapper = {
              required: false,
              serializedName: 'parsedResponse',
              type: {
                name: 'Object'
              }
            };
            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
          }
        } catch (error) {
          let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
          deserializationError.request = msRest.stripRequest(httpRequest);
          deserializationError.response = msRest.stripResponse(response);
          return Promise.reject(deserializationError);
        }
      }

    } catch(err) {
      return Promise.reject(err);
    }

    return Promise.resolve(operationRes);
  }
  // methods on the client.

  /**
   * @summary Deletes a queue user association;
   *
   * @param {number} userID The user identifier.
   *
   * @param {number} queueID The queue identifier.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  async deleteQueueUserAssociationWithHttpOperationResponse(userID: number, queueID: number, options?: msRest.RequestOptionsBase): Promise<msRest.HttpOperationResponse> {
    let client = this;
    // Validate
    try {
      if (userID === null || userID === undefined || typeof userID !== 'number') {
        throw new Error('userID cannot be null or undefined and it must be of type number.');
      }
      if (queueID === null || queueID === undefined || typeof queueID !== 'number') {
        throw new Error('queueID cannot be null or undefined and it must be of type number.');
      }
    } catch (error) {
      return Promise.reject(error);
    }

    // Construct URL
    let baseUrl = this.baseUri;
    let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'v1/workflow/queues/{queueID}/users/{userID}';
    requestUrl = requestUrl.replace('{userID}', encodeURIComponent(userID.toString()));
    requestUrl = requestUrl.replace('{queueID}', encodeURIComponent(queueID.toString()));

    // Create HTTP transport objects
    let httpRequest = new WebResource();
    httpRequest.method = 'DELETE';
    httpRequest.url = requestUrl;
    httpRequest.headers = {};
    // Set Headers
    httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
    if(options && options.customHeaders) {
      for(let headerName in options.customHeaders) {
        if (options.customHeaders.hasOwnProperty(headerName)) {
          httpRequest.headers[headerName] = options.customHeaders[headerName];
        }
      }
    }
    // Send Request
    let operationRes: msRest.HttpOperationResponse;
    try {
      operationRes = await client.pipeline(httpRequest);
      let response = operationRes.response;
      let statusCode = response.status;
      if (statusCode !== 204 && statusCode !== 403 && statusCode !== 404) {
        let error = new msRest.RestError(operationRes.bodyAsText as string);
        error.statusCode = response.status;
        error.request = msRest.stripRequest(httpRequest);
        error.response = msRest.stripResponse(response);
        let parsedErrorResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedErrorResponse) {
            let internalError = null;
            if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
            error.code = internalError ? internalError.code : parsedErrorResponse.code;
            error.message = internalError ? internalError.message : parsedErrorResponse.message;
          }
        } catch (defaultError) {
          error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                           `- "${operationRes.bodyAsText}" for the default response.`;
          return Promise.reject(error);
        }
        return Promise.reject(error);
      }
      // Deserialize Response
      if (statusCode === 204) {
        let parsedResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedResponse !== null && parsedResponse !== undefined) {
            let resultMapper = {
              required: false,
              serializedName: 'parsedResponse',
              type: {
                name: 'Object'
              }
            };
            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
          }
        } catch (error) {
          let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
          deserializationError.request = msRest.stripRequest(httpRequest);
          deserializationError.response = msRest.stripResponse(response);
          return Promise.reject(deserializationError);
        }
      }

    } catch(err) {
      return Promise.reject(err);
    }

    return Promise.resolve(operationRes);
  }
  // methods on the client.

  /**
   * @summary Inserts/Updates the user queue association.
   *
   * @param {number} userID The user identifier.
   *
   * @param {number} queueID The queue identifier.
   *
   * @param {UserQueueModel} model The model.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  async createOrUpdateUserQueueAssociationWithHttpOperationResponse(userID: number, queueID: number, model: Models.UserQueueModel, options?: msRest.RequestOptionsBase): Promise<msRest.HttpOperationResponse> {
    let client = this;
    // Validate
    try {
      if (userID === null || userID === undefined || typeof userID !== 'number') {
        throw new Error('userID cannot be null or undefined and it must be of type number.');
      }
      if (queueID === null || queueID === undefined || typeof queueID !== 'number') {
        throw new Error('queueID cannot be null or undefined and it must be of type number.');
      }
      if (model === null || model === undefined) {
        throw new Error('model cannot be null or undefined.');
      }
    } catch (error) {
      return Promise.reject(error);
    }

    // Construct URL
    let baseUrl = this.baseUri;
    let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'v1/directory/users/{userID}/queues/{queueID}';
    requestUrl = requestUrl.replace('{userID}', encodeURIComponent(userID.toString()));
    requestUrl = requestUrl.replace('{queueID}', encodeURIComponent(queueID.toString()));

    // Create HTTP transport objects
    let httpRequest = new WebResource();
    httpRequest.method = 'PUT';
    httpRequest.url = requestUrl;
    httpRequest.headers = {};
    // Set Headers
    httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
    if(options && options.customHeaders) {
      for(let headerName in options.customHeaders) {
        if (options.customHeaders.hasOwnProperty(headerName)) {
          httpRequest.headers[headerName] = options.customHeaders[headerName];
        }
      }
    }
    // Serialize Request
    let requestContent = null;
    let requestModel = null;
    try {
      if (model !== null && model !== undefined) {
        let requestModelMapper = Mappers.UserQueueModel;
        requestModel = client.serializer.serialize(requestModelMapper, model, 'model');
        requestContent = JSON.stringify(requestModel);
      }
    } catch (error) {
      let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
          `payload - ${JSON.stringify(model, null, 2)}.`);
      return Promise.reject(serializationError);
    }
    httpRequest.body = requestContent;
    // Send Request
    let operationRes: msRest.HttpOperationResponse;
    try {
      operationRes = await client.pipeline(httpRequest);
      let response = operationRes.response;
      let statusCode = response.status;
      if (statusCode !== 204 && statusCode !== 403) {
        let error = new msRest.RestError(operationRes.bodyAsText as string);
        error.statusCode = response.status;
        error.request = msRest.stripRequest(httpRequest);
        error.response = msRest.stripResponse(response);
        let parsedErrorResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedErrorResponse) {
            let internalError = null;
            if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
            error.code = internalError ? internalError.code : parsedErrorResponse.code;
            error.message = internalError ? internalError.message : parsedErrorResponse.message;
          }
        } catch (defaultError) {
          error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                           `- "${operationRes.bodyAsText}" for the default response.`;
          return Promise.reject(error);
        }
        return Promise.reject(error);
      }
      // Deserialize Response
      if (statusCode === 204) {
        let parsedResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedResponse !== null && parsedResponse !== undefined) {
            let resultMapper = {
              required: false,
              serializedName: 'parsedResponse',
              type: {
                name: 'Object'
              }
            };
            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
          }
        } catch (error) {
          let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
          deserializationError.request = msRest.stripRequest(httpRequest);
          deserializationError.response = msRest.stripResponse(response);
          return Promise.reject(deserializationError);
        }
      }

    } catch(err) {
      return Promise.reject(err);
    }

    return Promise.resolve(operationRes);
  }
  // methods on the client.

  /**
   * @summary Deletes a user queue association;
   *
   * @param {number} userID The user identifier.
   *
   * @param {number} queueID The queue identifier.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  async deleteUserQueueAssociationWithHttpOperationResponse(userID: number, queueID: number, options?: msRest.RequestOptionsBase): Promise<msRest.HttpOperationResponse> {
    let client = this;
    // Validate
    try {
      if (userID === null || userID === undefined || typeof userID !== 'number') {
        throw new Error('userID cannot be null or undefined and it must be of type number.');
      }
      if (queueID === null || queueID === undefined || typeof queueID !== 'number') {
        throw new Error('queueID cannot be null or undefined and it must be of type number.');
      }
    } catch (error) {
      return Promise.reject(error);
    }

    // Construct URL
    let baseUrl = this.baseUri;
    let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'v1/directory/users/{userID}/queues/{queueID}';
    requestUrl = requestUrl.replace('{userID}', encodeURIComponent(userID.toString()));
    requestUrl = requestUrl.replace('{queueID}', encodeURIComponent(queueID.toString()));

    // Create HTTP transport objects
    let httpRequest = new WebResource();
    httpRequest.method = 'DELETE';
    httpRequest.url = requestUrl;
    httpRequest.headers = {};
    // Set Headers
    httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
    if(options && options.customHeaders) {
      for(let headerName in options.customHeaders) {
        if (options.customHeaders.hasOwnProperty(headerName)) {
          httpRequest.headers[headerName] = options.customHeaders[headerName];
        }
      }
    }
    // Send Request
    let operationRes: msRest.HttpOperationResponse;
    try {
      operationRes = await client.pipeline(httpRequest);
      let response = operationRes.response;
      let statusCode = response.status;
      if (statusCode !== 204 && statusCode !== 403 && statusCode !== 404) {
        let error = new msRest.RestError(operationRes.bodyAsText as string);
        error.statusCode = response.status;
        error.request = msRest.stripRequest(httpRequest);
        error.response = msRest.stripResponse(response);
        let parsedErrorResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedErrorResponse) {
            let internalError = null;
            if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
            error.code = internalError ? internalError.code : parsedErrorResponse.code;
            error.message = internalError ? internalError.message : parsedErrorResponse.message;
          }
        } catch (defaultError) {
          error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                           `- "${operationRes.bodyAsText}" for the default response.`;
          return Promise.reject(error);
        }
        return Promise.reject(error);
      }
      // Deserialize Response
      if (statusCode === 204) {
        let parsedResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedResponse !== null && parsedResponse !== undefined) {
            let resultMapper = {
              required: false,
              serializedName: 'parsedResponse',
              type: {
                name: 'Object'
              }
            };
            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
          }
        } catch (error) {
          let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
          deserializationError.request = msRest.stripRequest(httpRequest);
          deserializationError.response = msRest.stripResponse(response);
          return Promise.reject(deserializationError);
        }
      }

    } catch(err) {
      return Promise.reject(err);
    }

    return Promise.resolve(operationRes);
  }
  // methods on the client.

  /**
   * @summary Gets a list of application user associations.
   *
   * @param {number} applicationID The application identifier.
   *
   * @param {SoftheonEnterpriseAPIGetApplicationUserAssociationsOptionalParams}
   * [options] Optional Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  async getApplicationUserAssociationsWithHttpOperationResponse(applicationID: number, options?: Models.SoftheonEnterpriseAPIGetApplicationUserAssociationsOptionalParams): Promise<msRest.HttpOperationResponse> {
    let client = this;
    let userID = (options && options.userID !== undefined) ? options.userID : undefined;
    let acl = (options && options.acl !== undefined) ? options.acl : undefined;
    let page = (options && options.page !== undefined) ? options.page : undefined;
    let pageSize = (options && options.pageSize !== undefined) ? options.pageSize : undefined;
    let sortOrder = (options && options.sortOrder !== undefined) ? options.sortOrder : undefined;
    let sortBy = (options && options.sortBy !== undefined) ? options.sortBy : undefined;
    // Validate
    try {
      if (userID !== null && userID !== undefined && typeof userID !== 'number') {
        throw new Error('userID must be of type number.');
      }
      if (applicationID === null || applicationID === undefined || typeof applicationID !== 'number') {
        throw new Error('applicationID cannot be null or undefined and it must be of type number.');
      }
      if (acl !== null && acl !== undefined && typeof acl !== 'number') {
        throw new Error('acl must be of type number.');
      }
      if (page !== null && page !== undefined && typeof page !== 'number') {
        throw new Error('page must be of type number.');
      }
      if (page !== null && page !== undefined) {
        if (page > 2147483647)
        {
          throw new Error('"page" should satisfy the constraint - "InclusiveMaximum": 2147483647');
        }
        if (page < 1)
        {
          throw new Error('"page" should satisfy the constraint - "InclusiveMinimum": 1');
        }
      }
      if (pageSize !== null && pageSize !== undefined && typeof pageSize !== 'number') {
        throw new Error('pageSize must be of type number.');
      }
      if (pageSize !== null && pageSize !== undefined) {
        if (pageSize > 1000)
        {
          throw new Error('"pageSize" should satisfy the constraint - "InclusiveMaximum": 1000');
        }
        if (pageSize < 1)
        {
          throw new Error('"pageSize" should satisfy the constraint - "InclusiveMinimum": 1');
        }
      }
      if (sortOrder !== null && sortOrder !== undefined && typeof sortOrder.valueOf() !== 'string') {
        throw new Error('sortOrder must be of type string.');
      }
      if (sortBy !== null && sortBy !== undefined && typeof sortBy.valueOf() !== 'string') {
        throw new Error('sortBy must be of type string.');
      }
    } catch (error) {
      return Promise.reject(error);
    }

    // Construct URL
    let baseUrl = this.baseUri;
    let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'v1/directory/applications/{applicationID}/users';
    requestUrl = requestUrl.replace('{applicationID}', encodeURIComponent(applicationID.toString()));
    let queryParamsArray: Array<any> = [];
    if (userID !== null && userID !== undefined) {
      queryParamsArray.push('userID=' + encodeURIComponent(userID.toString()));
    }
    if (acl !== null && acl !== undefined) {
      queryParamsArray.push('acl=' + encodeURIComponent(acl.toString()));
    }
    if (page !== null && page !== undefined) {
      queryParamsArray.push('page=' + encodeURIComponent(page.toString()));
    }
    if (pageSize !== null && pageSize !== undefined) {
      queryParamsArray.push('pageSize=' + encodeURIComponent(pageSize.toString()));
    }
    if (sortOrder !== null && sortOrder !== undefined) {
      queryParamsArray.push('sortOrder=' + encodeURIComponent(sortOrder));
    }
    if (sortBy !== null && sortBy !== undefined) {
      queryParamsArray.push('sortBy=' + encodeURIComponent(sortBy));
    }
    if (queryParamsArray.length > 0) {
      requestUrl += '?' + queryParamsArray.join('&');
    }

    // Create HTTP transport objects
    let httpRequest = new WebResource();
    httpRequest.method = 'GET';
    httpRequest.url = requestUrl;
    httpRequest.headers = {};
    // Set Headers
    httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
    if(options && options.customHeaders) {
      for(let headerName in options.customHeaders) {
        if (options.customHeaders.hasOwnProperty(headerName)) {
          httpRequest.headers[headerName] = options.customHeaders[headerName];
        }
      }
    }
    // Send Request
    let operationRes: msRest.HttpOperationResponse;
    try {
      operationRes = await client.pipeline(httpRequest);
      let response = operationRes.response;
      let statusCode = response.status;
      if (statusCode !== 200 && statusCode !== 403) {
        let error = new msRest.RestError(operationRes.bodyAsText as string);
        error.statusCode = response.status;
        error.request = msRest.stripRequest(httpRequest);
        error.response = msRest.stripResponse(response);
        let parsedErrorResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedErrorResponse) {
            let internalError = null;
            if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
            error.code = internalError ? internalError.code : parsedErrorResponse.code;
            error.message = internalError ? internalError.message : parsedErrorResponse.message;
          }
        } catch (defaultError) {
          error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                           `- "${operationRes.bodyAsText}" for the default response.`;
          return Promise.reject(error);
        }
        return Promise.reject(error);
      }
      // Deserialize Response
      if (statusCode === 200) {
        let parsedResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedResponse !== null && parsedResponse !== undefined) {
            let resultMapper = {
              required: false,
              serializedName: 'parsedResponse',
              type: {
                name: 'Sequence',
                element: {
                    required: false,
                    serializedName: 'UserApplicationModelElementType',
                    type: {
                      name: 'Composite',
                      className: 'UserApplicationModel'
                    }
                }
              }
            };
            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
          }
        } catch (error) {
          let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
          deserializationError.request = msRest.stripRequest(httpRequest);
          deserializationError.response = msRest.stripResponse(response);
          return Promise.reject(deserializationError);
        }
      }

    } catch(err) {
      return Promise.reject(err);
    }

    return Promise.resolve(operationRes);
  }
  // methods on the client.

  /**
   * @summary Gets a list of user application associations.
   *
   * @param {number} userID The user identifier.
   *
   * @param {SoftheonEnterpriseAPIGetUserApplicationAssociationsOptionalParams}
   * [options] Optional Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  async getUserApplicationAssociationsWithHttpOperationResponse(userID: number, options?: Models.SoftheonEnterpriseAPIGetUserApplicationAssociationsOptionalParams): Promise<msRest.HttpOperationResponse> {
    let client = this;
    let applicationID = (options && options.applicationID !== undefined) ? options.applicationID : undefined;
    let acl = (options && options.acl !== undefined) ? options.acl : undefined;
    let page = (options && options.page !== undefined) ? options.page : undefined;
    let pageSize = (options && options.pageSize !== undefined) ? options.pageSize : undefined;
    let sortOrder = (options && options.sortOrder !== undefined) ? options.sortOrder : undefined;
    let sortBy = (options && options.sortBy !== undefined) ? options.sortBy : undefined;
    // Validate
    try {
      if (userID === null || userID === undefined || typeof userID !== 'number') {
        throw new Error('userID cannot be null or undefined and it must be of type number.');
      }
      if (applicationID !== null && applicationID !== undefined && typeof applicationID !== 'number') {
        throw new Error('applicationID must be of type number.');
      }
      if (acl !== null && acl !== undefined && typeof acl !== 'number') {
        throw new Error('acl must be of type number.');
      }
      if (page !== null && page !== undefined && typeof page !== 'number') {
        throw new Error('page must be of type number.');
      }
      if (page !== null && page !== undefined) {
        if (page > 2147483647)
        {
          throw new Error('"page" should satisfy the constraint - "InclusiveMaximum": 2147483647');
        }
        if (page < 1)
        {
          throw new Error('"page" should satisfy the constraint - "InclusiveMinimum": 1');
        }
      }
      if (pageSize !== null && pageSize !== undefined && typeof pageSize !== 'number') {
        throw new Error('pageSize must be of type number.');
      }
      if (pageSize !== null && pageSize !== undefined) {
        if (pageSize > 1000)
        {
          throw new Error('"pageSize" should satisfy the constraint - "InclusiveMaximum": 1000');
        }
        if (pageSize < 1)
        {
          throw new Error('"pageSize" should satisfy the constraint - "InclusiveMinimum": 1');
        }
      }
      if (sortOrder !== null && sortOrder !== undefined && typeof sortOrder.valueOf() !== 'string') {
        throw new Error('sortOrder must be of type string.');
      }
      if (sortBy !== null && sortBy !== undefined && typeof sortBy.valueOf() !== 'string') {
        throw new Error('sortBy must be of type string.');
      }
    } catch (error) {
      return Promise.reject(error);
    }

    // Construct URL
    let baseUrl = this.baseUri;
    let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'v1/directory/users/{userID}/applications';
    requestUrl = requestUrl.replace('{userID}', encodeURIComponent(userID.toString()));
    let queryParamsArray: Array<any> = [];
    if (applicationID !== null && applicationID !== undefined) {
      queryParamsArray.push('applicationID=' + encodeURIComponent(applicationID.toString()));
    }
    if (acl !== null && acl !== undefined) {
      queryParamsArray.push('acl=' + encodeURIComponent(acl.toString()));
    }
    if (page !== null && page !== undefined) {
      queryParamsArray.push('page=' + encodeURIComponent(page.toString()));
    }
    if (pageSize !== null && pageSize !== undefined) {
      queryParamsArray.push('pageSize=' + encodeURIComponent(pageSize.toString()));
    }
    if (sortOrder !== null && sortOrder !== undefined) {
      queryParamsArray.push('sortOrder=' + encodeURIComponent(sortOrder));
    }
    if (sortBy !== null && sortBy !== undefined) {
      queryParamsArray.push('sortBy=' + encodeURIComponent(sortBy));
    }
    if (queryParamsArray.length > 0) {
      requestUrl += '?' + queryParamsArray.join('&');
    }

    // Create HTTP transport objects
    let httpRequest = new WebResource();
    httpRequest.method = 'GET';
    httpRequest.url = requestUrl;
    httpRequest.headers = {};
    // Set Headers
    httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
    if(options && options.customHeaders) {
      for(let headerName in options.customHeaders) {
        if (options.customHeaders.hasOwnProperty(headerName)) {
          httpRequest.headers[headerName] = options.customHeaders[headerName];
        }
      }
    }
    // Send Request
    let operationRes: msRest.HttpOperationResponse;
    try {
      operationRes = await client.pipeline(httpRequest);
      let response = operationRes.response;
      let statusCode = response.status;
      if (statusCode !== 200 && statusCode !== 403) {
        let error = new msRest.RestError(operationRes.bodyAsText as string);
        error.statusCode = response.status;
        error.request = msRest.stripRequest(httpRequest);
        error.response = msRest.stripResponse(response);
        let parsedErrorResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedErrorResponse) {
            let internalError = null;
            if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
            error.code = internalError ? internalError.code : parsedErrorResponse.code;
            error.message = internalError ? internalError.message : parsedErrorResponse.message;
          }
        } catch (defaultError) {
          error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                           `- "${operationRes.bodyAsText}" for the default response.`;
          return Promise.reject(error);
        }
        return Promise.reject(error);
      }
      // Deserialize Response
      if (statusCode === 200) {
        let parsedResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedResponse !== null && parsedResponse !== undefined) {
            let resultMapper = {
              required: false,
              serializedName: 'parsedResponse',
              type: {
                name: 'Sequence',
                element: {
                    required: false,
                    serializedName: 'UserApplicationModelElementType',
                    type: {
                      name: 'Composite',
                      className: 'UserApplicationModel'
                    }
                }
              }
            };
            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
          }
        } catch (error) {
          let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
          deserializationError.request = msRest.stripRequest(httpRequest);
          deserializationError.response = msRest.stripResponse(response);
          return Promise.reject(deserializationError);
        }
      }

    } catch(err) {
      return Promise.reject(err);
    }

    return Promise.resolve(operationRes);
  }
  // methods on the client.

  /**
   * @summary Inserts/Updates the application user association.
   *
   * @param {number} userID The user identifier.
   *
   * @param {number} applicationID The application identifier.
   *
   * @param {UserApplicationModel} model The model.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  async createOrUpdateApplicationUserAssociationWithHttpOperationResponse(userID: number, applicationID: number, model: Models.UserApplicationModel, options?: msRest.RequestOptionsBase): Promise<msRest.HttpOperationResponse> {
    let client = this;
    // Validate
    try {
      if (userID === null || userID === undefined || typeof userID !== 'number') {
        throw new Error('userID cannot be null or undefined and it must be of type number.');
      }
      if (applicationID === null || applicationID === undefined || typeof applicationID !== 'number') {
        throw new Error('applicationID cannot be null or undefined and it must be of type number.');
      }
      if (model === null || model === undefined) {
        throw new Error('model cannot be null or undefined.');
      }
    } catch (error) {
      return Promise.reject(error);
    }

    // Construct URL
    let baseUrl = this.baseUri;
    let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'v1/directory/applications/{applicationID}/users/{userID}';
    requestUrl = requestUrl.replace('{userID}', encodeURIComponent(userID.toString()));
    requestUrl = requestUrl.replace('{applicationID}', encodeURIComponent(applicationID.toString()));

    // Create HTTP transport objects
    let httpRequest = new WebResource();
    httpRequest.method = 'PUT';
    httpRequest.url = requestUrl;
    httpRequest.headers = {};
    // Set Headers
    httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
    if(options && options.customHeaders) {
      for(let headerName in options.customHeaders) {
        if (options.customHeaders.hasOwnProperty(headerName)) {
          httpRequest.headers[headerName] = options.customHeaders[headerName];
        }
      }
    }
    // Serialize Request
    let requestContent = null;
    let requestModel = null;
    try {
      if (model !== null && model !== undefined) {
        let requestModelMapper = Mappers.UserApplicationModel;
        requestModel = client.serializer.serialize(requestModelMapper, model, 'model');
        requestContent = JSON.stringify(requestModel);
      }
    } catch (error) {
      let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
          `payload - ${JSON.stringify(model, null, 2)}.`);
      return Promise.reject(serializationError);
    }
    httpRequest.body = requestContent;
    // Send Request
    let operationRes: msRest.HttpOperationResponse;
    try {
      operationRes = await client.pipeline(httpRequest);
      let response = operationRes.response;
      let statusCode = response.status;
      if (statusCode !== 204 && statusCode !== 403) {
        let error = new msRest.RestError(operationRes.bodyAsText as string);
        error.statusCode = response.status;
        error.request = msRest.stripRequest(httpRequest);
        error.response = msRest.stripResponse(response);
        let parsedErrorResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedErrorResponse) {
            let internalError = null;
            if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
            error.code = internalError ? internalError.code : parsedErrorResponse.code;
            error.message = internalError ? internalError.message : parsedErrorResponse.message;
          }
        } catch (defaultError) {
          error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                           `- "${operationRes.bodyAsText}" for the default response.`;
          return Promise.reject(error);
        }
        return Promise.reject(error);
      }
      // Deserialize Response
      if (statusCode === 204) {
        let parsedResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedResponse !== null && parsedResponse !== undefined) {
            let resultMapper = {
              required: false,
              serializedName: 'parsedResponse',
              type: {
                name: 'Object'
              }
            };
            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
          }
        } catch (error) {
          let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
          deserializationError.request = msRest.stripRequest(httpRequest);
          deserializationError.response = msRest.stripResponse(response);
          return Promise.reject(deserializationError);
        }
      }

    } catch(err) {
      return Promise.reject(err);
    }

    return Promise.resolve(operationRes);
  }
  // methods on the client.

  /**
   * @summary Deletes an application user association;
   *
   * @param {number} userID The user identifier.
   *
   * @param {number} applicationID The application identifier.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  async deleteApplicationUserAssociationWithHttpOperationResponse(userID: number, applicationID: number, options?: msRest.RequestOptionsBase): Promise<msRest.HttpOperationResponse> {
    let client = this;
    // Validate
    try {
      if (userID === null || userID === undefined || typeof userID !== 'number') {
        throw new Error('userID cannot be null or undefined and it must be of type number.');
      }
      if (applicationID === null || applicationID === undefined || typeof applicationID !== 'number') {
        throw new Error('applicationID cannot be null or undefined and it must be of type number.');
      }
    } catch (error) {
      return Promise.reject(error);
    }

    // Construct URL
    let baseUrl = this.baseUri;
    let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'v1/directory/applications/{applicationID}/users/{userID}';
    requestUrl = requestUrl.replace('{userID}', encodeURIComponent(userID.toString()));
    requestUrl = requestUrl.replace('{applicationID}', encodeURIComponent(applicationID.toString()));

    // Create HTTP transport objects
    let httpRequest = new WebResource();
    httpRequest.method = 'DELETE';
    httpRequest.url = requestUrl;
    httpRequest.headers = {};
    // Set Headers
    httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
    if(options && options.customHeaders) {
      for(let headerName in options.customHeaders) {
        if (options.customHeaders.hasOwnProperty(headerName)) {
          httpRequest.headers[headerName] = options.customHeaders[headerName];
        }
      }
    }
    // Send Request
    let operationRes: msRest.HttpOperationResponse;
    try {
      operationRes = await client.pipeline(httpRequest);
      let response = operationRes.response;
      let statusCode = response.status;
      if (statusCode !== 204 && statusCode !== 403 && statusCode !== 404) {
        let error = new msRest.RestError(operationRes.bodyAsText as string);
        error.statusCode = response.status;
        error.request = msRest.stripRequest(httpRequest);
        error.response = msRest.stripResponse(response);
        let parsedErrorResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedErrorResponse) {
            let internalError = null;
            if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
            error.code = internalError ? internalError.code : parsedErrorResponse.code;
            error.message = internalError ? internalError.message : parsedErrorResponse.message;
          }
        } catch (defaultError) {
          error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                           `- "${operationRes.bodyAsText}" for the default response.`;
          return Promise.reject(error);
        }
        return Promise.reject(error);
      }
      // Deserialize Response
      if (statusCode === 204) {
        let parsedResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedResponse !== null && parsedResponse !== undefined) {
            let resultMapper = {
              required: false,
              serializedName: 'parsedResponse',
              type: {
                name: 'Object'
              }
            };
            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
          }
        } catch (error) {
          let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
          deserializationError.request = msRest.stripRequest(httpRequest);
          deserializationError.response = msRest.stripResponse(response);
          return Promise.reject(deserializationError);
        }
      }

    } catch(err) {
      return Promise.reject(err);
    }

    return Promise.resolve(operationRes);
  }
  // methods on the client.

  /**
   * @summary Inserts/Updates the user application association.
   *
   * @param {number} userID The user identifier.
   *
   * @param {number} applicationID The application identifier.
   *
   * @param {UserApplicationModel} model The model.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  async createOrUpdateUserApplicationAssociationWithHttpOperationResponse(userID: number, applicationID: number, model: Models.UserApplicationModel, options?: msRest.RequestOptionsBase): Promise<msRest.HttpOperationResponse> {
    let client = this;
    // Validate
    try {
      if (userID === null || userID === undefined || typeof userID !== 'number') {
        throw new Error('userID cannot be null or undefined and it must be of type number.');
      }
      if (applicationID === null || applicationID === undefined || typeof applicationID !== 'number') {
        throw new Error('applicationID cannot be null or undefined and it must be of type number.');
      }
      if (model === null || model === undefined) {
        throw new Error('model cannot be null or undefined.');
      }
    } catch (error) {
      return Promise.reject(error);
    }

    // Construct URL
    let baseUrl = this.baseUri;
    let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'v1/directory/users/{userID}/applications/{applicationID}';
    requestUrl = requestUrl.replace('{userID}', encodeURIComponent(userID.toString()));
    requestUrl = requestUrl.replace('{applicationID}', encodeURIComponent(applicationID.toString()));

    // Create HTTP transport objects
    let httpRequest = new WebResource();
    httpRequest.method = 'PUT';
    httpRequest.url = requestUrl;
    httpRequest.headers = {};
    // Set Headers
    httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
    if(options && options.customHeaders) {
      for(let headerName in options.customHeaders) {
        if (options.customHeaders.hasOwnProperty(headerName)) {
          httpRequest.headers[headerName] = options.customHeaders[headerName];
        }
      }
    }
    // Serialize Request
    let requestContent = null;
    let requestModel = null;
    try {
      if (model !== null && model !== undefined) {
        let requestModelMapper = Mappers.UserApplicationModel;
        requestModel = client.serializer.serialize(requestModelMapper, model, 'model');
        requestContent = JSON.stringify(requestModel);
      }
    } catch (error) {
      let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
          `payload - ${JSON.stringify(model, null, 2)}.`);
      return Promise.reject(serializationError);
    }
    httpRequest.body = requestContent;
    // Send Request
    let operationRes: msRest.HttpOperationResponse;
    try {
      operationRes = await client.pipeline(httpRequest);
      let response = operationRes.response;
      let statusCode = response.status;
      if (statusCode !== 204 && statusCode !== 403) {
        let error = new msRest.RestError(operationRes.bodyAsText as string);
        error.statusCode = response.status;
        error.request = msRest.stripRequest(httpRequest);
        error.response = msRest.stripResponse(response);
        let parsedErrorResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedErrorResponse) {
            let internalError = null;
            if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
            error.code = internalError ? internalError.code : parsedErrorResponse.code;
            error.message = internalError ? internalError.message : parsedErrorResponse.message;
          }
        } catch (defaultError) {
          error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                           `- "${operationRes.bodyAsText}" for the default response.`;
          return Promise.reject(error);
        }
        return Promise.reject(error);
      }
      // Deserialize Response
      if (statusCode === 204) {
        let parsedResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedResponse !== null && parsedResponse !== undefined) {
            let resultMapper = {
              required: false,
              serializedName: 'parsedResponse',
              type: {
                name: 'Object'
              }
            };
            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
          }
        } catch (error) {
          let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
          deserializationError.request = msRest.stripRequest(httpRequest);
          deserializationError.response = msRest.stripResponse(response);
          return Promise.reject(deserializationError);
        }
      }

    } catch(err) {
      return Promise.reject(err);
    }

    return Promise.resolve(operationRes);
  }
  // methods on the client.

  /**
   * @summary Deletes a user application association;
   *
   * @param {number} userID The user identifier.
   *
   * @param {number} applicationID The application identifier.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  async deleteUserApplicationAssociationWithHttpOperationResponse(userID: number, applicationID: number, options?: msRest.RequestOptionsBase): Promise<msRest.HttpOperationResponse> {
    let client = this;
    // Validate
    try {
      if (userID === null || userID === undefined || typeof userID !== 'number') {
        throw new Error('userID cannot be null or undefined and it must be of type number.');
      }
      if (applicationID === null || applicationID === undefined || typeof applicationID !== 'number') {
        throw new Error('applicationID cannot be null or undefined and it must be of type number.');
      }
    } catch (error) {
      return Promise.reject(error);
    }

    // Construct URL
    let baseUrl = this.baseUri;
    let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'v1/directory/users/{userID}/applications/{applicationID}';
    requestUrl = requestUrl.replace('{userID}', encodeURIComponent(userID.toString()));
    requestUrl = requestUrl.replace('{applicationID}', encodeURIComponent(applicationID.toString()));

    // Create HTTP transport objects
    let httpRequest = new WebResource();
    httpRequest.method = 'DELETE';
    httpRequest.url = requestUrl;
    httpRequest.headers = {};
    // Set Headers
    httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
    if(options && options.customHeaders) {
      for(let headerName in options.customHeaders) {
        if (options.customHeaders.hasOwnProperty(headerName)) {
          httpRequest.headers[headerName] = options.customHeaders[headerName];
        }
      }
    }
    // Send Request
    let operationRes: msRest.HttpOperationResponse;
    try {
      operationRes = await client.pipeline(httpRequest);
      let response = operationRes.response;
      let statusCode = response.status;
      if (statusCode !== 204 && statusCode !== 403 && statusCode !== 404) {
        let error = new msRest.RestError(operationRes.bodyAsText as string);
        error.statusCode = response.status;
        error.request = msRest.stripRequest(httpRequest);
        error.response = msRest.stripResponse(response);
        let parsedErrorResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedErrorResponse) {
            let internalError = null;
            if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
            error.code = internalError ? internalError.code : parsedErrorResponse.code;
            error.message = internalError ? internalError.message : parsedErrorResponse.message;
          }
        } catch (defaultError) {
          error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                           `- "${operationRes.bodyAsText}" for the default response.`;
          return Promise.reject(error);
        }
        return Promise.reject(error);
      }
      // Deserialize Response
      if (statusCode === 204) {
        let parsedResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedResponse !== null && parsedResponse !== undefined) {
            let resultMapper = {
              required: false,
              serializedName: 'parsedResponse',
              type: {
                name: 'Object'
              }
            };
            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
          }
        } catch (error) {
          let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
          deserializationError.request = msRest.stripRequest(httpRequest);
          deserializationError.response = msRest.stripResponse(response);
          return Promise.reject(deserializationError);
        }
      }

    } catch(err) {
      return Promise.reject(err);
    }

    return Promise.resolve(operationRes);
  }
  // methods on the client.

  /**
   * @summary Gets a paged list of attachment metadata.
   *
   * @param {SoftheonEnterpriseAPIGetAttachmentsByFilterOptionalParams} [options]
   * Optional Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  async getAttachmentsByFilterWithHttpOperationResponse(options?: Models.SoftheonEnterpriseAPIGetAttachmentsByFilterOptionalParams): Promise<msRest.HttpOperationResponse> {
    let client = this;
    let type = (options && options.type !== undefined) ? options.type : undefined;
    let extension = (options && options.extension !== undefined) ? options.extension : undefined;
    let minSize = (options && options.minSize !== undefined) ? options.minSize : undefined;
    let maxSize = (options && options.maxSize !== undefined) ? options.maxSize : undefined;
    let acl = (options && options.acl !== undefined) ? options.acl : undefined;
    let entityID = (options && options.entityID !== undefined) ? options.entityID : undefined;
    let drawerID = (options && options.drawerID !== undefined) ? options.drawerID : undefined;
    let name = (options && options.name !== undefined) ? options.name : undefined;
    let creatorUserID = (options && options.creatorUserID !== undefined) ? options.creatorUserID : undefined;
    let modifierUserID = (options && options.modifierUserID !== undefined) ? options.modifierUserID : undefined;
    let minInsertionTime = (options && options.minInsertionTime !== undefined) ? options.minInsertionTime : undefined;
    let maxInsertionTime = (options && options.maxInsertionTime !== undefined) ? options.maxInsertionTime : undefined;
    let minModificationTime = (options && options.minModificationTime !== undefined) ? options.minModificationTime : undefined;
    let maxModificationTime = (options && options.maxModificationTime !== undefined) ? options.maxModificationTime : undefined;
    let page = (options && options.page !== undefined) ? options.page : undefined;
    let pageSize = (options && options.pageSize !== undefined) ? options.pageSize : undefined;
    let sortOrder = (options && options.sortOrder !== undefined) ? options.sortOrder : undefined;
    let sortBy = (options && options.sortBy !== undefined) ? options.sortBy : undefined;
    // Validate
    try {
      if (type !== null && type !== undefined && typeof type.valueOf() !== 'string') {
        throw new Error('type must be of type string.');
      }
      if (extension !== null && extension !== undefined && typeof extension.valueOf() !== 'string') {
        throw new Error('extension must be of type string.');
      }
      if (extension !== null && extension !== undefined) {
        if (extension.length > 255)
        {
          throw new Error('"extension" should satisfy the constraint - "MaxLength": 255');
        }
        if (extension.length < 0)
        {
          throw new Error('"extension" should satisfy the constraint - "MinLength": 0');
        }
      }
      if (minSize !== null && minSize !== undefined && typeof minSize !== 'number') {
        throw new Error('minSize must be of type number.');
      }
      if (minSize !== null && minSize !== undefined) {
        if (minSize < 0)
        {
          throw new Error('"minSize" should satisfy the constraint - "InclusiveMinimum": 0');
        }
      }
      if (maxSize !== null && maxSize !== undefined && typeof maxSize !== 'number') {
        throw new Error('maxSize must be of type number.');
      }
      if (maxSize !== null && maxSize !== undefined) {
        if (maxSize < 1)
        {
          throw new Error('"maxSize" should satisfy the constraint - "InclusiveMinimum": 1');
        }
      }
      if (acl !== null && acl !== undefined && typeof acl !== 'number') {
        throw new Error('acl must be of type number.');
      }
      if (entityID !== null && entityID !== undefined && typeof entityID !== 'number') {
        throw new Error('entityID must be of type number.');
      }
      if (entityID !== null && entityID !== undefined) {
        if (entityID > 2147483647)
        {
          throw new Error('"entityID" should satisfy the constraint - "InclusiveMaximum": 2147483647');
        }
        if (entityID < 1)
        {
          throw new Error('"entityID" should satisfy the constraint - "InclusiveMinimum": 1');
        }
      }
      if (drawerID !== null && drawerID !== undefined && typeof drawerID !== 'number') {
        throw new Error('drawerID must be of type number.');
      }
      if (drawerID !== null && drawerID !== undefined) {
        if (drawerID > 2147483647)
        {
          throw new Error('"drawerID" should satisfy the constraint - "InclusiveMaximum": 2147483647');
        }
        if (drawerID < 1)
        {
          throw new Error('"drawerID" should satisfy the constraint - "InclusiveMinimum": 1');
        }
      }
      if (name !== null && name !== undefined && typeof name.valueOf() !== 'string') {
        throw new Error('name must be of type string.');
      }
      if (name !== null && name !== undefined) {
        if (name.length > 255)
        {
          throw new Error('"name" should satisfy the constraint - "MaxLength": 255');
        }
        if (name.length < 0)
        {
          throw new Error('"name" should satisfy the constraint - "MinLength": 0');
        }
      }
      if (creatorUserID !== null && creatorUserID !== undefined && typeof creatorUserID !== 'number') {
        throw new Error('creatorUserID must be of type number.');
      }
      if (creatorUserID !== null && creatorUserID !== undefined) {
        if (creatorUserID > 2147483647)
        {
          throw new Error('"creatorUserID" should satisfy the constraint - "InclusiveMaximum": 2147483647');
        }
        if (creatorUserID < 1)
        {
          throw new Error('"creatorUserID" should satisfy the constraint - "InclusiveMinimum": 1');
        }
      }
      if (modifierUserID !== null && modifierUserID !== undefined && typeof modifierUserID !== 'number') {
        throw new Error('modifierUserID must be of type number.');
      }
      if (modifierUserID !== null && modifierUserID !== undefined) {
        if (modifierUserID > 2147483647)
        {
          throw new Error('"modifierUserID" should satisfy the constraint - "InclusiveMaximum": 2147483647');
        }
        if (modifierUserID < 1)
        {
          throw new Error('"modifierUserID" should satisfy the constraint - "InclusiveMinimum": 1');
        }
      }
      if (minInsertionTime && !(minInsertionTime instanceof Date ||
          (typeof (minInsertionTime as string).valueOf() === 'string' && !isNaN(Date.parse(minInsertionTime as string))))) {
            throw new Error('minInsertionTime must be of type date.');
          }
      if (maxInsertionTime && !(maxInsertionTime instanceof Date ||
          (typeof (maxInsertionTime as string).valueOf() === 'string' && !isNaN(Date.parse(maxInsertionTime as string))))) {
            throw new Error('maxInsertionTime must be of type date.');
          }
      if (minModificationTime && !(minModificationTime instanceof Date ||
          (typeof (minModificationTime as string).valueOf() === 'string' && !isNaN(Date.parse(minModificationTime as string))))) {
            throw new Error('minModificationTime must be of type date.');
          }
      if (maxModificationTime && !(maxModificationTime instanceof Date ||
          (typeof (maxModificationTime as string).valueOf() === 'string' && !isNaN(Date.parse(maxModificationTime as string))))) {
            throw new Error('maxModificationTime must be of type date.');
          }
      if (page !== null && page !== undefined && typeof page !== 'number') {
        throw new Error('page must be of type number.');
      }
      if (page !== null && page !== undefined) {
        if (page > 2147483647)
        {
          throw new Error('"page" should satisfy the constraint - "InclusiveMaximum": 2147483647');
        }
        if (page < 1)
        {
          throw new Error('"page" should satisfy the constraint - "InclusiveMinimum": 1');
        }
      }
      if (pageSize !== null && pageSize !== undefined && typeof pageSize !== 'number') {
        throw new Error('pageSize must be of type number.');
      }
      if (pageSize !== null && pageSize !== undefined) {
        if (pageSize > 1000)
        {
          throw new Error('"pageSize" should satisfy the constraint - "InclusiveMaximum": 1000');
        }
        if (pageSize < 1)
        {
          throw new Error('"pageSize" should satisfy the constraint - "InclusiveMinimum": 1');
        }
      }
      if (sortOrder !== null && sortOrder !== undefined && typeof sortOrder.valueOf() !== 'string') {
        throw new Error('sortOrder must be of type string.');
      }
      if (sortBy !== null && sortBy !== undefined && typeof sortBy.valueOf() !== 'string') {
        throw new Error('sortBy must be of type string.');
      }
    } catch (error) {
      return Promise.reject(error);
    }

    // Construct URL
    let baseUrl = this.baseUri;
    let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'v1/content/attachments';
    let queryParamsArray: Array<any> = [];
    if (type !== null && type !== undefined) {
      queryParamsArray.push('type=' + encodeURIComponent(type));
    }
    if (extension !== null && extension !== undefined) {
      queryParamsArray.push('extension=' + encodeURIComponent(extension));
    }
    if (minSize !== null && minSize !== undefined) {
      queryParamsArray.push('minSize=' + encodeURIComponent(minSize.toString()));
    }
    if (maxSize !== null && maxSize !== undefined) {
      queryParamsArray.push('maxSize=' + encodeURIComponent(maxSize.toString()));
    }
    if (acl !== null && acl !== undefined) {
      queryParamsArray.push('acl=' + encodeURIComponent(acl.toString()));
    }
    if (entityID !== null && entityID !== undefined) {
      queryParamsArray.push('entityID=' + encodeURIComponent(entityID.toString()));
    }
    if (drawerID !== null && drawerID !== undefined) {
      queryParamsArray.push('drawerID=' + encodeURIComponent(drawerID.toString()));
    }
    if (name !== null && name !== undefined) {
      queryParamsArray.push('name=' + encodeURIComponent(name));
    }
    if (creatorUserID !== null && creatorUserID !== undefined) {
      queryParamsArray.push('creatorUserID=' + encodeURIComponent(creatorUserID.toString()));
    }
    if (modifierUserID !== null && modifierUserID !== undefined) {
      queryParamsArray.push('modifierUserID=' + encodeURIComponent(modifierUserID.toString()));
    }
    if (minInsertionTime !== null && minInsertionTime !== undefined) {
      queryParamsArray.push('minInsertionTime=' + encodeURIComponent(msRest.serializeObject(minInsertionTime)));
    }
    if (maxInsertionTime !== null && maxInsertionTime !== undefined) {
      queryParamsArray.push('maxInsertionTime=' + encodeURIComponent(msRest.serializeObject(maxInsertionTime)));
    }
    if (minModificationTime !== null && minModificationTime !== undefined) {
      queryParamsArray.push('minModificationTime=' + encodeURIComponent(msRest.serializeObject(minModificationTime)));
    }
    if (maxModificationTime !== null && maxModificationTime !== undefined) {
      queryParamsArray.push('maxModificationTime=' + encodeURIComponent(msRest.serializeObject(maxModificationTime)));
    }
    if (page !== null && page !== undefined) {
      queryParamsArray.push('page=' + encodeURIComponent(page.toString()));
    }
    if (pageSize !== null && pageSize !== undefined) {
      queryParamsArray.push('pageSize=' + encodeURIComponent(pageSize.toString()));
    }
    if (sortOrder !== null && sortOrder !== undefined) {
      queryParamsArray.push('sortOrder=' + encodeURIComponent(sortOrder));
    }
    if (sortBy !== null && sortBy !== undefined) {
      queryParamsArray.push('sortBy=' + encodeURIComponent(sortBy));
    }
    if (queryParamsArray.length > 0) {
      requestUrl += '?' + queryParamsArray.join('&');
    }

    // Create HTTP transport objects
    let httpRequest = new WebResource();
    httpRequest.method = 'GET';
    httpRequest.url = requestUrl;
    httpRequest.headers = {};
    // Set Headers
    httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
    if(options && options.customHeaders) {
      for(let headerName in options.customHeaders) {
        if (options.customHeaders.hasOwnProperty(headerName)) {
          httpRequest.headers[headerName] = options.customHeaders[headerName];
        }
      }
    }
    // Send Request
    let operationRes: msRest.HttpOperationResponse;
    try {
      operationRes = await client.pipeline(httpRequest);
      let response = operationRes.response;
      let statusCode = response.status;
      if (statusCode !== 200) {
        let error = new msRest.RestError(operationRes.bodyAsText as string);
        error.statusCode = response.status;
        error.request = msRest.stripRequest(httpRequest);
        error.response = msRest.stripResponse(response);
        let parsedErrorResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedErrorResponse) {
            let internalError = null;
            if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
            error.code = internalError ? internalError.code : parsedErrorResponse.code;
            error.message = internalError ? internalError.message : parsedErrorResponse.message;
          }
        } catch (defaultError) {
          error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                           `- "${operationRes.bodyAsText}" for the default response.`;
          return Promise.reject(error);
        }
        return Promise.reject(error);
      }
      // Deserialize Response
      if (statusCode === 200) {
        let parsedResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedResponse !== null && parsedResponse !== undefined) {
            let resultMapper = {
              required: false,
              serializedName: 'parsedResponse',
              type: {
                name: 'Sequence',
                element: {
                    required: false,
                    serializedName: 'AttachmentModelElementType',
                    type: {
                      name: 'Composite',
                      className: 'AttachmentModel'
                    }
                }
              }
            };
            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
          }
        } catch (error) {
          let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
          deserializationError.request = msRest.stripRequest(httpRequest);
          deserializationError.response = msRest.stripResponse(response);
          return Promise.reject(deserializationError);
        }
      }

    } catch(err) {
      return Promise.reject(err);
    }

    return Promise.resolve(operationRes);
  }
  // methods on the client.

  /**
   * @summary Gets a single attachment metadata based on its unique identifier.
   *
   * @param {number} drawer The drawer identifier.
   *
   * @param {number} id The attachment identifier.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  async getAttachmentByIdWithHttpOperationResponse(drawer: number, id: number, options?: msRest.RequestOptionsBase): Promise<msRest.HttpOperationResponse> {
    let client = this;
    // Validate
    try {
      if (drawer === null || drawer === undefined || typeof drawer !== 'number') {
        throw new Error('drawer cannot be null or undefined and it must be of type number.');
      }
      if (id === null || id === undefined || typeof id !== 'number') {
        throw new Error('id cannot be null or undefined and it must be of type number.');
      }
    } catch (error) {
      return Promise.reject(error);
    }

    // Construct URL
    let baseUrl = this.baseUri;
    let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'v1/content/attachments/{drawer}/{id}';
    requestUrl = requestUrl.replace('{drawer}', encodeURIComponent(drawer.toString()));
    requestUrl = requestUrl.replace('{id}', encodeURIComponent(id.toString()));

    // Create HTTP transport objects
    let httpRequest = new WebResource();
    httpRequest.method = 'GET';
    httpRequest.url = requestUrl;
    httpRequest.headers = {};
    // Set Headers
    httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
    if(options && options.customHeaders) {
      for(let headerName in options.customHeaders) {
        if (options.customHeaders.hasOwnProperty(headerName)) {
          httpRequest.headers[headerName] = options.customHeaders[headerName];
        }
      }
    }
    // Send Request
    let operationRes: msRest.HttpOperationResponse;
    try {
      operationRes = await client.pipeline(httpRequest);
      let response = operationRes.response;
      let statusCode = response.status;
      if (statusCode !== 200 && statusCode !== 404) {
        let error = new msRest.RestError(operationRes.bodyAsText as string);
        error.statusCode = response.status;
        error.request = msRest.stripRequest(httpRequest);
        error.response = msRest.stripResponse(response);
        let parsedErrorResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedErrorResponse) {
            let internalError = null;
            if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
            error.code = internalError ? internalError.code : parsedErrorResponse.code;
            error.message = internalError ? internalError.message : parsedErrorResponse.message;
          }
        } catch (defaultError) {
          error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                           `- "${operationRes.bodyAsText}" for the default response.`;
          return Promise.reject(error);
        }
        return Promise.reject(error);
      }
      // Deserialize Response
      if (statusCode === 200) {
        let parsedResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedResponse !== null && parsedResponse !== undefined) {
            let resultMapper = Mappers.AttachmentModel;
            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
          }
        } catch (error) {
          let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
          deserializationError.request = msRest.stripRequest(httpRequest);
          deserializationError.response = msRest.stripResponse(response);
          return Promise.reject(deserializationError);
        }
      }

    } catch(err) {
      return Promise.reject(err);
    }

    return Promise.resolve(operationRes);
  }
  // methods on the client.

  /**
   * @summary Updates a specified attachment's metadata..
   *
   * @param {number} drawer The drawer identifier.
   *
   * @param {number} id The attachment identifier.
   *
   * @param {UpdateAttachmentRequestModel} model The model.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  async updateAttachmentWithHttpOperationResponse(drawer: number, id: number, model: Models.UpdateAttachmentRequestModel, options?: msRest.RequestOptionsBase): Promise<msRest.HttpOperationResponse> {
    let client = this;
    // Validate
    try {
      if (drawer === null || drawer === undefined || typeof drawer !== 'number') {
        throw new Error('drawer cannot be null or undefined and it must be of type number.');
      }
      if (id === null || id === undefined || typeof id !== 'number') {
        throw new Error('id cannot be null or undefined and it must be of type number.');
      }
      if (model === null || model === undefined) {
        throw new Error('model cannot be null or undefined.');
      }
    } catch (error) {
      return Promise.reject(error);
    }

    // Construct URL
    let baseUrl = this.baseUri;
    let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'v1/content/attachments/{drawer}/{id}';
    requestUrl = requestUrl.replace('{drawer}', encodeURIComponent(drawer.toString()));
    requestUrl = requestUrl.replace('{id}', encodeURIComponent(id.toString()));

    // Create HTTP transport objects
    let httpRequest = new WebResource();
    httpRequest.method = 'PUT';
    httpRequest.url = requestUrl;
    httpRequest.headers = {};
    // Set Headers
    httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
    if(options && options.customHeaders) {
      for(let headerName in options.customHeaders) {
        if (options.customHeaders.hasOwnProperty(headerName)) {
          httpRequest.headers[headerName] = options.customHeaders[headerName];
        }
      }
    }
    // Serialize Request
    let requestContent = null;
    let requestModel = null;
    try {
      if (model !== null && model !== undefined) {
        let requestModelMapper = Mappers.UpdateAttachmentRequestModel;
        requestModel = client.serializer.serialize(requestModelMapper, model, 'model');
        requestContent = JSON.stringify(requestModel);
      }
    } catch (error) {
      let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
          `payload - ${JSON.stringify(model, null, 2)}.`);
      return Promise.reject(serializationError);
    }
    httpRequest.body = requestContent;
    // Send Request
    let operationRes: msRest.HttpOperationResponse;
    try {
      operationRes = await client.pipeline(httpRequest);
      let response = operationRes.response;
      let statusCode = response.status;
      if (statusCode !== 204 && statusCode !== 403 && statusCode !== 404) {
        let error = new msRest.RestError(operationRes.bodyAsText as string);
        error.statusCode = response.status;
        error.request = msRest.stripRequest(httpRequest);
        error.response = msRest.stripResponse(response);
        let parsedErrorResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedErrorResponse) {
            let internalError = null;
            if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
            error.code = internalError ? internalError.code : parsedErrorResponse.code;
            error.message = internalError ? internalError.message : parsedErrorResponse.message;
          }
        } catch (defaultError) {
          error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                           `- "${operationRes.bodyAsText}" for the default response.`;
          return Promise.reject(error);
        }
        return Promise.reject(error);
      }
      // Deserialize Response
      if (statusCode === 204) {
        let parsedResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedResponse !== null && parsedResponse !== undefined) {
            let resultMapper = {
              required: false,
              serializedName: 'parsedResponse',
              type: {
                name: 'Object'
              }
            };
            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
          }
        } catch (error) {
          let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
          deserializationError.request = msRest.stripRequest(httpRequest);
          deserializationError.response = msRest.stripResponse(response);
          return Promise.reject(deserializationError);
        }
      }

    } catch(err) {
      return Promise.reject(err);
    }

    return Promise.resolve(operationRes);
  }
  // methods on the client.

  /**
   * @summary Deletes an attachment
   *
   * @param {number} drawer The drawer identifier.
   *
   * @param {number} id The attachment identifier.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  async deleteAttachmentWithHttpOperationResponse(drawer: number, id: number, options?: msRest.RequestOptionsBase): Promise<msRest.HttpOperationResponse> {
    let client = this;
    // Validate
    try {
      if (drawer === null || drawer === undefined || typeof drawer !== 'number') {
        throw new Error('drawer cannot be null or undefined and it must be of type number.');
      }
      if (id === null || id === undefined || typeof id !== 'number') {
        throw new Error('id cannot be null or undefined and it must be of type number.');
      }
    } catch (error) {
      return Promise.reject(error);
    }

    // Construct URL
    let baseUrl = this.baseUri;
    let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'v1/content/attachments/{drawer}/{id}';
    requestUrl = requestUrl.replace('{drawer}', encodeURIComponent(drawer.toString()));
    requestUrl = requestUrl.replace('{id}', encodeURIComponent(id.toString()));

    // Create HTTP transport objects
    let httpRequest = new WebResource();
    httpRequest.method = 'DELETE';
    httpRequest.url = requestUrl;
    httpRequest.headers = {};
    // Set Headers
    httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
    if(options && options.customHeaders) {
      for(let headerName in options.customHeaders) {
        if (options.customHeaders.hasOwnProperty(headerName)) {
          httpRequest.headers[headerName] = options.customHeaders[headerName];
        }
      }
    }
    // Send Request
    let operationRes: msRest.HttpOperationResponse;
    try {
      operationRes = await client.pipeline(httpRequest);
      let response = operationRes.response;
      let statusCode = response.status;
      if (statusCode !== 204 && statusCode !== 403 && statusCode !== 404) {
        let error = new msRest.RestError(operationRes.bodyAsText as string);
        error.statusCode = response.status;
        error.request = msRest.stripRequest(httpRequest);
        error.response = msRest.stripResponse(response);
        let parsedErrorResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedErrorResponse) {
            let internalError = null;
            if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
            error.code = internalError ? internalError.code : parsedErrorResponse.code;
            error.message = internalError ? internalError.message : parsedErrorResponse.message;
          }
        } catch (defaultError) {
          error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                           `- "${operationRes.bodyAsText}" for the default response.`;
          return Promise.reject(error);
        }
        return Promise.reject(error);
      }
      // Deserialize Response
      if (statusCode === 204) {
        let parsedResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedResponse !== null && parsedResponse !== undefined) {
            let resultMapper = {
              required: false,
              serializedName: 'parsedResponse',
              type: {
                name: 'Object'
              }
            };
            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
          }
        } catch (error) {
          let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
          deserializationError.request = msRest.stripRequest(httpRequest);
          deserializationError.response = msRest.stripResponse(response);
          return Promise.reject(deserializationError);
        }
      }

    } catch(err) {
      return Promise.reject(err);
    }

    return Promise.resolve(operationRes);
  }
  // methods on the client.

  /**
   * @summary Gets an attachment's file content.
   *
   * @param {number} drawer The drawer identifier.
   *
   * @param {number} id The attachment identifier.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  async getAttachmentFileContentWithHttpOperationResponse(drawer: number, id: number, options?: msRest.RequestOptionsBase): Promise<msRest.HttpOperationResponse> {
    let client = this;
    // Validate
    try {
      if (drawer === null || drawer === undefined || typeof drawer !== 'number') {
        throw new Error('drawer cannot be null or undefined and it must be of type number.');
      }
      if (id === null || id === undefined || typeof id !== 'number') {
        throw new Error('id cannot be null or undefined and it must be of type number.');
      }
    } catch (error) {
      return Promise.reject(error);
    }

    // Construct URL
    let baseUrl = this.baseUri;
    let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'v1/content/attachments/{drawer}/{id}/file';
    requestUrl = requestUrl.replace('{drawer}', encodeURIComponent(drawer.toString()));
    requestUrl = requestUrl.replace('{id}', encodeURIComponent(id.toString()));

    // Create HTTP transport objects
    let httpRequest = new WebResource();
    httpRequest.method = 'GET';
    httpRequest.url = requestUrl;
    httpRequest.headers = {};
    // Set Headers
    httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
    if(options && options.customHeaders) {
      for(let headerName in options.customHeaders) {
        if (options.customHeaders.hasOwnProperty(headerName)) {
          httpRequest.headers[headerName] = options.customHeaders[headerName];
        }
      }
    }
    // Send Request
    let operationRes: msRest.HttpOperationResponse;
    try {
      operationRes = await client.pipeline(httpRequest);
      let response = operationRes.response;
      let statusCode = response.status;
      if (statusCode !== 200 && statusCode !== 403 && statusCode !== 404) {
        let error = new msRest.RestError(operationRes.bodyAsText as string);
        error.statusCode = response.status;
        error.request = msRest.stripRequest(httpRequest);
        error.response = msRest.stripResponse(response);
        let parsedErrorResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedErrorResponse) {
            let internalError = null;
            if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
            error.code = internalError ? internalError.code : parsedErrorResponse.code;
            error.message = internalError ? internalError.message : parsedErrorResponse.message;
          }
        } catch (defaultError) {
          error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                           `- "${operationRes.bodyAsText}" for the default response.`;
          return Promise.reject(error);
        }
        return Promise.reject(error);
      }
      // Deserialize Response
      if (statusCode === 200) {
        let parsedResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedResponse !== null && parsedResponse !== undefined) {
            let resultMapper = {
              required: false,
              serializedName: 'parsedResponse',
              type: {
                name: 'Object'
              }
            };
            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
          }
        } catch (error) {
          let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
          deserializationError.request = msRest.stripRequest(httpRequest);
          deserializationError.response = msRest.stripResponse(response);
          return Promise.reject(deserializationError);
        }
      }

    } catch(err) {
      return Promise.reject(err);
    }

    return Promise.resolve(operationRes);
  }
  // methods on the client.

  /**
   * @summary Inserts a new file attachment.
   *
   * @param {number} drawer The drawer identifier.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  async createAttachmentWithHttpOperationResponse(drawer: number, options?: msRest.RequestOptionsBase): Promise<msRest.HttpOperationResponse> {
    let client = this;
    // Validate
    try {
      if (drawer === null || drawer === undefined || typeof drawer !== 'number') {
        throw new Error('drawer cannot be null or undefined and it must be of type number.');
      }
    } catch (error) {
      return Promise.reject(error);
    }

    // Construct URL
    let baseUrl = this.baseUri;
    let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'v1/content/attachments/{drawer}';
    requestUrl = requestUrl.replace('{drawer}', encodeURIComponent(drawer.toString()));

    // Create HTTP transport objects
    let httpRequest = new WebResource();
    httpRequest.method = 'POST';
    httpRequest.url = requestUrl;
    httpRequest.headers = {};
    // Set Headers
    httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
    if(options && options.customHeaders) {
      for(let headerName in options.customHeaders) {
        if (options.customHeaders.hasOwnProperty(headerName)) {
          httpRequest.headers[headerName] = options.customHeaders[headerName];
        }
      }
    }
    // Send Request
    let operationRes: msRest.HttpOperationResponse;
    try {
      operationRes = await client.pipeline(httpRequest);
      let response = operationRes.response;
      let statusCode = response.status;
      if (statusCode !== 201 && statusCode !== 400 && statusCode !== 403 && statusCode !== 404) {
        let error = new msRest.RestError(operationRes.bodyAsText as string);
        error.statusCode = response.status;
        error.request = msRest.stripRequest(httpRequest);
        error.response = msRest.stripResponse(response);
        let parsedErrorResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedErrorResponse) {
            let internalError = null;
            if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
            error.code = internalError ? internalError.code : parsedErrorResponse.code;
            error.message = internalError ? internalError.message : parsedErrorResponse.message;
          }
        } catch (defaultError) {
          error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                           `- "${operationRes.bodyAsText}" for the default response.`;
          return Promise.reject(error);
        }
        return Promise.reject(error);
      }
      // Deserialize Response
      if (statusCode === 201) {
        let parsedResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedResponse !== null && parsedResponse !== undefined) {
            let resultMapper = Mappers.AttachmentModel;
            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
          }
        } catch (error) {
          let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
          deserializationError.request = msRest.stripRequest(httpRequest);
          deserializationError.response = msRest.stripResponse(response);
          return Promise.reject(deserializationError);
        }
      }

    } catch(err) {
      return Promise.reject(err);
    }

    return Promise.resolve(operationRes);
  }
  // methods on the client.

  /**
   * @summary Archives an attachment
   *
   * @param {number} drawer The drawer identifier.
   *
   * @param {number} id The attachment identifier.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  async archiveAttachmentWithHttpOperationResponse(drawer: number, id: number, options?: msRest.RequestOptionsBase): Promise<msRest.HttpOperationResponse> {
    let client = this;
    // Validate
    try {
      if (drawer === null || drawer === undefined || typeof drawer !== 'number') {
        throw new Error('drawer cannot be null or undefined and it must be of type number.');
      }
      if (id === null || id === undefined || typeof id !== 'number') {
        throw new Error('id cannot be null or undefined and it must be of type number.');
      }
    } catch (error) {
      return Promise.reject(error);
    }

    // Construct URL
    let baseUrl = this.baseUri;
    let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'v1/content/attachments/{drawer}/{id}/archive';
    requestUrl = requestUrl.replace('{drawer}', encodeURIComponent(drawer.toString()));
    requestUrl = requestUrl.replace('{id}', encodeURIComponent(id.toString()));

    // Create HTTP transport objects
    let httpRequest = new WebResource();
    httpRequest.method = 'PUT';
    httpRequest.url = requestUrl;
    httpRequest.headers = {};
    // Set Headers
    httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
    if(options && options.customHeaders) {
      for(let headerName in options.customHeaders) {
        if (options.customHeaders.hasOwnProperty(headerName)) {
          httpRequest.headers[headerName] = options.customHeaders[headerName];
        }
      }
    }
    // Send Request
    let operationRes: msRest.HttpOperationResponse;
    try {
      operationRes = await client.pipeline(httpRequest);
      let response = operationRes.response;
      let statusCode = response.status;
      if (statusCode !== 204 && statusCode !== 400 && statusCode !== 403 && statusCode !== 404) {
        let error = new msRest.RestError(operationRes.bodyAsText as string);
        error.statusCode = response.status;
        error.request = msRest.stripRequest(httpRequest);
        error.response = msRest.stripResponse(response);
        let parsedErrorResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedErrorResponse) {
            let internalError = null;
            if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
            error.code = internalError ? internalError.code : parsedErrorResponse.code;
            error.message = internalError ? internalError.message : parsedErrorResponse.message;
          }
        } catch (defaultError) {
          error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                           `- "${operationRes.bodyAsText}" for the default response.`;
          return Promise.reject(error);
        }
        return Promise.reject(error);
      }
      // Deserialize Response
      if (statusCode === 204) {
        let parsedResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedResponse !== null && parsedResponse !== undefined) {
            let resultMapper = {
              required: false,
              serializedName: 'parsedResponse',
              type: {
                name: 'Object'
              }
            };
            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
          }
        } catch (error) {
          let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
          deserializationError.request = msRest.stripRequest(httpRequest);
          deserializationError.response = msRest.stripResponse(response);
          return Promise.reject(deserializationError);
        }
      }

    } catch(err) {
      return Promise.reject(err);
    }

    return Promise.resolve(operationRes);
  }
  // methods on the client.

  /**
   * @summary Gets the paged list of attachment versions.
   *
   * @param {number} drawer The drawer identifier.
   *
   * @param {number} id The attachment identifier.
   *
   * @param {SoftheonEnterpriseAPIGetAttachmentVersionsByFilterOptionalParams}
   * [options] Optional Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  async getAttachmentVersionsByFilterWithHttpOperationResponse(drawer: number, id: number, options?: Models.SoftheonEnterpriseAPIGetAttachmentVersionsByFilterOptionalParams): Promise<msRest.HttpOperationResponse> {
    let client = this;
    let version = (options && options.version !== undefined) ? options.version : undefined;
    let creatorUserID = (options && options.creatorUserID !== undefined) ? options.creatorUserID : undefined;
    let accessorUserID = (options && options.accessorUserID !== undefined) ? options.accessorUserID : undefined;
    let minAccessTime = (options && options.minAccessTime !== undefined) ? options.minAccessTime : undefined;
    let maxAccessTime = (options && options.maxAccessTime !== undefined) ? options.maxAccessTime : undefined;
    let minCreationTime = (options && options.minCreationTime !== undefined) ? options.minCreationTime : undefined;
    let maxCreationTime = (options && options.maxCreationTime !== undefined) ? options.maxCreationTime : undefined;
    let minModificationTime = (options && options.minModificationTime !== undefined) ? options.minModificationTime : undefined;
    let maxModificationTime = (options && options.maxModificationTime !== undefined) ? options.maxModificationTime : undefined;
    let page = (options && options.page !== undefined) ? options.page : undefined;
    let pageSize = (options && options.pageSize !== undefined) ? options.pageSize : undefined;
    let sortOrder = (options && options.sortOrder !== undefined) ? options.sortOrder : undefined;
    let sortBy = (options && options.sortBy !== undefined) ? options.sortBy : undefined;
    // Validate
    try {
      if (drawer === null || drawer === undefined || typeof drawer !== 'number') {
        throw new Error('drawer cannot be null or undefined and it must be of type number.');
      }
      if (id === null || id === undefined || typeof id !== 'number') {
        throw new Error('id cannot be null or undefined and it must be of type number.');
      }
      if (version !== null && version !== undefined && typeof version !== 'number') {
        throw new Error('version must be of type number.');
      }
      if (version !== null && version !== undefined) {
        if (version > 2147483647)
        {
          throw new Error('"version" should satisfy the constraint - "InclusiveMaximum": 2147483647');
        }
        if (version < 1)
        {
          throw new Error('"version" should satisfy the constraint - "InclusiveMinimum": 1');
        }
      }
      if (creatorUserID !== null && creatorUserID !== undefined && typeof creatorUserID !== 'number') {
        throw new Error('creatorUserID must be of type number.');
      }
      if (creatorUserID !== null && creatorUserID !== undefined) {
        if (creatorUserID > 2147483647)
        {
          throw new Error('"creatorUserID" should satisfy the constraint - "InclusiveMaximum": 2147483647');
        }
        if (creatorUserID < 1)
        {
          throw new Error('"creatorUserID" should satisfy the constraint - "InclusiveMinimum": 1');
        }
      }
      if (accessorUserID !== null && accessorUserID !== undefined && typeof accessorUserID !== 'number') {
        throw new Error('accessorUserID must be of type number.');
      }
      if (accessorUserID !== null && accessorUserID !== undefined) {
        if (accessorUserID > 2147483647)
        {
          throw new Error('"accessorUserID" should satisfy the constraint - "InclusiveMaximum": 2147483647');
        }
        if (accessorUserID < 1)
        {
          throw new Error('"accessorUserID" should satisfy the constraint - "InclusiveMinimum": 1');
        }
      }
      if (minAccessTime && !(minAccessTime instanceof Date ||
          (typeof (minAccessTime as string).valueOf() === 'string' && !isNaN(Date.parse(minAccessTime as string))))) {
            throw new Error('minAccessTime must be of type date.');
          }
      if (maxAccessTime && !(maxAccessTime instanceof Date ||
          (typeof (maxAccessTime as string).valueOf() === 'string' && !isNaN(Date.parse(maxAccessTime as string))))) {
            throw new Error('maxAccessTime must be of type date.');
          }
      if (minCreationTime && !(minCreationTime instanceof Date ||
          (typeof (minCreationTime as string).valueOf() === 'string' && !isNaN(Date.parse(minCreationTime as string))))) {
            throw new Error('minCreationTime must be of type date.');
          }
      if (maxCreationTime && !(maxCreationTime instanceof Date ||
          (typeof (maxCreationTime as string).valueOf() === 'string' && !isNaN(Date.parse(maxCreationTime as string))))) {
            throw new Error('maxCreationTime must be of type date.');
          }
      if (minModificationTime && !(minModificationTime instanceof Date ||
          (typeof (minModificationTime as string).valueOf() === 'string' && !isNaN(Date.parse(minModificationTime as string))))) {
            throw new Error('minModificationTime must be of type date.');
          }
      if (maxModificationTime && !(maxModificationTime instanceof Date ||
          (typeof (maxModificationTime as string).valueOf() === 'string' && !isNaN(Date.parse(maxModificationTime as string))))) {
            throw new Error('maxModificationTime must be of type date.');
          }
      if (page !== null && page !== undefined && typeof page !== 'number') {
        throw new Error('page must be of type number.');
      }
      if (page !== null && page !== undefined) {
        if (page > 2147483647)
        {
          throw new Error('"page" should satisfy the constraint - "InclusiveMaximum": 2147483647');
        }
        if (page < 1)
        {
          throw new Error('"page" should satisfy the constraint - "InclusiveMinimum": 1');
        }
      }
      if (pageSize !== null && pageSize !== undefined && typeof pageSize !== 'number') {
        throw new Error('pageSize must be of type number.');
      }
      if (pageSize !== null && pageSize !== undefined) {
        if (pageSize > 1000)
        {
          throw new Error('"pageSize" should satisfy the constraint - "InclusiveMaximum": 1000');
        }
        if (pageSize < 1)
        {
          throw new Error('"pageSize" should satisfy the constraint - "InclusiveMinimum": 1');
        }
      }
      if (sortOrder !== null && sortOrder !== undefined && typeof sortOrder.valueOf() !== 'string') {
        throw new Error('sortOrder must be of type string.');
      }
      if (sortBy !== null && sortBy !== undefined && typeof sortBy.valueOf() !== 'string') {
        throw new Error('sortBy must be of type string.');
      }
    } catch (error) {
      return Promise.reject(error);
    }

    // Construct URL
    let baseUrl = this.baseUri;
    let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'v1/content/attachments/{drawer}/{id}/versions';
    requestUrl = requestUrl.replace('{drawer}', encodeURIComponent(drawer.toString()));
    requestUrl = requestUrl.replace('{id}', encodeURIComponent(id.toString()));
    let queryParamsArray: Array<any> = [];
    if (version !== null && version !== undefined) {
      queryParamsArray.push('version=' + encodeURIComponent(version.toString()));
    }
    if (creatorUserID !== null && creatorUserID !== undefined) {
      queryParamsArray.push('creatorUserID=' + encodeURIComponent(creatorUserID.toString()));
    }
    if (accessorUserID !== null && accessorUserID !== undefined) {
      queryParamsArray.push('accessorUserID=' + encodeURIComponent(accessorUserID.toString()));
    }
    if (minAccessTime !== null && minAccessTime !== undefined) {
      queryParamsArray.push('minAccessTime=' + encodeURIComponent(msRest.serializeObject(minAccessTime)));
    }
    if (maxAccessTime !== null && maxAccessTime !== undefined) {
      queryParamsArray.push('maxAccessTime=' + encodeURIComponent(msRest.serializeObject(maxAccessTime)));
    }
    if (minCreationTime !== null && minCreationTime !== undefined) {
      queryParamsArray.push('minCreationTime=' + encodeURIComponent(msRest.serializeObject(minCreationTime)));
    }
    if (maxCreationTime !== null && maxCreationTime !== undefined) {
      queryParamsArray.push('maxCreationTime=' + encodeURIComponent(msRest.serializeObject(maxCreationTime)));
    }
    if (minModificationTime !== null && minModificationTime !== undefined) {
      queryParamsArray.push('minModificationTime=' + encodeURIComponent(msRest.serializeObject(minModificationTime)));
    }
    if (maxModificationTime !== null && maxModificationTime !== undefined) {
      queryParamsArray.push('maxModificationTime=' + encodeURIComponent(msRest.serializeObject(maxModificationTime)));
    }
    if (page !== null && page !== undefined) {
      queryParamsArray.push('page=' + encodeURIComponent(page.toString()));
    }
    if (pageSize !== null && pageSize !== undefined) {
      queryParamsArray.push('pageSize=' + encodeURIComponent(pageSize.toString()));
    }
    if (sortOrder !== null && sortOrder !== undefined) {
      queryParamsArray.push('sortOrder=' + encodeURIComponent(sortOrder));
    }
    if (sortBy !== null && sortBy !== undefined) {
      queryParamsArray.push('sortBy=' + encodeURIComponent(sortBy));
    }
    if (queryParamsArray.length > 0) {
      requestUrl += '?' + queryParamsArray.join('&');
    }

    // Create HTTP transport objects
    let httpRequest = new WebResource();
    httpRequest.method = 'GET';
    httpRequest.url = requestUrl;
    httpRequest.headers = {};
    // Set Headers
    httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
    if(options && options.customHeaders) {
      for(let headerName in options.customHeaders) {
        if (options.customHeaders.hasOwnProperty(headerName)) {
          httpRequest.headers[headerName] = options.customHeaders[headerName];
        }
      }
    }
    // Send Request
    let operationRes: msRest.HttpOperationResponse;
    try {
      operationRes = await client.pipeline(httpRequest);
      let response = operationRes.response;
      let statusCode = response.status;
      if (statusCode !== 200 && statusCode !== 404) {
        let error = new msRest.RestError(operationRes.bodyAsText as string);
        error.statusCode = response.status;
        error.request = msRest.stripRequest(httpRequest);
        error.response = msRest.stripResponse(response);
        let parsedErrorResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedErrorResponse) {
            let internalError = null;
            if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
            error.code = internalError ? internalError.code : parsedErrorResponse.code;
            error.message = internalError ? internalError.message : parsedErrorResponse.message;
          }
        } catch (defaultError) {
          error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                           `- "${operationRes.bodyAsText}" for the default response.`;
          return Promise.reject(error);
        }
        return Promise.reject(error);
      }
      // Deserialize Response
      if (statusCode === 200) {
        let parsedResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedResponse !== null && parsedResponse !== undefined) {
            let resultMapper = {
              required: false,
              serializedName: 'parsedResponse',
              type: {
                name: 'Sequence',
                element: {
                    required: false,
                    serializedName: 'AttachmentVersionModelElementType',
                    type: {
                      name: 'Composite',
                      className: 'AttachmentVersionModel'
                    }
                }
              }
            };
            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
          }
        } catch (error) {
          let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
          deserializationError.request = msRest.stripRequest(httpRequest);
          deserializationError.response = msRest.stripResponse(response);
          return Promise.reject(deserializationError);
        }
      }

    } catch(err) {
      return Promise.reject(err);
    }

    return Promise.resolve(operationRes);
  }
  // methods on the client.

  /**
   * @summary Gets a file for a specified attachment version.
   *
   * @param {number} drawer The drawer identifier.
   *
   * @param {number} id The attachment identifier.
   *
   * @param {number} versionID The version identifier.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  async getAttachmentVersionFileContentWithHttpOperationResponse(drawer: number, id: number, versionID: number, options?: msRest.RequestOptionsBase): Promise<msRest.HttpOperationResponse> {
    let client = this;
    // Validate
    try {
      if (drawer === null || drawer === undefined || typeof drawer !== 'number') {
        throw new Error('drawer cannot be null or undefined and it must be of type number.');
      }
      if (id === null || id === undefined || typeof id !== 'number') {
        throw new Error('id cannot be null or undefined and it must be of type number.');
      }
      if (versionID === null || versionID === undefined || typeof versionID !== 'number') {
        throw new Error('versionID cannot be null or undefined and it must be of type number.');
      }
    } catch (error) {
      return Promise.reject(error);
    }

    // Construct URL
    let baseUrl = this.baseUri;
    let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'v1/content/attachments/{drawer}/{id}/versions/{versionID}';
    requestUrl = requestUrl.replace('{drawer}', encodeURIComponent(drawer.toString()));
    requestUrl = requestUrl.replace('{id}', encodeURIComponent(id.toString()));
    requestUrl = requestUrl.replace('{versionID}', encodeURIComponent(versionID.toString()));

    // Create HTTP transport objects
    let httpRequest = new WebResource();
    httpRequest.method = 'GET';
    httpRequest.url = requestUrl;
    httpRequest.headers = {};
    // Set Headers
    httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
    if(options && options.customHeaders) {
      for(let headerName in options.customHeaders) {
        if (options.customHeaders.hasOwnProperty(headerName)) {
          httpRequest.headers[headerName] = options.customHeaders[headerName];
        }
      }
    }
    // Send Request
    let operationRes: msRest.HttpOperationResponse;
    try {
      operationRes = await client.pipeline(httpRequest);
      let response = operationRes.response;
      let statusCode = response.status;
      if (statusCode !== 200 && statusCode !== 403 && statusCode !== 404) {
        let error = new msRest.RestError(operationRes.bodyAsText as string);
        error.statusCode = response.status;
        error.request = msRest.stripRequest(httpRequest);
        error.response = msRest.stripResponse(response);
        let parsedErrorResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedErrorResponse) {
            let internalError = null;
            if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
            error.code = internalError ? internalError.code : parsedErrorResponse.code;
            error.message = internalError ? internalError.message : parsedErrorResponse.message;
          }
        } catch (defaultError) {
          error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                           `- "${operationRes.bodyAsText}" for the default response.`;
          return Promise.reject(error);
        }
        return Promise.reject(error);
      }
      // Deserialize Response
      if (statusCode === 200) {
        let parsedResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedResponse !== null && parsedResponse !== undefined) {
            let resultMapper = {
              required: false,
              serializedName: 'parsedResponse',
              type: {
                name: 'Object'
              }
            };
            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
          }
        } catch (error) {
          let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
          deserializationError.request = msRest.stripRequest(httpRequest);
          deserializationError.response = msRest.stripResponse(response);
          return Promise.reject(deserializationError);
        }
      }

    } catch(err) {
      return Promise.reject(err);
    }

    return Promise.resolve(operationRes);
  }
  // methods on the client.

  /**
   * @summary Checks out the attachment file.
   *
   * @param {number} drawer The drawer identifier.
   *
   * @param {number} id The attachment identifier.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  async checkOutAttachmentWithHttpOperationResponse(drawer: number, id: number, options?: msRest.RequestOptionsBase): Promise<msRest.HttpOperationResponse> {
    let client = this;
    // Validate
    try {
      if (drawer === null || drawer === undefined || typeof drawer !== 'number') {
        throw new Error('drawer cannot be null or undefined and it must be of type number.');
      }
      if (id === null || id === undefined || typeof id !== 'number') {
        throw new Error('id cannot be null or undefined and it must be of type number.');
      }
    } catch (error) {
      return Promise.reject(error);
    }

    // Construct URL
    let baseUrl = this.baseUri;
    let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'v1/content/attachments/{drawer}/{id}/checkout';
    requestUrl = requestUrl.replace('{drawer}', encodeURIComponent(drawer.toString()));
    requestUrl = requestUrl.replace('{id}', encodeURIComponent(id.toString()));

    // Create HTTP transport objects
    let httpRequest = new WebResource();
    httpRequest.method = 'PUT';
    httpRequest.url = requestUrl;
    httpRequest.headers = {};
    // Set Headers
    httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
    if(options && options.customHeaders) {
      for(let headerName in options.customHeaders) {
        if (options.customHeaders.hasOwnProperty(headerName)) {
          httpRequest.headers[headerName] = options.customHeaders[headerName];
        }
      }
    }
    // Send Request
    let operationRes: msRest.HttpOperationResponse;
    try {
      operationRes = await client.pipeline(httpRequest);
      let response = operationRes.response;
      let statusCode = response.status;
      if (statusCode !== 204 && statusCode !== 400 && statusCode !== 403 && statusCode !== 404) {
        let error = new msRest.RestError(operationRes.bodyAsText as string);
        error.statusCode = response.status;
        error.request = msRest.stripRequest(httpRequest);
        error.response = msRest.stripResponse(response);
        let parsedErrorResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedErrorResponse) {
            let internalError = null;
            if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
            error.code = internalError ? internalError.code : parsedErrorResponse.code;
            error.message = internalError ? internalError.message : parsedErrorResponse.message;
          }
        } catch (defaultError) {
          error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                           `- "${operationRes.bodyAsText}" for the default response.`;
          return Promise.reject(error);
        }
        return Promise.reject(error);
      }
      // Deserialize Response
      if (statusCode === 204) {
        let parsedResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedResponse !== null && parsedResponse !== undefined) {
            let resultMapper = {
              required: false,
              serializedName: 'parsedResponse',
              type: {
                name: 'Object'
              }
            };
            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
          }
        } catch (error) {
          let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
          deserializationError.request = msRest.stripRequest(httpRequest);
          deserializationError.response = msRest.stripResponse(response);
          return Promise.reject(deserializationError);
        }
      }

    } catch(err) {
      return Promise.reject(err);
    }

    return Promise.resolve(operationRes);
  }
  // methods on the client.

  /**
   * @summary Undoes the attachment check out of the attachment file.
   *
   * @param {number} drawer The drawer identifier.
   *
   * @param {number} id The attachment identifier.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  async undoCheckOutAttachmentWithHttpOperationResponse(drawer: number, id: number, options?: msRest.RequestOptionsBase): Promise<msRest.HttpOperationResponse> {
    let client = this;
    // Validate
    try {
      if (drawer === null || drawer === undefined || typeof drawer !== 'number') {
        throw new Error('drawer cannot be null or undefined and it must be of type number.');
      }
      if (id === null || id === undefined || typeof id !== 'number') {
        throw new Error('id cannot be null or undefined and it must be of type number.');
      }
    } catch (error) {
      return Promise.reject(error);
    }

    // Construct URL
    let baseUrl = this.baseUri;
    let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'v1/content/attachments/{drawer}/{id}/checkout';
    requestUrl = requestUrl.replace('{drawer}', encodeURIComponent(drawer.toString()));
    requestUrl = requestUrl.replace('{id}', encodeURIComponent(id.toString()));

    // Create HTTP transport objects
    let httpRequest = new WebResource();
    httpRequest.method = 'DELETE';
    httpRequest.url = requestUrl;
    httpRequest.headers = {};
    // Set Headers
    httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
    if(options && options.customHeaders) {
      for(let headerName in options.customHeaders) {
        if (options.customHeaders.hasOwnProperty(headerName)) {
          httpRequest.headers[headerName] = options.customHeaders[headerName];
        }
      }
    }
    // Send Request
    let operationRes: msRest.HttpOperationResponse;
    try {
      operationRes = await client.pipeline(httpRequest);
      let response = operationRes.response;
      let statusCode = response.status;
      if (statusCode !== 204 && statusCode !== 400 && statusCode !== 403 && statusCode !== 404) {
        let error = new msRest.RestError(operationRes.bodyAsText as string);
        error.statusCode = response.status;
        error.request = msRest.stripRequest(httpRequest);
        error.response = msRest.stripResponse(response);
        let parsedErrorResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedErrorResponse) {
            let internalError = null;
            if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
            error.code = internalError ? internalError.code : parsedErrorResponse.code;
            error.message = internalError ? internalError.message : parsedErrorResponse.message;
          }
        } catch (defaultError) {
          error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                           `- "${operationRes.bodyAsText}" for the default response.`;
          return Promise.reject(error);
        }
        return Promise.reject(error);
      }
      // Deserialize Response
      if (statusCode === 204) {
        let parsedResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedResponse !== null && parsedResponse !== undefined) {
            let resultMapper = {
              required: false,
              serializedName: 'parsedResponse',
              type: {
                name: 'Object'
              }
            };
            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
          }
        } catch (error) {
          let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
          deserializationError.request = msRest.stripRequest(httpRequest);
          deserializationError.response = msRest.stripResponse(response);
          return Promise.reject(deserializationError);
        }
      }

    } catch(err) {
      return Promise.reject(err);
    }

    return Promise.resolve(operationRes);
  }
  // methods on the client.

  /**
   * @summary Checks in the new version of attachment file.
   *
   * @param {number} drawer The drawer identifier.
   *
   * @param {number} id The attachment identifier.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  async checkInAttachmentWithHttpOperationResponse(drawer: number, id: number, options?: msRest.RequestOptionsBase): Promise<msRest.HttpOperationResponse> {
    let client = this;
    // Validate
    try {
      if (drawer === null || drawer === undefined || typeof drawer !== 'number') {
        throw new Error('drawer cannot be null or undefined and it must be of type number.');
      }
      if (id === null || id === undefined || typeof id !== 'number') {
        throw new Error('id cannot be null or undefined and it must be of type number.');
      }
    } catch (error) {
      return Promise.reject(error);
    }

    // Construct URL
    let baseUrl = this.baseUri;
    let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'v1/content/attachments/{drawer}/{id}/checkin';
    requestUrl = requestUrl.replace('{drawer}', encodeURIComponent(drawer.toString()));
    requestUrl = requestUrl.replace('{id}', encodeURIComponent(id.toString()));

    // Create HTTP transport objects
    let httpRequest = new WebResource();
    httpRequest.method = 'PUT';
    httpRequest.url = requestUrl;
    httpRequest.headers = {};
    // Set Headers
    httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
    if(options && options.customHeaders) {
      for(let headerName in options.customHeaders) {
        if (options.customHeaders.hasOwnProperty(headerName)) {
          httpRequest.headers[headerName] = options.customHeaders[headerName];
        }
      }
    }
    // Send Request
    let operationRes: msRest.HttpOperationResponse;
    try {
      operationRes = await client.pipeline(httpRequest);
      let response = operationRes.response;
      let statusCode = response.status;
      if (statusCode !== 204 && statusCode !== 400 && statusCode !== 403 && statusCode !== 404) {
        let error = new msRest.RestError(operationRes.bodyAsText as string);
        error.statusCode = response.status;
        error.request = msRest.stripRequest(httpRequest);
        error.response = msRest.stripResponse(response);
        let parsedErrorResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedErrorResponse) {
            let internalError = null;
            if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
            error.code = internalError ? internalError.code : parsedErrorResponse.code;
            error.message = internalError ? internalError.message : parsedErrorResponse.message;
          }
        } catch (defaultError) {
          error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                           `- "${operationRes.bodyAsText}" for the default response.`;
          return Promise.reject(error);
        }
        return Promise.reject(error);
      }
      // Deserialize Response
      if (statusCode === 204) {
        let parsedResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedResponse !== null && parsedResponse !== undefined) {
            let resultMapper = {
              required: false,
              serializedName: 'parsedResponse',
              type: {
                name: 'Object'
              }
            };
            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
          }
        } catch (error) {
          let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
          deserializationError.request = msRest.stripRequest(httpRequest);
          deserializationError.response = msRest.stripResponse(response);
          return Promise.reject(deserializationError);
        }
      }

    } catch(err) {
      return Promise.reject(err);
    }

    return Promise.resolve(operationRes);
  }
  // methods on the client.

  /**
   * @summary Rolls back to a specified version the attachment file.
   *
   * @param {number} drawer The drawer identifier.
   *
   * @param {number} id The attachment identifier.
   *
   * @param {number} versionID The version identifier.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  async rollbackAttachmentVersionWithHttpOperationResponse(drawer: number, id: number, versionID: number, options?: msRest.RequestOptionsBase): Promise<msRest.HttpOperationResponse> {
    let client = this;
    // Validate
    try {
      if (drawer === null || drawer === undefined || typeof drawer !== 'number') {
        throw new Error('drawer cannot be null or undefined and it must be of type number.');
      }
      if (id === null || id === undefined || typeof id !== 'number') {
        throw new Error('id cannot be null or undefined and it must be of type number.');
      }
      if (versionID === null || versionID === undefined || typeof versionID !== 'number') {
        throw new Error('versionID cannot be null or undefined and it must be of type number.');
      }
    } catch (error) {
      return Promise.reject(error);
    }

    // Construct URL
    let baseUrl = this.baseUri;
    let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'v1/content/attachments/{drawer}/{id}/rollback/{versionID}';
    requestUrl = requestUrl.replace('{drawer}', encodeURIComponent(drawer.toString()));
    requestUrl = requestUrl.replace('{id}', encodeURIComponent(id.toString()));
    requestUrl = requestUrl.replace('{versionID}', encodeURIComponent(versionID.toString()));

    // Create HTTP transport objects
    let httpRequest = new WebResource();
    httpRequest.method = 'PUT';
    httpRequest.url = requestUrl;
    httpRequest.headers = {};
    // Set Headers
    httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
    if(options && options.customHeaders) {
      for(let headerName in options.customHeaders) {
        if (options.customHeaders.hasOwnProperty(headerName)) {
          httpRequest.headers[headerName] = options.customHeaders[headerName];
        }
      }
    }
    // Send Request
    let operationRes: msRest.HttpOperationResponse;
    try {
      operationRes = await client.pipeline(httpRequest);
      let response = operationRes.response;
      let statusCode = response.status;
      if (statusCode !== 204 && statusCode !== 400 && statusCode !== 403 && statusCode !== 404) {
        let error = new msRest.RestError(operationRes.bodyAsText as string);
        error.statusCode = response.status;
        error.request = msRest.stripRequest(httpRequest);
        error.response = msRest.stripResponse(response);
        let parsedErrorResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedErrorResponse) {
            let internalError = null;
            if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
            error.code = internalError ? internalError.code : parsedErrorResponse.code;
            error.message = internalError ? internalError.message : parsedErrorResponse.message;
          }
        } catch (defaultError) {
          error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                           `- "${operationRes.bodyAsText}" for the default response.`;
          return Promise.reject(error);
        }
        return Promise.reject(error);
      }
      // Deserialize Response
      if (statusCode === 204) {
        let parsedResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedResponse !== null && parsedResponse !== undefined) {
            let resultMapper = {
              required: false,
              serializedName: 'parsedResponse',
              type: {
                name: 'Object'
              }
            };
            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
          }
        } catch (error) {
          let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
          deserializationError.request = msRest.stripRequest(httpRequest);
          deserializationError.response = msRest.stripResponse(response);
          return Promise.reject(deserializationError);
        }
      }

    } catch(err) {
      return Promise.reject(err);
    }

    return Promise.resolve(operationRes);
  }
  // methods on the client.

  /**
   * @summary Gets a list of all available drawers.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  async getAllDrawersWithHttpOperationResponse(options?: msRest.RequestOptionsBase): Promise<msRest.HttpOperationResponse> {
    let client = this;

    // Construct URL
    let baseUrl = this.baseUri;
    let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'v1/directory/drawers';

    // Create HTTP transport objects
    let httpRequest = new WebResource();
    httpRequest.method = 'GET';
    httpRequest.url = requestUrl;
    httpRequest.headers = {};
    // Set Headers
    httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
    if(options && options.customHeaders) {
      for(let headerName in options.customHeaders) {
        if (options.customHeaders.hasOwnProperty(headerName)) {
          httpRequest.headers[headerName] = options.customHeaders[headerName];
        }
      }
    }
    // Send Request
    let operationRes: msRest.HttpOperationResponse;
    try {
      operationRes = await client.pipeline(httpRequest);
      let response = operationRes.response;
      let statusCode = response.status;
      if (statusCode !== 200) {
        let error = new msRest.RestError(operationRes.bodyAsText as string);
        error.statusCode = response.status;
        error.request = msRest.stripRequest(httpRequest);
        error.response = msRest.stripResponse(response);
        let parsedErrorResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedErrorResponse) {
            let internalError = null;
            if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
            error.code = internalError ? internalError.code : parsedErrorResponse.code;
            error.message = internalError ? internalError.message : parsedErrorResponse.message;
          }
        } catch (defaultError) {
          error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                           `- "${operationRes.bodyAsText}" for the default response.`;
          return Promise.reject(error);
        }
        return Promise.reject(error);
      }
      // Deserialize Response
      if (statusCode === 200) {
        let parsedResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedResponse !== null && parsedResponse !== undefined) {
            let resultMapper = {
              required: false,
              serializedName: 'parsedResponse',
              type: {
                name: 'Sequence',
                element: {
                    required: false,
                    serializedName: 'DrawerModelElementType',
                    type: {
                      name: 'Composite',
                      className: 'DrawerModel'
                    }
                }
              }
            };
            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
          }
        } catch (error) {
          let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
          deserializationError.request = msRest.stripRequest(httpRequest);
          deserializationError.response = msRest.stripResponse(response);
          return Promise.reject(deserializationError);
        }
      }

    } catch(err) {
      return Promise.reject(err);
    }

    return Promise.resolve(operationRes);
  }
  // methods on the client.

  /**
   * @summary Gets a single drawer by its unique identifier.
   *
   * @param {number} id The drawer identifier.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  async getDrawerByIdWithHttpOperationResponse(id: number, options?: msRest.RequestOptionsBase): Promise<msRest.HttpOperationResponse> {
    let client = this;
    // Validate
    try {
      if (id === null || id === undefined || typeof id !== 'number') {
        throw new Error('id cannot be null or undefined and it must be of type number.');
      }
    } catch (error) {
      return Promise.reject(error);
    }

    // Construct URL
    let baseUrl = this.baseUri;
    let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'v1/directory/drawers/{id}';
    requestUrl = requestUrl.replace('{id}', encodeURIComponent(id.toString()));

    // Create HTTP transport objects
    let httpRequest = new WebResource();
    httpRequest.method = 'GET';
    httpRequest.url = requestUrl;
    httpRequest.headers = {};
    // Set Headers
    httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
    if(options && options.customHeaders) {
      for(let headerName in options.customHeaders) {
        if (options.customHeaders.hasOwnProperty(headerName)) {
          httpRequest.headers[headerName] = options.customHeaders[headerName];
        }
      }
    }
    // Send Request
    let operationRes: msRest.HttpOperationResponse;
    try {
      operationRes = await client.pipeline(httpRequest);
      let response = operationRes.response;
      let statusCode = response.status;
      if (statusCode !== 200 && statusCode !== 404) {
        let error = new msRest.RestError(operationRes.bodyAsText as string);
        error.statusCode = response.status;
        error.request = msRest.stripRequest(httpRequest);
        error.response = msRest.stripResponse(response);
        let parsedErrorResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedErrorResponse) {
            let internalError = null;
            if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
            error.code = internalError ? internalError.code : parsedErrorResponse.code;
            error.message = internalError ? internalError.message : parsedErrorResponse.message;
          }
        } catch (defaultError) {
          error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                           `- "${operationRes.bodyAsText}" for the default response.`;
          return Promise.reject(error);
        }
        return Promise.reject(error);
      }
      // Deserialize Response
      if (statusCode === 200) {
        let parsedResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedResponse !== null && parsedResponse !== undefined) {
            let resultMapper = Mappers.DrawerModel;
            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
          }
        } catch (error) {
          let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
          deserializationError.request = msRest.stripRequest(httpRequest);
          deserializationError.response = msRest.stripResponse(response);
          return Promise.reject(deserializationError);
        }
      }

    } catch(err) {
      return Promise.reject(err);
    }

    return Promise.resolve(operationRes);
  }
  // methods on the client.

  /**
   * @summary Updates a specified drawer.
   *
   * @param {number} id The drawer identifier.
   *
   * @param {DrawerBase} model The model.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  async updateDrawerWithHttpOperationResponse(id: number, model: Models.DrawerBase, options?: msRest.RequestOptionsBase): Promise<msRest.HttpOperationResponse> {
    let client = this;
    // Validate
    try {
      if (id === null || id === undefined || typeof id !== 'number') {
        throw new Error('id cannot be null or undefined and it must be of type number.');
      }
      if (model === null || model === undefined) {
        throw new Error('model cannot be null or undefined.');
      }
    } catch (error) {
      return Promise.reject(error);
    }

    // Construct URL
    let baseUrl = this.baseUri;
    let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'v1/directory/drawers/{id}';
    requestUrl = requestUrl.replace('{id}', encodeURIComponent(id.toString()));

    // Create HTTP transport objects
    let httpRequest = new WebResource();
    httpRequest.method = 'PUT';
    httpRequest.url = requestUrl;
    httpRequest.headers = {};
    // Set Headers
    httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
    if(options && options.customHeaders) {
      for(let headerName in options.customHeaders) {
        if (options.customHeaders.hasOwnProperty(headerName)) {
          httpRequest.headers[headerName] = options.customHeaders[headerName];
        }
      }
    }
    // Serialize Request
    let requestContent = null;
    let requestModel = null;
    try {
      if (model !== null && model !== undefined) {
        let requestModelMapper = Mappers.DrawerBase;
        requestModel = client.serializer.serialize(requestModelMapper, model, 'model');
        requestContent = JSON.stringify(requestModel);
      }
    } catch (error) {
      let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
          `payload - ${JSON.stringify(model, null, 2)}.`);
      return Promise.reject(serializationError);
    }
    httpRequest.body = requestContent;
    // Send Request
    let operationRes: msRest.HttpOperationResponse;
    try {
      operationRes = await client.pipeline(httpRequest);
      let response = operationRes.response;
      let statusCode = response.status;
      if (statusCode !== 204 && statusCode !== 403 && statusCode !== 404) {
        let error = new msRest.RestError(operationRes.bodyAsText as string);
        error.statusCode = response.status;
        error.request = msRest.stripRequest(httpRequest);
        error.response = msRest.stripResponse(response);
        let parsedErrorResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedErrorResponse) {
            let internalError = null;
            if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
            error.code = internalError ? internalError.code : parsedErrorResponse.code;
            error.message = internalError ? internalError.message : parsedErrorResponse.message;
          }
        } catch (defaultError) {
          error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                           `- "${operationRes.bodyAsText}" for the default response.`;
          return Promise.reject(error);
        }
        return Promise.reject(error);
      }
      // Deserialize Response
      if (statusCode === 204) {
        let parsedResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedResponse !== null && parsedResponse !== undefined) {
            let resultMapper = {
              required: false,
              serializedName: 'parsedResponse',
              type: {
                name: 'Object'
              }
            };
            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
          }
        } catch (error) {
          let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
          deserializationError.request = msRest.stripRequest(httpRequest);
          deserializationError.response = msRest.stripResponse(response);
          return Promise.reject(deserializationError);
        }
      }

    } catch(err) {
      return Promise.reject(err);
    }

    return Promise.resolve(operationRes);
  }
  // methods on the client.

  /**
   * @summary Gets a single drawer by its name.
   *
   * @param {string} name The drawer name.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  async getDrawerByNameWithHttpOperationResponse(name: string, options?: msRest.RequestOptionsBase): Promise<msRest.HttpOperationResponse> {
    let client = this;
    // Validate
    try {
      if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
        throw new Error('name cannot be null or undefined and it must be of type string.');
      }
    } catch (error) {
      return Promise.reject(error);
    }

    // Construct URL
    let baseUrl = this.baseUri;
    let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'v1/directory/drawers/{name}';
    requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));

    // Create HTTP transport objects
    let httpRequest = new WebResource();
    httpRequest.method = 'GET';
    httpRequest.url = requestUrl;
    httpRequest.headers = {};
    // Set Headers
    httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
    if(options && options.customHeaders) {
      for(let headerName in options.customHeaders) {
        if (options.customHeaders.hasOwnProperty(headerName)) {
          httpRequest.headers[headerName] = options.customHeaders[headerName];
        }
      }
    }
    // Send Request
    let operationRes: msRest.HttpOperationResponse;
    try {
      operationRes = await client.pipeline(httpRequest);
      let response = operationRes.response;
      let statusCode = response.status;
      if (statusCode !== 200 && statusCode !== 404) {
        let error = new msRest.RestError(operationRes.bodyAsText as string);
        error.statusCode = response.status;
        error.request = msRest.stripRequest(httpRequest);
        error.response = msRest.stripResponse(response);
        let parsedErrorResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedErrorResponse) {
            let internalError = null;
            if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
            error.code = internalError ? internalError.code : parsedErrorResponse.code;
            error.message = internalError ? internalError.message : parsedErrorResponse.message;
          }
        } catch (defaultError) {
          error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                           `- "${operationRes.bodyAsText}" for the default response.`;
          return Promise.reject(error);
        }
        return Promise.reject(error);
      }
      // Deserialize Response
      if (statusCode === 200) {
        let parsedResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedResponse !== null && parsedResponse !== undefined) {
            let resultMapper = Mappers.DrawerModel;
            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
          }
        } catch (error) {
          let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
          deserializationError.request = msRest.stripRequest(httpRequest);
          deserializationError.response = msRest.stripResponse(response);
          return Promise.reject(deserializationError);
        }
      }

    } catch(err) {
      return Promise.reject(err);
    }

    return Promise.resolve(operationRes);
  }
  // methods on the client.

  /**
   * @summary Gets a paged list of entity summaries.
   *
   * @param {number} drawerID Gets or sets the drawer identifier.
   *
   * @param {SoftheonEnterpriseAPIGetEntitiesByFilterOptionalParams} [options]
   * Optional Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  async getEntitiesByFilterWithHttpOperationResponse(drawerID: number, options?: Models.SoftheonEnterpriseAPIGetEntitiesByFilterOptionalParams): Promise<msRest.HttpOperationResponse> {
    let client = this;
    let acl = (options && options.acl !== undefined) ? options.acl : undefined;
    let type = (options && options.type !== undefined) ? options.type : undefined;
    let name = (options && options.name !== undefined) ? options.name : undefined;
    let state = (options && options.state !== undefined) ? options.state : undefined;
    let referenceCount = (options && options.referenceCount !== undefined) ? options.referenceCount : undefined;
    let attachCount = (options && options.attachCount !== undefined) ? options.attachCount : undefined;
    let noteCount = (options && options.noteCount !== undefined) ? options.noteCount : undefined;
    let ownerUserID = (options && options.ownerUserID !== undefined) ? options.ownerUserID : undefined;
    let ownerGroupID = (options && options.ownerGroupID !== undefined) ? options.ownerGroupID : undefined;
    let creatorUserID = (options && options.creatorUserID !== undefined) ? options.creatorUserID : undefined;
    let creatorGroupID = (options && options.creatorGroupID !== undefined) ? options.creatorGroupID : undefined;
    let modifierUserID = (options && options.modifierUserID !== undefined) ? options.modifierUserID : undefined;
    let modifierGroupID = (options && options.modifierGroupID !== undefined) ? options.modifierGroupID : undefined;
    let minCreationTime = (options && options.minCreationTime !== undefined) ? options.minCreationTime : undefined;
    let maxCreationTime = (options && options.maxCreationTime !== undefined) ? options.maxCreationTime : undefined;
    let minModificationTime = (options && options.minModificationTime !== undefined) ? options.minModificationTime : undefined;
    let maxModificationTime = (options && options.maxModificationTime !== undefined) ? options.maxModificationTime : undefined;
    let metadata = (options && options.metadata !== undefined) ? options.metadata : undefined;
    let page = (options && options.page !== undefined) ? options.page : undefined;
    let pageSize = (options && options.pageSize !== undefined) ? options.pageSize : undefined;
    let sortOrder = (options && options.sortOrder !== undefined) ? options.sortOrder : undefined;
    let sortBy = (options && options.sortBy !== undefined) ? options.sortBy : undefined;
    // Validate
    try {
      if (drawerID === null || drawerID === undefined || typeof drawerID !== 'number') {
        throw new Error('drawerID cannot be null or undefined and it must be of type number.');
      }
      if (drawerID !== null && drawerID !== undefined) {
        if (drawerID > 2147483647)
        {
          throw new Error('"drawerID" should satisfy the constraint - "InclusiveMaximum": 2147483647');
        }
        if (drawerID < 1)
        {
          throw new Error('"drawerID" should satisfy the constraint - "InclusiveMinimum": 1');
        }
      }
      if (acl !== null && acl !== undefined && typeof acl !== 'number') {
        throw new Error('acl must be of type number.');
      }
      if (type !== null && type !== undefined && typeof type !== 'number') {
        throw new Error('type must be of type number.');
      }
      if (type !== null && type !== undefined) {
        if (type > 2147483647)
        {
          throw new Error('"type" should satisfy the constraint - "InclusiveMaximum": 2147483647');
        }
        if (type < 1)
        {
          throw new Error('"type" should satisfy the constraint - "InclusiveMinimum": 1');
        }
      }
      if (name !== null && name !== undefined && typeof name.valueOf() !== 'string') {
        throw new Error('name must be of type string.');
      }
      if (name !== null && name !== undefined) {
        if (name.length > 255)
        {
          throw new Error('"name" should satisfy the constraint - "MaxLength": 255');
        }
        if (name.length < 0)
        {
          throw new Error('"name" should satisfy the constraint - "MinLength": 0');
        }
      }
      if (state !== null && state !== undefined && typeof state.valueOf() !== 'string') {
        throw new Error('state must be of type string.');
      }
      if (referenceCount !== null && referenceCount !== undefined && typeof referenceCount !== 'number') {
        throw new Error('referenceCount must be of type number.');
      }
      if (referenceCount !== null && referenceCount !== undefined) {
        if (referenceCount > 2147483647)
        {
          throw new Error('"referenceCount" should satisfy the constraint - "InclusiveMaximum": 2147483647');
        }
        if (referenceCount < 0)
        {
          throw new Error('"referenceCount" should satisfy the constraint - "InclusiveMinimum": 0');
        }
      }
      if (attachCount !== null && attachCount !== undefined && typeof attachCount !== 'number') {
        throw new Error('attachCount must be of type number.');
      }
      if (attachCount !== null && attachCount !== undefined) {
        if (attachCount > 2147483647)
        {
          throw new Error('"attachCount" should satisfy the constraint - "InclusiveMaximum": 2147483647');
        }
        if (attachCount < 0)
        {
          throw new Error('"attachCount" should satisfy the constraint - "InclusiveMinimum": 0');
        }
      }
      if (noteCount !== null && noteCount !== undefined && typeof noteCount !== 'number') {
        throw new Error('noteCount must be of type number.');
      }
      if (noteCount !== null && noteCount !== undefined) {
        if (noteCount > 2147483647)
        {
          throw new Error('"noteCount" should satisfy the constraint - "InclusiveMaximum": 2147483647');
        }
        if (noteCount < 0)
        {
          throw new Error('"noteCount" should satisfy the constraint - "InclusiveMinimum": 0');
        }
      }
      if (ownerUserID !== null && ownerUserID !== undefined && typeof ownerUserID !== 'number') {
        throw new Error('ownerUserID must be of type number.');
      }
      if (ownerUserID !== null && ownerUserID !== undefined) {
        if (ownerUserID > 2147483647)
        {
          throw new Error('"ownerUserID" should satisfy the constraint - "InclusiveMaximum": 2147483647');
        }
        if (ownerUserID < 1)
        {
          throw new Error('"ownerUserID" should satisfy the constraint - "InclusiveMinimum": 1');
        }
      }
      if (ownerGroupID !== null && ownerGroupID !== undefined && typeof ownerGroupID !== 'number') {
        throw new Error('ownerGroupID must be of type number.');
      }
      if (ownerGroupID !== null && ownerGroupID !== undefined) {
        if (ownerGroupID > 2147483647)
        {
          throw new Error('"ownerGroupID" should satisfy the constraint - "InclusiveMaximum": 2147483647');
        }
        if (ownerGroupID < 0)
        {
          throw new Error('"ownerGroupID" should satisfy the constraint - "InclusiveMinimum": 0');
        }
      }
      if (creatorUserID !== null && creatorUserID !== undefined && typeof creatorUserID !== 'number') {
        throw new Error('creatorUserID must be of type number.');
      }
      if (creatorUserID !== null && creatorUserID !== undefined) {
        if (creatorUserID > 2147483647)
        {
          throw new Error('"creatorUserID" should satisfy the constraint - "InclusiveMaximum": 2147483647');
        }
        if (creatorUserID < 1)
        {
          throw new Error('"creatorUserID" should satisfy the constraint - "InclusiveMinimum": 1');
        }
      }
      if (creatorGroupID !== null && creatorGroupID !== undefined && typeof creatorGroupID !== 'number') {
        throw new Error('creatorGroupID must be of type number.');
      }
      if (creatorGroupID !== null && creatorGroupID !== undefined) {
        if (creatorGroupID > 2147483647)
        {
          throw new Error('"creatorGroupID" should satisfy the constraint - "InclusiveMaximum": 2147483647');
        }
        if (creatorGroupID < 0)
        {
          throw new Error('"creatorGroupID" should satisfy the constraint - "InclusiveMinimum": 0');
        }
      }
      if (modifierUserID !== null && modifierUserID !== undefined && typeof modifierUserID !== 'number') {
        throw new Error('modifierUserID must be of type number.');
      }
      if (modifierUserID !== null && modifierUserID !== undefined) {
        if (modifierUserID > 2147483647)
        {
          throw new Error('"modifierUserID" should satisfy the constraint - "InclusiveMaximum": 2147483647');
        }
        if (modifierUserID < 1)
        {
          throw new Error('"modifierUserID" should satisfy the constraint - "InclusiveMinimum": 1');
        }
      }
      if (modifierGroupID !== null && modifierGroupID !== undefined && typeof modifierGroupID !== 'number') {
        throw new Error('modifierGroupID must be of type number.');
      }
      if (modifierGroupID !== null && modifierGroupID !== undefined) {
        if (modifierGroupID > 2147483647)
        {
          throw new Error('"modifierGroupID" should satisfy the constraint - "InclusiveMaximum": 2147483647');
        }
        if (modifierGroupID < 0)
        {
          throw new Error('"modifierGroupID" should satisfy the constraint - "InclusiveMinimum": 0');
        }
      }
      if (minCreationTime && !(minCreationTime instanceof Date ||
          (typeof (minCreationTime as string).valueOf() === 'string' && !isNaN(Date.parse(minCreationTime as string))))) {
            throw new Error('minCreationTime must be of type date.');
          }
      if (maxCreationTime && !(maxCreationTime instanceof Date ||
          (typeof (maxCreationTime as string).valueOf() === 'string' && !isNaN(Date.parse(maxCreationTime as string))))) {
            throw new Error('maxCreationTime must be of type date.');
          }
      if (minModificationTime && !(minModificationTime instanceof Date ||
          (typeof (minModificationTime as string).valueOf() === 'string' && !isNaN(Date.parse(minModificationTime as string))))) {
            throw new Error('minModificationTime must be of type date.');
          }
      if (maxModificationTime && !(maxModificationTime instanceof Date ||
          (typeof (maxModificationTime as string).valueOf() === 'string' && !isNaN(Date.parse(maxModificationTime as string))))) {
            throw new Error('maxModificationTime must be of type date.');
          }
      if (Array.isArray(metadata)) {
        for (let i = 0; i < metadata.length; i++) {
          if (metadata[i] !== null && metadata[i] !== undefined && typeof metadata[i] !== 'object') {
            throw new Error('metadata[i] must be of type object.');
          }
        }
      }
      if (page !== null && page !== undefined && typeof page !== 'number') {
        throw new Error('page must be of type number.');
      }
      if (page !== null && page !== undefined) {
        if (page > 2147483647)
        {
          throw new Error('"page" should satisfy the constraint - "InclusiveMaximum": 2147483647');
        }
        if (page < 1)
        {
          throw new Error('"page" should satisfy the constraint - "InclusiveMinimum": 1');
        }
      }
      if (pageSize !== null && pageSize !== undefined && typeof pageSize !== 'number') {
        throw new Error('pageSize must be of type number.');
      }
      if (pageSize !== null && pageSize !== undefined) {
        if (pageSize > 1000)
        {
          throw new Error('"pageSize" should satisfy the constraint - "InclusiveMaximum": 1000');
        }
        if (pageSize < 1)
        {
          throw new Error('"pageSize" should satisfy the constraint - "InclusiveMinimum": 1');
        }
      }
      if (sortOrder !== null && sortOrder !== undefined && typeof sortOrder.valueOf() !== 'string') {
        throw new Error('sortOrder must be of type string.');
      }
      if (sortBy !== null && sortBy !== undefined && typeof sortBy.valueOf() !== 'string') {
        throw new Error('sortBy must be of type string.');
      }
    } catch (error) {
      return Promise.reject(error);
    }

    // Construct URL
    let baseUrl = this.baseUri;
    let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'v1/content/entities';
    let queryParamsArray: Array<any> = [];
    queryParamsArray.push('drawerID=' + encodeURIComponent(drawerID.toString()));
    if (acl !== null && acl !== undefined) {
      queryParamsArray.push('acl=' + encodeURIComponent(acl.toString()));
    }
    if (type !== null && type !== undefined) {
      queryParamsArray.push('type=' + encodeURIComponent(type.toString()));
    }
    if (name !== null && name !== undefined) {
      queryParamsArray.push('name=' + encodeURIComponent(name));
    }
    if (state !== null && state !== undefined) {
      queryParamsArray.push('state=' + encodeURIComponent(state));
    }
    if (referenceCount !== null && referenceCount !== undefined) {
      queryParamsArray.push('referenceCount=' + encodeURIComponent(referenceCount.toString()));
    }
    if (attachCount !== null && attachCount !== undefined) {
      queryParamsArray.push('attachCount=' + encodeURIComponent(attachCount.toString()));
    }
    if (noteCount !== null && noteCount !== undefined) {
      queryParamsArray.push('noteCount=' + encodeURIComponent(noteCount.toString()));
    }
    if (ownerUserID !== null && ownerUserID !== undefined) {
      queryParamsArray.push('ownerUserID=' + encodeURIComponent(ownerUserID.toString()));
    }
    if (ownerGroupID !== null && ownerGroupID !== undefined) {
      queryParamsArray.push('ownerGroupID=' + encodeURIComponent(ownerGroupID.toString()));
    }
    if (creatorUserID !== null && creatorUserID !== undefined) {
      queryParamsArray.push('creatorUserID=' + encodeURIComponent(creatorUserID.toString()));
    }
    if (creatorGroupID !== null && creatorGroupID !== undefined) {
      queryParamsArray.push('creatorGroupID=' + encodeURIComponent(creatorGroupID.toString()));
    }
    if (modifierUserID !== null && modifierUserID !== undefined) {
      queryParamsArray.push('modifierUserID=' + encodeURIComponent(modifierUserID.toString()));
    }
    if (modifierGroupID !== null && modifierGroupID !== undefined) {
      queryParamsArray.push('modifierGroupID=' + encodeURIComponent(modifierGroupID.toString()));
    }
    if (minCreationTime !== null && minCreationTime !== undefined) {
      queryParamsArray.push('minCreationTime=' + encodeURIComponent(msRest.serializeObject(minCreationTime)));
    }
    if (maxCreationTime !== null && maxCreationTime !== undefined) {
      queryParamsArray.push('maxCreationTime=' + encodeURIComponent(msRest.serializeObject(maxCreationTime)));
    }
    if (minModificationTime !== null && minModificationTime !== undefined) {
      queryParamsArray.push('minModificationTime=' + encodeURIComponent(msRest.serializeObject(minModificationTime)));
    }
    if (maxModificationTime !== null && maxModificationTime !== undefined) {
      queryParamsArray.push('maxModificationTime=' + encodeURIComponent(msRest.serializeObject(maxModificationTime)));
    }
    if (metadata !== null && metadata !== undefined) {
      if (metadata.length == 0) {
        queryParamsArray.push('metadata=' + encodeURIComponent(''));
      } else {
        for (let item of metadata) {
          item = (item === null || item === undefined) ? '' : item;
          queryParamsArray.push('metadata=' + encodeURIComponent('' + item));
        }
      }
    }
    if (page !== null && page !== undefined) {
      queryParamsArray.push('page=' + encodeURIComponent(page.toString()));
    }
    if (pageSize !== null && pageSize !== undefined) {
      queryParamsArray.push('pageSize=' + encodeURIComponent(pageSize.toString()));
    }
    if (sortOrder !== null && sortOrder !== undefined) {
      queryParamsArray.push('sortOrder=' + encodeURIComponent(sortOrder));
    }
    if (sortBy !== null && sortBy !== undefined) {
      queryParamsArray.push('sortBy=' + encodeURIComponent(sortBy));
    }
    if (queryParamsArray.length > 0) {
      requestUrl += '?' + queryParamsArray.join('&');
    }

    // Create HTTP transport objects
    let httpRequest = new WebResource();
    httpRequest.method = 'GET';
    httpRequest.url = requestUrl;
    httpRequest.headers = {};
    // Set Headers
    httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
    if(options && options.customHeaders) {
      for(let headerName in options.customHeaders) {
        if (options.customHeaders.hasOwnProperty(headerName)) {
          httpRequest.headers[headerName] = options.customHeaders[headerName];
        }
      }
    }
    // Send Request
    let operationRes: msRest.HttpOperationResponse;
    try {
      operationRes = await client.pipeline(httpRequest);
      let response = operationRes.response;
      let statusCode = response.status;
      if (statusCode !== 200) {
        let error = new msRest.RestError(operationRes.bodyAsText as string);
        error.statusCode = response.status;
        error.request = msRest.stripRequest(httpRequest);
        error.response = msRest.stripResponse(response);
        let parsedErrorResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedErrorResponse) {
            let internalError = null;
            if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
            error.code = internalError ? internalError.code : parsedErrorResponse.code;
            error.message = internalError ? internalError.message : parsedErrorResponse.message;
          }
        } catch (defaultError) {
          error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                           `- "${operationRes.bodyAsText}" for the default response.`;
          return Promise.reject(error);
        }
        return Promise.reject(error);
      }
      // Deserialize Response
      if (statusCode === 200) {
        let parsedResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedResponse !== null && parsedResponse !== undefined) {
            let resultMapper = {
              required: false,
              serializedName: 'parsedResponse',
              type: {
                name: 'Sequence',
                element: {
                    required: false,
                    serializedName: 'GetEntityBaseResponseElementType',
                    type: {
                      name: 'Composite',
                      className: 'GetEntityBaseResponse'
                    }
                }
              }
            };
            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
          }
        } catch (error) {
          let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
          deserializationError.request = msRest.stripRequest(httpRequest);
          deserializationError.response = msRest.stripResponse(response);
          return Promise.reject(deserializationError);
        }
      }

    } catch(err) {
      return Promise.reject(err);
    }

    return Promise.resolve(operationRes);
  }
  // methods on the client.

  /**
   * @summary Gets a single entity complete with all profile metadata.
   *
   * @param {number} drawer The drawer identifier.
   *
   * @param {number} id The entity identifier.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  async getEntityByIdWithHttpOperationResponse(drawer: number, id: number, options?: msRest.RequestOptionsBase): Promise<msRest.HttpOperationResponse> {
    let client = this;
    // Validate
    try {
      if (drawer === null || drawer === undefined || typeof drawer !== 'number') {
        throw new Error('drawer cannot be null or undefined and it must be of type number.');
      }
      if (id === null || id === undefined || typeof id !== 'number') {
        throw new Error('id cannot be null or undefined and it must be of type number.');
      }
    } catch (error) {
      return Promise.reject(error);
    }

    // Construct URL
    let baseUrl = this.baseUri;
    let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'v1/content/entities/{drawer}/{id}';
    requestUrl = requestUrl.replace('{drawer}', encodeURIComponent(drawer.toString()));
    requestUrl = requestUrl.replace('{id}', encodeURIComponent(id.toString()));

    // Create HTTP transport objects
    let httpRequest = new WebResource();
    httpRequest.method = 'GET';
    httpRequest.url = requestUrl;
    httpRequest.headers = {};
    // Set Headers
    httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
    if(options && options.customHeaders) {
      for(let headerName in options.customHeaders) {
        if (options.customHeaders.hasOwnProperty(headerName)) {
          httpRequest.headers[headerName] = options.customHeaders[headerName];
        }
      }
    }
    // Send Request
    let operationRes: msRest.HttpOperationResponse;
    try {
      operationRes = await client.pipeline(httpRequest);
      let response = operationRes.response;
      let statusCode = response.status;
      if (statusCode !== 200 && statusCode !== 403 && statusCode !== 404) {
        let error = new msRest.RestError(operationRes.bodyAsText as string);
        error.statusCode = response.status;
        error.request = msRest.stripRequest(httpRequest);
        error.response = msRest.stripResponse(response);
        let parsedErrorResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedErrorResponse) {
            let internalError = null;
            if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
            error.code = internalError ? internalError.code : parsedErrorResponse.code;
            error.message = internalError ? internalError.message : parsedErrorResponse.message;
          }
        } catch (defaultError) {
          error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                           `- "${operationRes.bodyAsText}" for the default response.`;
          return Promise.reject(error);
        }
        return Promise.reject(error);
      }
      // Deserialize Response
      if (statusCode === 200) {
        let parsedResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedResponse !== null && parsedResponse !== undefined) {
            let resultMapper = Mappers.EntityModel;
            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
          }
        } catch (error) {
          let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
          deserializationError.request = msRest.stripRequest(httpRequest);
          deserializationError.response = msRest.stripResponse(response);
          return Promise.reject(deserializationError);
        }
      }

    } catch(err) {
      return Promise.reject(err);
    }

    return Promise.resolve(operationRes);
  }
  // methods on the client.

  /**
   * @summary Updates a specified entity.
   *
   * @param {number} drawer The drawer identifier.
   *
   * @param {number} id The entity identifier.
   *
   * @param {UpdateEntityRequestModel} model The entity model.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  async updateEntityWithHttpOperationResponse(drawer: number, id: number, model: Models.UpdateEntityRequestModel, options?: msRest.RequestOptionsBase): Promise<msRest.HttpOperationResponse> {
    let client = this;
    // Validate
    try {
      if (drawer === null || drawer === undefined || typeof drawer !== 'number') {
        throw new Error('drawer cannot be null or undefined and it must be of type number.');
      }
      if (id === null || id === undefined || typeof id !== 'number') {
        throw new Error('id cannot be null or undefined and it must be of type number.');
      }
      if (model === null || model === undefined) {
        throw new Error('model cannot be null or undefined.');
      }
    } catch (error) {
      return Promise.reject(error);
    }

    // Construct URL
    let baseUrl = this.baseUri;
    let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'v1/content/entities/{drawer}/{id}';
    requestUrl = requestUrl.replace('{drawer}', encodeURIComponent(drawer.toString()));
    requestUrl = requestUrl.replace('{id}', encodeURIComponent(id.toString()));

    // Create HTTP transport objects
    let httpRequest = new WebResource();
    httpRequest.method = 'PUT';
    httpRequest.url = requestUrl;
    httpRequest.headers = {};
    // Set Headers
    httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
    if(options && options.customHeaders) {
      for(let headerName in options.customHeaders) {
        if (options.customHeaders.hasOwnProperty(headerName)) {
          httpRequest.headers[headerName] = options.customHeaders[headerName];
        }
      }
    }
    // Serialize Request
    let requestContent = null;
    let requestModel = null;
    try {
      if (model !== null && model !== undefined) {
        let requestModelMapper = Mappers.UpdateEntityRequestModel;
        requestModel = client.serializer.serialize(requestModelMapper, model, 'model');
        requestContent = JSON.stringify(requestModel);
      }
    } catch (error) {
      let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
          `payload - ${JSON.stringify(model, null, 2)}.`);
      return Promise.reject(serializationError);
    }
    httpRequest.body = requestContent;
    // Send Request
    let operationRes: msRest.HttpOperationResponse;
    try {
      operationRes = await client.pipeline(httpRequest);
      let response = operationRes.response;
      let statusCode = response.status;
      if (statusCode !== 204 && statusCode !== 403 && statusCode !== 404) {
        let error = new msRest.RestError(operationRes.bodyAsText as string);
        error.statusCode = response.status;
        error.request = msRest.stripRequest(httpRequest);
        error.response = msRest.stripResponse(response);
        let parsedErrorResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedErrorResponse) {
            let internalError = null;
            if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
            error.code = internalError ? internalError.code : parsedErrorResponse.code;
            error.message = internalError ? internalError.message : parsedErrorResponse.message;
          }
        } catch (defaultError) {
          error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                           `- "${operationRes.bodyAsText}" for the default response.`;
          return Promise.reject(error);
        }
        return Promise.reject(error);
      }
      // Deserialize Response
      if (statusCode === 204) {
        let parsedResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedResponse !== null && parsedResponse !== undefined) {
            let resultMapper = {
              required: false,
              serializedName: 'parsedResponse',
              type: {
                name: 'Object'
              }
            };
            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
          }
        } catch (error) {
          let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
          deserializationError.request = msRest.stripRequest(httpRequest);
          deserializationError.response = msRest.stripResponse(response);
          return Promise.reject(deserializationError);
        }
      }

    } catch(err) {
      return Promise.reject(err);
    }

    return Promise.resolve(operationRes);
  }
  // methods on the client.

  /**
   * @summary Deletes a specified entity.
   *
   * @param {number} drawer The drawer identifier.
   *
   * @param {number} id The entity identifier.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  async deleteEntityWithHttpOperationResponse(drawer: number, id: number, options?: msRest.RequestOptionsBase): Promise<msRest.HttpOperationResponse> {
    let client = this;
    // Validate
    try {
      if (drawer === null || drawer === undefined || typeof drawer !== 'number') {
        throw new Error('drawer cannot be null or undefined and it must be of type number.');
      }
      if (id === null || id === undefined || typeof id !== 'number') {
        throw new Error('id cannot be null or undefined and it must be of type number.');
      }
    } catch (error) {
      return Promise.reject(error);
    }

    // Construct URL
    let baseUrl = this.baseUri;
    let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'v1/content/entities/{drawer}/{id}';
    requestUrl = requestUrl.replace('{drawer}', encodeURIComponent(drawer.toString()));
    requestUrl = requestUrl.replace('{id}', encodeURIComponent(id.toString()));

    // Create HTTP transport objects
    let httpRequest = new WebResource();
    httpRequest.method = 'DELETE';
    httpRequest.url = requestUrl;
    httpRequest.headers = {};
    // Set Headers
    httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
    if(options && options.customHeaders) {
      for(let headerName in options.customHeaders) {
        if (options.customHeaders.hasOwnProperty(headerName)) {
          httpRequest.headers[headerName] = options.customHeaders[headerName];
        }
      }
    }
    // Send Request
    let operationRes: msRest.HttpOperationResponse;
    try {
      operationRes = await client.pipeline(httpRequest);
      let response = operationRes.response;
      let statusCode = response.status;
      if (statusCode !== 204 && statusCode !== 403 && statusCode !== 404) {
        let error = new msRest.RestError(operationRes.bodyAsText as string);
        error.statusCode = response.status;
        error.request = msRest.stripRequest(httpRequest);
        error.response = msRest.stripResponse(response);
        let parsedErrorResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedErrorResponse) {
            let internalError = null;
            if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
            error.code = internalError ? internalError.code : parsedErrorResponse.code;
            error.message = internalError ? internalError.message : parsedErrorResponse.message;
          }
        } catch (defaultError) {
          error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                           `- "${operationRes.bodyAsText}" for the default response.`;
          return Promise.reject(error);
        }
        return Promise.reject(error);
      }
      // Deserialize Response
      if (statusCode === 204) {
        let parsedResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedResponse !== null && parsedResponse !== undefined) {
            let resultMapper = {
              required: false,
              serializedName: 'parsedResponse',
              type: {
                name: 'Object'
              }
            };
            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
          }
        } catch (error) {
          let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
          deserializationError.request = msRest.stripRequest(httpRequest);
          deserializationError.response = msRest.stripResponse(response);
          return Promise.reject(deserializationError);
        }
      }

    } catch(err) {
      return Promise.reject(err);
    }

    return Promise.resolve(operationRes);
  }
  // methods on the client.

  /**
   * @summary Creates a new entity.
   *
   * @param {number} drawer The drawer identifier.
   *
   * @param {InsertEntityRequestModel} model The entity model.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  async createEntityWithHttpOperationResponse(drawer: number, model: Models.InsertEntityRequestModel, options?: msRest.RequestOptionsBase): Promise<msRest.HttpOperationResponse> {
    let client = this;
    // Validate
    try {
      if (drawer === null || drawer === undefined || typeof drawer !== 'number') {
        throw new Error('drawer cannot be null or undefined and it must be of type number.');
      }
      if (model === null || model === undefined) {
        throw new Error('model cannot be null or undefined.');
      }
    } catch (error) {
      return Promise.reject(error);
    }

    // Construct URL
    let baseUrl = this.baseUri;
    let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'v1/content/entities/{drawer}';
    requestUrl = requestUrl.replace('{drawer}', encodeURIComponent(drawer.toString()));

    // Create HTTP transport objects
    let httpRequest = new WebResource();
    httpRequest.method = 'POST';
    httpRequest.url = requestUrl;
    httpRequest.headers = {};
    // Set Headers
    httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
    if(options && options.customHeaders) {
      for(let headerName in options.customHeaders) {
        if (options.customHeaders.hasOwnProperty(headerName)) {
          httpRequest.headers[headerName] = options.customHeaders[headerName];
        }
      }
    }
    // Serialize Request
    let requestContent = null;
    let requestModel = null;
    try {
      if (model !== null && model !== undefined) {
        let requestModelMapper = Mappers.InsertEntityRequestModel;
        requestModel = client.serializer.serialize(requestModelMapper, model, 'model');
        requestContent = JSON.stringify(requestModel);
      }
    } catch (error) {
      let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
          `payload - ${JSON.stringify(model, null, 2)}.`);
      return Promise.reject(serializationError);
    }
    httpRequest.body = requestContent;
    // Send Request
    let operationRes: msRest.HttpOperationResponse;
    try {
      operationRes = await client.pipeline(httpRequest);
      let response = operationRes.response;
      let statusCode = response.status;
      if (statusCode !== 201 && statusCode !== 404) {
        let error = new msRest.RestError(operationRes.bodyAsText as string);
        error.statusCode = response.status;
        error.request = msRest.stripRequest(httpRequest);
        error.response = msRest.stripResponse(response);
        let parsedErrorResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedErrorResponse) {
            let internalError = null;
            if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
            error.code = internalError ? internalError.code : parsedErrorResponse.code;
            error.message = internalError ? internalError.message : parsedErrorResponse.message;
          }
        } catch (defaultError) {
          error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                           `- "${operationRes.bodyAsText}" for the default response.`;
          return Promise.reject(error);
        }
        return Promise.reject(error);
      }
      // Deserialize Response
      if (statusCode === 201) {
        let parsedResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedResponse !== null && parsedResponse !== undefined) {
            let resultMapper = Mappers.EntityModel;
            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
          }
        } catch (error) {
          let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
          deserializationError.request = msRest.stripRequest(httpRequest);
          deserializationError.response = msRest.stripResponse(response);
          return Promise.reject(deserializationError);
        }
      }

    } catch(err) {
      return Promise.reject(err);
    }

    return Promise.resolve(operationRes);
  }
  // methods on the client.

  /**
   * @summary Copies the contents of an entity.
   *
   * @param {number} drawer The drawer.
   *
   * @param {number} id The entity identifier.
   *
   * @param {EntityContentModel} model The model.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  async copyEntityWithHttpOperationResponse(drawer: number, id: number, model: Models.EntityContentModel, options?: msRest.RequestOptionsBase): Promise<msRest.HttpOperationResponse> {
    let client = this;
    // Validate
    try {
      if (drawer === null || drawer === undefined || typeof drawer !== 'number') {
        throw new Error('drawer cannot be null or undefined and it must be of type number.');
      }
      if (id === null || id === undefined || typeof id !== 'number') {
        throw new Error('id cannot be null or undefined and it must be of type number.');
      }
      if (model === null || model === undefined) {
        throw new Error('model cannot be null or undefined.');
      }
    } catch (error) {
      return Promise.reject(error);
    }

    // Construct URL
    let baseUrl = this.baseUri;
    let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'v1/content/entities/{drawer}/{id}/copy';
    requestUrl = requestUrl.replace('{drawer}', encodeURIComponent(drawer.toString()));
    requestUrl = requestUrl.replace('{id}', encodeURIComponent(id.toString()));

    // Create HTTP transport objects
    let httpRequest = new WebResource();
    httpRequest.method = 'POST';
    httpRequest.url = requestUrl;
    httpRequest.headers = {};
    // Set Headers
    httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
    if(options && options.customHeaders) {
      for(let headerName in options.customHeaders) {
        if (options.customHeaders.hasOwnProperty(headerName)) {
          httpRequest.headers[headerName] = options.customHeaders[headerName];
        }
      }
    }
    // Serialize Request
    let requestContent = null;
    let requestModel = null;
    try {
      if (model !== null && model !== undefined) {
        let requestModelMapper = Mappers.EntityContentModel;
        requestModel = client.serializer.serialize(requestModelMapper, model, 'model');
        requestContent = JSON.stringify(requestModel);
      }
    } catch (error) {
      let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
          `payload - ${JSON.stringify(model, null, 2)}.`);
      return Promise.reject(serializationError);
    }
    httpRequest.body = requestContent;
    // Send Request
    let operationRes: msRest.HttpOperationResponse;
    try {
      operationRes = await client.pipeline(httpRequest);
      let response = operationRes.response;
      let statusCode = response.status;
      if (statusCode !== 201 && statusCode !== 404) {
        let error = new msRest.RestError(operationRes.bodyAsText as string);
        error.statusCode = response.status;
        error.request = msRest.stripRequest(httpRequest);
        error.response = msRest.stripResponse(response);
        let parsedErrorResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedErrorResponse) {
            let internalError = null;
            if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
            error.code = internalError ? internalError.code : parsedErrorResponse.code;
            error.message = internalError ? internalError.message : parsedErrorResponse.message;
          }
        } catch (defaultError) {
          error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                           `- "${operationRes.bodyAsText}" for the default response.`;
          return Promise.reject(error);
        }
        return Promise.reject(error);
      }
      // Deserialize Response
      if (statusCode === 201) {
        let parsedResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedResponse !== null && parsedResponse !== undefined) {
            let resultMapper = Mappers.EntityModel;
            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
          }
        } catch (error) {
          let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
          deserializationError.request = msRest.stripRequest(httpRequest);
          deserializationError.response = msRest.stripResponse(response);
          return Promise.reject(deserializationError);
        }
      }

    } catch(err) {
      return Promise.reject(err);
    }

    return Promise.resolve(operationRes);
  }
  // methods on the client.

  /**
   * @summary Gets a paged list of events.
   *
   * @param {number} drawerID Gets or sets the drawer identifier.
   *
   * @param {number} entityID Gets or sets the entity identifier.
   *
   * @param {SoftheonEnterpriseAPIGetEventsByFilterOptionalParams} [options]
   * Optional Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  async getEventsByFilterWithHttpOperationResponse(drawerID: number, entityID: number, options?: Models.SoftheonEnterpriseAPIGetEventsByFilterOptionalParams): Promise<msRest.HttpOperationResponse> {
    let client = this;
    let type = (options && options.type !== undefined) ? options.type : undefined;
    let minEventTime = (options && options.minEventTime !== undefined) ? options.minEventTime : undefined;
    let maxEventTime = (options && options.maxEventTime !== undefined) ? options.maxEventTime : undefined;
    let eventUserID = (options && options.eventUserID !== undefined) ? options.eventUserID : undefined;
    let eventGroupID = (options && options.eventGroupID !== undefined) ? options.eventGroupID : undefined;
    let category = (options && options.category !== undefined) ? options.category : undefined;
    let classProperty = (options && options.classProperty !== undefined) ? options.classProperty : undefined;
    let operation = (options && options.operation !== undefined) ? options.operation : undefined;
    let minProcessingTime = (options && options.minProcessingTime !== undefined) ? options.minProcessingTime : undefined;
    let maxProcessingTime = (options && options.maxProcessingTime !== undefined) ? options.maxProcessingTime : undefined;
    let page = (options && options.page !== undefined) ? options.page : undefined;
    let pageSize = (options && options.pageSize !== undefined) ? options.pageSize : undefined;
    let sortOrder = (options && options.sortOrder !== undefined) ? options.sortOrder : undefined;
    let sortBy = (options && options.sortBy !== undefined) ? options.sortBy : undefined;
    // Validate
    try {
      if (drawerID === null || drawerID === undefined || typeof drawerID !== 'number') {
        throw new Error('drawerID cannot be null or undefined and it must be of type number.');
      }
      if (drawerID !== null && drawerID !== undefined) {
        if (drawerID > 2147483647)
        {
          throw new Error('"drawerID" should satisfy the constraint - "InclusiveMaximum": 2147483647');
        }
        if (drawerID < 1)
        {
          throw new Error('"drawerID" should satisfy the constraint - "InclusiveMinimum": 1');
        }
      }
      if (entityID === null || entityID === undefined || typeof entityID !== 'number') {
        throw new Error('entityID cannot be null or undefined and it must be of type number.');
      }
      if (entityID !== null && entityID !== undefined) {
        if (entityID > 2147483647)
        {
          throw new Error('"entityID" should satisfy the constraint - "InclusiveMaximum": 2147483647');
        }
        if (entityID < 1)
        {
          throw new Error('"entityID" should satisfy the constraint - "InclusiveMinimum": 1');
        }
      }
      if (type !== null && type !== undefined && typeof type.valueOf() !== 'string') {
        throw new Error('type must be of type string.');
      }
      if (minEventTime && !(minEventTime instanceof Date ||
          (typeof (minEventTime as string).valueOf() === 'string' && !isNaN(Date.parse(minEventTime as string))))) {
            throw new Error('minEventTime must be of type date.');
          }
      if (maxEventTime && !(maxEventTime instanceof Date ||
          (typeof (maxEventTime as string).valueOf() === 'string' && !isNaN(Date.parse(maxEventTime as string))))) {
            throw new Error('maxEventTime must be of type date.');
          }
      if (eventUserID !== null && eventUserID !== undefined && typeof eventUserID !== 'number') {
        throw new Error('eventUserID must be of type number.');
      }
      if (eventUserID !== null && eventUserID !== undefined) {
        if (eventUserID > 2147483647)
        {
          throw new Error('"eventUserID" should satisfy the constraint - "InclusiveMaximum": 2147483647');
        }
        if (eventUserID < 1)
        {
          throw new Error('"eventUserID" should satisfy the constraint - "InclusiveMinimum": 1');
        }
      }
      if (eventGroupID !== null && eventGroupID !== undefined && typeof eventGroupID !== 'number') {
        throw new Error('eventGroupID must be of type number.');
      }
      if (eventGroupID !== null && eventGroupID !== undefined) {
        if (eventGroupID > 2147483647)
        {
          throw new Error('"eventGroupID" should satisfy the constraint - "InclusiveMaximum": 2147483647');
        }
        if (eventGroupID < 1)
        {
          throw new Error('"eventGroupID" should satisfy the constraint - "InclusiveMinimum": 1');
        }
      }
      if (category !== null && category !== undefined && typeof category.valueOf() !== 'string') {
        throw new Error('category must be of type string.');
      }
      if (classParameter !== null && classParameter !== undefined && typeof classParameter.valueOf() !== 'string') {
        throw new Error('classParameter must be of type string.');
      }
      if (operation !== null && operation !== undefined && typeof operation.valueOf() !== 'string') {
        throw new Error('operation must be of type string.');
      }
      if (minProcessingTime !== null && minProcessingTime !== undefined && typeof minProcessingTime !== 'number') {
        throw new Error('minProcessingTime must be of type number.');
      }
      if (maxProcessingTime !== null && maxProcessingTime !== undefined && typeof maxProcessingTime !== 'number') {
        throw new Error('maxProcessingTime must be of type number.');
      }
      if (page !== null && page !== undefined && typeof page !== 'number') {
        throw new Error('page must be of type number.');
      }
      if (page !== null && page !== undefined) {
        if (page > 2147483647)
        {
          throw new Error('"page" should satisfy the constraint - "InclusiveMaximum": 2147483647');
        }
        if (page < 1)
        {
          throw new Error('"page" should satisfy the constraint - "InclusiveMinimum": 1');
        }
      }
      if (pageSize !== null && pageSize !== undefined && typeof pageSize !== 'number') {
        throw new Error('pageSize must be of type number.');
      }
      if (pageSize !== null && pageSize !== undefined) {
        if (pageSize > 1000)
        {
          throw new Error('"pageSize" should satisfy the constraint - "InclusiveMaximum": 1000');
        }
        if (pageSize < 1)
        {
          throw new Error('"pageSize" should satisfy the constraint - "InclusiveMinimum": 1');
        }
      }
      if (sortOrder !== null && sortOrder !== undefined && typeof sortOrder.valueOf() !== 'string') {
        throw new Error('sortOrder must be of type string.');
      }
      if (sortBy !== null && sortBy !== undefined && typeof sortBy.valueOf() !== 'string') {
        throw new Error('sortBy must be of type string.');
      }
    } catch (error) {
      return Promise.reject(error);
    }

    // Construct URL
    let baseUrl = this.baseUri;
    let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'v1/content/events';
    let queryParamsArray: Array<any> = [];
    queryParamsArray.push('drawerID=' + encodeURIComponent(drawerID.toString()));
    queryParamsArray.push('entityID=' + encodeURIComponent(entityID.toString()));
    if (type !== null && type !== undefined) {
      queryParamsArray.push('type=' + encodeURIComponent(type));
    }
    if (minEventTime !== null && minEventTime !== undefined) {
      queryParamsArray.push('minEventTime=' + encodeURIComponent(msRest.serializeObject(minEventTime)));
    }
    if (maxEventTime !== null && maxEventTime !== undefined) {
      queryParamsArray.push('maxEventTime=' + encodeURIComponent(msRest.serializeObject(maxEventTime)));
    }
    if (eventUserID !== null && eventUserID !== undefined) {
      queryParamsArray.push('eventUserID=' + encodeURIComponent(eventUserID.toString()));
    }
    if (eventGroupID !== null && eventGroupID !== undefined) {
      queryParamsArray.push('eventGroupID=' + encodeURIComponent(eventGroupID.toString()));
    }
    if (category !== null && category !== undefined) {
      queryParamsArray.push('category=' + encodeURIComponent(category));
    }
    if (classParameter !== null && classParameter !== undefined) {
      queryParamsArray.push('class=' + encodeURIComponent(classParameter));
    }
    if (operation !== null && operation !== undefined) {
      queryParamsArray.push('operation=' + encodeURIComponent(operation));
    }
    if (minProcessingTime !== null && minProcessingTime !== undefined) {
      queryParamsArray.push('minProcessingTime=' + encodeURIComponent(minProcessingTime.toString()));
    }
    if (maxProcessingTime !== null && maxProcessingTime !== undefined) {
      queryParamsArray.push('maxProcessingTime=' + encodeURIComponent(maxProcessingTime.toString()));
    }
    if (page !== null && page !== undefined) {
      queryParamsArray.push('page=' + encodeURIComponent(page.toString()));
    }
    if (pageSize !== null && pageSize !== undefined) {
      queryParamsArray.push('pageSize=' + encodeURIComponent(pageSize.toString()));
    }
    if (sortOrder !== null && sortOrder !== undefined) {
      queryParamsArray.push('sortOrder=' + encodeURIComponent(sortOrder));
    }
    if (sortBy !== null && sortBy !== undefined) {
      queryParamsArray.push('sortBy=' + encodeURIComponent(sortBy));
    }
    if (queryParamsArray.length > 0) {
      requestUrl += '?' + queryParamsArray.join('&');
    }

    // Create HTTP transport objects
    let httpRequest = new WebResource();
    httpRequest.method = 'GET';
    httpRequest.url = requestUrl;
    httpRequest.headers = {};
    // Set Headers
    httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
    if(options && options.customHeaders) {
      for(let headerName in options.customHeaders) {
        if (options.customHeaders.hasOwnProperty(headerName)) {
          httpRequest.headers[headerName] = options.customHeaders[headerName];
        }
      }
    }
    // Send Request
    let operationRes: msRest.HttpOperationResponse;
    try {
      operationRes = await client.pipeline(httpRequest);
      let response = operationRes.response;
      let statusCode = response.status;
      if (statusCode !== 200) {
        let error = new msRest.RestError(operationRes.bodyAsText as string);
        error.statusCode = response.status;
        error.request = msRest.stripRequest(httpRequest);
        error.response = msRest.stripResponse(response);
        let parsedErrorResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedErrorResponse) {
            let internalError = null;
            if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
            error.code = internalError ? internalError.code : parsedErrorResponse.code;
            error.message = internalError ? internalError.message : parsedErrorResponse.message;
          }
        } catch (defaultError) {
          error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                           `- "${operationRes.bodyAsText}" for the default response.`;
          return Promise.reject(error);
        }
        return Promise.reject(error);
      }
      // Deserialize Response
      if (statusCode === 200) {
        let parsedResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedResponse !== null && parsedResponse !== undefined) {
            let resultMapper = {
              required: false,
              serializedName: 'parsedResponse',
              type: {
                name: 'Sequence',
                element: {
                    required: false,
                    serializedName: 'EventModelElementType',
                    type: {
                      name: 'Composite',
                      className: 'EventModel'
                    }
                }
              }
            };
            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
          }
        } catch (error) {
          let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
          deserializationError.request = msRest.stripRequest(httpRequest);
          deserializationError.response = msRest.stripResponse(response);
          return Promise.reject(deserializationError);
        }
      }

    } catch(err) {
      return Promise.reject(err);
    }

    return Promise.resolve(operationRes);
  }
  // methods on the client.

  /**
   * @summary Retrieves a single event based on its unique identifier.
   *
   * @param {number} drawer The drawer identifier.
   *
   * @param {number} id The event identifier.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  async getEventByIdWithHttpOperationResponse(drawer: number, id: number, options?: msRest.RequestOptionsBase): Promise<msRest.HttpOperationResponse> {
    let client = this;
    // Validate
    try {
      if (drawer === null || drawer === undefined || typeof drawer !== 'number') {
        throw new Error('drawer cannot be null or undefined and it must be of type number.');
      }
      if (id === null || id === undefined || typeof id !== 'number') {
        throw new Error('id cannot be null or undefined and it must be of type number.');
      }
    } catch (error) {
      return Promise.reject(error);
    }

    // Construct URL
    let baseUrl = this.baseUri;
    let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'v1/content/events/{drawer}/{id}';
    requestUrl = requestUrl.replace('{drawer}', encodeURIComponent(drawer.toString()));
    requestUrl = requestUrl.replace('{id}', encodeURIComponent(id.toString()));

    // Create HTTP transport objects
    let httpRequest = new WebResource();
    httpRequest.method = 'GET';
    httpRequest.url = requestUrl;
    httpRequest.headers = {};
    // Set Headers
    httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
    if(options && options.customHeaders) {
      for(let headerName in options.customHeaders) {
        if (options.customHeaders.hasOwnProperty(headerName)) {
          httpRequest.headers[headerName] = options.customHeaders[headerName];
        }
      }
    }
    // Send Request
    let operationRes: msRest.HttpOperationResponse;
    try {
      operationRes = await client.pipeline(httpRequest);
      let response = operationRes.response;
      let statusCode = response.status;
      if (statusCode !== 200 && statusCode !== 404) {
        let error = new msRest.RestError(operationRes.bodyAsText as string);
        error.statusCode = response.status;
        error.request = msRest.stripRequest(httpRequest);
        error.response = msRest.stripResponse(response);
        let parsedErrorResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedErrorResponse) {
            let internalError = null;
            if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
            error.code = internalError ? internalError.code : parsedErrorResponse.code;
            error.message = internalError ? internalError.message : parsedErrorResponse.message;
          }
        } catch (defaultError) {
          error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                           `- "${operationRes.bodyAsText}" for the default response.`;
          return Promise.reject(error);
        }
        return Promise.reject(error);
      }
      // Deserialize Response
      if (statusCode === 200) {
        let parsedResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedResponse !== null && parsedResponse !== undefined) {
            let resultMapper = Mappers.EventModel;
            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
          }
        } catch (error) {
          let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
          deserializationError.request = msRest.stripRequest(httpRequest);
          deserializationError.response = msRest.stripResponse(response);
          return Promise.reject(deserializationError);
        }
      }

    } catch(err) {
      return Promise.reject(err);
    }

    return Promise.resolve(operationRes);
  }
  // methods on the client.

  /**
   * @summary Creates a new event.
   *
   * @param {number} drawer The drawer identifier.
   *
   * @param {EventModel} model The event model.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  async createEventWithHttpOperationResponse(drawer: number, model: Models.EventModel, options?: msRest.RequestOptionsBase): Promise<msRest.HttpOperationResponse> {
    let client = this;
    // Validate
    try {
      if (drawer === null || drawer === undefined || typeof drawer !== 'number') {
        throw new Error('drawer cannot be null or undefined and it must be of type number.');
      }
      if (model === null || model === undefined) {
        throw new Error('model cannot be null or undefined.');
      }
    } catch (error) {
      return Promise.reject(error);
    }

    // Construct URL
    let baseUrl = this.baseUri;
    let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'v1/content/events/{drawer}';
    requestUrl = requestUrl.replace('{drawer}', encodeURIComponent(drawer.toString()));

    // Create HTTP transport objects
    let httpRequest = new WebResource();
    httpRequest.method = 'POST';
    httpRequest.url = requestUrl;
    httpRequest.headers = {};
    // Set Headers
    httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
    if(options && options.customHeaders) {
      for(let headerName in options.customHeaders) {
        if (options.customHeaders.hasOwnProperty(headerName)) {
          httpRequest.headers[headerName] = options.customHeaders[headerName];
        }
      }
    }
    // Serialize Request
    let requestContent = null;
    let requestModel = null;
    try {
      if (model !== null && model !== undefined) {
        let requestModelMapper = Mappers.EventModel;
        requestModel = client.serializer.serialize(requestModelMapper, model, 'model');
        requestContent = JSON.stringify(requestModel);
      }
    } catch (error) {
      let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
          `payload - ${JSON.stringify(model, null, 2)}.`);
      return Promise.reject(serializationError);
    }
    httpRequest.body = requestContent;
    // Send Request
    let operationRes: msRest.HttpOperationResponse;
    try {
      operationRes = await client.pipeline(httpRequest);
      let response = operationRes.response;
      let statusCode = response.status;
      if (statusCode !== 201 && statusCode !== 404) {
        let error = new msRest.RestError(operationRes.bodyAsText as string);
        error.statusCode = response.status;
        error.request = msRest.stripRequest(httpRequest);
        error.response = msRest.stripResponse(response);
        let parsedErrorResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedErrorResponse) {
            let internalError = null;
            if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
            error.code = internalError ? internalError.code : parsedErrorResponse.code;
            error.message = internalError ? internalError.message : parsedErrorResponse.message;
          }
        } catch (defaultError) {
          error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                           `- "${operationRes.bodyAsText}" for the default response.`;
          return Promise.reject(error);
        }
        return Promise.reject(error);
      }
      // Deserialize Response
      if (statusCode === 201) {
        let parsedResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedResponse !== null && parsedResponse !== undefined) {
            let resultMapper = Mappers.EventModel;
            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
          }
        } catch (error) {
          let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
          deserializationError.request = msRest.stripRequest(httpRequest);
          deserializationError.response = msRest.stripResponse(response);
          return Promise.reject(deserializationError);
        }
      }

    } catch(err) {
      return Promise.reject(err);
    }

    return Promise.resolve(operationRes);
  }
  // methods on the client.

  /**
   * @summary Gets a paged list of extension rows
   *
   * @param {number} drawerID Gets or sets the drawer identifier.
   *
   * @param {number} entityID Gets or sets the entity identifier.
   *
   * @param {number} profileID Gets or sets the profile identifier.
   *
   * @param {SoftheonEnterpriseAPIGetExtensionsByFilterOptionalParams} [options]
   * Optional Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  async getExtensionsByFilterWithHttpOperationResponse(drawerID: number, entityID: number, profileID: number, options?: Models.SoftheonEnterpriseAPIGetExtensionsByFilterOptionalParams): Promise<msRest.HttpOperationResponse> {
    let client = this;
    let iD = (options && options.iD !== undefined) ? options.iD : undefined;
    let type = (options && options.type !== undefined) ? options.type : undefined;
    let page = (options && options.page !== undefined) ? options.page : undefined;
    let pageSize = (options && options.pageSize !== undefined) ? options.pageSize : undefined;
    let sortOrder = (options && options.sortOrder !== undefined) ? options.sortOrder : undefined;
    let sortBy = (options && options.sortBy !== undefined) ? options.sortBy : undefined;
    // Validate
    try {
      if (drawerID === null || drawerID === undefined || typeof drawerID !== 'number') {
        throw new Error('drawerID cannot be null or undefined and it must be of type number.');
      }
      if (drawerID !== null && drawerID !== undefined) {
        if (drawerID > 2147483647)
        {
          throw new Error('"drawerID" should satisfy the constraint - "InclusiveMaximum": 2147483647');
        }
        if (drawerID < 1)
        {
          throw new Error('"drawerID" should satisfy the constraint - "InclusiveMinimum": 1');
        }
      }
      if (entityID === null || entityID === undefined || typeof entityID !== 'number') {
        throw new Error('entityID cannot be null or undefined and it must be of type number.');
      }
      if (entityID !== null && entityID !== undefined) {
        if (entityID > 2147483647)
        {
          throw new Error('"entityID" should satisfy the constraint - "InclusiveMaximum": 2147483647');
        }
        if (entityID < 1)
        {
          throw new Error('"entityID" should satisfy the constraint - "InclusiveMinimum": 1');
        }
      }
      if (profileID === null || profileID === undefined || typeof profileID !== 'number') {
        throw new Error('profileID cannot be null or undefined and it must be of type number.');
      }
      if (profileID !== null && profileID !== undefined) {
        if (profileID > 2147483647)
        {
          throw new Error('"profileID" should satisfy the constraint - "InclusiveMaximum": 2147483647');
        }
        if (profileID < 1)
        {
          throw new Error('"profileID" should satisfy the constraint - "InclusiveMinimum": 1');
        }
      }
      if (iD !== null && iD !== undefined && typeof iD !== 'number') {
        throw new Error('iD must be of type number.');
      }
      if (iD !== null && iD !== undefined) {
        if (iD > 2147483647)
        {
          throw new Error('"iD" should satisfy the constraint - "InclusiveMaximum": 2147483647');
        }
        if (iD < 1)
        {
          throw new Error('"iD" should satisfy the constraint - "InclusiveMinimum": 1');
        }
      }
      if (type !== null && type !== undefined && typeof type !== 'number') {
        throw new Error('type must be of type number.');
      }
      if (type !== null && type !== undefined) {
        if (type > 2147483647)
        {
          throw new Error('"type" should satisfy the constraint - "InclusiveMaximum": 2147483647');
        }
        if (type < 0)
        {
          throw new Error('"type" should satisfy the constraint - "InclusiveMinimum": 0');
        }
      }
      if (page !== null && page !== undefined && typeof page !== 'number') {
        throw new Error('page must be of type number.');
      }
      if (page !== null && page !== undefined) {
        if (page > 2147483647)
        {
          throw new Error('"page" should satisfy the constraint - "InclusiveMaximum": 2147483647');
        }
        if (page < 1)
        {
          throw new Error('"page" should satisfy the constraint - "InclusiveMinimum": 1');
        }
      }
      if (pageSize !== null && pageSize !== undefined && typeof pageSize !== 'number') {
        throw new Error('pageSize must be of type number.');
      }
      if (pageSize !== null && pageSize !== undefined) {
        if (pageSize > 1000)
        {
          throw new Error('"pageSize" should satisfy the constraint - "InclusiveMaximum": 1000');
        }
        if (pageSize < 1)
        {
          throw new Error('"pageSize" should satisfy the constraint - "InclusiveMinimum": 1');
        }
      }
      if (sortOrder !== null && sortOrder !== undefined && typeof sortOrder.valueOf() !== 'string') {
        throw new Error('sortOrder must be of type string.');
      }
      if (sortBy !== null && sortBy !== undefined && typeof sortBy.valueOf() !== 'string') {
        throw new Error('sortBy must be of type string.');
      }
    } catch (error) {
      return Promise.reject(error);
    }

    // Construct URL
    let baseUrl = this.baseUri;
    let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'v1/content/extensions';
    let queryParamsArray: Array<any> = [];
    queryParamsArray.push('drawerID=' + encodeURIComponent(drawerID.toString()));
    queryParamsArray.push('entityID=' + encodeURIComponent(entityID.toString()));
    queryParamsArray.push('profileID=' + encodeURIComponent(profileID.toString()));
    if (iD !== null && iD !== undefined) {
      queryParamsArray.push('iD=' + encodeURIComponent(iD.toString()));
    }
    if (type !== null && type !== undefined) {
      queryParamsArray.push('type=' + encodeURIComponent(type.toString()));
    }
    if (page !== null && page !== undefined) {
      queryParamsArray.push('page=' + encodeURIComponent(page.toString()));
    }
    if (pageSize !== null && pageSize !== undefined) {
      queryParamsArray.push('pageSize=' + encodeURIComponent(pageSize.toString()));
    }
    if (sortOrder !== null && sortOrder !== undefined) {
      queryParamsArray.push('sortOrder=' + encodeURIComponent(sortOrder));
    }
    if (sortBy !== null && sortBy !== undefined) {
      queryParamsArray.push('sortBy=' + encodeURIComponent(sortBy));
    }
    if (queryParamsArray.length > 0) {
      requestUrl += '?' + queryParamsArray.join('&');
    }

    // Create HTTP transport objects
    let httpRequest = new WebResource();
    httpRequest.method = 'GET';
    httpRequest.url = requestUrl;
    httpRequest.headers = {};
    // Set Headers
    httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
    if(options && options.customHeaders) {
      for(let headerName in options.customHeaders) {
        if (options.customHeaders.hasOwnProperty(headerName)) {
          httpRequest.headers[headerName] = options.customHeaders[headerName];
        }
      }
    }
    // Send Request
    let operationRes: msRest.HttpOperationResponse;
    try {
      operationRes = await client.pipeline(httpRequest);
      let response = operationRes.response;
      let statusCode = response.status;
      if (statusCode !== 200) {
        let error = new msRest.RestError(operationRes.bodyAsText as string);
        error.statusCode = response.status;
        error.request = msRest.stripRequest(httpRequest);
        error.response = msRest.stripResponse(response);
        let parsedErrorResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedErrorResponse) {
            let internalError = null;
            if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
            error.code = internalError ? internalError.code : parsedErrorResponse.code;
            error.message = internalError ? internalError.message : parsedErrorResponse.message;
          }
        } catch (defaultError) {
          error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                           `- "${operationRes.bodyAsText}" for the default response.`;
          return Promise.reject(error);
        }
        return Promise.reject(error);
      }
      // Deserialize Response
      if (statusCode === 200) {
        let parsedResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedResponse !== null && parsedResponse !== undefined) {
            let resultMapper = {
              required: false,
              serializedName: 'parsedResponse',
              type: {
                name: 'Sequence',
                element: {
                    required: false,
                    serializedName: 'ExtensionModelElementType',
                    type: {
                      name: 'Composite',
                      className: 'ExtensionModel'
                    }
                }
              }
            };
            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
          }
        } catch (error) {
          let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
          deserializationError.request = msRest.stripRequest(httpRequest);
          deserializationError.response = msRest.stripResponse(response);
          return Promise.reject(deserializationError);
        }
      }

    } catch(err) {
      return Promise.reject(err);
    }

    return Promise.resolve(operationRes);
  }
  // methods on the client.

  /**
   * @summary Gets a paged list of flows.
   *
   * @param {number} drawerID Gets or sets the drawer identifier.
   *
   * @param {number} entityID Gets or sets the entity identifier.
   *
   * @param {SoftheonEnterpriseAPIGetFlowsByFilterOptionalParams} [options]
   * Optional Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  async getFlowsByFilterWithHttpOperationResponse(drawerID: number, entityID: number, options?: Models.SoftheonEnterpriseAPIGetFlowsByFilterOptionalParams): Promise<msRest.HttpOperationResponse> {
    let client = this;
    let type = (options && options.type !== undefined) ? options.type : undefined;
    let queueID = (options && options.queueID !== undefined) ? options.queueID : undefined;
    let minWorkflowTime = (options && options.minWorkflowTime !== undefined) ? options.minWorkflowTime : undefined;
    let maxWorkflowTime = (options && options.maxWorkflowTime !== undefined) ? options.maxWorkflowTime : undefined;
    let minInsertionTime = (options && options.minInsertionTime !== undefined) ? options.minInsertionTime : undefined;
    let maxInsertionTime = (options && options.maxInsertionTime !== undefined) ? options.maxInsertionTime : undefined;
    let workflowUserID = (options && options.workflowUserID !== undefined) ? options.workflowUserID : undefined;
    let workflowGroupID = (options && options.workflowGroupID !== undefined) ? options.workflowGroupID : undefined;
    let operation = (options && options.operation !== undefined) ? options.operation : undefined;
    let category = (options && options.category !== undefined) ? options.category : undefined;
    let status = (options && options.status !== undefined) ? options.status : undefined;
    let state = (options && options.state !== undefined) ? options.state : undefined;
    let minIndex1 = (options && options.minIndex1 !== undefined) ? options.minIndex1 : undefined;
    let maxIndex1 = (options && options.maxIndex1 !== undefined) ? options.maxIndex1 : undefined;
    let minIndex2 = (options && options.minIndex2 !== undefined) ? options.minIndex2 : undefined;
    let maxIndex2 = (options && options.maxIndex2 !== undefined) ? options.maxIndex2 : undefined;
    let page = (options && options.page !== undefined) ? options.page : undefined;
    let pageSize = (options && options.pageSize !== undefined) ? options.pageSize : undefined;
    let sortOrder = (options && options.sortOrder !== undefined) ? options.sortOrder : undefined;
    let sortBy = (options && options.sortBy !== undefined) ? options.sortBy : undefined;
    // Validate
    try {
      if (drawerID === null || drawerID === undefined || typeof drawerID !== 'number') {
        throw new Error('drawerID cannot be null or undefined and it must be of type number.');
      }
      if (drawerID !== null && drawerID !== undefined) {
        if (drawerID > 2147483647)
        {
          throw new Error('"drawerID" should satisfy the constraint - "InclusiveMaximum": 2147483647');
        }
        if (drawerID < 1)
        {
          throw new Error('"drawerID" should satisfy the constraint - "InclusiveMinimum": 1');
        }
      }
      if (entityID === null || entityID === undefined || typeof entityID !== 'number') {
        throw new Error('entityID cannot be null or undefined and it must be of type number.');
      }
      if (entityID !== null && entityID !== undefined) {
        if (entityID > 2147483647)
        {
          throw new Error('"entityID" should satisfy the constraint - "InclusiveMaximum": 2147483647');
        }
        if (entityID < 1)
        {
          throw new Error('"entityID" should satisfy the constraint - "InclusiveMinimum": 1');
        }
      }
      if (type !== null && type !== undefined && typeof type.valueOf() !== 'string') {
        throw new Error('type must be of type string.');
      }
      if (queueID !== null && queueID !== undefined && typeof queueID !== 'number') {
        throw new Error('queueID must be of type number.');
      }
      if (queueID !== null && queueID !== undefined) {
        if (queueID > 2147483647)
        {
          throw new Error('"queueID" should satisfy the constraint - "InclusiveMaximum": 2147483647');
        }
        if (queueID < 1)
        {
          throw new Error('"queueID" should satisfy the constraint - "InclusiveMinimum": 1');
        }
      }
      if (minWorkflowTime && !(minWorkflowTime instanceof Date ||
          (typeof (minWorkflowTime as string).valueOf() === 'string' && !isNaN(Date.parse(minWorkflowTime as string))))) {
            throw new Error('minWorkflowTime must be of type date.');
          }
      if (maxWorkflowTime && !(maxWorkflowTime instanceof Date ||
          (typeof (maxWorkflowTime as string).valueOf() === 'string' && !isNaN(Date.parse(maxWorkflowTime as string))))) {
            throw new Error('maxWorkflowTime must be of type date.');
          }
      if (minInsertionTime && !(minInsertionTime instanceof Date ||
          (typeof (minInsertionTime as string).valueOf() === 'string' && !isNaN(Date.parse(minInsertionTime as string))))) {
            throw new Error('minInsertionTime must be of type date.');
          }
      if (maxInsertionTime && !(maxInsertionTime instanceof Date ||
          (typeof (maxInsertionTime as string).valueOf() === 'string' && !isNaN(Date.parse(maxInsertionTime as string))))) {
            throw new Error('maxInsertionTime must be of type date.');
          }
      if (workflowUserID !== null && workflowUserID !== undefined && typeof workflowUserID !== 'number') {
        throw new Error('workflowUserID must be of type number.');
      }
      if (workflowUserID !== null && workflowUserID !== undefined) {
        if (workflowUserID > 2147483647)
        {
          throw new Error('"workflowUserID" should satisfy the constraint - "InclusiveMaximum": 2147483647');
        }
        if (workflowUserID < 1)
        {
          throw new Error('"workflowUserID" should satisfy the constraint - "InclusiveMinimum": 1');
        }
      }
      if (workflowGroupID !== null && workflowGroupID !== undefined && typeof workflowGroupID !== 'number') {
        throw new Error('workflowGroupID must be of type number.');
      }
      if (workflowGroupID !== null && workflowGroupID !== undefined) {
        if (workflowGroupID > 2147483647)
        {
          throw new Error('"workflowGroupID" should satisfy the constraint - "InclusiveMaximum": 2147483647');
        }
        if (workflowGroupID < 1)
        {
          throw new Error('"workflowGroupID" should satisfy the constraint - "InclusiveMinimum": 1');
        }
      }
      if (operation !== null && operation !== undefined && typeof operation.valueOf() !== 'string') {
        throw new Error('operation must be of type string.');
      }
      if (category !== null && category !== undefined && typeof category.valueOf() !== 'string') {
        throw new Error('category must be of type string.');
      }
      if (status !== null && status !== undefined && typeof status.valueOf() !== 'string') {
        throw new Error('status must be of type string.');
      }
      if (state !== null && state !== undefined && typeof state.valueOf() !== 'string') {
        throw new Error('state must be of type string.');
      }
      if (minIndex1 !== null && minIndex1 !== undefined && typeof minIndex1 !== 'number') {
        throw new Error('minIndex1 must be of type number.');
      }
      if (maxIndex1 !== null && maxIndex1 !== undefined && typeof maxIndex1 !== 'number') {
        throw new Error('maxIndex1 must be of type number.');
      }
      if (minIndex2 !== null && minIndex2 !== undefined && typeof minIndex2 !== 'number') {
        throw new Error('minIndex2 must be of type number.');
      }
      if (maxIndex2 !== null && maxIndex2 !== undefined && typeof maxIndex2 !== 'number') {
        throw new Error('maxIndex2 must be of type number.');
      }
      if (page !== null && page !== undefined && typeof page !== 'number') {
        throw new Error('page must be of type number.');
      }
      if (page !== null && page !== undefined) {
        if (page > 2147483647)
        {
          throw new Error('"page" should satisfy the constraint - "InclusiveMaximum": 2147483647');
        }
        if (page < 1)
        {
          throw new Error('"page" should satisfy the constraint - "InclusiveMinimum": 1');
        }
      }
      if (pageSize !== null && pageSize !== undefined && typeof pageSize !== 'number') {
        throw new Error('pageSize must be of type number.');
      }
      if (pageSize !== null && pageSize !== undefined) {
        if (pageSize > 1000)
        {
          throw new Error('"pageSize" should satisfy the constraint - "InclusiveMaximum": 1000');
        }
        if (pageSize < 1)
        {
          throw new Error('"pageSize" should satisfy the constraint - "InclusiveMinimum": 1');
        }
      }
      if (sortOrder !== null && sortOrder !== undefined && typeof sortOrder.valueOf() !== 'string') {
        throw new Error('sortOrder must be of type string.');
      }
      if (sortBy !== null && sortBy !== undefined && typeof sortBy.valueOf() !== 'string') {
        throw new Error('sortBy must be of type string.');
      }
    } catch (error) {
      return Promise.reject(error);
    }

    // Construct URL
    let baseUrl = this.baseUri;
    let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'v1/content/flows';
    let queryParamsArray: Array<any> = [];
    queryParamsArray.push('drawerID=' + encodeURIComponent(drawerID.toString()));
    queryParamsArray.push('entityID=' + encodeURIComponent(entityID.toString()));
    if (type !== null && type !== undefined) {
      queryParamsArray.push('type=' + encodeURIComponent(type));
    }
    if (queueID !== null && queueID !== undefined) {
      queryParamsArray.push('queueID=' + encodeURIComponent(queueID.toString()));
    }
    if (minWorkflowTime !== null && minWorkflowTime !== undefined) {
      queryParamsArray.push('minWorkflowTime=' + encodeURIComponent(msRest.serializeObject(minWorkflowTime)));
    }
    if (maxWorkflowTime !== null && maxWorkflowTime !== undefined) {
      queryParamsArray.push('maxWorkflowTime=' + encodeURIComponent(msRest.serializeObject(maxWorkflowTime)));
    }
    if (minInsertionTime !== null && minInsertionTime !== undefined) {
      queryParamsArray.push('minInsertionTime=' + encodeURIComponent(msRest.serializeObject(minInsertionTime)));
    }
    if (maxInsertionTime !== null && maxInsertionTime !== undefined) {
      queryParamsArray.push('maxInsertionTime=' + encodeURIComponent(msRest.serializeObject(maxInsertionTime)));
    }
    if (workflowUserID !== null && workflowUserID !== undefined) {
      queryParamsArray.push('workflowUserID=' + encodeURIComponent(workflowUserID.toString()));
    }
    if (workflowGroupID !== null && workflowGroupID !== undefined) {
      queryParamsArray.push('workflowGroupID=' + encodeURIComponent(workflowGroupID.toString()));
    }
    if (operation !== null && operation !== undefined) {
      queryParamsArray.push('operation=' + encodeURIComponent(operation));
    }
    if (category !== null && category !== undefined) {
      queryParamsArray.push('category=' + encodeURIComponent(category));
    }
    if (status !== null && status !== undefined) {
      queryParamsArray.push('status=' + encodeURIComponent(status));
    }
    if (state !== null && state !== undefined) {
      queryParamsArray.push('state=' + encodeURIComponent(state));
    }
    if (minIndex1 !== null && minIndex1 !== undefined) {
      queryParamsArray.push('minIndex1=' + encodeURIComponent(minIndex1.toString()));
    }
    if (maxIndex1 !== null && maxIndex1 !== undefined) {
      queryParamsArray.push('maxIndex1=' + encodeURIComponent(maxIndex1.toString()));
    }
    if (minIndex2 !== null && minIndex2 !== undefined) {
      queryParamsArray.push('minIndex2=' + encodeURIComponent(minIndex2.toString()));
    }
    if (maxIndex2 !== null && maxIndex2 !== undefined) {
      queryParamsArray.push('maxIndex2=' + encodeURIComponent(maxIndex2.toString()));
    }
    if (page !== null && page !== undefined) {
      queryParamsArray.push('page=' + encodeURIComponent(page.toString()));
    }
    if (pageSize !== null && pageSize !== undefined) {
      queryParamsArray.push('pageSize=' + encodeURIComponent(pageSize.toString()));
    }
    if (sortOrder !== null && sortOrder !== undefined) {
      queryParamsArray.push('sortOrder=' + encodeURIComponent(sortOrder));
    }
    if (sortBy !== null && sortBy !== undefined) {
      queryParamsArray.push('sortBy=' + encodeURIComponent(sortBy));
    }
    if (queryParamsArray.length > 0) {
      requestUrl += '?' + queryParamsArray.join('&');
    }

    // Create HTTP transport objects
    let httpRequest = new WebResource();
    httpRequest.method = 'GET';
    httpRequest.url = requestUrl;
    httpRequest.headers = {};
    // Set Headers
    httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
    if(options && options.customHeaders) {
      for(let headerName in options.customHeaders) {
        if (options.customHeaders.hasOwnProperty(headerName)) {
          httpRequest.headers[headerName] = options.customHeaders[headerName];
        }
      }
    }
    // Send Request
    let operationRes: msRest.HttpOperationResponse;
    try {
      operationRes = await client.pipeline(httpRequest);
      let response = operationRes.response;
      let statusCode = response.status;
      if (statusCode !== 200) {
        let error = new msRest.RestError(operationRes.bodyAsText as string);
        error.statusCode = response.status;
        error.request = msRest.stripRequest(httpRequest);
        error.response = msRest.stripResponse(response);
        let parsedErrorResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedErrorResponse) {
            let internalError = null;
            if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
            error.code = internalError ? internalError.code : parsedErrorResponse.code;
            error.message = internalError ? internalError.message : parsedErrorResponse.message;
          }
        } catch (defaultError) {
          error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                           `- "${operationRes.bodyAsText}" for the default response.`;
          return Promise.reject(error);
        }
        return Promise.reject(error);
      }
      // Deserialize Response
      if (statusCode === 200) {
        let parsedResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedResponse !== null && parsedResponse !== undefined) {
            let resultMapper = {
              required: false,
              serializedName: 'parsedResponse',
              type: {
                name: 'Sequence',
                element: {
                    required: false,
                    serializedName: 'FlowModelElementType',
                    type: {
                      name: 'Composite',
                      className: 'FlowModel'
                    }
                }
              }
            };
            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
          }
        } catch (error) {
          let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
          deserializationError.request = msRest.stripRequest(httpRequest);
          deserializationError.response = msRest.stripResponse(response);
          return Promise.reject(deserializationError);
        }
      }

    } catch(err) {
      return Promise.reject(err);
    }

    return Promise.resolve(operationRes);
  }
  // methods on the client.

  /**
   * @summary Gets a single flow based on its unique identifier.
   *
   * @param {number} drawer The drawer identifier.
   *
   * @param {number} id The flow identifier.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  async getFlowByIdWithHttpOperationResponse(drawer: number, id: number, options?: msRest.RequestOptionsBase): Promise<msRest.HttpOperationResponse> {
    let client = this;
    // Validate
    try {
      if (drawer === null || drawer === undefined || typeof drawer !== 'number') {
        throw new Error('drawer cannot be null or undefined and it must be of type number.');
      }
      if (id === null || id === undefined || typeof id !== 'number') {
        throw new Error('id cannot be null or undefined and it must be of type number.');
      }
    } catch (error) {
      return Promise.reject(error);
    }

    // Construct URL
    let baseUrl = this.baseUri;
    let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'v1/content/flows/{drawer}/{id}';
    requestUrl = requestUrl.replace('{drawer}', encodeURIComponent(drawer.toString()));
    requestUrl = requestUrl.replace('{id}', encodeURIComponent(id.toString()));

    // Create HTTP transport objects
    let httpRequest = new WebResource();
    httpRequest.method = 'GET';
    httpRequest.url = requestUrl;
    httpRequest.headers = {};
    // Set Headers
    httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
    if(options && options.customHeaders) {
      for(let headerName in options.customHeaders) {
        if (options.customHeaders.hasOwnProperty(headerName)) {
          httpRequest.headers[headerName] = options.customHeaders[headerName];
        }
      }
    }
    // Send Request
    let operationRes: msRest.HttpOperationResponse;
    try {
      operationRes = await client.pipeline(httpRequest);
      let response = operationRes.response;
      let statusCode = response.status;
      if (statusCode !== 200 && statusCode !== 404) {
        let error = new msRest.RestError(operationRes.bodyAsText as string);
        error.statusCode = response.status;
        error.request = msRest.stripRequest(httpRequest);
        error.response = msRest.stripResponse(response);
        let parsedErrorResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedErrorResponse) {
            let internalError = null;
            if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
            error.code = internalError ? internalError.code : parsedErrorResponse.code;
            error.message = internalError ? internalError.message : parsedErrorResponse.message;
          }
        } catch (defaultError) {
          error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                           `- "${operationRes.bodyAsText}" for the default response.`;
          return Promise.reject(error);
        }
        return Promise.reject(error);
      }
      // Deserialize Response
      if (statusCode === 200) {
        let parsedResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedResponse !== null && parsedResponse !== undefined) {
            let resultMapper = Mappers.FlowModel;
            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
          }
        } catch (error) {
          let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
          deserializationError.request = msRest.stripRequest(httpRequest);
          deserializationError.response = msRest.stripResponse(response);
          return Promise.reject(deserializationError);
        }
      }

    } catch(err) {
      return Promise.reject(err);
    }

    return Promise.resolve(operationRes);
  }
  // methods on the client.

  /**
   * @summary Gets a paged list of entity template definitions.
   *
   * @param {SoftheonEnterpriseAPIGetTemplatesByFilterOptionalParams} [options]
   * Optional Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  async getTemplatesByFilterWithHttpOperationResponse(options?: Models.SoftheonEnterpriseAPIGetTemplatesByFilterOptionalParams): Promise<msRest.HttpOperationResponse> {
    let client = this;
    let drawerID = (options && options.drawerID !== undefined) ? options.drawerID : undefined;
    let name = (options && options.name !== undefined) ? options.name : undefined;
    let category = (options && options.category !== undefined) ? options.category : undefined;
    let page = (options && options.page !== undefined) ? options.page : undefined;
    let pageSize = (options && options.pageSize !== undefined) ? options.pageSize : undefined;
    let sortOrder = (options && options.sortOrder !== undefined) ? options.sortOrder : undefined;
    let sortBy = (options && options.sortBy !== undefined) ? options.sortBy : undefined;
    // Validate
    try {
      if (drawerID !== null && drawerID !== undefined && typeof drawerID !== 'number') {
        throw new Error('drawerID must be of type number.');
      }
      if (drawerID !== null && drawerID !== undefined) {
        if (drawerID > 2147483647)
        {
          throw new Error('"drawerID" should satisfy the constraint - "InclusiveMaximum": 2147483647');
        }
        if (drawerID < 1)
        {
          throw new Error('"drawerID" should satisfy the constraint - "InclusiveMinimum": 1');
        }
      }
      if (name !== null && name !== undefined && typeof name.valueOf() !== 'string') {
        throw new Error('name must be of type string.');
      }
      if (name !== null && name !== undefined) {
        if (name.length > 255)
        {
          throw new Error('"name" should satisfy the constraint - "MaxLength": 255');
        }
        if (name.length < 0)
        {
          throw new Error('"name" should satisfy the constraint - "MinLength": 0');
        }
      }
      if (category !== null && category !== undefined && typeof category.valueOf() !== 'string') {
        throw new Error('category must be of type string.');
      }
      if (category !== null && category !== undefined) {
        if (category.length > 255)
        {
          throw new Error('"category" should satisfy the constraint - "MaxLength": 255');
        }
        if (category.length < 0)
        {
          throw new Error('"category" should satisfy the constraint - "MinLength": 0');
        }
      }
      if (page !== null && page !== undefined && typeof page !== 'number') {
        throw new Error('page must be of type number.');
      }
      if (page !== null && page !== undefined) {
        if (page > 2147483647)
        {
          throw new Error('"page" should satisfy the constraint - "InclusiveMaximum": 2147483647');
        }
        if (page < 1)
        {
          throw new Error('"page" should satisfy the constraint - "InclusiveMinimum": 1');
        }
      }
      if (pageSize !== null && pageSize !== undefined && typeof pageSize !== 'number') {
        throw new Error('pageSize must be of type number.');
      }
      if (pageSize !== null && pageSize !== undefined) {
        if (pageSize > 1000)
        {
          throw new Error('"pageSize" should satisfy the constraint - "InclusiveMaximum": 1000');
        }
        if (pageSize < 1)
        {
          throw new Error('"pageSize" should satisfy the constraint - "InclusiveMinimum": 1');
        }
      }
      if (sortOrder !== null && sortOrder !== undefined && typeof sortOrder.valueOf() !== 'string') {
        throw new Error('sortOrder must be of type string.');
      }
      if (sortBy !== null && sortBy !== undefined && typeof sortBy !== 'number') {
        throw new Error('sortBy must be of type number.');
      }
    } catch (error) {
      return Promise.reject(error);
    }

    // Construct URL
    let baseUrl = this.baseUri;
    let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'v1/template/ftl';
    let queryParamsArray: Array<any> = [];
    if (drawerID !== null && drawerID !== undefined) {
      queryParamsArray.push('drawerID=' + encodeURIComponent(drawerID.toString()));
    }
    if (name !== null && name !== undefined) {
      queryParamsArray.push('name=' + encodeURIComponent(name));
    }
    if (category !== null && category !== undefined) {
      queryParamsArray.push('category=' + encodeURIComponent(category));
    }
    if (page !== null && page !== undefined) {
      queryParamsArray.push('page=' + encodeURIComponent(page.toString()));
    }
    if (pageSize !== null && pageSize !== undefined) {
      queryParamsArray.push('pageSize=' + encodeURIComponent(pageSize.toString()));
    }
    if (sortOrder !== null && sortOrder !== undefined) {
      queryParamsArray.push('sortOrder=' + encodeURIComponent(sortOrder));
    }
    if (sortBy !== null && sortBy !== undefined) {
      queryParamsArray.push('sortBy=' + encodeURIComponent(sortBy.toString()));
    }
    if (queryParamsArray.length > 0) {
      requestUrl += '?' + queryParamsArray.join('&');
    }

    // Create HTTP transport objects
    let httpRequest = new WebResource();
    httpRequest.method = 'GET';
    httpRequest.url = requestUrl;
    httpRequest.headers = {};
    // Set Headers
    httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
    if(options && options.customHeaders) {
      for(let headerName in options.customHeaders) {
        if (options.customHeaders.hasOwnProperty(headerName)) {
          httpRequest.headers[headerName] = options.customHeaders[headerName];
        }
      }
    }
    // Send Request
    let operationRes: msRest.HttpOperationResponse;
    try {
      operationRes = await client.pipeline(httpRequest);
      let response = operationRes.response;
      let statusCode = response.status;
      if (statusCode !== 200) {
        let error = new msRest.RestError(operationRes.bodyAsText as string);
        error.statusCode = response.status;
        error.request = msRest.stripRequest(httpRequest);
        error.response = msRest.stripResponse(response);
        let parsedErrorResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedErrorResponse) {
            let internalError = null;
            if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
            error.code = internalError ? internalError.code : parsedErrorResponse.code;
            error.message = internalError ? internalError.message : parsedErrorResponse.message;
          }
        } catch (defaultError) {
          error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                           `- "${operationRes.bodyAsText}" for the default response.`;
          return Promise.reject(error);
        }
        return Promise.reject(error);
      }
      // Deserialize Response
      if (statusCode === 200) {
        let parsedResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedResponse !== null && parsedResponse !== undefined) {
            let resultMapper = {
              required: false,
              serializedName: 'parsedResponse',
              type: {
                name: 'Sequence',
                element: {
                    required: false,
                    serializedName: 'EntityDefinitionModelElementType',
                    type: {
                      name: 'Composite',
                      className: 'EntityDefinitionModel'
                    }
                }
              }
            };
            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
          }
        } catch (error) {
          let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
          deserializationError.request = msRest.stripRequest(httpRequest);
          deserializationError.response = msRest.stripResponse(response);
          return Promise.reject(deserializationError);
        }
      }

    } catch(err) {
      return Promise.reject(err);
    }

    return Promise.resolve(operationRes);
  }
  // methods on the client.

  /**
   * @summary Creates a new entity template definition.
   *
   * @param {EntityDefinitionBase} model The entity template model.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  async createTemplateWithHttpOperationResponse(model: Models.EntityDefinitionBase, options?: msRest.RequestOptionsBase): Promise<msRest.HttpOperationResponse> {
    let client = this;
    // Validate
    try {
      if (model === null || model === undefined) {
        throw new Error('model cannot be null or undefined.');
      }
    } catch (error) {
      return Promise.reject(error);
    }

    // Construct URL
    let baseUrl = this.baseUri;
    let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'v1/template/ftl';

    // Create HTTP transport objects
    let httpRequest = new WebResource();
    httpRequest.method = 'POST';
    httpRequest.url = requestUrl;
    httpRequest.headers = {};
    // Set Headers
    httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
    if(options && options.customHeaders) {
      for(let headerName in options.customHeaders) {
        if (options.customHeaders.hasOwnProperty(headerName)) {
          httpRequest.headers[headerName] = options.customHeaders[headerName];
        }
      }
    }
    // Serialize Request
    let requestContent = null;
    let requestModel = null;
    try {
      if (model !== null && model !== undefined) {
        let requestModelMapper = Mappers.EntityDefinitionBase;
        requestModel = client.serializer.serialize(requestModelMapper, model, 'model');
        requestContent = JSON.stringify(requestModel);
      }
    } catch (error) {
      let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
          `payload - ${JSON.stringify(model, null, 2)}.`);
      return Promise.reject(serializationError);
    }
    httpRequest.body = requestContent;
    // Send Request
    let operationRes: msRest.HttpOperationResponse;
    try {
      operationRes = await client.pipeline(httpRequest);
      let response = operationRes.response;
      let statusCode = response.status;
      if (statusCode !== 201 && statusCode !== 403 && statusCode !== 404 && statusCode !== 409) {
        let error = new msRest.RestError(operationRes.bodyAsText as string);
        error.statusCode = response.status;
        error.request = msRest.stripRequest(httpRequest);
        error.response = msRest.stripResponse(response);
        let parsedErrorResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedErrorResponse) {
            let internalError = null;
            if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
            error.code = internalError ? internalError.code : parsedErrorResponse.code;
            error.message = internalError ? internalError.message : parsedErrorResponse.message;
          }
        } catch (defaultError) {
          error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                           `- "${operationRes.bodyAsText}" for the default response.`;
          return Promise.reject(error);
        }
        return Promise.reject(error);
      }
      // Deserialize Response
      if (statusCode === 201) {
        let parsedResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedResponse !== null && parsedResponse !== undefined) {
            let resultMapper = Mappers.EntityDefinitionModel;
            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
          }
        } catch (error) {
          let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
          deserializationError.request = msRest.stripRequest(httpRequest);
          deserializationError.response = msRest.stripResponse(response);
          return Promise.reject(deserializationError);
        }
      }

    } catch(err) {
      return Promise.reject(err);
    }

    return Promise.resolve(operationRes);
  }
  // methods on the client.

  /**
   * @summary Gets a single entity template definition by its type.
   *
   * @param {number} type The unique template type.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  async getTemplateByTypeWithHttpOperationResponse(type: number, options?: msRest.RequestOptionsBase): Promise<msRest.HttpOperationResponse> {
    let client = this;
    // Validate
    try {
      if (type === null || type === undefined || typeof type !== 'number') {
        throw new Error('type cannot be null or undefined and it must be of type number.');
      }
    } catch (error) {
      return Promise.reject(error);
    }

    // Construct URL
    let baseUrl = this.baseUri;
    let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'v1/template/ftl/{type}';
    requestUrl = requestUrl.replace('{type}', encodeURIComponent(type.toString()));

    // Create HTTP transport objects
    let httpRequest = new WebResource();
    httpRequest.method = 'GET';
    httpRequest.url = requestUrl;
    httpRequest.headers = {};
    // Set Headers
    httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
    if(options && options.customHeaders) {
      for(let headerName in options.customHeaders) {
        if (options.customHeaders.hasOwnProperty(headerName)) {
          httpRequest.headers[headerName] = options.customHeaders[headerName];
        }
      }
    }
    // Send Request
    let operationRes: msRest.HttpOperationResponse;
    try {
      operationRes = await client.pipeline(httpRequest);
      let response = operationRes.response;
      let statusCode = response.status;
      if (statusCode !== 200 && statusCode !== 404) {
        let error = new msRest.RestError(operationRes.bodyAsText as string);
        error.statusCode = response.status;
        error.request = msRest.stripRequest(httpRequest);
        error.response = msRest.stripResponse(response);
        let parsedErrorResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedErrorResponse) {
            let internalError = null;
            if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
            error.code = internalError ? internalError.code : parsedErrorResponse.code;
            error.message = internalError ? internalError.message : parsedErrorResponse.message;
          }
        } catch (defaultError) {
          error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                           `- "${operationRes.bodyAsText}" for the default response.`;
          return Promise.reject(error);
        }
        return Promise.reject(error);
      }
      // Deserialize Response
      if (statusCode === 200) {
        let parsedResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedResponse !== null && parsedResponse !== undefined) {
            let resultMapper = Mappers.EntityDefinitionModel;
            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
          }
        } catch (error) {
          let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
          deserializationError.request = msRest.stripRequest(httpRequest);
          deserializationError.response = msRest.stripResponse(response);
          return Promise.reject(deserializationError);
        }
      }

    } catch(err) {
      return Promise.reject(err);
    }

    return Promise.resolve(operationRes);
  }
  // methods on the client.

  /**
   * @summary Updates a specified entity template definition by type.
   *
   * @param {number} type The unique template type.
   *
   * @param {UpdateEntityDefinitionRequestModel} model The entity template model.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  async updateTemplateByTypeWithHttpOperationResponse(type: number, model: Models.UpdateEntityDefinitionRequestModel, options?: msRest.RequestOptionsBase): Promise<msRest.HttpOperationResponse> {
    let client = this;
    // Validate
    try {
      if (type === null || type === undefined || typeof type !== 'number') {
        throw new Error('type cannot be null or undefined and it must be of type number.');
      }
      if (model === null || model === undefined) {
        throw new Error('model cannot be null or undefined.');
      }
    } catch (error) {
      return Promise.reject(error);
    }

    // Construct URL
    let baseUrl = this.baseUri;
    let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'v1/template/ftl/{type}';
    requestUrl = requestUrl.replace('{type}', encodeURIComponent(type.toString()));

    // Create HTTP transport objects
    let httpRequest = new WebResource();
    httpRequest.method = 'PUT';
    httpRequest.url = requestUrl;
    httpRequest.headers = {};
    // Set Headers
    httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
    if(options && options.customHeaders) {
      for(let headerName in options.customHeaders) {
        if (options.customHeaders.hasOwnProperty(headerName)) {
          httpRequest.headers[headerName] = options.customHeaders[headerName];
        }
      }
    }
    // Serialize Request
    let requestContent = null;
    let requestModel = null;
    try {
      if (model !== null && model !== undefined) {
        let requestModelMapper = Mappers.UpdateEntityDefinitionRequestModel;
        requestModel = client.serializer.serialize(requestModelMapper, model, 'model');
        requestContent = JSON.stringify(requestModel);
      }
    } catch (error) {
      let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
          `payload - ${JSON.stringify(model, null, 2)}.`);
      return Promise.reject(serializationError);
    }
    httpRequest.body = requestContent;
    // Send Request
    let operationRes: msRest.HttpOperationResponse;
    try {
      operationRes = await client.pipeline(httpRequest);
      let response = operationRes.response;
      let statusCode = response.status;
      if (statusCode !== 204 && statusCode !== 403 && statusCode !== 404) {
        let error = new msRest.RestError(operationRes.bodyAsText as string);
        error.statusCode = response.status;
        error.request = msRest.stripRequest(httpRequest);
        error.response = msRest.stripResponse(response);
        let parsedErrorResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedErrorResponse) {
            let internalError = null;
            if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
            error.code = internalError ? internalError.code : parsedErrorResponse.code;
            error.message = internalError ? internalError.message : parsedErrorResponse.message;
          }
        } catch (defaultError) {
          error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                           `- "${operationRes.bodyAsText}" for the default response.`;
          return Promise.reject(error);
        }
        return Promise.reject(error);
      }
      // Deserialize Response
      if (statusCode === 204) {
        let parsedResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedResponse !== null && parsedResponse !== undefined) {
            let resultMapper = {
              required: false,
              serializedName: 'parsedResponse',
              type: {
                name: 'Object'
              }
            };
            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
          }
        } catch (error) {
          let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
          deserializationError.request = msRest.stripRequest(httpRequest);
          deserializationError.response = msRest.stripResponse(response);
          return Promise.reject(deserializationError);
        }
      }

    } catch(err) {
      return Promise.reject(err);
    }

    return Promise.resolve(operationRes);
  }
  // methods on the client.

  /**
   * @summary Deletes a specified entity template definition by type.
   *
   * @param {number} type The unique template type.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  async deleteTemplateByTypeWithHttpOperationResponse(type: number, options?: msRest.RequestOptionsBase): Promise<msRest.HttpOperationResponse> {
    let client = this;
    // Validate
    try {
      if (type === null || type === undefined || typeof type !== 'number') {
        throw new Error('type cannot be null or undefined and it must be of type number.');
      }
    } catch (error) {
      return Promise.reject(error);
    }

    // Construct URL
    let baseUrl = this.baseUri;
    let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'v1/template/ftl/{type}';
    requestUrl = requestUrl.replace('{type}', encodeURIComponent(type.toString()));

    // Create HTTP transport objects
    let httpRequest = new WebResource();
    httpRequest.method = 'DELETE';
    httpRequest.url = requestUrl;
    httpRequest.headers = {};
    // Set Headers
    httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
    if(options && options.customHeaders) {
      for(let headerName in options.customHeaders) {
        if (options.customHeaders.hasOwnProperty(headerName)) {
          httpRequest.headers[headerName] = options.customHeaders[headerName];
        }
      }
    }
    // Send Request
    let operationRes: msRest.HttpOperationResponse;
    try {
      operationRes = await client.pipeline(httpRequest);
      let response = operationRes.response;
      let statusCode = response.status;
      if (statusCode !== 204 && statusCode !== 403 && statusCode !== 404) {
        let error = new msRest.RestError(operationRes.bodyAsText as string);
        error.statusCode = response.status;
        error.request = msRest.stripRequest(httpRequest);
        error.response = msRest.stripResponse(response);
        let parsedErrorResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedErrorResponse) {
            let internalError = null;
            if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
            error.code = internalError ? internalError.code : parsedErrorResponse.code;
            error.message = internalError ? internalError.message : parsedErrorResponse.message;
          }
        } catch (defaultError) {
          error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                           `- "${operationRes.bodyAsText}" for the default response.`;
          return Promise.reject(error);
        }
        return Promise.reject(error);
      }
      // Deserialize Response
      if (statusCode === 204) {
        let parsedResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedResponse !== null && parsedResponse !== undefined) {
            let resultMapper = {
              required: false,
              serializedName: 'parsedResponse',
              type: {
                name: 'Object'
              }
            };
            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
          }
        } catch (error) {
          let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
          deserializationError.request = msRest.stripRequest(httpRequest);
          deserializationError.response = msRest.stripResponse(response);
          return Promise.reject(deserializationError);
        }
      }

    } catch(err) {
      return Promise.reject(err);
    }

    return Promise.resolve(operationRes);
  }
  // methods on the client.

  /**
   * @summary Gets a single entity template definition by its unique identifier.
   *
   * @param {string} id The template identifier.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  async getTemplateByIdWithHttpOperationResponse(id: string, options?: msRest.RequestOptionsBase): Promise<msRest.HttpOperationResponse> {
    let client = this;
    // Validate
    try {
      if (id === null || id === undefined || typeof id.valueOf() !== 'string') {
        throw new Error('id cannot be null or undefined and it must be of type string.');
      }
    } catch (error) {
      return Promise.reject(error);
    }

    // Construct URL
    let baseUrl = this.baseUri;
    let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'v1/template/ftl/{id}';
    requestUrl = requestUrl.replace('{id}', encodeURIComponent(id));

    // Create HTTP transport objects
    let httpRequest = new WebResource();
    httpRequest.method = 'GET';
    httpRequest.url = requestUrl;
    httpRequest.headers = {};
    // Set Headers
    httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
    if(options && options.customHeaders) {
      for(let headerName in options.customHeaders) {
        if (options.customHeaders.hasOwnProperty(headerName)) {
          httpRequest.headers[headerName] = options.customHeaders[headerName];
        }
      }
    }
    // Send Request
    let operationRes: msRest.HttpOperationResponse;
    try {
      operationRes = await client.pipeline(httpRequest);
      let response = operationRes.response;
      let statusCode = response.status;
      if (statusCode !== 200 && statusCode !== 404) {
        let error = new msRest.RestError(operationRes.bodyAsText as string);
        error.statusCode = response.status;
        error.request = msRest.stripRequest(httpRequest);
        error.response = msRest.stripResponse(response);
        let parsedErrorResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedErrorResponse) {
            let internalError = null;
            if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
            error.code = internalError ? internalError.code : parsedErrorResponse.code;
            error.message = internalError ? internalError.message : parsedErrorResponse.message;
          }
        } catch (defaultError) {
          error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                           `- "${operationRes.bodyAsText}" for the default response.`;
          return Promise.reject(error);
        }
        return Promise.reject(error);
      }
      // Deserialize Response
      if (statusCode === 200) {
        let parsedResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedResponse !== null && parsedResponse !== undefined) {
            let resultMapper = Mappers.EntityDefinitionModel;
            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
          }
        } catch (error) {
          let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
          deserializationError.request = msRest.stripRequest(httpRequest);
          deserializationError.response = msRest.stripResponse(response);
          return Promise.reject(deserializationError);
        }
      }

    } catch(err) {
      return Promise.reject(err);
    }

    return Promise.resolve(operationRes);
  }
  // methods on the client.

  /**
   * @summary Updates a specified entity template definition by identifier.
   *
   * @param {string} id The unique template identifier.
   *
   * @param {UpdateEntityDefinitionRequestModel} model The entity template model.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  async updateTemplateByIdWithHttpOperationResponse(id: string, model: Models.UpdateEntityDefinitionRequestModel, options?: msRest.RequestOptionsBase): Promise<msRest.HttpOperationResponse> {
    let client = this;
    // Validate
    try {
      if (id === null || id === undefined || typeof id.valueOf() !== 'string') {
        throw new Error('id cannot be null or undefined and it must be of type string.');
      }
      if (model === null || model === undefined) {
        throw new Error('model cannot be null or undefined.');
      }
    } catch (error) {
      return Promise.reject(error);
    }

    // Construct URL
    let baseUrl = this.baseUri;
    let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'v1/template/ftl/{id}';
    requestUrl = requestUrl.replace('{id}', encodeURIComponent(id));

    // Create HTTP transport objects
    let httpRequest = new WebResource();
    httpRequest.method = 'PUT';
    httpRequest.url = requestUrl;
    httpRequest.headers = {};
    // Set Headers
    httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
    if(options && options.customHeaders) {
      for(let headerName in options.customHeaders) {
        if (options.customHeaders.hasOwnProperty(headerName)) {
          httpRequest.headers[headerName] = options.customHeaders[headerName];
        }
      }
    }
    // Serialize Request
    let requestContent = null;
    let requestModel = null;
    try {
      if (model !== null && model !== undefined) {
        let requestModelMapper = Mappers.UpdateEntityDefinitionRequestModel;
        requestModel = client.serializer.serialize(requestModelMapper, model, 'model');
        requestContent = JSON.stringify(requestModel);
      }
    } catch (error) {
      let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
          `payload - ${JSON.stringify(model, null, 2)}.`);
      return Promise.reject(serializationError);
    }
    httpRequest.body = requestContent;
    // Send Request
    let operationRes: msRest.HttpOperationResponse;
    try {
      operationRes = await client.pipeline(httpRequest);
      let response = operationRes.response;
      let statusCode = response.status;
      if (statusCode !== 204 && statusCode !== 403 && statusCode !== 404) {
        let error = new msRest.RestError(operationRes.bodyAsText as string);
        error.statusCode = response.status;
        error.request = msRest.stripRequest(httpRequest);
        error.response = msRest.stripResponse(response);
        let parsedErrorResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedErrorResponse) {
            let internalError = null;
            if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
            error.code = internalError ? internalError.code : parsedErrorResponse.code;
            error.message = internalError ? internalError.message : parsedErrorResponse.message;
          }
        } catch (defaultError) {
          error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                           `- "${operationRes.bodyAsText}" for the default response.`;
          return Promise.reject(error);
        }
        return Promise.reject(error);
      }
      // Deserialize Response
      if (statusCode === 204) {
        let parsedResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedResponse !== null && parsedResponse !== undefined) {
            let resultMapper = {
              required: false,
              serializedName: 'parsedResponse',
              type: {
                name: 'Object'
              }
            };
            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
          }
        } catch (error) {
          let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
          deserializationError.request = msRest.stripRequest(httpRequest);
          deserializationError.response = msRest.stripResponse(response);
          return Promise.reject(deserializationError);
        }
      }

    } catch(err) {
      return Promise.reject(err);
    }

    return Promise.resolve(operationRes);
  }
  // methods on the client.

  /**
   * @summary Deletes a specified entity template definition by identifier.
   *
   * @param {string} id The unique template identifier.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  async deleteTemplateByIdWithHttpOperationResponse(id: string, options?: msRest.RequestOptionsBase): Promise<msRest.HttpOperationResponse> {
    let client = this;
    // Validate
    try {
      if (id === null || id === undefined || typeof id.valueOf() !== 'string') {
        throw new Error('id cannot be null or undefined and it must be of type string.');
      }
    } catch (error) {
      return Promise.reject(error);
    }

    // Construct URL
    let baseUrl = this.baseUri;
    let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'v1/template/ftl/{id}';
    requestUrl = requestUrl.replace('{id}', encodeURIComponent(id));

    // Create HTTP transport objects
    let httpRequest = new WebResource();
    httpRequest.method = 'DELETE';
    httpRequest.url = requestUrl;
    httpRequest.headers = {};
    // Set Headers
    httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
    if(options && options.customHeaders) {
      for(let headerName in options.customHeaders) {
        if (options.customHeaders.hasOwnProperty(headerName)) {
          httpRequest.headers[headerName] = options.customHeaders[headerName];
        }
      }
    }
    // Send Request
    let operationRes: msRest.HttpOperationResponse;
    try {
      operationRes = await client.pipeline(httpRequest);
      let response = operationRes.response;
      let statusCode = response.status;
      if (statusCode !== 204 && statusCode !== 403 && statusCode !== 404) {
        let error = new msRest.RestError(operationRes.bodyAsText as string);
        error.statusCode = response.status;
        error.request = msRest.stripRequest(httpRequest);
        error.response = msRest.stripResponse(response);
        let parsedErrorResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedErrorResponse) {
            let internalError = null;
            if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
            error.code = internalError ? internalError.code : parsedErrorResponse.code;
            error.message = internalError ? internalError.message : parsedErrorResponse.message;
          }
        } catch (defaultError) {
          error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                           `- "${operationRes.bodyAsText}" for the default response.`;
          return Promise.reject(error);
        }
        return Promise.reject(error);
      }
      // Deserialize Response
      if (statusCode === 204) {
        let parsedResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedResponse !== null && parsedResponse !== undefined) {
            let resultMapper = {
              required: false,
              serializedName: 'parsedResponse',
              type: {
                name: 'Object'
              }
            };
            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
          }
        } catch (error) {
          let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
          deserializationError.request = msRest.stripRequest(httpRequest);
          deserializationError.response = msRest.stripResponse(response);
          return Promise.reject(deserializationError);
        }
      }

    } catch(err) {
      return Promise.reject(err);
    }

    return Promise.resolve(operationRes);
  }
  // methods on the client.

  /**
   * @summary Validates the specified template field.
   *
   * @param {number} type The template type.
   *
   * @param {string} fieldID The field name.
   *
   * @param {SoftheonEnterpriseAPIValidateTemplateFieldOptionalParams} [options]
   * Optional Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  async validateTemplateFieldWithHttpOperationResponse(type: number, fieldID: string, options?: Models.SoftheonEnterpriseAPIValidateTemplateFieldOptionalParams): Promise<msRest.HttpOperationResponse> {
    let client = this;
    let sortColumn = (options && options.sortColumn !== undefined) ? options.sortColumn : undefined;
    let metadata = (options && options.metadata !== undefined) ? options.metadata : undefined;
    let page = (options && options.page !== undefined) ? options.page : undefined;
    let pageSize = (options && options.pageSize !== undefined) ? options.pageSize : undefined;
    let sortOrder = (options && options.sortOrder !== undefined) ? options.sortOrder : undefined;
    let sortBy = (options && options.sortBy !== undefined) ? options.sortBy : undefined;
    // Validate
    try {
      if (type === null || type === undefined || typeof type !== 'number') {
        throw new Error('type cannot be null or undefined and it must be of type number.');
      }
      if (fieldID === null || fieldID === undefined || typeof fieldID.valueOf() !== 'string') {
        throw new Error('fieldID cannot be null or undefined and it must be of type string.');
      }
      if (sortColumn !== null && sortColumn !== undefined && typeof sortColumn.valueOf() !== 'string') {
        throw new Error('sortColumn must be of type string.');
      }
      if (Array.isArray(metadata)) {
        for (let i = 0; i < metadata.length; i++) {
          if (metadata[i] !== null && metadata[i] !== undefined && typeof metadata[i] !== 'object') {
            throw new Error('metadata[i] must be of type object.');
          }
        }
      }
      if (page !== null && page !== undefined && typeof page !== 'number') {
        throw new Error('page must be of type number.');
      }
      if (page !== null && page !== undefined) {
        if (page > 2147483647)
        {
          throw new Error('"page" should satisfy the constraint - "InclusiveMaximum": 2147483647');
        }
        if (page < 1)
        {
          throw new Error('"page" should satisfy the constraint - "InclusiveMinimum": 1');
        }
      }
      if (pageSize !== null && pageSize !== undefined && typeof pageSize !== 'number') {
        throw new Error('pageSize must be of type number.');
      }
      if (pageSize !== null && pageSize !== undefined) {
        if (pageSize > 1000)
        {
          throw new Error('"pageSize" should satisfy the constraint - "InclusiveMaximum": 1000');
        }
        if (pageSize < 1)
        {
          throw new Error('"pageSize" should satisfy the constraint - "InclusiveMinimum": 1');
        }
      }
      if (sortOrder !== null && sortOrder !== undefined && typeof sortOrder.valueOf() !== 'string') {
        throw new Error('sortOrder must be of type string.');
      }
      if (sortBy !== null && sortBy !== undefined && typeof sortBy !== 'number') {
        throw new Error('sortBy must be of type number.');
      }
    } catch (error) {
      return Promise.reject(error);
    }

    // Construct URL
    let baseUrl = this.baseUri;
    let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'v1/template/ftl/{type}/validate/{fieldID}';
    requestUrl = requestUrl.replace('{type}', encodeURIComponent(type.toString()));
    requestUrl = requestUrl.replace('{fieldID}', encodeURIComponent(fieldID));
    let queryParamsArray: Array<any> = [];
    if (sortColumn !== null && sortColumn !== undefined) {
      queryParamsArray.push('sortColumn=' + encodeURIComponent(sortColumn));
    }
    if (metadata !== null && metadata !== undefined) {
      if (metadata.length == 0) {
        queryParamsArray.push('metadata=' + encodeURIComponent(''));
      } else {
        for (let item of metadata) {
          item = (item === null || item === undefined) ? '' : item;
          queryParamsArray.push('metadata=' + encodeURIComponent('' + item));
        }
      }
    }
    if (page !== null && page !== undefined) {
      queryParamsArray.push('page=' + encodeURIComponent(page.toString()));
    }
    if (pageSize !== null && pageSize !== undefined) {
      queryParamsArray.push('pageSize=' + encodeURIComponent(pageSize.toString()));
    }
    if (sortOrder !== null && sortOrder !== undefined) {
      queryParamsArray.push('sortOrder=' + encodeURIComponent(sortOrder));
    }
    if (sortBy !== null && sortBy !== undefined) {
      queryParamsArray.push('sortBy=' + encodeURIComponent(sortBy.toString()));
    }
    if (queryParamsArray.length > 0) {
      requestUrl += '?' + queryParamsArray.join('&');
    }

    // Create HTTP transport objects
    let httpRequest = new WebResource();
    httpRequest.method = 'GET';
    httpRequest.url = requestUrl;
    httpRequest.headers = {};
    // Set Headers
    httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
    if(options && options.customHeaders) {
      for(let headerName in options.customHeaders) {
        if (options.customHeaders.hasOwnProperty(headerName)) {
          httpRequest.headers[headerName] = options.customHeaders[headerName];
        }
      }
    }
    // Send Request
    let operationRes: msRest.HttpOperationResponse;
    try {
      operationRes = await client.pipeline(httpRequest);
      let response = operationRes.response;
      let statusCode = response.status;
      if (statusCode !== 200 && statusCode !== 404) {
        let error = new msRest.RestError(operationRes.bodyAsText as string);
        error.statusCode = response.status;
        error.request = msRest.stripRequest(httpRequest);
        error.response = msRest.stripResponse(response);
        let parsedErrorResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedErrorResponse) {
            let internalError = null;
            if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
            error.code = internalError ? internalError.code : parsedErrorResponse.code;
            error.message = internalError ? internalError.message : parsedErrorResponse.message;
          }
        } catch (defaultError) {
          error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                           `- "${operationRes.bodyAsText}" for the default response.`;
          return Promise.reject(error);
        }
        return Promise.reject(error);
      }
      // Deserialize Response
      if (statusCode === 200) {
        let parsedResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedResponse !== null && parsedResponse !== undefined) {
            let resultMapper = Mappers.FieldValidationModel;
            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
          }
        } catch (error) {
          let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
          deserializationError.request = msRest.stripRequest(httpRequest);
          deserializationError.response = msRest.stripResponse(response);
          return Promise.reject(deserializationError);
        }
      }

    } catch(err) {
      return Promise.reject(err);
    }

    return Promise.resolve(operationRes);
  }
  // methods on the client.

  /**
   * @summary Gets a paged list of groups.
   *
   * @param {SoftheonEnterpriseAPIGetGroupsByFilterOptionalParams} [options]
   * Optional Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  async getGroupsByFilterWithHttpOperationResponse(options?: Models.SoftheonEnterpriseAPIGetGroupsByFilterOptionalParams): Promise<msRest.HttpOperationResponse> {
    let client = this;
    let iD = (options && options.iD !== undefined) ? options.iD : undefined;
    let userID = (options && options.userID !== undefined) ? options.userID : undefined;
    let name = (options && options.name !== undefined) ? options.name : undefined;
    let type = (options && options.type !== undefined) ? options.type : undefined;
    let state = (options && options.state !== undefined) ? options.state : undefined;
    let page = (options && options.page !== undefined) ? options.page : undefined;
    let pageSize = (options && options.pageSize !== undefined) ? options.pageSize : undefined;
    let sortOrder = (options && options.sortOrder !== undefined) ? options.sortOrder : undefined;
    let sortBy = (options && options.sortBy !== undefined) ? options.sortBy : undefined;
    // Validate
    try {
      if (iD !== null && iD !== undefined && typeof iD !== 'number') {
        throw new Error('iD must be of type number.');
      }
      if (iD !== null && iD !== undefined) {
        if (iD > 2147483647)
        {
          throw new Error('"iD" should satisfy the constraint - "InclusiveMaximum": 2147483647');
        }
        if (iD < 1)
        {
          throw new Error('"iD" should satisfy the constraint - "InclusiveMinimum": 1');
        }
      }
      if (userID !== null && userID !== undefined && typeof userID !== 'number') {
        throw new Error('userID must be of type number.');
      }
      if (userID !== null && userID !== undefined) {
        if (userID > 2147483647)
        {
          throw new Error('"userID" should satisfy the constraint - "InclusiveMaximum": 2147483647');
        }
        if (userID < 1)
        {
          throw new Error('"userID" should satisfy the constraint - "InclusiveMinimum": 1');
        }
      }
      if (name !== null && name !== undefined && typeof name.valueOf() !== 'string') {
        throw new Error('name must be of type string.');
      }
      if (name !== null && name !== undefined) {
        if (name.length > 255)
        {
          throw new Error('"name" should satisfy the constraint - "MaxLength": 255');
        }
        if (name.length < 0)
        {
          throw new Error('"name" should satisfy the constraint - "MinLength": 0');
        }
      }
      if (type !== null && type !== undefined && typeof type.valueOf() !== 'string') {
        throw new Error('type must be of type string.');
      }
      if (state !== null && state !== undefined && typeof state.valueOf() !== 'string') {
        throw new Error('state must be of type string.');
      }
      if (page !== null && page !== undefined && typeof page !== 'number') {
        throw new Error('page must be of type number.');
      }
      if (page !== null && page !== undefined) {
        if (page > 2147483647)
        {
          throw new Error('"page" should satisfy the constraint - "InclusiveMaximum": 2147483647');
        }
        if (page < 1)
        {
          throw new Error('"page" should satisfy the constraint - "InclusiveMinimum": 1');
        }
      }
      if (pageSize !== null && pageSize !== undefined && typeof pageSize !== 'number') {
        throw new Error('pageSize must be of type number.');
      }
      if (pageSize !== null && pageSize !== undefined) {
        if (pageSize > 1000)
        {
          throw new Error('"pageSize" should satisfy the constraint - "InclusiveMaximum": 1000');
        }
        if (pageSize < 1)
        {
          throw new Error('"pageSize" should satisfy the constraint - "InclusiveMinimum": 1');
        }
      }
      if (sortOrder !== null && sortOrder !== undefined && typeof sortOrder.valueOf() !== 'string') {
        throw new Error('sortOrder must be of type string.');
      }
      if (sortBy !== null && sortBy !== undefined && typeof sortBy.valueOf() !== 'string') {
        throw new Error('sortBy must be of type string.');
      }
    } catch (error) {
      return Promise.reject(error);
    }

    // Construct URL
    let baseUrl = this.baseUri;
    let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'v1/directory/groups';
    let queryParamsArray: Array<any> = [];
    if (iD !== null && iD !== undefined) {
      queryParamsArray.push('iD=' + encodeURIComponent(iD.toString()));
    }
    if (userID !== null && userID !== undefined) {
      queryParamsArray.push('userID=' + encodeURIComponent(userID.toString()));
    }
    if (name !== null && name !== undefined) {
      queryParamsArray.push('name=' + encodeURIComponent(name));
    }
    if (type !== null && type !== undefined) {
      queryParamsArray.push('type=' + encodeURIComponent(type));
    }
    if (state !== null && state !== undefined) {
      queryParamsArray.push('state=' + encodeURIComponent(state));
    }
    if (page !== null && page !== undefined) {
      queryParamsArray.push('page=' + encodeURIComponent(page.toString()));
    }
    if (pageSize !== null && pageSize !== undefined) {
      queryParamsArray.push('pageSize=' + encodeURIComponent(pageSize.toString()));
    }
    if (sortOrder !== null && sortOrder !== undefined) {
      queryParamsArray.push('sortOrder=' + encodeURIComponent(sortOrder));
    }
    if (sortBy !== null && sortBy !== undefined) {
      queryParamsArray.push('sortBy=' + encodeURIComponent(sortBy));
    }
    if (queryParamsArray.length > 0) {
      requestUrl += '?' + queryParamsArray.join('&');
    }

    // Create HTTP transport objects
    let httpRequest = new WebResource();
    httpRequest.method = 'GET';
    httpRequest.url = requestUrl;
    httpRequest.headers = {};
    // Set Headers
    httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
    if(options && options.customHeaders) {
      for(let headerName in options.customHeaders) {
        if (options.customHeaders.hasOwnProperty(headerName)) {
          httpRequest.headers[headerName] = options.customHeaders[headerName];
        }
      }
    }
    // Send Request
    let operationRes: msRest.HttpOperationResponse;
    try {
      operationRes = await client.pipeline(httpRequest);
      let response = operationRes.response;
      let statusCode = response.status;
      if (statusCode !== 200 && statusCode !== 403) {
        let error = new msRest.RestError(operationRes.bodyAsText as string);
        error.statusCode = response.status;
        error.request = msRest.stripRequest(httpRequest);
        error.response = msRest.stripResponse(response);
        let parsedErrorResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedErrorResponse) {
            let internalError = null;
            if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
            error.code = internalError ? internalError.code : parsedErrorResponse.code;
            error.message = internalError ? internalError.message : parsedErrorResponse.message;
          }
        } catch (defaultError) {
          error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                           `- "${operationRes.bodyAsText}" for the default response.`;
          return Promise.reject(error);
        }
        return Promise.reject(error);
      }
      // Deserialize Response
      if (statusCode === 200) {
        let parsedResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedResponse !== null && parsedResponse !== undefined) {
            let resultMapper = {
              required: false,
              serializedName: 'parsedResponse',
              type: {
                name: 'Sequence',
                element: {
                    required: false,
                    serializedName: 'GroupModelElementType',
                    type: {
                      name: 'Composite',
                      className: 'GroupModel'
                    }
                }
              }
            };
            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
          }
        } catch (error) {
          let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
          deserializationError.request = msRest.stripRequest(httpRequest);
          deserializationError.response = msRest.stripResponse(response);
          return Promise.reject(deserializationError);
        }
      }

    } catch(err) {
      return Promise.reject(err);
    }

    return Promise.resolve(operationRes);
  }
  // methods on the client.

  /**
   * @summary Creates a new group.
   *
   * @param {InsertGroupRequestModel} model The group model.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  async createGroupWithHttpOperationResponse(model: Models.InsertGroupRequestModel, options?: msRest.RequestOptionsBase): Promise<msRest.HttpOperationResponse> {
    let client = this;
    // Validate
    try {
      if (model === null || model === undefined) {
        throw new Error('model cannot be null or undefined.');
      }
    } catch (error) {
      return Promise.reject(error);
    }

    // Construct URL
    let baseUrl = this.baseUri;
    let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'v1/directory/groups';

    // Create HTTP transport objects
    let httpRequest = new WebResource();
    httpRequest.method = 'POST';
    httpRequest.url = requestUrl;
    httpRequest.headers = {};
    // Set Headers
    httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
    if(options && options.customHeaders) {
      for(let headerName in options.customHeaders) {
        if (options.customHeaders.hasOwnProperty(headerName)) {
          httpRequest.headers[headerName] = options.customHeaders[headerName];
        }
      }
    }
    // Serialize Request
    let requestContent = null;
    let requestModel = null;
    try {
      if (model !== null && model !== undefined) {
        let requestModelMapper = Mappers.InsertGroupRequestModel;
        requestModel = client.serializer.serialize(requestModelMapper, model, 'model');
        requestContent = JSON.stringify(requestModel);
      }
    } catch (error) {
      let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
          `payload - ${JSON.stringify(model, null, 2)}.`);
      return Promise.reject(serializationError);
    }
    httpRequest.body = requestContent;
    // Send Request
    let operationRes: msRest.HttpOperationResponse;
    try {
      operationRes = await client.pipeline(httpRequest);
      let response = operationRes.response;
      let statusCode = response.status;
      if (statusCode !== 201 && statusCode !== 403 && statusCode !== 409) {
        let error = new msRest.RestError(operationRes.bodyAsText as string);
        error.statusCode = response.status;
        error.request = msRest.stripRequest(httpRequest);
        error.response = msRest.stripResponse(response);
        let parsedErrorResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedErrorResponse) {
            let internalError = null;
            if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
            error.code = internalError ? internalError.code : parsedErrorResponse.code;
            error.message = internalError ? internalError.message : parsedErrorResponse.message;
          }
        } catch (defaultError) {
          error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                           `- "${operationRes.bodyAsText}" for the default response.`;
          return Promise.reject(error);
        }
        return Promise.reject(error);
      }
      // Deserialize Response
      if (statusCode === 201) {
        let parsedResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedResponse !== null && parsedResponse !== undefined) {
            let resultMapper = Mappers.GroupModel;
            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
          }
        } catch (error) {
          let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
          deserializationError.request = msRest.stripRequest(httpRequest);
          deserializationError.response = msRest.stripResponse(response);
          return Promise.reject(deserializationError);
        }
      }

    } catch(err) {
      return Promise.reject(err);
    }

    return Promise.resolve(operationRes);
  }
  // methods on the client.

  /**
   * @summary Gets a single group by its unique identifier.
   *
   * @param {number} id The group identifier.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  async getGroupByIdWithHttpOperationResponse(id: number, options?: msRest.RequestOptionsBase): Promise<msRest.HttpOperationResponse> {
    let client = this;
    // Validate
    try {
      if (id === null || id === undefined || typeof id !== 'number') {
        throw new Error('id cannot be null or undefined and it must be of type number.');
      }
    } catch (error) {
      return Promise.reject(error);
    }

    // Construct URL
    let baseUrl = this.baseUri;
    let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'v1/directory/groups/{id}';
    requestUrl = requestUrl.replace('{id}', encodeURIComponent(id.toString()));

    // Create HTTP transport objects
    let httpRequest = new WebResource();
    httpRequest.method = 'GET';
    httpRequest.url = requestUrl;
    httpRequest.headers = {};
    // Set Headers
    httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
    if(options && options.customHeaders) {
      for(let headerName in options.customHeaders) {
        if (options.customHeaders.hasOwnProperty(headerName)) {
          httpRequest.headers[headerName] = options.customHeaders[headerName];
        }
      }
    }
    // Send Request
    let operationRes: msRest.HttpOperationResponse;
    try {
      operationRes = await client.pipeline(httpRequest);
      let response = operationRes.response;
      let statusCode = response.status;
      if (statusCode !== 200 && statusCode !== 403 && statusCode !== 404) {
        let error = new msRest.RestError(operationRes.bodyAsText as string);
        error.statusCode = response.status;
        error.request = msRest.stripRequest(httpRequest);
        error.response = msRest.stripResponse(response);
        let parsedErrorResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedErrorResponse) {
            let internalError = null;
            if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
            error.code = internalError ? internalError.code : parsedErrorResponse.code;
            error.message = internalError ? internalError.message : parsedErrorResponse.message;
          }
        } catch (defaultError) {
          error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                           `- "${operationRes.bodyAsText}" for the default response.`;
          return Promise.reject(error);
        }
        return Promise.reject(error);
      }
      // Deserialize Response
      if (statusCode === 200) {
        let parsedResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedResponse !== null && parsedResponse !== undefined) {
            let resultMapper = Mappers.GroupModel;
            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
          }
        } catch (error) {
          let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
          deserializationError.request = msRest.stripRequest(httpRequest);
          deserializationError.response = msRest.stripResponse(response);
          return Promise.reject(deserializationError);
        }
      }

    } catch(err) {
      return Promise.reject(err);
    }

    return Promise.resolve(operationRes);
  }
  // methods on the client.

  /**
   * @summary Updates a specified group.
   *
   * @param {number} id The group identifier.
   *
   * @param {GroupBase} model The group model.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  async updateGroupWithHttpOperationResponse(id: number, model: Models.GroupBase, options?: msRest.RequestOptionsBase): Promise<msRest.HttpOperationResponse> {
    let client = this;
    // Validate
    try {
      if (id === null || id === undefined || typeof id !== 'number') {
        throw new Error('id cannot be null or undefined and it must be of type number.');
      }
      if (model === null || model === undefined) {
        throw new Error('model cannot be null or undefined.');
      }
    } catch (error) {
      return Promise.reject(error);
    }

    // Construct URL
    let baseUrl = this.baseUri;
    let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'v1/directory/groups/{id}';
    requestUrl = requestUrl.replace('{id}', encodeURIComponent(id.toString()));

    // Create HTTP transport objects
    let httpRequest = new WebResource();
    httpRequest.method = 'PUT';
    httpRequest.url = requestUrl;
    httpRequest.headers = {};
    // Set Headers
    httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
    if(options && options.customHeaders) {
      for(let headerName in options.customHeaders) {
        if (options.customHeaders.hasOwnProperty(headerName)) {
          httpRequest.headers[headerName] = options.customHeaders[headerName];
        }
      }
    }
    // Serialize Request
    let requestContent = null;
    let requestModel = null;
    try {
      if (model !== null && model !== undefined) {
        let requestModelMapper = Mappers.GroupBase;
        requestModel = client.serializer.serialize(requestModelMapper, model, 'model');
        requestContent = JSON.stringify(requestModel);
      }
    } catch (error) {
      let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
          `payload - ${JSON.stringify(model, null, 2)}.`);
      return Promise.reject(serializationError);
    }
    httpRequest.body = requestContent;
    // Send Request
    let operationRes: msRest.HttpOperationResponse;
    try {
      operationRes = await client.pipeline(httpRequest);
      let response = operationRes.response;
      let statusCode = response.status;
      if (statusCode !== 204 && statusCode !== 403 && statusCode !== 404 && statusCode !== 500) {
        let error = new msRest.RestError(operationRes.bodyAsText as string);
        error.statusCode = response.status;
        error.request = msRest.stripRequest(httpRequest);
        error.response = msRest.stripResponse(response);
        let parsedErrorResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedErrorResponse) {
            let internalError = null;
            if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
            error.code = internalError ? internalError.code : parsedErrorResponse.code;
            error.message = internalError ? internalError.message : parsedErrorResponse.message;
          }
        } catch (defaultError) {
          error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                           `- "${operationRes.bodyAsText}" for the default response.`;
          return Promise.reject(error);
        }
        return Promise.reject(error);
      }
      // Deserialize Response
      if (statusCode === 204) {
        let parsedResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedResponse !== null && parsedResponse !== undefined) {
            let resultMapper = {
              required: false,
              serializedName: 'parsedResponse',
              type: {
                name: 'Object'
              }
            };
            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
          }
        } catch (error) {
          let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
          deserializationError.request = msRest.stripRequest(httpRequest);
          deserializationError.response = msRest.stripResponse(response);
          return Promise.reject(deserializationError);
        }
      }

    } catch(err) {
      return Promise.reject(err);
    }

    return Promise.resolve(operationRes);
  }
  // methods on the client.

  /**
   * @summary Deactivates a group and removes all group associations.
   *
   * @param {number} id The group identifier.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  async deleteGroupWithHttpOperationResponse(id: number, options?: msRest.RequestOptionsBase): Promise<msRest.HttpOperationResponse> {
    let client = this;
    // Validate
    try {
      if (id === null || id === undefined || typeof id !== 'number') {
        throw new Error('id cannot be null or undefined and it must be of type number.');
      }
    } catch (error) {
      return Promise.reject(error);
    }

    // Construct URL
    let baseUrl = this.baseUri;
    let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'v1/directory/groups/{id}';
    requestUrl = requestUrl.replace('{id}', encodeURIComponent(id.toString()));

    // Create HTTP transport objects
    let httpRequest = new WebResource();
    httpRequest.method = 'DELETE';
    httpRequest.url = requestUrl;
    httpRequest.headers = {};
    // Set Headers
    httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
    if(options && options.customHeaders) {
      for(let headerName in options.customHeaders) {
        if (options.customHeaders.hasOwnProperty(headerName)) {
          httpRequest.headers[headerName] = options.customHeaders[headerName];
        }
      }
    }
    // Send Request
    let operationRes: msRest.HttpOperationResponse;
    try {
      operationRes = await client.pipeline(httpRequest);
      let response = operationRes.response;
      let statusCode = response.status;
      if (statusCode !== 204 && statusCode !== 403 && statusCode !== 404 && statusCode !== 500) {
        let error = new msRest.RestError(operationRes.bodyAsText as string);
        error.statusCode = response.status;
        error.request = msRest.stripRequest(httpRequest);
        error.response = msRest.stripResponse(response);
        let parsedErrorResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedErrorResponse) {
            let internalError = null;
            if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
            error.code = internalError ? internalError.code : parsedErrorResponse.code;
            error.message = internalError ? internalError.message : parsedErrorResponse.message;
          }
        } catch (defaultError) {
          error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                           `- "${operationRes.bodyAsText}" for the default response.`;
          return Promise.reject(error);
        }
        return Promise.reject(error);
      }
      // Deserialize Response
      if (statusCode === 204) {
        let parsedResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedResponse !== null && parsedResponse !== undefined) {
            let resultMapper = {
              required: false,
              serializedName: 'parsedResponse',
              type: {
                name: 'Object'
              }
            };
            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
          }
        } catch (error) {
          let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
          deserializationError.request = msRest.stripRequest(httpRequest);
          deserializationError.response = msRest.stripResponse(response);
          return Promise.reject(deserializationError);
        }
      }

    } catch(err) {
      return Promise.reject(err);
    }

    return Promise.resolve(operationRes);
  }
  // methods on the client.

  /**
   * @summary Gets a paged list of entity links
   *
   * @param {SoftheonEnterpriseAPIGetLinksByFilterOptionalParams} [options]
   * Optional Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  async getLinksByFilterWithHttpOperationResponse(options?: Models.SoftheonEnterpriseAPIGetLinksByFilterOptionalParams): Promise<msRest.HttpOperationResponse> {
    let client = this;
    let childEntityID = (options && options.childEntityID !== undefined) ? options.childEntityID : undefined;
    let childDrawerID = (options && options.childDrawerID !== undefined) ? options.childDrawerID : undefined;
    let childType = (options && options.childType !== undefined) ? options.childType : undefined;
    let acl = (options && options.acl !== undefined) ? options.acl : undefined;
    let entityID = (options && options.entityID !== undefined) ? options.entityID : undefined;
    let drawerID = (options && options.drawerID !== undefined) ? options.drawerID : undefined;
    let name = (options && options.name !== undefined) ? options.name : undefined;
    let creatorUserID = (options && options.creatorUserID !== undefined) ? options.creatorUserID : undefined;
    let modifierUserID = (options && options.modifierUserID !== undefined) ? options.modifierUserID : undefined;
    let minInsertionTime = (options && options.minInsertionTime !== undefined) ? options.minInsertionTime : undefined;
    let maxInsertionTime = (options && options.maxInsertionTime !== undefined) ? options.maxInsertionTime : undefined;
    let minModificationTime = (options && options.minModificationTime !== undefined) ? options.minModificationTime : undefined;
    let maxModificationTime = (options && options.maxModificationTime !== undefined) ? options.maxModificationTime : undefined;
    let page = (options && options.page !== undefined) ? options.page : undefined;
    let pageSize = (options && options.pageSize !== undefined) ? options.pageSize : undefined;
    let sortOrder = (options && options.sortOrder !== undefined) ? options.sortOrder : undefined;
    let sortBy = (options && options.sortBy !== undefined) ? options.sortBy : undefined;
    // Validate
    try {
      if (childEntityID !== null && childEntityID !== undefined && typeof childEntityID !== 'number') {
        throw new Error('childEntityID must be of type number.');
      }
      if (childEntityID !== null && childEntityID !== undefined) {
        if (childEntityID > 2147483647)
        {
          throw new Error('"childEntityID" should satisfy the constraint - "InclusiveMaximum": 2147483647');
        }
        if (childEntityID < 1)
        {
          throw new Error('"childEntityID" should satisfy the constraint - "InclusiveMinimum": 1');
        }
      }
      if (childDrawerID !== null && childDrawerID !== undefined && typeof childDrawerID !== 'number') {
        throw new Error('childDrawerID must be of type number.');
      }
      if (childDrawerID !== null && childDrawerID !== undefined) {
        if (childDrawerID > 2147483647)
        {
          throw new Error('"childDrawerID" should satisfy the constraint - "InclusiveMaximum": 2147483647');
        }
        if (childDrawerID < 1)
        {
          throw new Error('"childDrawerID" should satisfy the constraint - "InclusiveMinimum": 1');
        }
      }
      if (childType !== null && childType !== undefined && typeof childType !== 'number') {
        throw new Error('childType must be of type number.');
      }
      if (childType !== null && childType !== undefined) {
        if (childType > 2147483647)
        {
          throw new Error('"childType" should satisfy the constraint - "InclusiveMaximum": 2147483647');
        }
        if (childType < 1)
        {
          throw new Error('"childType" should satisfy the constraint - "InclusiveMinimum": 1');
        }
      }
      if (acl !== null && acl !== undefined && typeof acl !== 'number') {
        throw new Error('acl must be of type number.');
      }
      if (entityID !== null && entityID !== undefined && typeof entityID !== 'number') {
        throw new Error('entityID must be of type number.');
      }
      if (entityID !== null && entityID !== undefined) {
        if (entityID > 2147483647)
        {
          throw new Error('"entityID" should satisfy the constraint - "InclusiveMaximum": 2147483647');
        }
        if (entityID < 1)
        {
          throw new Error('"entityID" should satisfy the constraint - "InclusiveMinimum": 1');
        }
      }
      if (drawerID !== null && drawerID !== undefined && typeof drawerID !== 'number') {
        throw new Error('drawerID must be of type number.');
      }
      if (drawerID !== null && drawerID !== undefined) {
        if (drawerID > 2147483647)
        {
          throw new Error('"drawerID" should satisfy the constraint - "InclusiveMaximum": 2147483647');
        }
        if (drawerID < 1)
        {
          throw new Error('"drawerID" should satisfy the constraint - "InclusiveMinimum": 1');
        }
      }
      if (name !== null && name !== undefined && typeof name.valueOf() !== 'string') {
        throw new Error('name must be of type string.');
      }
      if (name !== null && name !== undefined) {
        if (name.length > 255)
        {
          throw new Error('"name" should satisfy the constraint - "MaxLength": 255');
        }
        if (name.length < 0)
        {
          throw new Error('"name" should satisfy the constraint - "MinLength": 0');
        }
      }
      if (creatorUserID !== null && creatorUserID !== undefined && typeof creatorUserID !== 'number') {
        throw new Error('creatorUserID must be of type number.');
      }
      if (creatorUserID !== null && creatorUserID !== undefined) {
        if (creatorUserID > 2147483647)
        {
          throw new Error('"creatorUserID" should satisfy the constraint - "InclusiveMaximum": 2147483647');
        }
        if (creatorUserID < 1)
        {
          throw new Error('"creatorUserID" should satisfy the constraint - "InclusiveMinimum": 1');
        }
      }
      if (modifierUserID !== null && modifierUserID !== undefined && typeof modifierUserID !== 'number') {
        throw new Error('modifierUserID must be of type number.');
      }
      if (modifierUserID !== null && modifierUserID !== undefined) {
        if (modifierUserID > 2147483647)
        {
          throw new Error('"modifierUserID" should satisfy the constraint - "InclusiveMaximum": 2147483647');
        }
        if (modifierUserID < 1)
        {
          throw new Error('"modifierUserID" should satisfy the constraint - "InclusiveMinimum": 1');
        }
      }
      if (minInsertionTime && !(minInsertionTime instanceof Date ||
          (typeof (minInsertionTime as string).valueOf() === 'string' && !isNaN(Date.parse(minInsertionTime as string))))) {
            throw new Error('minInsertionTime must be of type date.');
          }
      if (maxInsertionTime && !(maxInsertionTime instanceof Date ||
          (typeof (maxInsertionTime as string).valueOf() === 'string' && !isNaN(Date.parse(maxInsertionTime as string))))) {
            throw new Error('maxInsertionTime must be of type date.');
          }
      if (minModificationTime && !(minModificationTime instanceof Date ||
          (typeof (minModificationTime as string).valueOf() === 'string' && !isNaN(Date.parse(minModificationTime as string))))) {
            throw new Error('minModificationTime must be of type date.');
          }
      if (maxModificationTime && !(maxModificationTime instanceof Date ||
          (typeof (maxModificationTime as string).valueOf() === 'string' && !isNaN(Date.parse(maxModificationTime as string))))) {
            throw new Error('maxModificationTime must be of type date.');
          }
      if (page !== null && page !== undefined && typeof page !== 'number') {
        throw new Error('page must be of type number.');
      }
      if (page !== null && page !== undefined) {
        if (page > 2147483647)
        {
          throw new Error('"page" should satisfy the constraint - "InclusiveMaximum": 2147483647');
        }
        if (page < 1)
        {
          throw new Error('"page" should satisfy the constraint - "InclusiveMinimum": 1');
        }
      }
      if (pageSize !== null && pageSize !== undefined && typeof pageSize !== 'number') {
        throw new Error('pageSize must be of type number.');
      }
      if (pageSize !== null && pageSize !== undefined) {
        if (pageSize > 1000)
        {
          throw new Error('"pageSize" should satisfy the constraint - "InclusiveMaximum": 1000');
        }
        if (pageSize < 1)
        {
          throw new Error('"pageSize" should satisfy the constraint - "InclusiveMinimum": 1');
        }
      }
      if (sortOrder !== null && sortOrder !== undefined && typeof sortOrder.valueOf() !== 'string') {
        throw new Error('sortOrder must be of type string.');
      }
      if (sortBy !== null && sortBy !== undefined && typeof sortBy.valueOf() !== 'string') {
        throw new Error('sortBy must be of type string.');
      }
    } catch (error) {
      return Promise.reject(error);
    }

    // Construct URL
    let baseUrl = this.baseUri;
    let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'v1/content/links';
    let queryParamsArray: Array<any> = [];
    if (childEntityID !== null && childEntityID !== undefined) {
      queryParamsArray.push('childEntityID=' + encodeURIComponent(childEntityID.toString()));
    }
    if (childDrawerID !== null && childDrawerID !== undefined) {
      queryParamsArray.push('childDrawerID=' + encodeURIComponent(childDrawerID.toString()));
    }
    if (childType !== null && childType !== undefined) {
      queryParamsArray.push('childType=' + encodeURIComponent(childType.toString()));
    }
    if (acl !== null && acl !== undefined) {
      queryParamsArray.push('acl=' + encodeURIComponent(acl.toString()));
    }
    if (entityID !== null && entityID !== undefined) {
      queryParamsArray.push('entityID=' + encodeURIComponent(entityID.toString()));
    }
    if (drawerID !== null && drawerID !== undefined) {
      queryParamsArray.push('drawerID=' + encodeURIComponent(drawerID.toString()));
    }
    if (name !== null && name !== undefined) {
      queryParamsArray.push('name=' + encodeURIComponent(name));
    }
    if (creatorUserID !== null && creatorUserID !== undefined) {
      queryParamsArray.push('creatorUserID=' + encodeURIComponent(creatorUserID.toString()));
    }
    if (modifierUserID !== null && modifierUserID !== undefined) {
      queryParamsArray.push('modifierUserID=' + encodeURIComponent(modifierUserID.toString()));
    }
    if (minInsertionTime !== null && minInsertionTime !== undefined) {
      queryParamsArray.push('minInsertionTime=' + encodeURIComponent(msRest.serializeObject(minInsertionTime)));
    }
    if (maxInsertionTime !== null && maxInsertionTime !== undefined) {
      queryParamsArray.push('maxInsertionTime=' + encodeURIComponent(msRest.serializeObject(maxInsertionTime)));
    }
    if (minModificationTime !== null && minModificationTime !== undefined) {
      queryParamsArray.push('minModificationTime=' + encodeURIComponent(msRest.serializeObject(minModificationTime)));
    }
    if (maxModificationTime !== null && maxModificationTime !== undefined) {
      queryParamsArray.push('maxModificationTime=' + encodeURIComponent(msRest.serializeObject(maxModificationTime)));
    }
    if (page !== null && page !== undefined) {
      queryParamsArray.push('page=' + encodeURIComponent(page.toString()));
    }
    if (pageSize !== null && pageSize !== undefined) {
      queryParamsArray.push('pageSize=' + encodeURIComponent(pageSize.toString()));
    }
    if (sortOrder !== null && sortOrder !== undefined) {
      queryParamsArray.push('sortOrder=' + encodeURIComponent(sortOrder));
    }
    if (sortBy !== null && sortBy !== undefined) {
      queryParamsArray.push('sortBy=' + encodeURIComponent(sortBy));
    }
    if (queryParamsArray.length > 0) {
      requestUrl += '?' + queryParamsArray.join('&');
    }

    // Create HTTP transport objects
    let httpRequest = new WebResource();
    httpRequest.method = 'GET';
    httpRequest.url = requestUrl;
    httpRequest.headers = {};
    // Set Headers
    httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
    if(options && options.customHeaders) {
      for(let headerName in options.customHeaders) {
        if (options.customHeaders.hasOwnProperty(headerName)) {
          httpRequest.headers[headerName] = options.customHeaders[headerName];
        }
      }
    }
    // Send Request
    let operationRes: msRest.HttpOperationResponse;
    try {
      operationRes = await client.pipeline(httpRequest);
      let response = operationRes.response;
      let statusCode = response.status;
      if (statusCode !== 200) {
        let error = new msRest.RestError(operationRes.bodyAsText as string);
        error.statusCode = response.status;
        error.request = msRest.stripRequest(httpRequest);
        error.response = msRest.stripResponse(response);
        let parsedErrorResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedErrorResponse) {
            let internalError = null;
            if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
            error.code = internalError ? internalError.code : parsedErrorResponse.code;
            error.message = internalError ? internalError.message : parsedErrorResponse.message;
          }
        } catch (defaultError) {
          error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                           `- "${operationRes.bodyAsText}" for the default response.`;
          return Promise.reject(error);
        }
        return Promise.reject(error);
      }
      // Deserialize Response
      if (statusCode === 200) {
        let parsedResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedResponse !== null && parsedResponse !== undefined) {
            let resultMapper = {
              required: false,
              serializedName: 'parsedResponse',
              type: {
                name: 'Sequence',
                element: {
                    required: false,
                    serializedName: 'EntityLinkModelElementType',
                    type: {
                      name: 'Composite',
                      className: 'EntityLinkModel'
                    }
                }
              }
            };
            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
          }
        } catch (error) {
          let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
          deserializationError.request = msRest.stripRequest(httpRequest);
          deserializationError.response = msRest.stripResponse(response);
          return Promise.reject(deserializationError);
        }
      }

    } catch(err) {
      return Promise.reject(err);
    }

    return Promise.resolve(operationRes);
  }
  // methods on the client.

  /**
   * @summary Gets a link based on its unique identifier.
   *
   * @param {number} drawer The drawer identifier.
   *
   * @param {number} id The link identifier.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  async getLinkByIdWithHttpOperationResponse(drawer: number, id: number, options?: msRest.RequestOptionsBase): Promise<msRest.HttpOperationResponse> {
    let client = this;
    // Validate
    try {
      if (drawer === null || drawer === undefined || typeof drawer !== 'number') {
        throw new Error('drawer cannot be null or undefined and it must be of type number.');
      }
      if (id === null || id === undefined || typeof id !== 'number') {
        throw new Error('id cannot be null or undefined and it must be of type number.');
      }
    } catch (error) {
      return Promise.reject(error);
    }

    // Construct URL
    let baseUrl = this.baseUri;
    let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'v1/content/links/{drawer}/{id}';
    requestUrl = requestUrl.replace('{drawer}', encodeURIComponent(drawer.toString()));
    requestUrl = requestUrl.replace('{id}', encodeURIComponent(id.toString()));

    // Create HTTP transport objects
    let httpRequest = new WebResource();
    httpRequest.method = 'GET';
    httpRequest.url = requestUrl;
    httpRequest.headers = {};
    // Set Headers
    httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
    if(options && options.customHeaders) {
      for(let headerName in options.customHeaders) {
        if (options.customHeaders.hasOwnProperty(headerName)) {
          httpRequest.headers[headerName] = options.customHeaders[headerName];
        }
      }
    }
    // Send Request
    let operationRes: msRest.HttpOperationResponse;
    try {
      operationRes = await client.pipeline(httpRequest);
      let response = operationRes.response;
      let statusCode = response.status;
      if (statusCode !== 200 && statusCode !== 403 && statusCode !== 404) {
        let error = new msRest.RestError(operationRes.bodyAsText as string);
        error.statusCode = response.status;
        error.request = msRest.stripRequest(httpRequest);
        error.response = msRest.stripResponse(response);
        let parsedErrorResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedErrorResponse) {
            let internalError = null;
            if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
            error.code = internalError ? internalError.code : parsedErrorResponse.code;
            error.message = internalError ? internalError.message : parsedErrorResponse.message;
          }
        } catch (defaultError) {
          error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                           `- "${operationRes.bodyAsText}" for the default response.`;
          return Promise.reject(error);
        }
        return Promise.reject(error);
      }
      // Deserialize Response
      if (statusCode === 200) {
        let parsedResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedResponse !== null && parsedResponse !== undefined) {
            let resultMapper = Mappers.EntityLinkModel;
            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
          }
        } catch (error) {
          let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
          deserializationError.request = msRest.stripRequest(httpRequest);
          deserializationError.response = msRest.stripResponse(response);
          return Promise.reject(deserializationError);
        }
      }

    } catch(err) {
      return Promise.reject(err);
    }

    return Promise.resolve(operationRes);
  }
  // methods on the client.

  /**
   * @summary Updates a specified link.
   *
   * @param {number} drawer The drawer identifier.
   *
   * @param {number} id The link identifier.
   *
   * @param {UpdateEntityLinkRequestModel} model The model.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  async updateLinkWithHttpOperationResponse(drawer: number, id: number, model: Models.UpdateEntityLinkRequestModel, options?: msRest.RequestOptionsBase): Promise<msRest.HttpOperationResponse> {
    let client = this;
    // Validate
    try {
      if (drawer === null || drawer === undefined || typeof drawer !== 'number') {
        throw new Error('drawer cannot be null or undefined and it must be of type number.');
      }
      if (id === null || id === undefined || typeof id !== 'number') {
        throw new Error('id cannot be null or undefined and it must be of type number.');
      }
      if (model === null || model === undefined) {
        throw new Error('model cannot be null or undefined.');
      }
    } catch (error) {
      return Promise.reject(error);
    }

    // Construct URL
    let baseUrl = this.baseUri;
    let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'v1/content/links/{drawer}/{id}';
    requestUrl = requestUrl.replace('{drawer}', encodeURIComponent(drawer.toString()));
    requestUrl = requestUrl.replace('{id}', encodeURIComponent(id.toString()));

    // Create HTTP transport objects
    let httpRequest = new WebResource();
    httpRequest.method = 'PUT';
    httpRequest.url = requestUrl;
    httpRequest.headers = {};
    // Set Headers
    httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
    if(options && options.customHeaders) {
      for(let headerName in options.customHeaders) {
        if (options.customHeaders.hasOwnProperty(headerName)) {
          httpRequest.headers[headerName] = options.customHeaders[headerName];
        }
      }
    }
    // Serialize Request
    let requestContent = null;
    let requestModel = null;
    try {
      if (model !== null && model !== undefined) {
        let requestModelMapper = Mappers.UpdateEntityLinkRequestModel;
        requestModel = client.serializer.serialize(requestModelMapper, model, 'model');
        requestContent = JSON.stringify(requestModel);
      }
    } catch (error) {
      let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
          `payload - ${JSON.stringify(model, null, 2)}.`);
      return Promise.reject(serializationError);
    }
    httpRequest.body = requestContent;
    // Send Request
    let operationRes: msRest.HttpOperationResponse;
    try {
      operationRes = await client.pipeline(httpRequest);
      let response = operationRes.response;
      let statusCode = response.status;
      if (statusCode !== 204 && statusCode !== 403 && statusCode !== 404) {
        let error = new msRest.RestError(operationRes.bodyAsText as string);
        error.statusCode = response.status;
        error.request = msRest.stripRequest(httpRequest);
        error.response = msRest.stripResponse(response);
        let parsedErrorResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedErrorResponse) {
            let internalError = null;
            if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
            error.code = internalError ? internalError.code : parsedErrorResponse.code;
            error.message = internalError ? internalError.message : parsedErrorResponse.message;
          }
        } catch (defaultError) {
          error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                           `- "${operationRes.bodyAsText}" for the default response.`;
          return Promise.reject(error);
        }
        return Promise.reject(error);
      }
      // Deserialize Response
      if (statusCode === 204) {
        let parsedResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedResponse !== null && parsedResponse !== undefined) {
            let resultMapper = {
              required: false,
              serializedName: 'parsedResponse',
              type: {
                name: 'Object'
              }
            };
            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
          }
        } catch (error) {
          let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
          deserializationError.request = msRest.stripRequest(httpRequest);
          deserializationError.response = msRest.stripResponse(response);
          return Promise.reject(deserializationError);
        }
      }

    } catch(err) {
      return Promise.reject(err);
    }

    return Promise.resolve(operationRes);
  }
  // methods on the client.

  /**
   * @summary Deletes a specified link.
   *
   * @param {number} drawer The drawer identifier.
   *
   * @param {number} id The link identifier.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  async deleteLinkWithHttpOperationResponse(drawer: number, id: number, options?: msRest.RequestOptionsBase): Promise<msRest.HttpOperationResponse> {
    let client = this;
    // Validate
    try {
      if (drawer === null || drawer === undefined || typeof drawer !== 'number') {
        throw new Error('drawer cannot be null or undefined and it must be of type number.');
      }
      if (id === null || id === undefined || typeof id !== 'number') {
        throw new Error('id cannot be null or undefined and it must be of type number.');
      }
    } catch (error) {
      return Promise.reject(error);
    }

    // Construct URL
    let baseUrl = this.baseUri;
    let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'v1/content/links/{drawer}/{id}';
    requestUrl = requestUrl.replace('{drawer}', encodeURIComponent(drawer.toString()));
    requestUrl = requestUrl.replace('{id}', encodeURIComponent(id.toString()));

    // Create HTTP transport objects
    let httpRequest = new WebResource();
    httpRequest.method = 'DELETE';
    httpRequest.url = requestUrl;
    httpRequest.headers = {};
    // Set Headers
    httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
    if(options && options.customHeaders) {
      for(let headerName in options.customHeaders) {
        if (options.customHeaders.hasOwnProperty(headerName)) {
          httpRequest.headers[headerName] = options.customHeaders[headerName];
        }
      }
    }
    // Send Request
    let operationRes: msRest.HttpOperationResponse;
    try {
      operationRes = await client.pipeline(httpRequest);
      let response = operationRes.response;
      let statusCode = response.status;
      if (statusCode !== 204 && statusCode !== 403 && statusCode !== 404) {
        let error = new msRest.RestError(operationRes.bodyAsText as string);
        error.statusCode = response.status;
        error.request = msRest.stripRequest(httpRequest);
        error.response = msRest.stripResponse(response);
        let parsedErrorResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedErrorResponse) {
            let internalError = null;
            if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
            error.code = internalError ? internalError.code : parsedErrorResponse.code;
            error.message = internalError ? internalError.message : parsedErrorResponse.message;
          }
        } catch (defaultError) {
          error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                           `- "${operationRes.bodyAsText}" for the default response.`;
          return Promise.reject(error);
        }
        return Promise.reject(error);
      }
      // Deserialize Response
      if (statusCode === 204) {
        let parsedResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedResponse !== null && parsedResponse !== undefined) {
            let resultMapper = {
              required: false,
              serializedName: 'parsedResponse',
              type: {
                name: 'Object'
              }
            };
            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
          }
        } catch (error) {
          let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
          deserializationError.request = msRest.stripRequest(httpRequest);
          deserializationError.response = msRest.stripResponse(response);
          return Promise.reject(deserializationError);
        }
      }

    } catch(err) {
      return Promise.reject(err);
    }

    return Promise.resolve(operationRes);
  }
  // methods on the client.

  /**
   * @summary Creates a new link.
   *
   * @param {number} drawer The drawer identifier.
   *
   * @param {InsertEntityLinkRequestModel} model The link model.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  async createLinkWithHttpOperationResponse(drawer: number, model: Models.InsertEntityLinkRequestModel, options?: msRest.RequestOptionsBase): Promise<msRest.HttpOperationResponse> {
    let client = this;
    // Validate
    try {
      if (drawer === null || drawer === undefined || typeof drawer !== 'number') {
        throw new Error('drawer cannot be null or undefined and it must be of type number.');
      }
      if (model === null || model === undefined) {
        throw new Error('model cannot be null or undefined.');
      }
    } catch (error) {
      return Promise.reject(error);
    }

    // Construct URL
    let baseUrl = this.baseUri;
    let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'v1/content/links/{drawer}';
    requestUrl = requestUrl.replace('{drawer}', encodeURIComponent(drawer.toString()));

    // Create HTTP transport objects
    let httpRequest = new WebResource();
    httpRequest.method = 'POST';
    httpRequest.url = requestUrl;
    httpRequest.headers = {};
    // Set Headers
    httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
    if(options && options.customHeaders) {
      for(let headerName in options.customHeaders) {
        if (options.customHeaders.hasOwnProperty(headerName)) {
          httpRequest.headers[headerName] = options.customHeaders[headerName];
        }
      }
    }
    // Serialize Request
    let requestContent = null;
    let requestModel = null;
    try {
      if (model !== null && model !== undefined) {
        let requestModelMapper = Mappers.InsertEntityLinkRequestModel;
        requestModel = client.serializer.serialize(requestModelMapper, model, 'model');
        requestContent = JSON.stringify(requestModel);
      }
    } catch (error) {
      let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
          `payload - ${JSON.stringify(model, null, 2)}.`);
      return Promise.reject(serializationError);
    }
    httpRequest.body = requestContent;
    // Send Request
    let operationRes: msRest.HttpOperationResponse;
    try {
      operationRes = await client.pipeline(httpRequest);
      let response = operationRes.response;
      let statusCode = response.status;
      if (statusCode !== 201 && statusCode !== 403 && statusCode !== 404 && statusCode !== 409) {
        let error = new msRest.RestError(operationRes.bodyAsText as string);
        error.statusCode = response.status;
        error.request = msRest.stripRequest(httpRequest);
        error.response = msRest.stripResponse(response);
        let parsedErrorResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedErrorResponse) {
            let internalError = null;
            if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
            error.code = internalError ? internalError.code : parsedErrorResponse.code;
            error.message = internalError ? internalError.message : parsedErrorResponse.message;
          }
        } catch (defaultError) {
          error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                           `- "${operationRes.bodyAsText}" for the default response.`;
          return Promise.reject(error);
        }
        return Promise.reject(error);
      }
      // Deserialize Response
      if (statusCode === 201) {
        let parsedResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedResponse !== null && parsedResponse !== undefined) {
            let resultMapper = Mappers.EntityLinkModel;
            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
          }
        } catch (error) {
          let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
          deserializationError.request = msRest.stripRequest(httpRequest);
          deserializationError.response = msRest.stripResponse(response);
          return Promise.reject(deserializationError);
        }
      }

    } catch(err) {
      return Promise.reject(err);
    }

    return Promise.resolve(operationRes);
  }
  // methods on the client.

  /**
   * @summary Gets a lock for a single entity based on its unique identifier.
   *
   * @param {number} drawer The drawer identifier.
   *
   * @param {number} id The entity identifier.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  async getLocksByFilterWithHttpOperationResponse(drawer: number, id: number, options?: msRest.RequestOptionsBase): Promise<msRest.HttpOperationResponse> {
    let client = this;
    // Validate
    try {
      if (drawer === null || drawer === undefined || typeof drawer !== 'number') {
        throw new Error('drawer cannot be null or undefined and it must be of type number.');
      }
      if (id === null || id === undefined || typeof id !== 'number') {
        throw new Error('id cannot be null or undefined and it must be of type number.');
      }
    } catch (error) {
      return Promise.reject(error);
    }

    // Construct URL
    let baseUrl = this.baseUri;
    let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'v1/content/entities/{drawer}/{id}/locks';
    requestUrl = requestUrl.replace('{drawer}', encodeURIComponent(drawer.toString()));
    requestUrl = requestUrl.replace('{id}', encodeURIComponent(id.toString()));

    // Create HTTP transport objects
    let httpRequest = new WebResource();
    httpRequest.method = 'GET';
    httpRequest.url = requestUrl;
    httpRequest.headers = {};
    // Set Headers
    httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
    if(options && options.customHeaders) {
      for(let headerName in options.customHeaders) {
        if (options.customHeaders.hasOwnProperty(headerName)) {
          httpRequest.headers[headerName] = options.customHeaders[headerName];
        }
      }
    }
    // Send Request
    let operationRes: msRest.HttpOperationResponse;
    try {
      operationRes = await client.pipeline(httpRequest);
      let response = operationRes.response;
      let statusCode = response.status;
      if (statusCode !== 200 && statusCode !== 404) {
        let error = new msRest.RestError(operationRes.bodyAsText as string);
        error.statusCode = response.status;
        error.request = msRest.stripRequest(httpRequest);
        error.response = msRest.stripResponse(response);
        let parsedErrorResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedErrorResponse) {
            let internalError = null;
            if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
            error.code = internalError ? internalError.code : parsedErrorResponse.code;
            error.message = internalError ? internalError.message : parsedErrorResponse.message;
          }
        } catch (defaultError) {
          error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                           `- "${operationRes.bodyAsText}" for the default response.`;
          return Promise.reject(error);
        }
        return Promise.reject(error);
      }
      // Deserialize Response
      if (statusCode === 200) {
        let parsedResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedResponse !== null && parsedResponse !== undefined) {
            let resultMapper = Mappers.LockModel;
            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
          }
        } catch (error) {
          let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
          deserializationError.request = msRest.stripRequest(httpRequest);
          deserializationError.response = msRest.stripResponse(response);
          return Promise.reject(deserializationError);
        }
      }

    } catch(err) {
      return Promise.reject(err);
    }

    return Promise.resolve(operationRes);
  }
  // methods on the client.

  /**
   * @summary Inserts or updates lock on a specified entity.
   *
   * @param {number} drawer The drawer identifier.
   *
   * @param {number} id The entity identifier.
   *
   * @param {UpdateLockRequestModel} model The lock model.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  async createOrUpdateLockWithHttpOperationResponse(drawer: number, id: number, model: Models.UpdateLockRequestModel, options?: msRest.RequestOptionsBase): Promise<msRest.HttpOperationResponse> {
    let client = this;
    // Validate
    try {
      if (drawer === null || drawer === undefined || typeof drawer !== 'number') {
        throw new Error('drawer cannot be null or undefined and it must be of type number.');
      }
      if (id === null || id === undefined || typeof id !== 'number') {
        throw new Error('id cannot be null or undefined and it must be of type number.');
      }
      if (model === null || model === undefined) {
        throw new Error('model cannot be null or undefined.');
      }
    } catch (error) {
      return Promise.reject(error);
    }

    // Construct URL
    let baseUrl = this.baseUri;
    let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'v1/content/entities/{drawer}/{id}/locks';
    requestUrl = requestUrl.replace('{drawer}', encodeURIComponent(drawer.toString()));
    requestUrl = requestUrl.replace('{id}', encodeURIComponent(id.toString()));

    // Create HTTP transport objects
    let httpRequest = new WebResource();
    httpRequest.method = 'PUT';
    httpRequest.url = requestUrl;
    httpRequest.headers = {};
    // Set Headers
    httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
    if(options && options.customHeaders) {
      for(let headerName in options.customHeaders) {
        if (options.customHeaders.hasOwnProperty(headerName)) {
          httpRequest.headers[headerName] = options.customHeaders[headerName];
        }
      }
    }
    // Serialize Request
    let requestContent = null;
    let requestModel = null;
    try {
      if (model !== null && model !== undefined) {
        let requestModelMapper = Mappers.UpdateLockRequestModel;
        requestModel = client.serializer.serialize(requestModelMapper, model, 'model');
        requestContent = JSON.stringify(requestModel);
      }
    } catch (error) {
      let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
          `payload - ${JSON.stringify(model, null, 2)}.`);
      return Promise.reject(serializationError);
    }
    httpRequest.body = requestContent;
    // Send Request
    let operationRes: msRest.HttpOperationResponse;
    try {
      operationRes = await client.pipeline(httpRequest);
      let response = operationRes.response;
      let statusCode = response.status;
      if (statusCode !== 201 && statusCode !== 403 && statusCode !== 404) {
        let error = new msRest.RestError(operationRes.bodyAsText as string);
        error.statusCode = response.status;
        error.request = msRest.stripRequest(httpRequest);
        error.response = msRest.stripResponse(response);
        let parsedErrorResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedErrorResponse) {
            let internalError = null;
            if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
            error.code = internalError ? internalError.code : parsedErrorResponse.code;
            error.message = internalError ? internalError.message : parsedErrorResponse.message;
          }
        } catch (defaultError) {
          error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                           `- "${operationRes.bodyAsText}" for the default response.`;
          return Promise.reject(error);
        }
        return Promise.reject(error);
      }
      // Deserialize Response
      if (statusCode === 201) {
        let parsedResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedResponse !== null && parsedResponse !== undefined) {
            let resultMapper = {
              required: false,
              serializedName: 'parsedResponse',
              type: {
                name: 'Object'
              }
            };
            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
          }
        } catch (error) {
          let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
          deserializationError.request = msRest.stripRequest(httpRequest);
          deserializationError.response = msRest.stripResponse(response);
          return Promise.reject(deserializationError);
        }
      }

    } catch(err) {
      return Promise.reject(err);
    }

    return Promise.resolve(operationRes);
  }
  // methods on the client.

  /**
   * @summary Deletes a lock on a specified entity.
   *
   * @param {number} drawer The drawer identifier.
   *
   * @param {number} id The entity identifier.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  async deleteLockWithHttpOperationResponse(drawer: number, id: number, options?: msRest.RequestOptionsBase): Promise<msRest.HttpOperationResponse> {
    let client = this;
    // Validate
    try {
      if (drawer === null || drawer === undefined || typeof drawer !== 'number') {
        throw new Error('drawer cannot be null or undefined and it must be of type number.');
      }
      if (id === null || id === undefined || typeof id !== 'number') {
        throw new Error('id cannot be null or undefined and it must be of type number.');
      }
    } catch (error) {
      return Promise.reject(error);
    }

    // Construct URL
    let baseUrl = this.baseUri;
    let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'v1/content/entities/{drawer}/{id}/locks';
    requestUrl = requestUrl.replace('{drawer}', encodeURIComponent(drawer.toString()));
    requestUrl = requestUrl.replace('{id}', encodeURIComponent(id.toString()));

    // Create HTTP transport objects
    let httpRequest = new WebResource();
    httpRequest.method = 'DELETE';
    httpRequest.url = requestUrl;
    httpRequest.headers = {};
    // Set Headers
    httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
    if(options && options.customHeaders) {
      for(let headerName in options.customHeaders) {
        if (options.customHeaders.hasOwnProperty(headerName)) {
          httpRequest.headers[headerName] = options.customHeaders[headerName];
        }
      }
    }
    // Send Request
    let operationRes: msRest.HttpOperationResponse;
    try {
      operationRes = await client.pipeline(httpRequest);
      let response = operationRes.response;
      let statusCode = response.status;
      if (statusCode !== 204 && statusCode !== 403 && statusCode !== 404) {
        let error = new msRest.RestError(operationRes.bodyAsText as string);
        error.statusCode = response.status;
        error.request = msRest.stripRequest(httpRequest);
        error.response = msRest.stripResponse(response);
        let parsedErrorResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedErrorResponse) {
            let internalError = null;
            if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
            error.code = internalError ? internalError.code : parsedErrorResponse.code;
            error.message = internalError ? internalError.message : parsedErrorResponse.message;
          }
        } catch (defaultError) {
          error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                           `- "${operationRes.bodyAsText}" for the default response.`;
          return Promise.reject(error);
        }
        return Promise.reject(error);
      }
      // Deserialize Response
      if (statusCode === 204) {
        let parsedResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedResponse !== null && parsedResponse !== undefined) {
            let resultMapper = {
              required: false,
              serializedName: 'parsedResponse',
              type: {
                name: 'Object'
              }
            };
            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
          }
        } catch (error) {
          let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
          deserializationError.request = msRest.stripRequest(httpRequest);
          deserializationError.response = msRest.stripResponse(response);
          return Promise.reject(deserializationError);
        }
      }

    } catch(err) {
      return Promise.reject(err);
    }

    return Promise.resolve(operationRes);
  }
  // methods on the client.

  /**
   * @summary Gets a paged list of notes.
   *
   * @param {number} drawerID Gets or sets the drawer identifier.
   *
   * @param {SoftheonEnterpriseAPIGetNotesByFilterOptionalParams} [options]
   * Optional Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  async getNotesByFilterWithHttpOperationResponse(drawerID: number, options?: Models.SoftheonEnterpriseAPIGetNotesByFilterOptionalParams): Promise<msRest.HttpOperationResponse> {
    let client = this;
    let entityID = (options && options.entityID !== undefined) ? options.entityID : undefined;
    let name = (options && options.name !== undefined) ? options.name : undefined;
    let creatorUserID = (options && options.creatorUserID !== undefined) ? options.creatorUserID : undefined;
    let modifierUserID = (options && options.modifierUserID !== undefined) ? options.modifierUserID : undefined;
    let minCreationTime = (options && options.minCreationTime !== undefined) ? options.minCreationTime : undefined;
    let maxCreationTime = (options && options.maxCreationTime !== undefined) ? options.maxCreationTime : undefined;
    let minModificationTime = (options && options.minModificationTime !== undefined) ? options.minModificationTime : undefined;
    let maxModificationTime = (options && options.maxModificationTime !== undefined) ? options.maxModificationTime : undefined;
    let parentID = (options && options.parentID !== undefined) ? options.parentID : undefined;
    let page = (options && options.page !== undefined) ? options.page : undefined;
    let pageSize = (options && options.pageSize !== undefined) ? options.pageSize : undefined;
    let sortOrder = (options && options.sortOrder !== undefined) ? options.sortOrder : undefined;
    let sortBy = (options && options.sortBy !== undefined) ? options.sortBy : undefined;
    // Validate
    try {
      if (drawerID === null || drawerID === undefined || typeof drawerID !== 'number') {
        throw new Error('drawerID cannot be null or undefined and it must be of type number.');
      }
      if (drawerID !== null && drawerID !== undefined) {
        if (drawerID > 2147483647)
        {
          throw new Error('"drawerID" should satisfy the constraint - "InclusiveMaximum": 2147483647');
        }
        if (drawerID < 1)
        {
          throw new Error('"drawerID" should satisfy the constraint - "InclusiveMinimum": 1');
        }
      }
      if (entityID !== null && entityID !== undefined && typeof entityID !== 'number') {
        throw new Error('entityID must be of type number.');
      }
      if (entityID !== null && entityID !== undefined) {
        if (entityID > 2147483647)
        {
          throw new Error('"entityID" should satisfy the constraint - "InclusiveMaximum": 2147483647');
        }
        if (entityID < 1)
        {
          throw new Error('"entityID" should satisfy the constraint - "InclusiveMinimum": 1');
        }
      }
      if (name !== null && name !== undefined && typeof name.valueOf() !== 'string') {
        throw new Error('name must be of type string.');
      }
      if (name !== null && name !== undefined) {
        if (name.length > 255)
        {
          throw new Error('"name" should satisfy the constraint - "MaxLength": 255');
        }
        if (name.length < 0)
        {
          throw new Error('"name" should satisfy the constraint - "MinLength": 0');
        }
      }
      if (creatorUserID !== null && creatorUserID !== undefined && typeof creatorUserID !== 'number') {
        throw new Error('creatorUserID must be of type number.');
      }
      if (creatorUserID !== null && creatorUserID !== undefined) {
        if (creatorUserID > 2147483647)
        {
          throw new Error('"creatorUserID" should satisfy the constraint - "InclusiveMaximum": 2147483647');
        }
        if (creatorUserID < 1)
        {
          throw new Error('"creatorUserID" should satisfy the constraint - "InclusiveMinimum": 1');
        }
      }
      if (modifierUserID !== null && modifierUserID !== undefined && typeof modifierUserID !== 'number') {
        throw new Error('modifierUserID must be of type number.');
      }
      if (modifierUserID !== null && modifierUserID !== undefined) {
        if (modifierUserID > 2147483647)
        {
          throw new Error('"modifierUserID" should satisfy the constraint - "InclusiveMaximum": 2147483647');
        }
        if (modifierUserID < 1)
        {
          throw new Error('"modifierUserID" should satisfy the constraint - "InclusiveMinimum": 1');
        }
      }
      if (minCreationTime && !(minCreationTime instanceof Date ||
          (typeof (minCreationTime as string).valueOf() === 'string' && !isNaN(Date.parse(minCreationTime as string))))) {
            throw new Error('minCreationTime must be of type date.');
          }
      if (maxCreationTime && !(maxCreationTime instanceof Date ||
          (typeof (maxCreationTime as string).valueOf() === 'string' && !isNaN(Date.parse(maxCreationTime as string))))) {
            throw new Error('maxCreationTime must be of type date.');
          }
      if (minModificationTime && !(minModificationTime instanceof Date ||
          (typeof (minModificationTime as string).valueOf() === 'string' && !isNaN(Date.parse(minModificationTime as string))))) {
            throw new Error('minModificationTime must be of type date.');
          }
      if (maxModificationTime && !(maxModificationTime instanceof Date ||
          (typeof (maxModificationTime as string).valueOf() === 'string' && !isNaN(Date.parse(maxModificationTime as string))))) {
            throw new Error('maxModificationTime must be of type date.');
          }
      if (parentID !== null && parentID !== undefined && typeof parentID !== 'number') {
        throw new Error('parentID must be of type number.');
      }
      if (parentID !== null && parentID !== undefined) {
        if (parentID > 2147483647)
        {
          throw new Error('"parentID" should satisfy the constraint - "InclusiveMaximum": 2147483647');
        }
        if (parentID < 1)
        {
          throw new Error('"parentID" should satisfy the constraint - "InclusiveMinimum": 1');
        }
      }
      if (page !== null && page !== undefined && typeof page !== 'number') {
        throw new Error('page must be of type number.');
      }
      if (page !== null && page !== undefined) {
        if (page > 2147483647)
        {
          throw new Error('"page" should satisfy the constraint - "InclusiveMaximum": 2147483647');
        }
        if (page < 1)
        {
          throw new Error('"page" should satisfy the constraint - "InclusiveMinimum": 1');
        }
      }
      if (pageSize !== null && pageSize !== undefined && typeof pageSize !== 'number') {
        throw new Error('pageSize must be of type number.');
      }
      if (pageSize !== null && pageSize !== undefined) {
        if (pageSize > 1000)
        {
          throw new Error('"pageSize" should satisfy the constraint - "InclusiveMaximum": 1000');
        }
        if (pageSize < 1)
        {
          throw new Error('"pageSize" should satisfy the constraint - "InclusiveMinimum": 1');
        }
      }
      if (sortOrder !== null && sortOrder !== undefined && typeof sortOrder.valueOf() !== 'string') {
        throw new Error('sortOrder must be of type string.');
      }
      if (sortBy !== null && sortBy !== undefined && typeof sortBy.valueOf() !== 'string') {
        throw new Error('sortBy must be of type string.');
      }
    } catch (error) {
      return Promise.reject(error);
    }

    // Construct URL
    let baseUrl = this.baseUri;
    let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'v1/content/notes';
    let queryParamsArray: Array<any> = [];
    queryParamsArray.push('drawerID=' + encodeURIComponent(drawerID.toString()));
    if (entityID !== null && entityID !== undefined) {
      queryParamsArray.push('entityID=' + encodeURIComponent(entityID.toString()));
    }
    if (name !== null && name !== undefined) {
      queryParamsArray.push('name=' + encodeURIComponent(name));
    }
    if (creatorUserID !== null && creatorUserID !== undefined) {
      queryParamsArray.push('creatorUserID=' + encodeURIComponent(creatorUserID.toString()));
    }
    if (modifierUserID !== null && modifierUserID !== undefined) {
      queryParamsArray.push('modifierUserID=' + encodeURIComponent(modifierUserID.toString()));
    }
    if (minCreationTime !== null && minCreationTime !== undefined) {
      queryParamsArray.push('minCreationTime=' + encodeURIComponent(msRest.serializeObject(minCreationTime)));
    }
    if (maxCreationTime !== null && maxCreationTime !== undefined) {
      queryParamsArray.push('maxCreationTime=' + encodeURIComponent(msRest.serializeObject(maxCreationTime)));
    }
    if (minModificationTime !== null && minModificationTime !== undefined) {
      queryParamsArray.push('minModificationTime=' + encodeURIComponent(msRest.serializeObject(minModificationTime)));
    }
    if (maxModificationTime !== null && maxModificationTime !== undefined) {
      queryParamsArray.push('maxModificationTime=' + encodeURIComponent(msRest.serializeObject(maxModificationTime)));
    }
    if (parentID !== null && parentID !== undefined) {
      queryParamsArray.push('parentID=' + encodeURIComponent(parentID.toString()));
    }
    if (page !== null && page !== undefined) {
      queryParamsArray.push('page=' + encodeURIComponent(page.toString()));
    }
    if (pageSize !== null && pageSize !== undefined) {
      queryParamsArray.push('pageSize=' + encodeURIComponent(pageSize.toString()));
    }
    if (sortOrder !== null && sortOrder !== undefined) {
      queryParamsArray.push('sortOrder=' + encodeURIComponent(sortOrder));
    }
    if (sortBy !== null && sortBy !== undefined) {
      queryParamsArray.push('sortBy=' + encodeURIComponent(sortBy));
    }
    if (queryParamsArray.length > 0) {
      requestUrl += '?' + queryParamsArray.join('&');
    }

    // Create HTTP transport objects
    let httpRequest = new WebResource();
    httpRequest.method = 'GET';
    httpRequest.url = requestUrl;
    httpRequest.headers = {};
    // Set Headers
    httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
    if(options && options.customHeaders) {
      for(let headerName in options.customHeaders) {
        if (options.customHeaders.hasOwnProperty(headerName)) {
          httpRequest.headers[headerName] = options.customHeaders[headerName];
        }
      }
    }
    // Send Request
    let operationRes: msRest.HttpOperationResponse;
    try {
      operationRes = await client.pipeline(httpRequest);
      let response = operationRes.response;
      let statusCode = response.status;
      if (statusCode !== 200) {
        let error = new msRest.RestError(operationRes.bodyAsText as string);
        error.statusCode = response.status;
        error.request = msRest.stripRequest(httpRequest);
        error.response = msRest.stripResponse(response);
        let parsedErrorResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedErrorResponse) {
            let internalError = null;
            if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
            error.code = internalError ? internalError.code : parsedErrorResponse.code;
            error.message = internalError ? internalError.message : parsedErrorResponse.message;
          }
        } catch (defaultError) {
          error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                           `- "${operationRes.bodyAsText}" for the default response.`;
          return Promise.reject(error);
        }
        return Promise.reject(error);
      }
      // Deserialize Response
      if (statusCode === 200) {
        let parsedResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedResponse !== null && parsedResponse !== undefined) {
            let resultMapper = {
              required: false,
              serializedName: 'parsedResponse',
              type: {
                name: 'Sequence',
                element: {
                    required: false,
                    serializedName: 'NoteModelElementType',
                    type: {
                      name: 'Composite',
                      className: 'NoteModel'
                    }
                }
              }
            };
            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
          }
        } catch (error) {
          let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
          deserializationError.request = msRest.stripRequest(httpRequest);
          deserializationError.response = msRest.stripResponse(response);
          return Promise.reject(deserializationError);
        }
      }

    } catch(err) {
      return Promise.reject(err);
    }

    return Promise.resolve(operationRes);
  }
  // methods on the client.

  /**
   * @summary Gets a note by its unique identifier.
   *
   * @param {number} drawer The drawer identifier.
   *
   * @param {number} id The note identifier.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  async getNoteByIdWithHttpOperationResponse(drawer: number, id: number, options?: msRest.RequestOptionsBase): Promise<msRest.HttpOperationResponse> {
    let client = this;
    // Validate
    try {
      if (drawer === null || drawer === undefined || typeof drawer !== 'number') {
        throw new Error('drawer cannot be null or undefined and it must be of type number.');
      }
      if (id === null || id === undefined || typeof id !== 'number') {
        throw new Error('id cannot be null or undefined and it must be of type number.');
      }
    } catch (error) {
      return Promise.reject(error);
    }

    // Construct URL
    let baseUrl = this.baseUri;
    let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'v1/content/notes/{drawer}/{id}';
    requestUrl = requestUrl.replace('{drawer}', encodeURIComponent(drawer.toString()));
    requestUrl = requestUrl.replace('{id}', encodeURIComponent(id.toString()));

    // Create HTTP transport objects
    let httpRequest = new WebResource();
    httpRequest.method = 'GET';
    httpRequest.url = requestUrl;
    httpRequest.headers = {};
    // Set Headers
    httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
    if(options && options.customHeaders) {
      for(let headerName in options.customHeaders) {
        if (options.customHeaders.hasOwnProperty(headerName)) {
          httpRequest.headers[headerName] = options.customHeaders[headerName];
        }
      }
    }
    // Send Request
    let operationRes: msRest.HttpOperationResponse;
    try {
      operationRes = await client.pipeline(httpRequest);
      let response = operationRes.response;
      let statusCode = response.status;
      if (statusCode !== 200 && statusCode !== 403 && statusCode !== 404) {
        let error = new msRest.RestError(operationRes.bodyAsText as string);
        error.statusCode = response.status;
        error.request = msRest.stripRequest(httpRequest);
        error.response = msRest.stripResponse(response);
        let parsedErrorResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedErrorResponse) {
            let internalError = null;
            if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
            error.code = internalError ? internalError.code : parsedErrorResponse.code;
            error.message = internalError ? internalError.message : parsedErrorResponse.message;
          }
        } catch (defaultError) {
          error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                           `- "${operationRes.bodyAsText}" for the default response.`;
          return Promise.reject(error);
        }
        return Promise.reject(error);
      }
      // Deserialize Response
      if (statusCode === 200) {
        let parsedResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedResponse !== null && parsedResponse !== undefined) {
            let resultMapper = Mappers.NoteModel;
            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
          }
        } catch (error) {
          let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
          deserializationError.request = msRest.stripRequest(httpRequest);
          deserializationError.response = msRest.stripResponse(response);
          return Promise.reject(deserializationError);
        }
      }

    } catch(err) {
      return Promise.reject(err);
    }

    return Promise.resolve(operationRes);
  }
  // methods on the client.

  /**
   * @summary Updates a specified note.
   *
   * @param {number} drawer The drawer identifier.
   *
   * @param {number} id The note identifier.
   *
   * @param {NoteBase} model The note model.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  async updateNoteWithHttpOperationResponse(drawer: number, id: number, model: Models.NoteBase, options?: msRest.RequestOptionsBase): Promise<msRest.HttpOperationResponse> {
    let client = this;
    // Validate
    try {
      if (drawer === null || drawer === undefined || typeof drawer !== 'number') {
        throw new Error('drawer cannot be null or undefined and it must be of type number.');
      }
      if (id === null || id === undefined || typeof id !== 'number') {
        throw new Error('id cannot be null or undefined and it must be of type number.');
      }
      if (model === null || model === undefined) {
        throw new Error('model cannot be null or undefined.');
      }
    } catch (error) {
      return Promise.reject(error);
    }

    // Construct URL
    let baseUrl = this.baseUri;
    let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'v1/content/notes/{drawer}/{id}';
    requestUrl = requestUrl.replace('{drawer}', encodeURIComponent(drawer.toString()));
    requestUrl = requestUrl.replace('{id}', encodeURIComponent(id.toString()));

    // Create HTTP transport objects
    let httpRequest = new WebResource();
    httpRequest.method = 'PUT';
    httpRequest.url = requestUrl;
    httpRequest.headers = {};
    // Set Headers
    httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
    if(options && options.customHeaders) {
      for(let headerName in options.customHeaders) {
        if (options.customHeaders.hasOwnProperty(headerName)) {
          httpRequest.headers[headerName] = options.customHeaders[headerName];
        }
      }
    }
    // Serialize Request
    let requestContent = null;
    let requestModel = null;
    try {
      if (model !== null && model !== undefined) {
        let requestModelMapper = Mappers.NoteBase;
        requestModel = client.serializer.serialize(requestModelMapper, model, 'model');
        requestContent = JSON.stringify(requestModel);
      }
    } catch (error) {
      let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
          `payload - ${JSON.stringify(model, null, 2)}.`);
      return Promise.reject(serializationError);
    }
    httpRequest.body = requestContent;
    // Send Request
    let operationRes: msRest.HttpOperationResponse;
    try {
      operationRes = await client.pipeline(httpRequest);
      let response = operationRes.response;
      let statusCode = response.status;
      if (statusCode !== 204 && statusCode !== 403 && statusCode !== 404) {
        let error = new msRest.RestError(operationRes.bodyAsText as string);
        error.statusCode = response.status;
        error.request = msRest.stripRequest(httpRequest);
        error.response = msRest.stripResponse(response);
        let parsedErrorResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedErrorResponse) {
            let internalError = null;
            if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
            error.code = internalError ? internalError.code : parsedErrorResponse.code;
            error.message = internalError ? internalError.message : parsedErrorResponse.message;
          }
        } catch (defaultError) {
          error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                           `- "${operationRes.bodyAsText}" for the default response.`;
          return Promise.reject(error);
        }
        return Promise.reject(error);
      }
      // Deserialize Response
      if (statusCode === 204) {
        let parsedResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedResponse !== null && parsedResponse !== undefined) {
            let resultMapper = {
              required: false,
              serializedName: 'parsedResponse',
              type: {
                name: 'Object'
              }
            };
            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
          }
        } catch (error) {
          let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
          deserializationError.request = msRest.stripRequest(httpRequest);
          deserializationError.response = msRest.stripResponse(response);
          return Promise.reject(deserializationError);
        }
      }

    } catch(err) {
      return Promise.reject(err);
    }

    return Promise.resolve(operationRes);
  }
  // methods on the client.

  /**
   * @summary Deletes a specified note.
   *
   * @param {number} drawer The drawer identifier.
   *
   * @param {number} id The note identifier.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  async deleteNoteWithHttpOperationResponse(drawer: number, id: number, options?: msRest.RequestOptionsBase): Promise<msRest.HttpOperationResponse> {
    let client = this;
    // Validate
    try {
      if (drawer === null || drawer === undefined || typeof drawer !== 'number') {
        throw new Error('drawer cannot be null or undefined and it must be of type number.');
      }
      if (id === null || id === undefined || typeof id !== 'number') {
        throw new Error('id cannot be null or undefined and it must be of type number.');
      }
    } catch (error) {
      return Promise.reject(error);
    }

    // Construct URL
    let baseUrl = this.baseUri;
    let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'v1/content/notes/{drawer}/{id}';
    requestUrl = requestUrl.replace('{drawer}', encodeURIComponent(drawer.toString()));
    requestUrl = requestUrl.replace('{id}', encodeURIComponent(id.toString()));

    // Create HTTP transport objects
    let httpRequest = new WebResource();
    httpRequest.method = 'DELETE';
    httpRequest.url = requestUrl;
    httpRequest.headers = {};
    // Set Headers
    httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
    if(options && options.customHeaders) {
      for(let headerName in options.customHeaders) {
        if (options.customHeaders.hasOwnProperty(headerName)) {
          httpRequest.headers[headerName] = options.customHeaders[headerName];
        }
      }
    }
    // Send Request
    let operationRes: msRest.HttpOperationResponse;
    try {
      operationRes = await client.pipeline(httpRequest);
      let response = operationRes.response;
      let statusCode = response.status;
      if (statusCode !== 204 && statusCode !== 403 && statusCode !== 404) {
        let error = new msRest.RestError(operationRes.bodyAsText as string);
        error.statusCode = response.status;
        error.request = msRest.stripRequest(httpRequest);
        error.response = msRest.stripResponse(response);
        let parsedErrorResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedErrorResponse) {
            let internalError = null;
            if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
            error.code = internalError ? internalError.code : parsedErrorResponse.code;
            error.message = internalError ? internalError.message : parsedErrorResponse.message;
          }
        } catch (defaultError) {
          error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                           `- "${operationRes.bodyAsText}" for the default response.`;
          return Promise.reject(error);
        }
        return Promise.reject(error);
      }
      // Deserialize Response
      if (statusCode === 204) {
        let parsedResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedResponse !== null && parsedResponse !== undefined) {
            let resultMapper = {
              required: false,
              serializedName: 'parsedResponse',
              type: {
                name: 'Object'
              }
            };
            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
          }
        } catch (error) {
          let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
          deserializationError.request = msRest.stripRequest(httpRequest);
          deserializationError.response = msRest.stripResponse(response);
          return Promise.reject(deserializationError);
        }
      }

    } catch(err) {
      return Promise.reject(err);
    }

    return Promise.resolve(operationRes);
  }
  // methods on the client.

  /**
   * @summary Creates a new note.
   *
   * @param {number} drawer The drawer identifier.
   *
   * @param {InsertNoteRequestModel} model The note model.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  async createNoteWithHttpOperationResponse(drawer: number, model: Models.InsertNoteRequestModel, options?: msRest.RequestOptionsBase): Promise<msRest.HttpOperationResponse> {
    let client = this;
    // Validate
    try {
      if (drawer === null || drawer === undefined || typeof drawer !== 'number') {
        throw new Error('drawer cannot be null or undefined and it must be of type number.');
      }
      if (model === null || model === undefined) {
        throw new Error('model cannot be null or undefined.');
      }
    } catch (error) {
      return Promise.reject(error);
    }

    // Construct URL
    let baseUrl = this.baseUri;
    let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'v1/content/notes/{drawer}';
    requestUrl = requestUrl.replace('{drawer}', encodeURIComponent(drawer.toString()));

    // Create HTTP transport objects
    let httpRequest = new WebResource();
    httpRequest.method = 'POST';
    httpRequest.url = requestUrl;
    httpRequest.headers = {};
    // Set Headers
    httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
    if(options && options.customHeaders) {
      for(let headerName in options.customHeaders) {
        if (options.customHeaders.hasOwnProperty(headerName)) {
          httpRequest.headers[headerName] = options.customHeaders[headerName];
        }
      }
    }
    // Serialize Request
    let requestContent = null;
    let requestModel = null;
    try {
      if (model !== null && model !== undefined) {
        let requestModelMapper = Mappers.InsertNoteRequestModel;
        requestModel = client.serializer.serialize(requestModelMapper, model, 'model');
        requestContent = JSON.stringify(requestModel);
      }
    } catch (error) {
      let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
          `payload - ${JSON.stringify(model, null, 2)}.`);
      return Promise.reject(serializationError);
    }
    httpRequest.body = requestContent;
    // Send Request
    let operationRes: msRest.HttpOperationResponse;
    try {
      operationRes = await client.pipeline(httpRequest);
      let response = operationRes.response;
      let statusCode = response.status;
      if (statusCode !== 201 && statusCode !== 403 && statusCode !== 404) {
        let error = new msRest.RestError(operationRes.bodyAsText as string);
        error.statusCode = response.status;
        error.request = msRest.stripRequest(httpRequest);
        error.response = msRest.stripResponse(response);
        let parsedErrorResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedErrorResponse) {
            let internalError = null;
            if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
            error.code = internalError ? internalError.code : parsedErrorResponse.code;
            error.message = internalError ? internalError.message : parsedErrorResponse.message;
          }
        } catch (defaultError) {
          error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                           `- "${operationRes.bodyAsText}" for the default response.`;
          return Promise.reject(error);
        }
        return Promise.reject(error);
      }
      // Deserialize Response
      if (statusCode === 201) {
        let parsedResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedResponse !== null && parsedResponse !== undefined) {
            let resultMapper = Mappers.NoteModel;
            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
          }
        } catch (error) {
          let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
          deserializationError.request = msRest.stripRequest(httpRequest);
          deserializationError.response = msRest.stripResponse(response);
          return Promise.reject(deserializationError);
        }
      }

    } catch(err) {
      return Promise.reject(err);
    }

    return Promise.resolve(operationRes);
  }
  // methods on the client.

  /**
   * @summary Gets a paged list of queue assignments.
   *
   * @param {SoftheonEnterpriseAPIGetQueueAssignmentsByFilterOptionalParams}
   * [options] Optional Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  async getQueueAssignmentsByFilterWithHttpOperationResponse(options?: Models.SoftheonEnterpriseAPIGetQueueAssignmentsByFilterOptionalParams): Promise<msRest.HttpOperationResponse> {
    let client = this;
    let queueID = (options && options.queueID !== undefined) ? options.queueID : undefined;
    let userID = (options && options.userID !== undefined) ? options.userID : undefined;
    let groupID = (options && options.groupID !== undefined) ? options.groupID : undefined;
    let type = (options && options.type !== undefined) ? options.type : undefined;
    let order = (options && options.order !== undefined) ? options.order : undefined;
    let taskSortColumn = (options && options.taskSortColumn !== undefined) ? options.taskSortColumn : undefined;
    let state = (options && options.state !== undefined) ? options.state : undefined;
    let fetchType = (options && options.fetchType !== undefined) ? options.fetchType : undefined;
    let page = (options && options.page !== undefined) ? options.page : undefined;
    let pageSize = (options && options.pageSize !== undefined) ? options.pageSize : undefined;
    let sortOrder = (options && options.sortOrder !== undefined) ? options.sortOrder : undefined;
    let sortBy = (options && options.sortBy !== undefined) ? options.sortBy : undefined;
    // Validate
    try {
      if (queueID !== null && queueID !== undefined && typeof queueID !== 'number') {
        throw new Error('queueID must be of type number.');
      }
      if (queueID !== null && queueID !== undefined) {
        if (queueID > 2147483647)
        {
          throw new Error('"queueID" should satisfy the constraint - "InclusiveMaximum": 2147483647');
        }
        if (queueID < 1)
        {
          throw new Error('"queueID" should satisfy the constraint - "InclusiveMinimum": 1');
        }
      }
      if (userID !== null && userID !== undefined && typeof userID !== 'number') {
        throw new Error('userID must be of type number.');
      }
      if (userID !== null && userID !== undefined) {
        if (userID > 2147483647)
        {
          throw new Error('"userID" should satisfy the constraint - "InclusiveMaximum": 2147483647');
        }
        if (userID < 1)
        {
          throw new Error('"userID" should satisfy the constraint - "InclusiveMinimum": 1');
        }
      }
      if (groupID !== null && groupID !== undefined && typeof groupID !== 'number') {
        throw new Error('groupID must be of type number.');
      }
      if (groupID !== null && groupID !== undefined) {
        if (groupID > 2147483647)
        {
          throw new Error('"groupID" should satisfy the constraint - "InclusiveMaximum": 2147483647');
        }
        if (groupID < 1)
        {
          throw new Error('"groupID" should satisfy the constraint - "InclusiveMinimum": 1');
        }
      }
      if (type !== null && type !== undefined && typeof type.valueOf() !== 'string') {
        throw new Error('type must be of type string.');
      }
      if (order !== null && order !== undefined && typeof order !== 'number') {
        throw new Error('order must be of type number.');
      }
      if (order !== null && order !== undefined) {
        if (order > 2147483647)
        {
          throw new Error('"order" should satisfy the constraint - "InclusiveMaximum": 2147483647');
        }
        if (order < 1)
        {
          throw new Error('"order" should satisfy the constraint - "InclusiveMinimum": 1');
        }
      }
      if (taskSortColumn !== null && taskSortColumn !== undefined && typeof taskSortColumn.valueOf() !== 'string') {
        throw new Error('taskSortColumn must be of type string.');
      }
      if (state !== null && state !== undefined && typeof state.valueOf() !== 'string') {
        throw new Error('state must be of type string.');
      }
      if (fetchType !== null && fetchType !== undefined && typeof fetchType.valueOf() !== 'string') {
        throw new Error('fetchType must be of type string.');
      }
      if (page !== null && page !== undefined && typeof page !== 'number') {
        throw new Error('page must be of type number.');
      }
      if (page !== null && page !== undefined) {
        if (page > 2147483647)
        {
          throw new Error('"page" should satisfy the constraint - "InclusiveMaximum": 2147483647');
        }
        if (page < 1)
        {
          throw new Error('"page" should satisfy the constraint - "InclusiveMinimum": 1');
        }
      }
      if (pageSize !== null && pageSize !== undefined && typeof pageSize !== 'number') {
        throw new Error('pageSize must be of type number.');
      }
      if (pageSize !== null && pageSize !== undefined) {
        if (pageSize > 1000)
        {
          throw new Error('"pageSize" should satisfy the constraint - "InclusiveMaximum": 1000');
        }
        if (pageSize < 1)
        {
          throw new Error('"pageSize" should satisfy the constraint - "InclusiveMinimum": 1');
        }
      }
      if (sortOrder !== null && sortOrder !== undefined && typeof sortOrder.valueOf() !== 'string') {
        throw new Error('sortOrder must be of type string.');
      }
      if (sortBy !== null && sortBy !== undefined && typeof sortBy.valueOf() !== 'string') {
        throw new Error('sortBy must be of type string.');
      }
    } catch (error) {
      return Promise.reject(error);
    }

    // Construct URL
    let baseUrl = this.baseUri;
    let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'v1/workflow/assignments';
    let queryParamsArray: Array<any> = [];
    if (queueID !== null && queueID !== undefined) {
      queryParamsArray.push('queueID=' + encodeURIComponent(queueID.toString()));
    }
    if (userID !== null && userID !== undefined) {
      queryParamsArray.push('userID=' + encodeURIComponent(userID.toString()));
    }
    if (groupID !== null && groupID !== undefined) {
      queryParamsArray.push('groupID=' + encodeURIComponent(groupID.toString()));
    }
    if (type !== null && type !== undefined) {
      queryParamsArray.push('type=' + encodeURIComponent(type));
    }
    if (order !== null && order !== undefined) {
      queryParamsArray.push('order=' + encodeURIComponent(order.toString()));
    }
    if (taskSortColumn !== null && taskSortColumn !== undefined) {
      queryParamsArray.push('taskSortColumn=' + encodeURIComponent(taskSortColumn));
    }
    if (state !== null && state !== undefined) {
      queryParamsArray.push('state=' + encodeURIComponent(state));
    }
    if (fetchType !== null && fetchType !== undefined) {
      queryParamsArray.push('fetchType=' + encodeURIComponent(fetchType));
    }
    if (page !== null && page !== undefined) {
      queryParamsArray.push('page=' + encodeURIComponent(page.toString()));
    }
    if (pageSize !== null && pageSize !== undefined) {
      queryParamsArray.push('pageSize=' + encodeURIComponent(pageSize.toString()));
    }
    if (sortOrder !== null && sortOrder !== undefined) {
      queryParamsArray.push('sortOrder=' + encodeURIComponent(sortOrder));
    }
    if (sortBy !== null && sortBy !== undefined) {
      queryParamsArray.push('sortBy=' + encodeURIComponent(sortBy));
    }
    if (queryParamsArray.length > 0) {
      requestUrl += '?' + queryParamsArray.join('&');
    }

    // Create HTTP transport objects
    let httpRequest = new WebResource();
    httpRequest.method = 'GET';
    httpRequest.url = requestUrl;
    httpRequest.headers = {};
    // Set Headers
    httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
    if(options && options.customHeaders) {
      for(let headerName in options.customHeaders) {
        if (options.customHeaders.hasOwnProperty(headerName)) {
          httpRequest.headers[headerName] = options.customHeaders[headerName];
        }
      }
    }
    // Send Request
    let operationRes: msRest.HttpOperationResponse;
    try {
      operationRes = await client.pipeline(httpRequest);
      let response = operationRes.response;
      let statusCode = response.status;
      if (statusCode !== 200 && statusCode !== 403) {
        let error = new msRest.RestError(operationRes.bodyAsText as string);
        error.statusCode = response.status;
        error.request = msRest.stripRequest(httpRequest);
        error.response = msRest.stripResponse(response);
        let parsedErrorResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedErrorResponse) {
            let internalError = null;
            if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
            error.code = internalError ? internalError.code : parsedErrorResponse.code;
            error.message = internalError ? internalError.message : parsedErrorResponse.message;
          }
        } catch (defaultError) {
          error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                           `- "${operationRes.bodyAsText}" for the default response.`;
          return Promise.reject(error);
        }
        return Promise.reject(error);
      }
      // Deserialize Response
      if (statusCode === 200) {
        let parsedResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedResponse !== null && parsedResponse !== undefined) {
            let resultMapper = {
              required: false,
              serializedName: 'parsedResponse',
              type: {
                name: 'Sequence',
                element: {
                    required: false,
                    serializedName: 'QueueAssignmentModelElementType',
                    type: {
                      name: 'Composite',
                      className: 'QueueAssignmentModel'
                    }
                }
              }
            };
            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
          }
        } catch (error) {
          let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
          deserializationError.request = msRest.stripRequest(httpRequest);
          deserializationError.response = msRest.stripResponse(response);
          return Promise.reject(deserializationError);
        }
      }

    } catch(err) {
      return Promise.reject(err);
    }

    return Promise.resolve(operationRes);
  }
  // methods on the client.

  /**
   * @summary Updates the specified queue assignment.
   *
   * @param {QueueAssignmentModel} model The model.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  async updateQueueAssignemntWithHttpOperationResponse(model: Models.QueueAssignmentModel, options?: msRest.RequestOptionsBase): Promise<msRest.HttpOperationResponse> {
    let client = this;
    // Validate
    try {
      if (model === null || model === undefined) {
        throw new Error('model cannot be null or undefined.');
      }
    } catch (error) {
      return Promise.reject(error);
    }

    // Construct URL
    let baseUrl = this.baseUri;
    let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'v1/workflow/assignments';

    // Create HTTP transport objects
    let httpRequest = new WebResource();
    httpRequest.method = 'PUT';
    httpRequest.url = requestUrl;
    httpRequest.headers = {};
    // Set Headers
    httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
    if(options && options.customHeaders) {
      for(let headerName in options.customHeaders) {
        if (options.customHeaders.hasOwnProperty(headerName)) {
          httpRequest.headers[headerName] = options.customHeaders[headerName];
        }
      }
    }
    // Serialize Request
    let requestContent = null;
    let requestModel = null;
    try {
      if (model !== null && model !== undefined) {
        let requestModelMapper = Mappers.QueueAssignmentModel;
        requestModel = client.serializer.serialize(requestModelMapper, model, 'model');
        requestContent = JSON.stringify(requestModel);
      }
    } catch (error) {
      let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
          `payload - ${JSON.stringify(model, null, 2)}.`);
      return Promise.reject(serializationError);
    }
    httpRequest.body = requestContent;
    // Send Request
    let operationRes: msRest.HttpOperationResponse;
    try {
      operationRes = await client.pipeline(httpRequest);
      let response = operationRes.response;
      let statusCode = response.status;
      if (statusCode !== 204 && statusCode !== 403 && statusCode !== 404) {
        let error = new msRest.RestError(operationRes.bodyAsText as string);
        error.statusCode = response.status;
        error.request = msRest.stripRequest(httpRequest);
        error.response = msRest.stripResponse(response);
        let parsedErrorResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedErrorResponse) {
            let internalError = null;
            if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
            error.code = internalError ? internalError.code : parsedErrorResponse.code;
            error.message = internalError ? internalError.message : parsedErrorResponse.message;
          }
        } catch (defaultError) {
          error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                           `- "${operationRes.bodyAsText}" for the default response.`;
          return Promise.reject(error);
        }
        return Promise.reject(error);
      }
      // Deserialize Response
      if (statusCode === 204) {
        let parsedResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedResponse !== null && parsedResponse !== undefined) {
            let resultMapper = {
              required: false,
              serializedName: 'parsedResponse',
              type: {
                name: 'Object'
              }
            };
            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
          }
        } catch (error) {
          let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
          deserializationError.request = msRest.stripRequest(httpRequest);
          deserializationError.response = msRest.stripResponse(response);
          return Promise.reject(deserializationError);
        }
      }

    } catch(err) {
      return Promise.reject(err);
    }

    return Promise.resolve(operationRes);
  }
  // methods on the client.

  /**
   * @summary Creates a new queue assignment.
   *
   * @param {InsertQueueAssignmentRequestModel} model The model.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  async createQueueAssignmentWithHttpOperationResponse(model: Models.InsertQueueAssignmentRequestModel, options?: msRest.RequestOptionsBase): Promise<msRest.HttpOperationResponse> {
    let client = this;
    // Validate
    try {
      if (model === null || model === undefined) {
        throw new Error('model cannot be null or undefined.');
      }
    } catch (error) {
      return Promise.reject(error);
    }

    // Construct URL
    let baseUrl = this.baseUri;
    let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'v1/workflow/assignments';

    // Create HTTP transport objects
    let httpRequest = new WebResource();
    httpRequest.method = 'POST';
    httpRequest.url = requestUrl;
    httpRequest.headers = {};
    // Set Headers
    httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
    if(options && options.customHeaders) {
      for(let headerName in options.customHeaders) {
        if (options.customHeaders.hasOwnProperty(headerName)) {
          httpRequest.headers[headerName] = options.customHeaders[headerName];
        }
      }
    }
    // Serialize Request
    let requestContent = null;
    let requestModel = null;
    try {
      if (model !== null && model !== undefined) {
        let requestModelMapper = Mappers.InsertQueueAssignmentRequestModel;
        requestModel = client.serializer.serialize(requestModelMapper, model, 'model');
        requestContent = JSON.stringify(requestModel);
      }
    } catch (error) {
      let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
          `payload - ${JSON.stringify(model, null, 2)}.`);
      return Promise.reject(serializationError);
    }
    httpRequest.body = requestContent;
    // Send Request
    let operationRes: msRest.HttpOperationResponse;
    try {
      operationRes = await client.pipeline(httpRequest);
      let response = operationRes.response;
      let statusCode = response.status;
      if (statusCode !== 201 && statusCode !== 403 && statusCode !== 404 && statusCode !== 409) {
        let error = new msRest.RestError(operationRes.bodyAsText as string);
        error.statusCode = response.status;
        error.request = msRest.stripRequest(httpRequest);
        error.response = msRest.stripResponse(response);
        let parsedErrorResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedErrorResponse) {
            let internalError = null;
            if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
            error.code = internalError ? internalError.code : parsedErrorResponse.code;
            error.message = internalError ? internalError.message : parsedErrorResponse.message;
          }
        } catch (defaultError) {
          error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                           `- "${operationRes.bodyAsText}" for the default response.`;
          return Promise.reject(error);
        }
        return Promise.reject(error);
      }
      // Deserialize Response
      if (statusCode === 201) {
        let parsedResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedResponse !== null && parsedResponse !== undefined) {
            let resultMapper = Mappers.QueueAssignmentModel;
            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
          }
        } catch (error) {
          let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
          deserializationError.request = msRest.stripRequest(httpRequest);
          deserializationError.response = msRest.stripResponse(response);
          return Promise.reject(deserializationError);
        }
      }

    } catch(err) {
      return Promise.reject(err);
    }

    return Promise.resolve(operationRes);
  }
  // methods on the client.

  /**
   * @summary Gets a single queue assignment based on user and queue identifiers.
   *
   * @param {number} userId The user identifier.
   *
   * @param {number} queueId The queue identifier.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  async getQueueAssignmentsByIdWithHttpOperationResponse(userId: number, queueId: number, options?: msRest.RequestOptionsBase): Promise<msRest.HttpOperationResponse> {
    let client = this;
    // Validate
    try {
      if (userId === null || userId === undefined || typeof userId !== 'number') {
        throw new Error('userId cannot be null or undefined and it must be of type number.');
      }
      if (queueId === null || queueId === undefined || typeof queueId !== 'number') {
        throw new Error('queueId cannot be null or undefined and it must be of type number.');
      }
    } catch (error) {
      return Promise.reject(error);
    }

    // Construct URL
    let baseUrl = this.baseUri;
    let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'v1/workflow/assignments/users/{userId}/queues/{queueId}';
    requestUrl = requestUrl.replace('{userId}', encodeURIComponent(userId.toString()));
    requestUrl = requestUrl.replace('{queueId}', encodeURIComponent(queueId.toString()));

    // Create HTTP transport objects
    let httpRequest = new WebResource();
    httpRequest.method = 'GET';
    httpRequest.url = requestUrl;
    httpRequest.headers = {};
    // Set Headers
    httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
    if(options && options.customHeaders) {
      for(let headerName in options.customHeaders) {
        if (options.customHeaders.hasOwnProperty(headerName)) {
          httpRequest.headers[headerName] = options.customHeaders[headerName];
        }
      }
    }
    // Send Request
    let operationRes: msRest.HttpOperationResponse;
    try {
      operationRes = await client.pipeline(httpRequest);
      let response = operationRes.response;
      let statusCode = response.status;
      if (statusCode !== 200 && statusCode !== 403 && statusCode !== 404) {
        let error = new msRest.RestError(operationRes.bodyAsText as string);
        error.statusCode = response.status;
        error.request = msRest.stripRequest(httpRequest);
        error.response = msRest.stripResponse(response);
        let parsedErrorResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedErrorResponse) {
            let internalError = null;
            if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
            error.code = internalError ? internalError.code : parsedErrorResponse.code;
            error.message = internalError ? internalError.message : parsedErrorResponse.message;
          }
        } catch (defaultError) {
          error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                           `- "${operationRes.bodyAsText}" for the default response.`;
          return Promise.reject(error);
        }
        return Promise.reject(error);
      }
      // Deserialize Response
      if (statusCode === 200) {
        let parsedResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedResponse !== null && parsedResponse !== undefined) {
            let resultMapper = Mappers.QueueAssignmentModel;
            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
          }
        } catch (error) {
          let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
          deserializationError.request = msRest.stripRequest(httpRequest);
          deserializationError.response = msRest.stripResponse(response);
          return Promise.reject(deserializationError);
        }
      }

    } catch(err) {
      return Promise.reject(err);
    }

    return Promise.resolve(operationRes);
  }
  // methods on the client.

  /**
   * @summary Deletes the specified queue assignment.
   *
   * @param {number} userId The user identifier.
   *
   * @param {number} queueId The queue identifier.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  async deleteQueueAssignmentWithHttpOperationResponse(userId: number, queueId: number, options?: msRest.RequestOptionsBase): Promise<msRest.HttpOperationResponse> {
    let client = this;
    // Validate
    try {
      if (userId === null || userId === undefined || typeof userId !== 'number') {
        throw new Error('userId cannot be null or undefined and it must be of type number.');
      }
      if (queueId === null || queueId === undefined || typeof queueId !== 'number') {
        throw new Error('queueId cannot be null or undefined and it must be of type number.');
      }
    } catch (error) {
      return Promise.reject(error);
    }

    // Construct URL
    let baseUrl = this.baseUri;
    let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'v1/workflow/assignments/users/{userId}/queues/{queueId}';
    requestUrl = requestUrl.replace('{userId}', encodeURIComponent(userId.toString()));
    requestUrl = requestUrl.replace('{queueId}', encodeURIComponent(queueId.toString()));

    // Create HTTP transport objects
    let httpRequest = new WebResource();
    httpRequest.method = 'DELETE';
    httpRequest.url = requestUrl;
    httpRequest.headers = {};
    // Set Headers
    httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
    if(options && options.customHeaders) {
      for(let headerName in options.customHeaders) {
        if (options.customHeaders.hasOwnProperty(headerName)) {
          httpRequest.headers[headerName] = options.customHeaders[headerName];
        }
      }
    }
    // Send Request
    let operationRes: msRest.HttpOperationResponse;
    try {
      operationRes = await client.pipeline(httpRequest);
      let response = operationRes.response;
      let statusCode = response.status;
      if (statusCode !== 204 && statusCode !== 403 && statusCode !== 404) {
        let error = new msRest.RestError(operationRes.bodyAsText as string);
        error.statusCode = response.status;
        error.request = msRest.stripRequest(httpRequest);
        error.response = msRest.stripResponse(response);
        let parsedErrorResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedErrorResponse) {
            let internalError = null;
            if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
            error.code = internalError ? internalError.code : parsedErrorResponse.code;
            error.message = internalError ? internalError.message : parsedErrorResponse.message;
          }
        } catch (defaultError) {
          error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                           `- "${operationRes.bodyAsText}" for the default response.`;
          return Promise.reject(error);
        }
        return Promise.reject(error);
      }
      // Deserialize Response
      if (statusCode === 204) {
        let parsedResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedResponse !== null && parsedResponse !== undefined) {
            let resultMapper = {
              required: false,
              serializedName: 'parsedResponse',
              type: {
                name: 'Object'
              }
            };
            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
          }
        } catch (error) {
          let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
          deserializationError.request = msRest.stripRequest(httpRequest);
          deserializationError.response = msRest.stripResponse(response);
          return Promise.reject(deserializationError);
        }
      }

    } catch(err) {
      return Promise.reject(err);
    }

    return Promise.resolve(operationRes);
  }
  // methods on the client.

  /**
   * @summary Gets a paged list of queues.
   *
   * @param {SoftheonEnterpriseAPIGetQueuesByFilterOptionalParams} [options]
   * Optional Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  async getQueuesByFilterWithHttpOperationResponse(options?: Models.SoftheonEnterpriseAPIGetQueuesByFilterOptionalParams): Promise<msRest.HttpOperationResponse> {
    let client = this;
    let iD = (options && options.iD !== undefined) ? options.iD : undefined;
    let name = (options && options.name !== undefined) ? options.name : undefined;
    let alias = (options && options.alias !== undefined) ? options.alias : undefined;
    let type = (options && options.type !== undefined) ? options.type : undefined;
    let access = (options && options.access !== undefined) ? options.access : undefined;
    let bypassSecurity = (options && options.bypassSecurity !== undefined) ? options.bypassSecurity : undefined;
    let page = (options && options.page !== undefined) ? options.page : undefined;
    let pageSize = (options && options.pageSize !== undefined) ? options.pageSize : undefined;
    let sortOrder = (options && options.sortOrder !== undefined) ? options.sortOrder : undefined;
    let sortBy = (options && options.sortBy !== undefined) ? options.sortBy : undefined;
    // Validate
    try {
      if (iD !== null && iD !== undefined && typeof iD !== 'number') {
        throw new Error('iD must be of type number.');
      }
      if (iD !== null && iD !== undefined) {
        if (iD > 2147483647)
        {
          throw new Error('"iD" should satisfy the constraint - "InclusiveMaximum": 2147483647');
        }
        if (iD < 1)
        {
          throw new Error('"iD" should satisfy the constraint - "InclusiveMinimum": 1');
        }
      }
      if (name !== null && name !== undefined && typeof name.valueOf() !== 'string') {
        throw new Error('name must be of type string.');
      }
      if (name !== null && name !== undefined) {
        if (name.length > 255)
        {
          throw new Error('"name" should satisfy the constraint - "MaxLength": 255');
        }
        if (name.length < 0)
        {
          throw new Error('"name" should satisfy the constraint - "MinLength": 0');
        }
      }
      if (alias !== null && alias !== undefined && typeof alias.valueOf() !== 'string') {
        throw new Error('alias must be of type string.');
      }
      if (alias !== null && alias !== undefined) {
        if (alias.length > 255)
        {
          throw new Error('"alias" should satisfy the constraint - "MaxLength": 255');
        }
        if (alias.length < 0)
        {
          throw new Error('"alias" should satisfy the constraint - "MinLength": 0');
        }
      }
      if (type !== null && type !== undefined && typeof type.valueOf() !== 'string') {
        throw new Error('type must be of type string.');
      }
      if (access !== null && access !== undefined && typeof access !== 'number') {
        throw new Error('access must be of type number.');
      }
      if (bypassSecurity !== null && bypassSecurity !== undefined && typeof bypassSecurity !== 'boolean') {
        throw new Error('bypassSecurity must be of type boolean.');
      }
      if (page !== null && page !== undefined && typeof page !== 'number') {
        throw new Error('page must be of type number.');
      }
      if (page !== null && page !== undefined) {
        if (page > 2147483647)
        {
          throw new Error('"page" should satisfy the constraint - "InclusiveMaximum": 2147483647');
        }
        if (page < 1)
        {
          throw new Error('"page" should satisfy the constraint - "InclusiveMinimum": 1');
        }
      }
      if (pageSize !== null && pageSize !== undefined && typeof pageSize !== 'number') {
        throw new Error('pageSize must be of type number.');
      }
      if (pageSize !== null && pageSize !== undefined) {
        if (pageSize > 1000)
        {
          throw new Error('"pageSize" should satisfy the constraint - "InclusiveMaximum": 1000');
        }
        if (pageSize < 1)
        {
          throw new Error('"pageSize" should satisfy the constraint - "InclusiveMinimum": 1');
        }
      }
      if (sortOrder !== null && sortOrder !== undefined && typeof sortOrder.valueOf() !== 'string') {
        throw new Error('sortOrder must be of type string.');
      }
      if (sortBy !== null && sortBy !== undefined && typeof sortBy.valueOf() !== 'string') {
        throw new Error('sortBy must be of type string.');
      }
    } catch (error) {
      return Promise.reject(error);
    }

    // Construct URL
    let baseUrl = this.baseUri;
    let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'v1/workflow/queues';
    let queryParamsArray: Array<any> = [];
    if (iD !== null && iD !== undefined) {
      queryParamsArray.push('iD=' + encodeURIComponent(iD.toString()));
    }
    if (name !== null && name !== undefined) {
      queryParamsArray.push('name=' + encodeURIComponent(name));
    }
    if (alias !== null && alias !== undefined) {
      queryParamsArray.push('alias=' + encodeURIComponent(alias));
    }
    if (type !== null && type !== undefined) {
      queryParamsArray.push('type=' + encodeURIComponent(type));
    }
    if (access !== null && access !== undefined) {
      queryParamsArray.push('access=' + encodeURIComponent(access.toString()));
    }
    if (bypassSecurity !== null && bypassSecurity !== undefined) {
      queryParamsArray.push('bypassSecurity=' + encodeURIComponent(bypassSecurity.toString()));
    }
    if (page !== null && page !== undefined) {
      queryParamsArray.push('page=' + encodeURIComponent(page.toString()));
    }
    if (pageSize !== null && pageSize !== undefined) {
      queryParamsArray.push('pageSize=' + encodeURIComponent(pageSize.toString()));
    }
    if (sortOrder !== null && sortOrder !== undefined) {
      queryParamsArray.push('sortOrder=' + encodeURIComponent(sortOrder));
    }
    if (sortBy !== null && sortBy !== undefined) {
      queryParamsArray.push('sortBy=' + encodeURIComponent(sortBy));
    }
    if (queryParamsArray.length > 0) {
      requestUrl += '?' + queryParamsArray.join('&');
    }

    // Create HTTP transport objects
    let httpRequest = new WebResource();
    httpRequest.method = 'GET';
    httpRequest.url = requestUrl;
    httpRequest.headers = {};
    // Set Headers
    httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
    if(options && options.customHeaders) {
      for(let headerName in options.customHeaders) {
        if (options.customHeaders.hasOwnProperty(headerName)) {
          httpRequest.headers[headerName] = options.customHeaders[headerName];
        }
      }
    }
    // Send Request
    let operationRes: msRest.HttpOperationResponse;
    try {
      operationRes = await client.pipeline(httpRequest);
      let response = operationRes.response;
      let statusCode = response.status;
      if (statusCode !== 200) {
        let error = new msRest.RestError(operationRes.bodyAsText as string);
        error.statusCode = response.status;
        error.request = msRest.stripRequest(httpRequest);
        error.response = msRest.stripResponse(response);
        let parsedErrorResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedErrorResponse) {
            let internalError = null;
            if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
            error.code = internalError ? internalError.code : parsedErrorResponse.code;
            error.message = internalError ? internalError.message : parsedErrorResponse.message;
          }
        } catch (defaultError) {
          error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                           `- "${operationRes.bodyAsText}" for the default response.`;
          return Promise.reject(error);
        }
        return Promise.reject(error);
      }
      // Deserialize Response
      if (statusCode === 200) {
        let parsedResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedResponse !== null && parsedResponse !== undefined) {
            let resultMapper = {
              required: false,
              serializedName: 'parsedResponse',
              type: {
                name: 'Sequence',
                element: {
                    required: false,
                    serializedName: 'QueueModelElementType',
                    type: {
                      name: 'Composite',
                      className: 'QueueModel'
                    }
                }
              }
            };
            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
          }
        } catch (error) {
          let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
          deserializationError.request = msRest.stripRequest(httpRequest);
          deserializationError.response = msRest.stripResponse(response);
          return Promise.reject(deserializationError);
        }
      }

    } catch(err) {
      return Promise.reject(err);
    }

    return Promise.resolve(operationRes);
  }
  // methods on the client.

  /**
   * @summary Creates a new queue.
   *
   * @param {InsertQueueRequestModel} model The queue model.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  async createQueueWithHttpOperationResponse(model: Models.InsertQueueRequestModel, options?: msRest.RequestOptionsBase): Promise<msRest.HttpOperationResponse> {
    let client = this;
    // Validate
    try {
      if (model === null || model === undefined) {
        throw new Error('model cannot be null or undefined.');
      }
    } catch (error) {
      return Promise.reject(error);
    }

    // Construct URL
    let baseUrl = this.baseUri;
    let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'v1/workflow/queues';

    // Create HTTP transport objects
    let httpRequest = new WebResource();
    httpRequest.method = 'POST';
    httpRequest.url = requestUrl;
    httpRequest.headers = {};
    // Set Headers
    httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
    if(options && options.customHeaders) {
      for(let headerName in options.customHeaders) {
        if (options.customHeaders.hasOwnProperty(headerName)) {
          httpRequest.headers[headerName] = options.customHeaders[headerName];
        }
      }
    }
    // Serialize Request
    let requestContent = null;
    let requestModel = null;
    try {
      if (model !== null && model !== undefined) {
        let requestModelMapper = Mappers.InsertQueueRequestModel;
        requestModel = client.serializer.serialize(requestModelMapper, model, 'model');
        requestContent = JSON.stringify(requestModel);
      }
    } catch (error) {
      let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
          `payload - ${JSON.stringify(model, null, 2)}.`);
      return Promise.reject(serializationError);
    }
    httpRequest.body = requestContent;
    // Send Request
    let operationRes: msRest.HttpOperationResponse;
    try {
      operationRes = await client.pipeline(httpRequest);
      let response = operationRes.response;
      let statusCode = response.status;
      if (statusCode !== 201 && statusCode !== 403) {
        let error = new msRest.RestError(operationRes.bodyAsText as string);
        error.statusCode = response.status;
        error.request = msRest.stripRequest(httpRequest);
        error.response = msRest.stripResponse(response);
        let parsedErrorResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedErrorResponse) {
            let internalError = null;
            if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
            error.code = internalError ? internalError.code : parsedErrorResponse.code;
            error.message = internalError ? internalError.message : parsedErrorResponse.message;
          }
        } catch (defaultError) {
          error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                           `- "${operationRes.bodyAsText}" for the default response.`;
          return Promise.reject(error);
        }
        return Promise.reject(error);
      }
      // Deserialize Response
      if (statusCode === 201) {
        let parsedResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedResponse !== null && parsedResponse !== undefined) {
            let resultMapper = Mappers.QueueModel;
            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
          }
        } catch (error) {
          let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
          deserializationError.request = msRest.stripRequest(httpRequest);
          deserializationError.response = msRest.stripResponse(response);
          return Promise.reject(deserializationError);
        }
      }

    } catch(err) {
      return Promise.reject(err);
    }

    return Promise.resolve(operationRes);
  }
  // methods on the client.

  /**
   * @summary Gets a single queue by its unique identifier.
   *
   * @param {number} id The queue identifier.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  async getQueueByIdWithHttpOperationResponse(id: number, options?: msRest.RequestOptionsBase): Promise<msRest.HttpOperationResponse> {
    let client = this;
    // Validate
    try {
      if (id === null || id === undefined || typeof id !== 'number') {
        throw new Error('id cannot be null or undefined and it must be of type number.');
      }
    } catch (error) {
      return Promise.reject(error);
    }

    // Construct URL
    let baseUrl = this.baseUri;
    let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'v1/workflow/queues/{id}';
    requestUrl = requestUrl.replace('{id}', encodeURIComponent(id.toString()));

    // Create HTTP transport objects
    let httpRequest = new WebResource();
    httpRequest.method = 'GET';
    httpRequest.url = requestUrl;
    httpRequest.headers = {};
    // Set Headers
    httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
    if(options && options.customHeaders) {
      for(let headerName in options.customHeaders) {
        if (options.customHeaders.hasOwnProperty(headerName)) {
          httpRequest.headers[headerName] = options.customHeaders[headerName];
        }
      }
    }
    // Send Request
    let operationRes: msRest.HttpOperationResponse;
    try {
      operationRes = await client.pipeline(httpRequest);
      let response = operationRes.response;
      let statusCode = response.status;
      if (statusCode !== 200 && statusCode !== 404) {
        let error = new msRest.RestError(operationRes.bodyAsText as string);
        error.statusCode = response.status;
        error.request = msRest.stripRequest(httpRequest);
        error.response = msRest.stripResponse(response);
        let parsedErrorResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedErrorResponse) {
            let internalError = null;
            if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
            error.code = internalError ? internalError.code : parsedErrorResponse.code;
            error.message = internalError ? internalError.message : parsedErrorResponse.message;
          }
        } catch (defaultError) {
          error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                           `- "${operationRes.bodyAsText}" for the default response.`;
          return Promise.reject(error);
        }
        return Promise.reject(error);
      }
      // Deserialize Response
      if (statusCode === 200) {
        let parsedResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedResponse !== null && parsedResponse !== undefined) {
            let resultMapper = Mappers.QueueModel;
            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
          }
        } catch (error) {
          let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
          deserializationError.request = msRest.stripRequest(httpRequest);
          deserializationError.response = msRest.stripResponse(response);
          return Promise.reject(deserializationError);
        }
      }

    } catch(err) {
      return Promise.reject(err);
    }

    return Promise.resolve(operationRes);
  }
  // methods on the client.

  /**
   * @summary Updates a specified queue.
   *
   * @param {number} id The unique queue identifier.
   *
   * @param {QueueBase} model The queue model.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  async updateQueueWithHttpOperationResponse(id: number, model: Models.QueueBase, options?: msRest.RequestOptionsBase): Promise<msRest.HttpOperationResponse> {
    let client = this;
    // Validate
    try {
      if (id === null || id === undefined || typeof id !== 'number') {
        throw new Error('id cannot be null or undefined and it must be of type number.');
      }
      if (model === null || model === undefined) {
        throw new Error('model cannot be null or undefined.');
      }
    } catch (error) {
      return Promise.reject(error);
    }

    // Construct URL
    let baseUrl = this.baseUri;
    let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'v1/workflow/queues/{id}';
    requestUrl = requestUrl.replace('{id}', encodeURIComponent(id.toString()));

    // Create HTTP transport objects
    let httpRequest = new WebResource();
    httpRequest.method = 'PUT';
    httpRequest.url = requestUrl;
    httpRequest.headers = {};
    // Set Headers
    httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
    if(options && options.customHeaders) {
      for(let headerName in options.customHeaders) {
        if (options.customHeaders.hasOwnProperty(headerName)) {
          httpRequest.headers[headerName] = options.customHeaders[headerName];
        }
      }
    }
    // Serialize Request
    let requestContent = null;
    let requestModel = null;
    try {
      if (model !== null && model !== undefined) {
        let requestModelMapper = Mappers.QueueBase;
        requestModel = client.serializer.serialize(requestModelMapper, model, 'model');
        requestContent = JSON.stringify(requestModel);
      }
    } catch (error) {
      let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
          `payload - ${JSON.stringify(model, null, 2)}.`);
      return Promise.reject(serializationError);
    }
    httpRequest.body = requestContent;
    // Send Request
    let operationRes: msRest.HttpOperationResponse;
    try {
      operationRes = await client.pipeline(httpRequest);
      let response = operationRes.response;
      let statusCode = response.status;
      if (statusCode !== 200 && statusCode !== 403 && statusCode !== 404) {
        let error = new msRest.RestError(operationRes.bodyAsText as string);
        error.statusCode = response.status;
        error.request = msRest.stripRequest(httpRequest);
        error.response = msRest.stripResponse(response);
        let parsedErrorResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedErrorResponse) {
            let internalError = null;
            if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
            error.code = internalError ? internalError.code : parsedErrorResponse.code;
            error.message = internalError ? internalError.message : parsedErrorResponse.message;
          }
        } catch (defaultError) {
          error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                           `- "${operationRes.bodyAsText}" for the default response.`;
          return Promise.reject(error);
        }
        return Promise.reject(error);
      }
      // Deserialize Response
      if (statusCode === 200) {
        let parsedResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedResponse !== null && parsedResponse !== undefined) {
            let resultMapper = {
              required: false,
              serializedName: 'parsedResponse',
              type: {
                name: 'Object'
              }
            };
            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
          }
        } catch (error) {
          let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
          deserializationError.request = msRest.stripRequest(httpRequest);
          deserializationError.response = msRest.stripResponse(response);
          return Promise.reject(deserializationError);
        }
      }

    } catch(err) {
      return Promise.reject(err);
    }

    return Promise.resolve(operationRes);
  }
  // methods on the client.

  /**
   * @summary Deletes a specified queue.
   *
   * @param {number} id The queue identifier.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  async deleteQueueWithHttpOperationResponse(id: number, options?: msRest.RequestOptionsBase): Promise<msRest.HttpOperationResponse> {
    let client = this;
    // Validate
    try {
      if (id === null || id === undefined || typeof id !== 'number') {
        throw new Error('id cannot be null or undefined and it must be of type number.');
      }
    } catch (error) {
      return Promise.reject(error);
    }

    // Construct URL
    let baseUrl = this.baseUri;
    let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'v1/workflow/queues/{id}';
    requestUrl = requestUrl.replace('{id}', encodeURIComponent(id.toString()));

    // Create HTTP transport objects
    let httpRequest = new WebResource();
    httpRequest.method = 'DELETE';
    httpRequest.url = requestUrl;
    httpRequest.headers = {};
    // Set Headers
    httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
    if(options && options.customHeaders) {
      for(let headerName in options.customHeaders) {
        if (options.customHeaders.hasOwnProperty(headerName)) {
          httpRequest.headers[headerName] = options.customHeaders[headerName];
        }
      }
    }
    // Send Request
    let operationRes: msRest.HttpOperationResponse;
    try {
      operationRes = await client.pipeline(httpRequest);
      let response = operationRes.response;
      let statusCode = response.status;
      if (statusCode !== 204 && statusCode !== 403 && statusCode !== 404) {
        let error = new msRest.RestError(operationRes.bodyAsText as string);
        error.statusCode = response.status;
        error.request = msRest.stripRequest(httpRequest);
        error.response = msRest.stripResponse(response);
        let parsedErrorResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedErrorResponse) {
            let internalError = null;
            if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
            error.code = internalError ? internalError.code : parsedErrorResponse.code;
            error.message = internalError ? internalError.message : parsedErrorResponse.message;
          }
        } catch (defaultError) {
          error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                           `- "${operationRes.bodyAsText}" for the default response.`;
          return Promise.reject(error);
        }
        return Promise.reject(error);
      }
      // Deserialize Response
      if (statusCode === 204) {
        let parsedResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedResponse !== null && parsedResponse !== undefined) {
            let resultMapper = {
              required: false,
              serializedName: 'parsedResponse',
              type: {
                name: 'Object'
              }
            };
            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
          }
        } catch (error) {
          let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
          deserializationError.request = msRest.stripRequest(httpRequest);
          deserializationError.response = msRest.stripResponse(response);
          return Promise.reject(deserializationError);
        }
      }

    } catch(err) {
      return Promise.reject(err);
    }

    return Promise.resolve(operationRes);
  }
  // methods on the client.

  /**
   * @summary Gets a single queue by its name.
   *
   * @param {string} name The queue name.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  async getQueueByNameWithHttpOperationResponse(name: string, options?: msRest.RequestOptionsBase): Promise<msRest.HttpOperationResponse> {
    let client = this;
    // Validate
    try {
      if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
        throw new Error('name cannot be null or undefined and it must be of type string.');
      }
    } catch (error) {
      return Promise.reject(error);
    }

    // Construct URL
    let baseUrl = this.baseUri;
    let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'v1/workflow/queues/{name}';
    requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));

    // Create HTTP transport objects
    let httpRequest = new WebResource();
    httpRequest.method = 'GET';
    httpRequest.url = requestUrl;
    httpRequest.headers = {};
    // Set Headers
    httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
    if(options && options.customHeaders) {
      for(let headerName in options.customHeaders) {
        if (options.customHeaders.hasOwnProperty(headerName)) {
          httpRequest.headers[headerName] = options.customHeaders[headerName];
        }
      }
    }
    // Send Request
    let operationRes: msRest.HttpOperationResponse;
    try {
      operationRes = await client.pipeline(httpRequest);
      let response = operationRes.response;
      let statusCode = response.status;
      if (statusCode !== 200 && statusCode !== 404) {
        let error = new msRest.RestError(operationRes.bodyAsText as string);
        error.statusCode = response.status;
        error.request = msRest.stripRequest(httpRequest);
        error.response = msRest.stripResponse(response);
        let parsedErrorResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedErrorResponse) {
            let internalError = null;
            if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
            error.code = internalError ? internalError.code : parsedErrorResponse.code;
            error.message = internalError ? internalError.message : parsedErrorResponse.message;
          }
        } catch (defaultError) {
          error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                           `- "${operationRes.bodyAsText}" for the default response.`;
          return Promise.reject(error);
        }
        return Promise.reject(error);
      }
      // Deserialize Response
      if (statusCode === 200) {
        let parsedResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedResponse !== null && parsedResponse !== undefined) {
            let resultMapper = Mappers.QueueModel;
            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
          }
        } catch (error) {
          let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
          deserializationError.request = msRest.stripRequest(httpRequest);
          deserializationError.response = msRest.stripResponse(response);
          return Promise.reject(deserializationError);
        }
      }

    } catch(err) {
      return Promise.reject(err);
    }

    return Promise.resolve(operationRes);
  }
  // methods on the client.

  /**
   * @summary Gets a paged list of tasks.
   *
   * @param {SoftheonEnterpriseAPIGetTasksByFilterOptionalParams} [options]
   * Optional Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  async getTasksByFilterWithHttpOperationResponse(options?: Models.SoftheonEnterpriseAPIGetTasksByFilterOptionalParams): Promise<msRest.HttpOperationResponse> {
    let client = this;
    let lastTaskID = (options && options.lastTaskID !== undefined) ? options.lastTaskID : undefined;
    let iD = (options && options.iD !== undefined) ? options.iD : undefined;
    let type = (options && options.type !== undefined) ? options.type : undefined;
    let queueID = (options && options.queueID !== undefined) ? options.queueID : undefined;
    let queueType = (options && options.queueType !== undefined) ? options.queueType : undefined;
    let drawerID = (options && options.drawerID !== undefined) ? options.drawerID : undefined;
    let description = (options && options.description !== undefined) ? options.description : undefined;
    let taskID = (options && options.taskID !== undefined) ? options.taskID : undefined;
    let page = (options && options.page !== undefined) ? options.page : undefined;
    let pageSize = (options && options.pageSize !== undefined) ? options.pageSize : undefined;
    let sortOrder = (options && options.sortOrder !== undefined) ? options.sortOrder : undefined;
    let sortBy = (options && options.sortBy !== undefined) ? options.sortBy : undefined;
    // Validate
    try {
      if (lastTaskID !== null && lastTaskID !== undefined && typeof lastTaskID !== 'number') {
        throw new Error('lastTaskID must be of type number.');
      }
      if (lastTaskID !== null && lastTaskID !== undefined) {
        if (lastTaskID > 2147483647)
        {
          throw new Error('"lastTaskID" should satisfy the constraint - "InclusiveMaximum": 2147483647');
        }
        if (lastTaskID < 0)
        {
          throw new Error('"lastTaskID" should satisfy the constraint - "InclusiveMinimum": 0');
        }
      }
      if (iD !== null && iD !== undefined && typeof iD !== 'number') {
        throw new Error('iD must be of type number.');
      }
      if (iD !== null && iD !== undefined) {
        if (iD > 2147483647)
        {
          throw new Error('"iD" should satisfy the constraint - "InclusiveMaximum": 2147483647');
        }
        if (iD < 1)
        {
          throw new Error('"iD" should satisfy the constraint - "InclusiveMinimum": 1');
        }
      }
      if (type !== null && type !== undefined && typeof type !== 'number') {
        throw new Error('type must be of type number.');
      }
      if (queueID !== null && queueID !== undefined && typeof queueID !== 'number') {
        throw new Error('queueID must be of type number.');
      }
      if (queueType !== null && queueType !== undefined && typeof queueType !== 'number') {
        throw new Error('queueType must be of type number.');
      }
      if (queueType !== null && queueType !== undefined) {
        if (queueType > 2147483647)
        {
          throw new Error('"queueType" should satisfy the constraint - "InclusiveMaximum": 2147483647');
        }
        if (queueType < 1)
        {
          throw new Error('"queueType" should satisfy the constraint - "InclusiveMinimum": 1');
        }
      }
      if (drawerID !== null && drawerID !== undefined && typeof drawerID !== 'number') {
        throw new Error('drawerID must be of type number.');
      }
      if (drawerID !== null && drawerID !== undefined) {
        if (drawerID > 2147483647)
        {
          throw new Error('"drawerID" should satisfy the constraint - "InclusiveMaximum": 2147483647');
        }
        if (drawerID < 1)
        {
          throw new Error('"drawerID" should satisfy the constraint - "InclusiveMinimum": 1');
        }
      }
      if (description !== null && description !== undefined && typeof description.valueOf() !== 'string') {
        throw new Error('description must be of type string.');
      }
      if (description !== null && description !== undefined) {
        if (description.length > 255)
        {
          throw new Error('"description" should satisfy the constraint - "MaxLength": 255');
        }
        if (description.length < 0)
        {
          throw new Error('"description" should satisfy the constraint - "MinLength": 0');
        }
      }
      if (taskID !== null && taskID !== undefined && typeof taskID !== 'number') {
        throw new Error('taskID must be of type number.');
      }
      if (page !== null && page !== undefined && typeof page !== 'number') {
        throw new Error('page must be of type number.');
      }
      if (page !== null && page !== undefined) {
        if (page > 2147483647)
        {
          throw new Error('"page" should satisfy the constraint - "InclusiveMaximum": 2147483647');
        }
        if (page < 1)
        {
          throw new Error('"page" should satisfy the constraint - "InclusiveMinimum": 1');
        }
      }
      if (pageSize !== null && pageSize !== undefined && typeof pageSize !== 'number') {
        throw new Error('pageSize must be of type number.');
      }
      if (pageSize !== null && pageSize !== undefined) {
        if (pageSize > 1000)
        {
          throw new Error('"pageSize" should satisfy the constraint - "InclusiveMaximum": 1000');
        }
        if (pageSize < 1)
        {
          throw new Error('"pageSize" should satisfy the constraint - "InclusiveMinimum": 1');
        }
      }
      if (sortOrder !== null && sortOrder !== undefined && typeof sortOrder.valueOf() !== 'string') {
        throw new Error('sortOrder must be of type string.');
      }
      if (sortBy !== null && sortBy !== undefined && typeof sortBy.valueOf() !== 'string') {
        throw new Error('sortBy must be of type string.');
      }
    } catch (error) {
      return Promise.reject(error);
    }

    // Construct URL
    let baseUrl = this.baseUri;
    let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'v1/workflow/tasks';
    let queryParamsArray: Array<any> = [];
    if (lastTaskID !== null && lastTaskID !== undefined) {
      queryParamsArray.push('lastTaskID=' + encodeURIComponent(lastTaskID.toString()));
    }
    if (iD !== null && iD !== undefined) {
      queryParamsArray.push('iD=' + encodeURIComponent(iD.toString()));
    }
    if (type !== null && type !== undefined) {
      queryParamsArray.push('type=' + encodeURIComponent(type.toString()));
    }
    if (queueID !== null && queueID !== undefined) {
      queryParamsArray.push('queueID=' + encodeURIComponent(queueID.toString()));
    }
    if (queueType !== null && queueType !== undefined) {
      queryParamsArray.push('queueType=' + encodeURIComponent(queueType.toString()));
    }
    if (drawerID !== null && drawerID !== undefined) {
      queryParamsArray.push('drawerID=' + encodeURIComponent(drawerID.toString()));
    }
    if (description !== null && description !== undefined) {
      queryParamsArray.push('description=' + encodeURIComponent(description));
    }
    if (taskID !== null && taskID !== undefined) {
      queryParamsArray.push('taskID=' + encodeURIComponent(taskID.toString()));
    }
    if (page !== null && page !== undefined) {
      queryParamsArray.push('page=' + encodeURIComponent(page.toString()));
    }
    if (pageSize !== null && pageSize !== undefined) {
      queryParamsArray.push('pageSize=' + encodeURIComponent(pageSize.toString()));
    }
    if (sortOrder !== null && sortOrder !== undefined) {
      queryParamsArray.push('sortOrder=' + encodeURIComponent(sortOrder));
    }
    if (sortBy !== null && sortBy !== undefined) {
      queryParamsArray.push('sortBy=' + encodeURIComponent(sortBy));
    }
    if (queryParamsArray.length > 0) {
      requestUrl += '?' + queryParamsArray.join('&');
    }

    // Create HTTP transport objects
    let httpRequest = new WebResource();
    httpRequest.method = 'GET';
    httpRequest.url = requestUrl;
    httpRequest.headers = {};
    // Set Headers
    httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
    if(options && options.customHeaders) {
      for(let headerName in options.customHeaders) {
        if (options.customHeaders.hasOwnProperty(headerName)) {
          httpRequest.headers[headerName] = options.customHeaders[headerName];
        }
      }
    }
    // Send Request
    let operationRes: msRest.HttpOperationResponse;
    try {
      operationRes = await client.pipeline(httpRequest);
      let response = operationRes.response;
      let statusCode = response.status;
      if (statusCode !== 200) {
        let error = new msRest.RestError(operationRes.bodyAsText as string);
        error.statusCode = response.status;
        error.request = msRest.stripRequest(httpRequest);
        error.response = msRest.stripResponse(response);
        let parsedErrorResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedErrorResponse) {
            let internalError = null;
            if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
            error.code = internalError ? internalError.code : parsedErrorResponse.code;
            error.message = internalError ? internalError.message : parsedErrorResponse.message;
          }
        } catch (defaultError) {
          error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                           `- "${operationRes.bodyAsText}" for the default response.`;
          return Promise.reject(error);
        }
        return Promise.reject(error);
      }
      // Deserialize Response
      if (statusCode === 200) {
        let parsedResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedResponse !== null && parsedResponse !== undefined) {
            let resultMapper = {
              required: false,
              serializedName: 'parsedResponse',
              type: {
                name: 'Sequence',
                element: {
                    required: false,
                    serializedName: 'TaskModelElementType',
                    type: {
                      name: 'Composite',
                      className: 'TaskModel'
                    }
                }
              }
            };
            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
          }
        } catch (error) {
          let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
          deserializationError.request = msRest.stripRequest(httpRequest);
          deserializationError.response = msRest.stripResponse(response);
          return Promise.reject(deserializationError);
        }
      }

    } catch(err) {
      return Promise.reject(err);
    }

    return Promise.resolve(operationRes);
  }
  // methods on the client.

  /**
   * @summary Creates a new task.
   *
   * @param {InsertTaskRequestModel} model The task model.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  async createTaskWithHttpOperationResponse(model: Models.InsertTaskRequestModel, options?: msRest.RequestOptionsBase): Promise<msRest.HttpOperationResponse> {
    let client = this;
    // Validate
    try {
      if (model === null || model === undefined) {
        throw new Error('model cannot be null or undefined.');
      }
    } catch (error) {
      return Promise.reject(error);
    }

    // Construct URL
    let baseUrl = this.baseUri;
    let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'v1/workflow/tasks';

    // Create HTTP transport objects
    let httpRequest = new WebResource();
    httpRequest.method = 'POST';
    httpRequest.url = requestUrl;
    httpRequest.headers = {};
    // Set Headers
    httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
    if(options && options.customHeaders) {
      for(let headerName in options.customHeaders) {
        if (options.customHeaders.hasOwnProperty(headerName)) {
          httpRequest.headers[headerName] = options.customHeaders[headerName];
        }
      }
    }
    // Serialize Request
    let requestContent = null;
    let requestModel = null;
    try {
      if (model !== null && model !== undefined) {
        let requestModelMapper = Mappers.InsertTaskRequestModel;
        requestModel = client.serializer.serialize(requestModelMapper, model, 'model');
        requestContent = JSON.stringify(requestModel);
      }
    } catch (error) {
      let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
          `payload - ${JSON.stringify(model, null, 2)}.`);
      return Promise.reject(serializationError);
    }
    httpRequest.body = requestContent;
    // Send Request
    let operationRes: msRest.HttpOperationResponse;
    try {
      operationRes = await client.pipeline(httpRequest);
      let response = operationRes.response;
      let statusCode = response.status;
      if (statusCode !== 201 && statusCode !== 403 && statusCode !== 404 && statusCode !== 409) {
        let error = new msRest.RestError(operationRes.bodyAsText as string);
        error.statusCode = response.status;
        error.request = msRest.stripRequest(httpRequest);
        error.response = msRest.stripResponse(response);
        let parsedErrorResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedErrorResponse) {
            let internalError = null;
            if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
            error.code = internalError ? internalError.code : parsedErrorResponse.code;
            error.message = internalError ? internalError.message : parsedErrorResponse.message;
          }
        } catch (defaultError) {
          error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                           `- "${operationRes.bodyAsText}" for the default response.`;
          return Promise.reject(error);
        }
        return Promise.reject(error);
      }
      // Deserialize Response
      if (statusCode === 201) {
        let parsedResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedResponse !== null && parsedResponse !== undefined) {
            let resultMapper = {
              required: false,
              serializedName: 'parsedResponse',
              type: {
                name: 'Object'
              }
            };
            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
          }
        } catch (error) {
          let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
          deserializationError.request = msRest.stripRequest(httpRequest);
          deserializationError.response = msRest.stripResponse(response);
          return Promise.reject(deserializationError);
        }
      }

    } catch(err) {
      return Promise.reject(err);
    }

    return Promise.resolve(operationRes);
  }
  // methods on the client.

  /**
   * @summary Gets a single task based on its unique identifier.
   *
   * @param {number} id The identifier.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  async getTaskByIdWithHttpOperationResponse(id: number, options?: msRest.RequestOptionsBase): Promise<msRest.HttpOperationResponse> {
    let client = this;
    // Validate
    try {
      if (id === null || id === undefined || typeof id !== 'number') {
        throw new Error('id cannot be null or undefined and it must be of type number.');
      }
    } catch (error) {
      return Promise.reject(error);
    }

    // Construct URL
    let baseUrl = this.baseUri;
    let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'v1/workflow/tasks/{id}';
    requestUrl = requestUrl.replace('{id}', encodeURIComponent(id.toString()));

    // Create HTTP transport objects
    let httpRequest = new WebResource();
    httpRequest.method = 'GET';
    httpRequest.url = requestUrl;
    httpRequest.headers = {};
    // Set Headers
    httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
    if(options && options.customHeaders) {
      for(let headerName in options.customHeaders) {
        if (options.customHeaders.hasOwnProperty(headerName)) {
          httpRequest.headers[headerName] = options.customHeaders[headerName];
        }
      }
    }
    // Send Request
    let operationRes: msRest.HttpOperationResponse;
    try {
      operationRes = await client.pipeline(httpRequest);
      let response = operationRes.response;
      let statusCode = response.status;
      if (statusCode !== 200 && statusCode !== 404) {
        let error = new msRest.RestError(operationRes.bodyAsText as string);
        error.statusCode = response.status;
        error.request = msRest.stripRequest(httpRequest);
        error.response = msRest.stripResponse(response);
        let parsedErrorResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedErrorResponse) {
            let internalError = null;
            if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
            error.code = internalError ? internalError.code : parsedErrorResponse.code;
            error.message = internalError ? internalError.message : parsedErrorResponse.message;
          }
        } catch (defaultError) {
          error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                           `- "${operationRes.bodyAsText}" for the default response.`;
          return Promise.reject(error);
        }
        return Promise.reject(error);
      }
      // Deserialize Response
      if (statusCode === 200) {
        let parsedResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedResponse !== null && parsedResponse !== undefined) {
            let resultMapper = Mappers.TaskModel;
            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
          }
        } catch (error) {
          let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
          deserializationError.request = msRest.stripRequest(httpRequest);
          deserializationError.response = msRest.stripResponse(response);
          return Promise.reject(deserializationError);
        }
      }

    } catch(err) {
      return Promise.reject(err);
    }

    return Promise.resolve(operationRes);
  }
  // methods on the client.

  /**
   * @summary Updates a specified task.
   *
   * @param {number} id The identifier.
   *
   * @param {TaskBase} model The task model.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  async updateTaskWithHttpOperationResponse(id: number, model: Models.TaskBase, options?: msRest.RequestOptionsBase): Promise<msRest.HttpOperationResponse> {
    let client = this;
    // Validate
    try {
      if (id === null || id === undefined || typeof id !== 'number') {
        throw new Error('id cannot be null or undefined and it must be of type number.');
      }
      if (model === null || model === undefined) {
        throw new Error('model cannot be null or undefined.');
      }
    } catch (error) {
      return Promise.reject(error);
    }

    // Construct URL
    let baseUrl = this.baseUri;
    let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'v1/workflow/tasks/{id}';
    requestUrl = requestUrl.replace('{id}', encodeURIComponent(id.toString()));

    // Create HTTP transport objects
    let httpRequest = new WebResource();
    httpRequest.method = 'PUT';
    httpRequest.url = requestUrl;
    httpRequest.headers = {};
    // Set Headers
    httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
    if(options && options.customHeaders) {
      for(let headerName in options.customHeaders) {
        if (options.customHeaders.hasOwnProperty(headerName)) {
          httpRequest.headers[headerName] = options.customHeaders[headerName];
        }
      }
    }
    // Serialize Request
    let requestContent = null;
    let requestModel = null;
    try {
      if (model !== null && model !== undefined) {
        let requestModelMapper = Mappers.TaskBase;
        requestModel = client.serializer.serialize(requestModelMapper, model, 'model');
        requestContent = JSON.stringify(requestModel);
      }
    } catch (error) {
      let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
          `payload - ${JSON.stringify(model, null, 2)}.`);
      return Promise.reject(serializationError);
    }
    httpRequest.body = requestContent;
    // Send Request
    let operationRes: msRest.HttpOperationResponse;
    try {
      operationRes = await client.pipeline(httpRequest);
      let response = operationRes.response;
      let statusCode = response.status;
      if (statusCode !== 204 && statusCode !== 403 && statusCode !== 404) {
        let error = new msRest.RestError(operationRes.bodyAsText as string);
        error.statusCode = response.status;
        error.request = msRest.stripRequest(httpRequest);
        error.response = msRest.stripResponse(response);
        let parsedErrorResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedErrorResponse) {
            let internalError = null;
            if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
            error.code = internalError ? internalError.code : parsedErrorResponse.code;
            error.message = internalError ? internalError.message : parsedErrorResponse.message;
          }
        } catch (defaultError) {
          error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                           `- "${operationRes.bodyAsText}" for the default response.`;
          return Promise.reject(error);
        }
        return Promise.reject(error);
      }
      // Deserialize Response
      if (statusCode === 204) {
        let parsedResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedResponse !== null && parsedResponse !== undefined) {
            let resultMapper = {
              required: false,
              serializedName: 'parsedResponse',
              type: {
                name: 'Object'
              }
            };
            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
          }
        } catch (error) {
          let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
          deserializationError.request = msRest.stripRequest(httpRequest);
          deserializationError.response = msRest.stripResponse(response);
          return Promise.reject(deserializationError);
        }
      }

    } catch(err) {
      return Promise.reject(err);
    }

    return Promise.resolve(operationRes);
  }
  // methods on the client.

  /**
   * @summary Deletes a specified task.
   *
   * @param {number} id The identifier.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  async deleteTaskWithHttpOperationResponse(id: number, options?: msRest.RequestOptionsBase): Promise<msRest.HttpOperationResponse> {
    let client = this;
    // Validate
    try {
      if (id === null || id === undefined || typeof id !== 'number') {
        throw new Error('id cannot be null or undefined and it must be of type number.');
      }
    } catch (error) {
      return Promise.reject(error);
    }

    // Construct URL
    let baseUrl = this.baseUri;
    let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'v1/workflow/tasks/{id}';
    requestUrl = requestUrl.replace('{id}', encodeURIComponent(id.toString()));

    // Create HTTP transport objects
    let httpRequest = new WebResource();
    httpRequest.method = 'DELETE';
    httpRequest.url = requestUrl;
    httpRequest.headers = {};
    // Set Headers
    httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
    if(options && options.customHeaders) {
      for(let headerName in options.customHeaders) {
        if (options.customHeaders.hasOwnProperty(headerName)) {
          httpRequest.headers[headerName] = options.customHeaders[headerName];
        }
      }
    }
    // Send Request
    let operationRes: msRest.HttpOperationResponse;
    try {
      operationRes = await client.pipeline(httpRequest);
      let response = operationRes.response;
      let statusCode = response.status;
      if (statusCode !== 204 && statusCode !== 403 && statusCode !== 404) {
        let error = new msRest.RestError(operationRes.bodyAsText as string);
        error.statusCode = response.status;
        error.request = msRest.stripRequest(httpRequest);
        error.response = msRest.stripResponse(response);
        let parsedErrorResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedErrorResponse) {
            let internalError = null;
            if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
            error.code = internalError ? internalError.code : parsedErrorResponse.code;
            error.message = internalError ? internalError.message : parsedErrorResponse.message;
          }
        } catch (defaultError) {
          error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                           `- "${operationRes.bodyAsText}" for the default response.`;
          return Promise.reject(error);
        }
        return Promise.reject(error);
      }
      // Deserialize Response
      if (statusCode === 204) {
        let parsedResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedResponse !== null && parsedResponse !== undefined) {
            let resultMapper = {
              required: false,
              serializedName: 'parsedResponse',
              type: {
                name: 'Object'
              }
            };
            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
          }
        } catch (error) {
          let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
          deserializationError.request = msRest.stripRequest(httpRequest);
          deserializationError.response = msRest.stripResponse(response);
          return Promise.reject(deserializationError);
        }
      }

    } catch(err) {
      return Promise.reject(err);
    }

    return Promise.resolve(operationRes);
  }
  // methods on the client.

  /**
   * @summary Gets a single task based on user predefined queue assignment
   * criteria.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  async fetchTaskFromQueueAssignmentWithHttpOperationResponse(options?: msRest.RequestOptionsBase): Promise<msRest.HttpOperationResponse> {
    let client = this;

    // Construct URL
    let baseUrl = this.baseUri;
    let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'v1/workflow/tasks/fetch';

    // Create HTTP transport objects
    let httpRequest = new WebResource();
    httpRequest.method = 'GET';
    httpRequest.url = requestUrl;
    httpRequest.headers = {};
    // Set Headers
    httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
    if(options && options.customHeaders) {
      for(let headerName in options.customHeaders) {
        if (options.customHeaders.hasOwnProperty(headerName)) {
          httpRequest.headers[headerName] = options.customHeaders[headerName];
        }
      }
    }
    // Send Request
    let operationRes: msRest.HttpOperationResponse;
    try {
      operationRes = await client.pipeline(httpRequest);
      let response = operationRes.response;
      let statusCode = response.status;
      if (statusCode !== 200 && statusCode !== 404) {
        let error = new msRest.RestError(operationRes.bodyAsText as string);
        error.statusCode = response.status;
        error.request = msRest.stripRequest(httpRequest);
        error.response = msRest.stripResponse(response);
        let parsedErrorResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedErrorResponse) {
            let internalError = null;
            if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
            error.code = internalError ? internalError.code : parsedErrorResponse.code;
            error.message = internalError ? internalError.message : parsedErrorResponse.message;
          }
        } catch (defaultError) {
          error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                           `- "${operationRes.bodyAsText}" for the default response.`;
          return Promise.reject(error);
        }
        return Promise.reject(error);
      }
      // Deserialize Response
      if (statusCode === 200) {
        let parsedResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedResponse !== null && parsedResponse !== undefined) {
            let resultMapper = Mappers.TaskModel;
            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
          }
        } catch (error) {
          let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
          deserializationError.request = msRest.stripRequest(httpRequest);
          deserializationError.response = msRest.stripResponse(response);
          return Promise.reject(deserializationError);
        }
      }

    } catch(err) {
      return Promise.reject(err);
    }

    return Promise.resolve(operationRes);
  }
  // methods on the client.

  /**
   * @summary Gets a paged list of users.Gets a paged list of users.
   *
   * @param {SoftheonEnterpriseAPIGetUsersByFilterOptionalParams} [options]
   * Optional Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  async getUsersByFilterWithHttpOperationResponse(options?: Models.SoftheonEnterpriseAPIGetUsersByFilterOptionalParams): Promise<msRest.HttpOperationResponse> {
    let client = this;
    let iD = (options && options.iD !== undefined) ? options.iD : undefined;
    let primaryGroupID = (options && options.primaryGroupID !== undefined) ? options.primaryGroupID : undefined;
    let groupID = (options && options.groupID !== undefined) ? options.groupID : undefined;
    let groupName = (options && options.groupName !== undefined) ? options.groupName : undefined;
    let username = (options && options.username !== undefined) ? options.username : undefined;
    let type = (options && options.type !== undefined) ? options.type : undefined;
    let state = (options && options.state !== undefined) ? options.state : undefined;
    let fullName = (options && options.fullName !== undefined) ? options.fullName : undefined;
    let page = (options && options.page !== undefined) ? options.page : undefined;
    let pageSize = (options && options.pageSize !== undefined) ? options.pageSize : undefined;
    let sortOrder = (options && options.sortOrder !== undefined) ? options.sortOrder : undefined;
    let sortBy = (options && options.sortBy !== undefined) ? options.sortBy : undefined;
    // Validate
    try {
      if (iD !== null && iD !== undefined && typeof iD !== 'number') {
        throw new Error('iD must be of type number.');
      }
      if (primaryGroupID !== null && primaryGroupID !== undefined && typeof primaryGroupID !== 'number') {
        throw new Error('primaryGroupID must be of type number.');
      }
      if (groupID !== null && groupID !== undefined && typeof groupID !== 'number') {
        throw new Error('groupID must be of type number.');
      }
      if (groupName !== null && groupName !== undefined && typeof groupName.valueOf() !== 'string') {
        throw new Error('groupName must be of type string.');
      }
      if (username !== null && username !== undefined && typeof username.valueOf() !== 'string') {
        throw new Error('username must be of type string.');
      }
      if (type !== null && type !== undefined && typeof type.valueOf() !== 'string') {
        throw new Error('type must be of type string.');
      }
      if (state !== null && state !== undefined && typeof state.valueOf() !== 'string') {
        throw new Error('state must be of type string.');
      }
      if (fullName !== null && fullName !== undefined && typeof fullName.valueOf() !== 'string') {
        throw new Error('fullName must be of type string.');
      }
      if (page !== null && page !== undefined && typeof page !== 'number') {
        throw new Error('page must be of type number.');
      }
      if (page !== null && page !== undefined) {
        if (page > 2147483647)
        {
          throw new Error('"page" should satisfy the constraint - "InclusiveMaximum": 2147483647');
        }
        if (page < 1)
        {
          throw new Error('"page" should satisfy the constraint - "InclusiveMinimum": 1');
        }
      }
      if (pageSize !== null && pageSize !== undefined && typeof pageSize !== 'number') {
        throw new Error('pageSize must be of type number.');
      }
      if (pageSize !== null && pageSize !== undefined) {
        if (pageSize > 1000)
        {
          throw new Error('"pageSize" should satisfy the constraint - "InclusiveMaximum": 1000');
        }
        if (pageSize < 1)
        {
          throw new Error('"pageSize" should satisfy the constraint - "InclusiveMinimum": 1');
        }
      }
      if (sortOrder !== null && sortOrder !== undefined && typeof sortOrder.valueOf() !== 'string') {
        throw new Error('sortOrder must be of type string.');
      }
      if (sortBy !== null && sortBy !== undefined && typeof sortBy.valueOf() !== 'string') {
        throw new Error('sortBy must be of type string.');
      }
    } catch (error) {
      return Promise.reject(error);
    }

    // Construct URL
    let baseUrl = this.baseUri;
    let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'v1/directory/users';
    let queryParamsArray: Array<any> = [];
    if (iD !== null && iD !== undefined) {
      queryParamsArray.push('iD=' + encodeURIComponent(iD.toString()));
    }
    if (primaryGroupID !== null && primaryGroupID !== undefined) {
      queryParamsArray.push('primaryGroupID=' + encodeURIComponent(primaryGroupID.toString()));
    }
    if (groupID !== null && groupID !== undefined) {
      queryParamsArray.push('groupID=' + encodeURIComponent(groupID.toString()));
    }
    if (groupName !== null && groupName !== undefined) {
      queryParamsArray.push('groupName=' + encodeURIComponent(groupName));
    }
    if (username !== null && username !== undefined) {
      queryParamsArray.push('username=' + encodeURIComponent(username));
    }
    if (type !== null && type !== undefined) {
      queryParamsArray.push('type=' + encodeURIComponent(type));
    }
    if (state !== null && state !== undefined) {
      queryParamsArray.push('state=' + encodeURIComponent(state));
    }
    if (fullName !== null && fullName !== undefined) {
      queryParamsArray.push('fullName=' + encodeURIComponent(fullName));
    }
    if (page !== null && page !== undefined) {
      queryParamsArray.push('page=' + encodeURIComponent(page.toString()));
    }
    if (pageSize !== null && pageSize !== undefined) {
      queryParamsArray.push('pageSize=' + encodeURIComponent(pageSize.toString()));
    }
    if (sortOrder !== null && sortOrder !== undefined) {
      queryParamsArray.push('sortOrder=' + encodeURIComponent(sortOrder));
    }
    if (sortBy !== null && sortBy !== undefined) {
      queryParamsArray.push('sortBy=' + encodeURIComponent(sortBy));
    }
    if (queryParamsArray.length > 0) {
      requestUrl += '?' + queryParamsArray.join('&');
    }

    // Create HTTP transport objects
    let httpRequest = new WebResource();
    httpRequest.method = 'GET';
    httpRequest.url = requestUrl;
    httpRequest.headers = {};
    // Set Headers
    httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
    if(options && options.customHeaders) {
      for(let headerName in options.customHeaders) {
        if (options.customHeaders.hasOwnProperty(headerName)) {
          httpRequest.headers[headerName] = options.customHeaders[headerName];
        }
      }
    }
    // Send Request
    let operationRes: msRest.HttpOperationResponse;
    try {
      operationRes = await client.pipeline(httpRequest);
      let response = operationRes.response;
      let statusCode = response.status;
      if (statusCode !== 200 && statusCode !== 403) {
        let error = new msRest.RestError(operationRes.bodyAsText as string);
        error.statusCode = response.status;
        error.request = msRest.stripRequest(httpRequest);
        error.response = msRest.stripResponse(response);
        let parsedErrorResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedErrorResponse) {
            let internalError = null;
            if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
            error.code = internalError ? internalError.code : parsedErrorResponse.code;
            error.message = internalError ? internalError.message : parsedErrorResponse.message;
          }
        } catch (defaultError) {
          error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                           `- "${operationRes.bodyAsText}" for the default response.`;
          return Promise.reject(error);
        }
        return Promise.reject(error);
      }
      // Deserialize Response
      if (statusCode === 200) {
        let parsedResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedResponse !== null && parsedResponse !== undefined) {
            let resultMapper = {
              required: false,
              serializedName: 'parsedResponse',
              type: {
                name: 'Sequence',
                element: {
                    required: false,
                    serializedName: 'UserModelElementType',
                    type: {
                      name: 'Composite',
                      className: 'UserModel'
                    }
                }
              }
            };
            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
          }
        } catch (error) {
          let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
          deserializationError.request = msRest.stripRequest(httpRequest);
          deserializationError.response = msRest.stripResponse(response);
          return Promise.reject(deserializationError);
        }
      }

    } catch(err) {
      return Promise.reject(err);
    }

    return Promise.resolve(operationRes);
  }
  // methods on the client.

  /**
   * @summary Creates a new user.
   *
   * @param {InsertUserRequestModel} model The user model.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  async createUserWithHttpOperationResponse(model: Models.InsertUserRequestModel, options?: msRest.RequestOptionsBase): Promise<msRest.HttpOperationResponse> {
    let client = this;
    // Validate
    try {
      if (model === null || model === undefined) {
        throw new Error('model cannot be null or undefined.');
      }
    } catch (error) {
      return Promise.reject(error);
    }

    // Construct URL
    let baseUrl = this.baseUri;
    let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'v1/directory/users';

    // Create HTTP transport objects
    let httpRequest = new WebResource();
    httpRequest.method = 'POST';
    httpRequest.url = requestUrl;
    httpRequest.headers = {};
    // Set Headers
    httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
    if(options && options.customHeaders) {
      for(let headerName in options.customHeaders) {
        if (options.customHeaders.hasOwnProperty(headerName)) {
          httpRequest.headers[headerName] = options.customHeaders[headerName];
        }
      }
    }
    // Serialize Request
    let requestContent = null;
    let requestModel = null;
    try {
      if (model !== null && model !== undefined) {
        let requestModelMapper = Mappers.InsertUserRequestModel;
        requestModel = client.serializer.serialize(requestModelMapper, model, 'model');
        requestContent = JSON.stringify(requestModel);
      }
    } catch (error) {
      let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
          `payload - ${JSON.stringify(model, null, 2)}.`);
      return Promise.reject(serializationError);
    }
    httpRequest.body = requestContent;
    // Send Request
    let operationRes: msRest.HttpOperationResponse;
    try {
      operationRes = await client.pipeline(httpRequest);
      let response = operationRes.response;
      let statusCode = response.status;
      if (statusCode !== 201 && statusCode !== 403 && statusCode !== 409) {
        let error = new msRest.RestError(operationRes.bodyAsText as string);
        error.statusCode = response.status;
        error.request = msRest.stripRequest(httpRequest);
        error.response = msRest.stripResponse(response);
        let parsedErrorResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedErrorResponse) {
            let internalError = null;
            if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
            error.code = internalError ? internalError.code : parsedErrorResponse.code;
            error.message = internalError ? internalError.message : parsedErrorResponse.message;
          }
        } catch (defaultError) {
          error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                           `- "${operationRes.bodyAsText}" for the default response.`;
          return Promise.reject(error);
        }
        return Promise.reject(error);
      }
      // Deserialize Response
      if (statusCode === 201) {
        let parsedResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedResponse !== null && parsedResponse !== undefined) {
            let resultMapper = Mappers.UserModel;
            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
          }
        } catch (error) {
          let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
          deserializationError.request = msRest.stripRequest(httpRequest);
          deserializationError.response = msRest.stripResponse(response);
          return Promise.reject(deserializationError);
        }
      }

    } catch(err) {
      return Promise.reject(err);
    }

    return Promise.resolve(operationRes);
  }
  // methods on the client.

  /**
   * @summary Gets a single user by its unique identifier.
   *
   * @param {number} id The user identifier.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  async getUserByIdWithHttpOperationResponse(id: number, options?: msRest.RequestOptionsBase): Promise<msRest.HttpOperationResponse> {
    let client = this;
    // Validate
    try {
      if (id === null || id === undefined || typeof id !== 'number') {
        throw new Error('id cannot be null or undefined and it must be of type number.');
      }
    } catch (error) {
      return Promise.reject(error);
    }

    // Construct URL
    let baseUrl = this.baseUri;
    let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'v1/directory/users/{id}';
    requestUrl = requestUrl.replace('{id}', encodeURIComponent(id.toString()));

    // Create HTTP transport objects
    let httpRequest = new WebResource();
    httpRequest.method = 'GET';
    httpRequest.url = requestUrl;
    httpRequest.headers = {};
    // Set Headers
    httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
    if(options && options.customHeaders) {
      for(let headerName in options.customHeaders) {
        if (options.customHeaders.hasOwnProperty(headerName)) {
          httpRequest.headers[headerName] = options.customHeaders[headerName];
        }
      }
    }
    // Send Request
    let operationRes: msRest.HttpOperationResponse;
    try {
      operationRes = await client.pipeline(httpRequest);
      let response = operationRes.response;
      let statusCode = response.status;
      if (statusCode !== 200 && statusCode !== 403 && statusCode !== 404) {
        let error = new msRest.RestError(operationRes.bodyAsText as string);
        error.statusCode = response.status;
        error.request = msRest.stripRequest(httpRequest);
        error.response = msRest.stripResponse(response);
        let parsedErrorResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedErrorResponse) {
            let internalError = null;
            if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
            error.code = internalError ? internalError.code : parsedErrorResponse.code;
            error.message = internalError ? internalError.message : parsedErrorResponse.message;
          }
        } catch (defaultError) {
          error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                           `- "${operationRes.bodyAsText}" for the default response.`;
          return Promise.reject(error);
        }
        return Promise.reject(error);
      }
      // Deserialize Response
      if (statusCode === 200) {
        let parsedResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedResponse !== null && parsedResponse !== undefined) {
            let resultMapper = Mappers.UserModel;
            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
          }
        } catch (error) {
          let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
          deserializationError.request = msRest.stripRequest(httpRequest);
          deserializationError.response = msRest.stripResponse(response);
          return Promise.reject(deserializationError);
        }
      }

    } catch(err) {
      return Promise.reject(err);
    }

    return Promise.resolve(operationRes);
  }
  // methods on the client.

  /**
   * @summary Updates a specified user.
   *
   * @param {number} id The user identifier.
   *
   * @param {UserBase} model The user model.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  async updateUserWithHttpOperationResponse(id: number, model: Models.UserBase, options?: msRest.RequestOptionsBase): Promise<msRest.HttpOperationResponse> {
    let client = this;
    // Validate
    try {
      if (id === null || id === undefined || typeof id !== 'number') {
        throw new Error('id cannot be null or undefined and it must be of type number.');
      }
      if (model === null || model === undefined) {
        throw new Error('model cannot be null or undefined.');
      }
    } catch (error) {
      return Promise.reject(error);
    }

    // Construct URL
    let baseUrl = this.baseUri;
    let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'v1/directory/users/{id}';
    requestUrl = requestUrl.replace('{id}', encodeURIComponent(id.toString()));

    // Create HTTP transport objects
    let httpRequest = new WebResource();
    httpRequest.method = 'PUT';
    httpRequest.url = requestUrl;
    httpRequest.headers = {};
    // Set Headers
    httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
    if(options && options.customHeaders) {
      for(let headerName in options.customHeaders) {
        if (options.customHeaders.hasOwnProperty(headerName)) {
          httpRequest.headers[headerName] = options.customHeaders[headerName];
        }
      }
    }
    // Serialize Request
    let requestContent = null;
    let requestModel = null;
    try {
      if (model !== null && model !== undefined) {
        let requestModelMapper = Mappers.UserBase;
        requestModel = client.serializer.serialize(requestModelMapper, model, 'model');
        requestContent = JSON.stringify(requestModel);
      }
    } catch (error) {
      let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
          `payload - ${JSON.stringify(model, null, 2)}.`);
      return Promise.reject(serializationError);
    }
    httpRequest.body = requestContent;
    // Send Request
    let operationRes: msRest.HttpOperationResponse;
    try {
      operationRes = await client.pipeline(httpRequest);
      let response = operationRes.response;
      let statusCode = response.status;
      if (statusCode !== 204 && statusCode !== 403 && statusCode !== 404) {
        let error = new msRest.RestError(operationRes.bodyAsText as string);
        error.statusCode = response.status;
        error.request = msRest.stripRequest(httpRequest);
        error.response = msRest.stripResponse(response);
        let parsedErrorResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedErrorResponse) {
            let internalError = null;
            if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
            error.code = internalError ? internalError.code : parsedErrorResponse.code;
            error.message = internalError ? internalError.message : parsedErrorResponse.message;
          }
        } catch (defaultError) {
          error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                           `- "${operationRes.bodyAsText}" for the default response.`;
          return Promise.reject(error);
        }
        return Promise.reject(error);
      }
      // Deserialize Response
      if (statusCode === 204) {
        let parsedResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedResponse !== null && parsedResponse !== undefined) {
            let resultMapper = {
              required: false,
              serializedName: 'parsedResponse',
              type: {
                name: 'Object'
              }
            };
            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
          }
        } catch (error) {
          let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
          deserializationError.request = msRest.stripRequest(httpRequest);
          deserializationError.response = msRest.stripResponse(response);
          return Promise.reject(deserializationError);
        }
      }

    } catch(err) {
      return Promise.reject(err);
    }

    return Promise.resolve(operationRes);
  }
  // methods on the client.

  /**
   * @summary Deactivates a specified user and removes all user associations.
   *
   * @param {number} id The user identifier.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  async deleteUserWithHttpOperationResponse(id: number, options?: msRest.RequestOptionsBase): Promise<msRest.HttpOperationResponse> {
    let client = this;
    // Validate
    try {
      if (id === null || id === undefined || typeof id !== 'number') {
        throw new Error('id cannot be null or undefined and it must be of type number.');
      }
    } catch (error) {
      return Promise.reject(error);
    }

    // Construct URL
    let baseUrl = this.baseUri;
    let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'v1/directory/users/{id}';
    requestUrl = requestUrl.replace('{id}', encodeURIComponent(id.toString()));

    // Create HTTP transport objects
    let httpRequest = new WebResource();
    httpRequest.method = 'DELETE';
    httpRequest.url = requestUrl;
    httpRequest.headers = {};
    // Set Headers
    httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
    if(options && options.customHeaders) {
      for(let headerName in options.customHeaders) {
        if (options.customHeaders.hasOwnProperty(headerName)) {
          httpRequest.headers[headerName] = options.customHeaders[headerName];
        }
      }
    }
    // Send Request
    let operationRes: msRest.HttpOperationResponse;
    try {
      operationRes = await client.pipeline(httpRequest);
      let response = operationRes.response;
      let statusCode = response.status;
      if (statusCode !== 204 && statusCode !== 403 && statusCode !== 404) {
        let error = new msRest.RestError(operationRes.bodyAsText as string);
        error.statusCode = response.status;
        error.request = msRest.stripRequest(httpRequest);
        error.response = msRest.stripResponse(response);
        let parsedErrorResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedErrorResponse) {
            let internalError = null;
            if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
            error.code = internalError ? internalError.code : parsedErrorResponse.code;
            error.message = internalError ? internalError.message : parsedErrorResponse.message;
          }
        } catch (defaultError) {
          error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                           `- "${operationRes.bodyAsText}" for the default response.`;
          return Promise.reject(error);
        }
        return Promise.reject(error);
      }
      // Deserialize Response
      if (statusCode === 204) {
        let parsedResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedResponse !== null && parsedResponse !== undefined) {
            let resultMapper = {
              required: false,
              serializedName: 'parsedResponse',
              type: {
                name: 'Object'
              }
            };
            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
          }
        } catch (error) {
          let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
          deserializationError.request = msRest.stripRequest(httpRequest);
          deserializationError.response = msRest.stripResponse(response);
          return Promise.reject(deserializationError);
        }
      }

    } catch(err) {
      return Promise.reject(err);
    }

    return Promise.resolve(operationRes);
  }
  // methods on the client.

  /**
   * @summary Gets a paged list of workflows.
   *
   * @param {SoftheonEnterpriseAPIGetWorkflowsByFilterOptionalParams} [options]
   * Optional Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  async getWorkflowsByFilterWithHttpOperationResponse(options?: Models.SoftheonEnterpriseAPIGetWorkflowsByFilterOptionalParams): Promise<msRest.HttpOperationResponse> {
    let client = this;
    let applicationID = (options && options.applicationID !== undefined) ? options.applicationID : undefined;
    let entityType = (options && options.entityType !== undefined) ? options.entityType : undefined;
    let name = (options && options.name !== undefined) ? options.name : undefined;
    let page = (options && options.page !== undefined) ? options.page : undefined;
    let pageSize = (options && options.pageSize !== undefined) ? options.pageSize : undefined;
    let sortOrder = (options && options.sortOrder !== undefined) ? options.sortOrder : undefined;
    let sortBy = (options && options.sortBy !== undefined) ? options.sortBy : undefined;
    // Validate
    try {
      if (applicationID !== null && applicationID !== undefined && typeof applicationID !== 'number') {
        throw new Error('applicationID must be of type number.');
      }
      if (applicationID !== null && applicationID !== undefined) {
        if (applicationID > 2147483647)
        {
          throw new Error('"applicationID" should satisfy the constraint - "InclusiveMaximum": 2147483647');
        }
        if (applicationID < 1)
        {
          throw new Error('"applicationID" should satisfy the constraint - "InclusiveMinimum": 1');
        }
      }
      if (entityType !== null && entityType !== undefined && typeof entityType !== 'number') {
        throw new Error('entityType must be of type number.');
      }
      if (entityType !== null && entityType !== undefined) {
        if (entityType > 2147483647)
        {
          throw new Error('"entityType" should satisfy the constraint - "InclusiveMaximum": 2147483647');
        }
        if (entityType < 1)
        {
          throw new Error('"entityType" should satisfy the constraint - "InclusiveMinimum": 1');
        }
      }
      if (name !== null && name !== undefined && typeof name.valueOf() !== 'string') {
        throw new Error('name must be of type string.');
      }
      if (name !== null && name !== undefined) {
        if (name.length > 255)
        {
          throw new Error('"name" should satisfy the constraint - "MaxLength": 255');
        }
        if (name.length < 0)
        {
          throw new Error('"name" should satisfy the constraint - "MinLength": 0');
        }
      }
      if (page !== null && page !== undefined && typeof page !== 'number') {
        throw new Error('page must be of type number.');
      }
      if (page !== null && page !== undefined) {
        if (page > 2147483647)
        {
          throw new Error('"page" should satisfy the constraint - "InclusiveMaximum": 2147483647');
        }
        if (page < 1)
        {
          throw new Error('"page" should satisfy the constraint - "InclusiveMinimum": 1');
        }
      }
      if (pageSize !== null && pageSize !== undefined && typeof pageSize !== 'number') {
        throw new Error('pageSize must be of type number.');
      }
      if (pageSize !== null && pageSize !== undefined) {
        if (pageSize > 1000)
        {
          throw new Error('"pageSize" should satisfy the constraint - "InclusiveMaximum": 1000');
        }
        if (pageSize < 1)
        {
          throw new Error('"pageSize" should satisfy the constraint - "InclusiveMinimum": 1');
        }
      }
      if (sortOrder !== null && sortOrder !== undefined && typeof sortOrder.valueOf() !== 'string') {
        throw new Error('sortOrder must be of type string.');
      }
      if (sortBy !== null && sortBy !== undefined && typeof sortBy !== 'number') {
        throw new Error('sortBy must be of type number.');
      }
    } catch (error) {
      return Promise.reject(error);
    }

    // Construct URL
    let baseUrl = this.baseUri;
    let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'v1/workflow/workflows';
    let queryParamsArray: Array<any> = [];
    if (applicationID !== null && applicationID !== undefined) {
      queryParamsArray.push('applicationID=' + encodeURIComponent(applicationID.toString()));
    }
    if (entityType !== null && entityType !== undefined) {
      queryParamsArray.push('entityType=' + encodeURIComponent(entityType.toString()));
    }
    if (name !== null && name !== undefined) {
      queryParamsArray.push('name=' + encodeURIComponent(name));
    }
    if (page !== null && page !== undefined) {
      queryParamsArray.push('page=' + encodeURIComponent(page.toString()));
    }
    if (pageSize !== null && pageSize !== undefined) {
      queryParamsArray.push('pageSize=' + encodeURIComponent(pageSize.toString()));
    }
    if (sortOrder !== null && sortOrder !== undefined) {
      queryParamsArray.push('sortOrder=' + encodeURIComponent(sortOrder));
    }
    if (sortBy !== null && sortBy !== undefined) {
      queryParamsArray.push('sortBy=' + encodeURIComponent(sortBy.toString()));
    }
    if (queryParamsArray.length > 0) {
      requestUrl += '?' + queryParamsArray.join('&');
    }

    // Create HTTP transport objects
    let httpRequest = new WebResource();
    httpRequest.method = 'GET';
    httpRequest.url = requestUrl;
    httpRequest.headers = {};
    // Set Headers
    httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
    if(options && options.customHeaders) {
      for(let headerName in options.customHeaders) {
        if (options.customHeaders.hasOwnProperty(headerName)) {
          httpRequest.headers[headerName] = options.customHeaders[headerName];
        }
      }
    }
    // Send Request
    let operationRes: msRest.HttpOperationResponse;
    try {
      operationRes = await client.pipeline(httpRequest);
      let response = operationRes.response;
      let statusCode = response.status;
      if (statusCode !== 200) {
        let error = new msRest.RestError(operationRes.bodyAsText as string);
        error.statusCode = response.status;
        error.request = msRest.stripRequest(httpRequest);
        error.response = msRest.stripResponse(response);
        let parsedErrorResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedErrorResponse) {
            let internalError = null;
            if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
            error.code = internalError ? internalError.code : parsedErrorResponse.code;
            error.message = internalError ? internalError.message : parsedErrorResponse.message;
          }
        } catch (defaultError) {
          error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                           `- "${operationRes.bodyAsText}" for the default response.`;
          return Promise.reject(error);
        }
        return Promise.reject(error);
      }
      // Deserialize Response
      if (statusCode === 200) {
        let parsedResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedResponse !== null && parsedResponse !== undefined) {
            let resultMapper = {
              required: false,
              serializedName: 'parsedResponse',
              type: {
                name: 'Sequence',
                element: {
                    required: false,
                    serializedName: 'WorkflowModelElementType',
                    type: {
                      name: 'Composite',
                      className: 'WorkflowModel'
                    }
                }
              }
            };
            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
          }
        } catch (error) {
          let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
          deserializationError.request = msRest.stripRequest(httpRequest);
          deserializationError.response = msRest.stripResponse(response);
          return Promise.reject(deserializationError);
        }
      }

    } catch(err) {
      return Promise.reject(err);
    }

    return Promise.resolve(operationRes);
  }
  // methods on the client.

  /**
   * @summary Gets a single workflow based on its unique identifier.
   *
   * @param {number} id The workflow identifier.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  async getWorkflowByIdWithHttpOperationResponse(id: number, options?: msRest.RequestOptionsBase): Promise<msRest.HttpOperationResponse> {
    let client = this;
    // Validate
    try {
      if (id === null || id === undefined || typeof id !== 'number') {
        throw new Error('id cannot be null or undefined and it must be of type number.');
      }
    } catch (error) {
      return Promise.reject(error);
    }

    // Construct URL
    let baseUrl = this.baseUri;
    let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'v1/workflow/workflows/{id}';
    requestUrl = requestUrl.replace('{id}', encodeURIComponent(id.toString()));

    // Create HTTP transport objects
    let httpRequest = new WebResource();
    httpRequest.method = 'GET';
    httpRequest.url = requestUrl;
    httpRequest.headers = {};
    // Set Headers
    httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
    if(options && options.customHeaders) {
      for(let headerName in options.customHeaders) {
        if (options.customHeaders.hasOwnProperty(headerName)) {
          httpRequest.headers[headerName] = options.customHeaders[headerName];
        }
      }
    }
    // Send Request
    let operationRes: msRest.HttpOperationResponse;
    try {
      operationRes = await client.pipeline(httpRequest);
      let response = operationRes.response;
      let statusCode = response.status;
      if (statusCode !== 200 && statusCode !== 404) {
        let error = new msRest.RestError(operationRes.bodyAsText as string);
        error.statusCode = response.status;
        error.request = msRest.stripRequest(httpRequest);
        error.response = msRest.stripResponse(response);
        let parsedErrorResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedErrorResponse) {
            let internalError = null;
            if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
            error.code = internalError ? internalError.code : parsedErrorResponse.code;
            error.message = internalError ? internalError.message : parsedErrorResponse.message;
          }
        } catch (defaultError) {
          error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                           `- "${operationRes.bodyAsText}" for the default response.`;
          return Promise.reject(error);
        }
        return Promise.reject(error);
      }
      // Deserialize Response
      if (statusCode === 200) {
        let parsedResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedResponse !== null && parsedResponse !== undefined) {
            let resultMapper = Mappers.WorkflowModel;
            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
          }
        } catch (error) {
          let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
          deserializationError.request = msRest.stripRequest(httpRequest);
          deserializationError.response = msRest.stripResponse(response);
          return Promise.reject(deserializationError);
        }
      }

    } catch(err) {
      return Promise.reject(err);
    }

    return Promise.resolve(operationRes);
  }
  // methods on the client.

  /**
   * @summary Gets queues for a specific workflow.
   *
   * @param {number} id The workflow identifier.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  async getWorkflowQueuesByIdWithHttpOperationResponse(id: number, options?: msRest.RequestOptionsBase): Promise<msRest.HttpOperationResponse> {
    let client = this;
    // Validate
    try {
      if (id === null || id === undefined || typeof id !== 'number') {
        throw new Error('id cannot be null or undefined and it must be of type number.');
      }
    } catch (error) {
      return Promise.reject(error);
    }

    // Construct URL
    let baseUrl = this.baseUri;
    let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'v1/workflow/workflows/{id}/queue';
    requestUrl = requestUrl.replace('{id}', encodeURIComponent(id.toString()));

    // Create HTTP transport objects
    let httpRequest = new WebResource();
    httpRequest.method = 'GET';
    httpRequest.url = requestUrl;
    httpRequest.headers = {};
    // Set Headers
    httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
    if(options && options.customHeaders) {
      for(let headerName in options.customHeaders) {
        if (options.customHeaders.hasOwnProperty(headerName)) {
          httpRequest.headers[headerName] = options.customHeaders[headerName];
        }
      }
    }
    // Send Request
    let operationRes: msRest.HttpOperationResponse;
    try {
      operationRes = await client.pipeline(httpRequest);
      let response = operationRes.response;
      let statusCode = response.status;
      if (statusCode !== 200 && statusCode !== 404) {
        let error = new msRest.RestError(operationRes.bodyAsText as string);
        error.statusCode = response.status;
        error.request = msRest.stripRequest(httpRequest);
        error.response = msRest.stripResponse(response);
        let parsedErrorResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedErrorResponse) {
            let internalError = null;
            if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
            error.code = internalError ? internalError.code : parsedErrorResponse.code;
            error.message = internalError ? internalError.message : parsedErrorResponse.message;
          }
        } catch (defaultError) {
          error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                           `- "${operationRes.bodyAsText}" for the default response.`;
          return Promise.reject(error);
        }
        return Promise.reject(error);
      }
      // Deserialize Response
      if (statusCode === 200) {
        let parsedResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedResponse !== null && parsedResponse !== undefined) {
            let resultMapper = {
              required: false,
              serializedName: 'parsedResponse',
              type: {
                name: 'Sequence',
                element: {
                    required: false,
                    serializedName: 'WorkflowQueueModelElementType',
                    type: {
                      name: 'Composite',
                      className: 'WorkflowQueueModel'
                    }
                }
              }
            };
            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
          }
        } catch (error) {
          let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
          deserializationError.request = msRest.stripRequest(httpRequest);
          deserializationError.response = msRest.stripResponse(response);
          return Promise.reject(deserializationError);
        }
      }

    } catch(err) {
      return Promise.reject(err);
    }

    return Promise.resolve(operationRes);
  }
  // methods on the client.

  /**
   * @summary Gets a single entity template definition completed with all
   * profiles definitions as XML entity definition.
   *
   * @param {number} type The unique template type.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  async getXMLTemplateByTypeWithHttpOperationResponse(type: number, options?: msRest.RequestOptionsBase): Promise<msRest.HttpOperationResponse> {
    let client = this;
    // Validate
    try {
      if (type === null || type === undefined || typeof type !== 'number') {
        throw new Error('type cannot be null or undefined and it must be of type number.');
      }
    } catch (error) {
      return Promise.reject(error);
    }

    // Construct URL
    let baseUrl = this.baseUri;
    let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'v1/template/xml/{type}';
    requestUrl = requestUrl.replace('{type}', encodeURIComponent(type.toString()));

    // Create HTTP transport objects
    let httpRequest = new WebResource();
    httpRequest.method = 'GET';
    httpRequest.url = requestUrl;
    httpRequest.headers = {};
    // Set Headers
    httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
    if(options && options.customHeaders) {
      for(let headerName in options.customHeaders) {
        if (options.customHeaders.hasOwnProperty(headerName)) {
          httpRequest.headers[headerName] = options.customHeaders[headerName];
        }
      }
    }
    // Send Request
    let operationRes: msRest.HttpOperationResponse;
    try {
      operationRes = await client.pipeline(httpRequest);
      let response = operationRes.response;
      let statusCode = response.status;
      if (statusCode !== 200 && statusCode !== 404) {
        let error = new msRest.RestError(operationRes.bodyAsText as string);
        error.statusCode = response.status;
        error.request = msRest.stripRequest(httpRequest);
        error.response = msRest.stripResponse(response);
        let parsedErrorResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedErrorResponse) {
            let internalError = null;
            if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
            error.code = internalError ? internalError.code : parsedErrorResponse.code;
            error.message = internalError ? internalError.message : parsedErrorResponse.message;
          }
        } catch (defaultError) {
          error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                           `- "${operationRes.bodyAsText}" for the default response.`;
          return Promise.reject(error);
        }
        return Promise.reject(error);
      }
      // Deserialize Response
      if (statusCode === 200) {
        let parsedResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedResponse !== null && parsedResponse !== undefined) {
            let resultMapper = {
              required: false,
              serializedName: 'parsedResponse',
              type: {
                name: 'String'
              }
            };
            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
          }
        } catch (error) {
          let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
          deserializationError.request = msRest.stripRequest(httpRequest);
          deserializationError.response = msRest.stripResponse(response);
          return Promise.reject(deserializationError);
        }
      }

    } catch(err) {
      return Promise.reject(err);
    }

    return Promise.resolve(operationRes);
  }
  // methods on the client.

  /**
   * @summary Creates a new entity template definition.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  async createXMLTemplateWithHttpOperationResponse(options?: msRest.RequestOptionsBase): Promise<msRest.HttpOperationResponse> {
    let client = this;

    // Construct URL
    let baseUrl = this.baseUri;
    let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'v1/template/xml';

    // Create HTTP transport objects
    let httpRequest = new WebResource();
    httpRequest.method = 'POST';
    httpRequest.url = requestUrl;
    httpRequest.headers = {};
    // Set Headers
    httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
    if(options && options.customHeaders) {
      for(let headerName in options.customHeaders) {
        if (options.customHeaders.hasOwnProperty(headerName)) {
          httpRequest.headers[headerName] = options.customHeaders[headerName];
        }
      }
    }
    // Send Request
    let operationRes: msRest.HttpOperationResponse;
    try {
      operationRes = await client.pipeline(httpRequest);
      let response = operationRes.response;
      let statusCode = response.status;
      if (statusCode !== 201 && statusCode !== 409 && statusCode !== 400 && statusCode !== 403) {
        let error = new msRest.RestError(operationRes.bodyAsText as string);
        error.statusCode = response.status;
        error.request = msRest.stripRequest(httpRequest);
        error.response = msRest.stripResponse(response);
        let parsedErrorResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedErrorResponse) {
            let internalError = null;
            if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
            error.code = internalError ? internalError.code : parsedErrorResponse.code;
            error.message = internalError ? internalError.message : parsedErrorResponse.message;
          }
        } catch (defaultError) {
          error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                           `- "${operationRes.bodyAsText}" for the default response.`;
          return Promise.reject(error);
        }
        return Promise.reject(error);
      }
      // Deserialize Response
      if (statusCode === 201) {
        let parsedResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedResponse !== null && parsedResponse !== undefined) {
            let resultMapper = {
              required: false,
              serializedName: 'parsedResponse',
              type: {
                name: 'String'
              }
            };
            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
          }
        } catch (error) {
          let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
          deserializationError.request = msRest.stripRequest(httpRequest);
          deserializationError.response = msRest.stripResponse(response);
          return Promise.reject(deserializationError);
        }
      }

    } catch(err) {
      return Promise.reject(err);
    }

    return Promise.resolve(operationRes);
  }

  /**
   * @summary Accepts the task.
   *
   * @param {WorkflowActionModel} model The model.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @param {ServiceCallback} callback - The callback.
   *
   * @returns {ServiceCallback} callback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {any} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {Response} [response] - The HTTP Response stream if an error did not occur.
   */
  acceptTask(model: Models.WorkflowActionModel): Promise<any>;
  acceptTask(model: Models.WorkflowActionModel, options: msRest.RequestOptionsBase): Promise<any>;
  acceptTask(model: Models.WorkflowActionModel, callback: msRest.ServiceCallback<any>): void;
  acceptTask(model: Models.WorkflowActionModel, options: msRest.RequestOptionsBase, callback: msRest.ServiceCallback<any>): void;
  acceptTask(model: Models.WorkflowActionModel, options?: msRest.RequestOptionsBase, callback?: msRest.ServiceCallback<any>): any {
    if (!callback && typeof options === 'function') {
      callback = options;
      options = undefined;
    }
    let cb = callback as msRest.ServiceCallback<any>;
    if (!callback) {
      return this.acceptTaskWithHttpOperationResponse(model, options).then((operationRes: msRest.HttpOperationResponse) => {
        return Promise.resolve(operationRes.bodyAsJson as any);
      }).catch((err: Error) => {
        return Promise.reject(err);
      });
    } else {
      msRest.promiseToCallback(this.acceptTaskWithHttpOperationResponse(model, options))((err: Error, data: msRest.HttpOperationResponse) => {
        if (err) {
          return cb(err);
        }
        let result = data.bodyAsJson as any;
        return cb(err, result, data.request, data.response);
      });
    }
  }

  /**
   * @summary Rejects the task.
   *
   * @param {WorkflowActionModel} model The model.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @param {ServiceCallback} callback - The callback.
   *
   * @returns {ServiceCallback} callback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {any} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {Response} [response] - The HTTP Response stream if an error did not occur.
   */
  rejectTask(model: Models.WorkflowActionModel): Promise<any>;
  rejectTask(model: Models.WorkflowActionModel, options: msRest.RequestOptionsBase): Promise<any>;
  rejectTask(model: Models.WorkflowActionModel, callback: msRest.ServiceCallback<any>): void;
  rejectTask(model: Models.WorkflowActionModel, options: msRest.RequestOptionsBase, callback: msRest.ServiceCallback<any>): void;
  rejectTask(model: Models.WorkflowActionModel, options?: msRest.RequestOptionsBase, callback?: msRest.ServiceCallback<any>): any {
    if (!callback && typeof options === 'function') {
      callback = options;
      options = undefined;
    }
    let cb = callback as msRest.ServiceCallback<any>;
    if (!callback) {
      return this.rejectTaskWithHttpOperationResponse(model, options).then((operationRes: msRest.HttpOperationResponse) => {
        return Promise.resolve(operationRes.bodyAsJson as any);
      }).catch((err: Error) => {
        return Promise.reject(err);
      });
    } else {
      msRest.promiseToCallback(this.rejectTaskWithHttpOperationResponse(model, options))((err: Error, data: msRest.HttpOperationResponse) => {
        if (err) {
          return cb(err);
        }
        let result = data.bodyAsJson as any;
        return cb(err, result, data.request, data.response);
      });
    }
  }

  /**
   * @summary Suspends the task.
   *
   * @param {WorkflowActionModel} model The model.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @param {ServiceCallback} callback - The callback.
   *
   * @returns {ServiceCallback} callback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {any} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {Response} [response] - The HTTP Response stream if an error did not occur.
   */
  suspendTask(model: Models.WorkflowActionModel): Promise<any>;
  suspendTask(model: Models.WorkflowActionModel, options: msRest.RequestOptionsBase): Promise<any>;
  suspendTask(model: Models.WorkflowActionModel, callback: msRest.ServiceCallback<any>): void;
  suspendTask(model: Models.WorkflowActionModel, options: msRest.RequestOptionsBase, callback: msRest.ServiceCallback<any>): void;
  suspendTask(model: Models.WorkflowActionModel, options?: msRest.RequestOptionsBase, callback?: msRest.ServiceCallback<any>): any {
    if (!callback && typeof options === 'function') {
      callback = options;
      options = undefined;
    }
    let cb = callback as msRest.ServiceCallback<any>;
    if (!callback) {
      return this.suspendTaskWithHttpOperationResponse(model, options).then((operationRes: msRest.HttpOperationResponse) => {
        return Promise.resolve(operationRes.bodyAsJson as any);
      }).catch((err: Error) => {
        return Promise.reject(err);
      });
    } else {
      msRest.promiseToCallback(this.suspendTaskWithHttpOperationResponse(model, options))((err: Error, data: msRest.HttpOperationResponse) => {
        if (err) {
          return cb(err);
        }
        let result = data.bodyAsJson as any;
        return cb(err, result, data.request, data.response);
      });
    }
  }

  /**
   * @summary Routes the task.
   *
   * @param {WorkflowActionRouteModel} model The model.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @param {ServiceCallback} callback - The callback.
   *
   * @returns {ServiceCallback} callback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {any} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {Response} [response] - The HTTP Response stream if an error did not occur.
   */
  routeTask(model: Models.WorkflowActionRouteModel): Promise<any>;
  routeTask(model: Models.WorkflowActionRouteModel, options: msRest.RequestOptionsBase): Promise<any>;
  routeTask(model: Models.WorkflowActionRouteModel, callback: msRest.ServiceCallback<any>): void;
  routeTask(model: Models.WorkflowActionRouteModel, options: msRest.RequestOptionsBase, callback: msRest.ServiceCallback<any>): void;
  routeTask(model: Models.WorkflowActionRouteModel, options?: msRest.RequestOptionsBase, callback?: msRest.ServiceCallback<any>): any {
    if (!callback && typeof options === 'function') {
      callback = options;
      options = undefined;
    }
    let cb = callback as msRest.ServiceCallback<any>;
    if (!callback) {
      return this.routeTaskWithHttpOperationResponse(model, options).then((operationRes: msRest.HttpOperationResponse) => {
        return Promise.resolve(operationRes.bodyAsJson as any);
      }).catch((err: Error) => {
        return Promise.reject(err);
      });
    } else {
      msRest.promiseToCallback(this.routeTaskWithHttpOperationResponse(model, options))((err: Error, data: msRest.HttpOperationResponse) => {
        if (err) {
          return cb(err);
        }
        let result = data.bodyAsJson as any;
        return cb(err, result, data.request, data.response);
      });
    }
  }

  /**
   * @summary Overrides the task.
   *
   * @param {WorkflowActionModel} model The model.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @param {ServiceCallback} callback - The callback.
   *
   * @returns {ServiceCallback} callback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {any} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {Response} [response] - The HTTP Response stream if an error did not occur.
   */
  overrideTask(model: Models.WorkflowActionModel): Promise<any>;
  overrideTask(model: Models.WorkflowActionModel, options: msRest.RequestOptionsBase): Promise<any>;
  overrideTask(model: Models.WorkflowActionModel, callback: msRest.ServiceCallback<any>): void;
  overrideTask(model: Models.WorkflowActionModel, options: msRest.RequestOptionsBase, callback: msRest.ServiceCallback<any>): void;
  overrideTask(model: Models.WorkflowActionModel, options?: msRest.RequestOptionsBase, callback?: msRest.ServiceCallback<any>): any {
    if (!callback && typeof options === 'function') {
      callback = options;
      options = undefined;
    }
    let cb = callback as msRest.ServiceCallback<any>;
    if (!callback) {
      return this.overrideTaskWithHttpOperationResponse(model, options).then((operationRes: msRest.HttpOperationResponse) => {
        return Promise.resolve(operationRes.bodyAsJson as any);
      }).catch((err: Error) => {
        return Promise.reject(err);
      });
    } else {
      msRest.promiseToCallback(this.overrideTaskWithHttpOperationResponse(model, options))((err: Error, data: msRest.HttpOperationResponse) => {
        if (err) {
          return cb(err);
        }
        let result = data.bodyAsJson as any;
        return cb(err, result, data.request, data.response);
      });
    }
  }

  /**
   * @summary Resets the task.
   *
   * @param {WorkflowActionModel} model The model.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @param {ServiceCallback} callback - The callback.
   *
   * @returns {ServiceCallback} callback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {any} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {Response} [response] - The HTTP Response stream if an error did not occur.
   */
  resetTask(model: Models.WorkflowActionModel): Promise<any>;
  resetTask(model: Models.WorkflowActionModel, options: msRest.RequestOptionsBase): Promise<any>;
  resetTask(model: Models.WorkflowActionModel, callback: msRest.ServiceCallback<any>): void;
  resetTask(model: Models.WorkflowActionModel, options: msRest.RequestOptionsBase, callback: msRest.ServiceCallback<any>): void;
  resetTask(model: Models.WorkflowActionModel, options?: msRest.RequestOptionsBase, callback?: msRest.ServiceCallback<any>): any {
    if (!callback && typeof options === 'function') {
      callback = options;
      options = undefined;
    }
    let cb = callback as msRest.ServiceCallback<any>;
    if (!callback) {
      return this.resetTaskWithHttpOperationResponse(model, options).then((operationRes: msRest.HttpOperationResponse) => {
        return Promise.resolve(operationRes.bodyAsJson as any);
      }).catch((err: Error) => {
        return Promise.reject(err);
      });
    } else {
      msRest.promiseToCallback(this.resetTaskWithHttpOperationResponse(model, options))((err: Error, data: msRest.HttpOperationResponse) => {
        if (err) {
          return cb(err);
        }
        let result = data.bodyAsJson as any;
        return cb(err, result, data.request, data.response);
      });
    }
  }

  /**
   * @summary Initializes the Workflow.
   *
   * @param {WorkflowActionInitializeModel} model The model.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @param {ServiceCallback} callback - The callback.
   *
   * @returns {ServiceCallback} callback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {any} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {Response} [response] - The HTTP Response stream if an error did not occur.
   */
  initializeEntityWorkflow(model: Models.WorkflowActionInitializeModel): Promise<any>;
  initializeEntityWorkflow(model: Models.WorkflowActionInitializeModel, options: msRest.RequestOptionsBase): Promise<any>;
  initializeEntityWorkflow(model: Models.WorkflowActionInitializeModel, callback: msRest.ServiceCallback<any>): void;
  initializeEntityWorkflow(model: Models.WorkflowActionInitializeModel, options: msRest.RequestOptionsBase, callback: msRest.ServiceCallback<any>): void;
  initializeEntityWorkflow(model: Models.WorkflowActionInitializeModel, options?: msRest.RequestOptionsBase, callback?: msRest.ServiceCallback<any>): any {
    if (!callback && typeof options === 'function') {
      callback = options;
      options = undefined;
    }
    let cb = callback as msRest.ServiceCallback<any>;
    if (!callback) {
      return this.initializeEntityWorkflowWithHttpOperationResponse(model, options).then((operationRes: msRest.HttpOperationResponse) => {
        return Promise.resolve(operationRes.bodyAsJson as any);
      }).catch((err: Error) => {
        return Promise.reject(err);
      });
    } else {
      msRest.promiseToCallback(this.initializeEntityWorkflowWithHttpOperationResponse(model, options))((err: Error, data: msRest.HttpOperationResponse) => {
        if (err) {
          return cb(err);
        }
        let result = data.bodyAsJson as any;
        return cb(err, result, data.request, data.response);
      });
    }
  }

  /**
   * @summary Gets a list of all available applications.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @param {ServiceCallback} callback - The callback.
   *
   * @returns {ServiceCallback} callback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {Models.ApplicationModel[]} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {Response} [response] - The HTTP Response stream if an error did not occur.
   */
  getAllApplications(): Promise<Models.ApplicationModel[]>;
  getAllApplications(options: msRest.RequestOptionsBase): Promise<Models.ApplicationModel[]>;
  getAllApplications(callback: msRest.ServiceCallback<Models.ApplicationModel[]>): void;
  getAllApplications(options: msRest.RequestOptionsBase, callback: msRest.ServiceCallback<Models.ApplicationModel[]>): void;
  getAllApplications(options?: msRest.RequestOptionsBase, callback?: msRest.ServiceCallback<Models.ApplicationModel[]>): any {
    if (!callback && typeof options === 'function') {
      callback = options;
      options = undefined;
    }
    let cb = callback as msRest.ServiceCallback<Models.ApplicationModel[]>;
    if (!callback) {
      return this.getAllApplicationsWithHttpOperationResponse(options).then((operationRes: msRest.HttpOperationResponse) => {
        return Promise.resolve(operationRes.bodyAsJson as Models.ApplicationModel[]);
      }).catch((err: Error) => {
        return Promise.reject(err);
      });
    } else {
      msRest.promiseToCallback(this.getAllApplicationsWithHttpOperationResponse(options))((err: Error, data: msRest.HttpOperationResponse) => {
        if (err) {
          return cb(err);
        }
        let result = data.bodyAsJson as Models.ApplicationModel[];
        return cb(err, result, data.request, data.response);
      });
    }
  }

  /**
   * @summary Gets a single application by its unique identifier.
   *
   * @param {number} id The unique application identifier.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @param {ServiceCallback} callback - The callback.
   *
   * @returns {ServiceCallback} callback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {Models.ApplicationModel} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link Models.ApplicationModel} for more
   *                      information.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {Response} [response] - The HTTP Response stream if an error did not occur.
   */
  getApplicationById(id: number): Promise<Models.ApplicationModel>;
  getApplicationById(id: number, options: msRest.RequestOptionsBase): Promise<Models.ApplicationModel>;
  getApplicationById(id: number, callback: msRest.ServiceCallback<Models.ApplicationModel>): void;
  getApplicationById(id: number, options: msRest.RequestOptionsBase, callback: msRest.ServiceCallback<Models.ApplicationModel>): void;
  getApplicationById(id: number, options?: msRest.RequestOptionsBase, callback?: msRest.ServiceCallback<Models.ApplicationModel>): any {
    if (!callback && typeof options === 'function') {
      callback = options;
      options = undefined;
    }
    let cb = callback as msRest.ServiceCallback<Models.ApplicationModel>;
    if (!callback) {
      return this.getApplicationByIdWithHttpOperationResponse(id, options).then((operationRes: msRest.HttpOperationResponse) => {
        return Promise.resolve(operationRes.bodyAsJson as Models.ApplicationModel);
      }).catch((err: Error) => {
        return Promise.reject(err);
      });
    } else {
      msRest.promiseToCallback(this.getApplicationByIdWithHttpOperationResponse(id, options))((err: Error, data: msRest.HttpOperationResponse) => {
        if (err) {
          return cb(err);
        }
        let result = data.bodyAsJson as Models.ApplicationModel;
        return cb(err, result, data.request, data.response);
      });
    }
  }

  /**
   * @summary Gets a single application by its name.
   *
   * @param {string} name The unique application name.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @param {ServiceCallback} callback - The callback.
   *
   * @returns {ServiceCallback} callback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {Models.ApplicationModel} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link Models.ApplicationModel} for more
   *                      information.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {Response} [response] - The HTTP Response stream if an error did not occur.
   */
  getApplicationByName(name: string): Promise<Models.ApplicationModel>;
  getApplicationByName(name: string, options: msRest.RequestOptionsBase): Promise<Models.ApplicationModel>;
  getApplicationByName(name: string, callback: msRest.ServiceCallback<Models.ApplicationModel>): void;
  getApplicationByName(name: string, options: msRest.RequestOptionsBase, callback: msRest.ServiceCallback<Models.ApplicationModel>): void;
  getApplicationByName(name: string, options?: msRest.RequestOptionsBase, callback?: msRest.ServiceCallback<Models.ApplicationModel>): any {
    if (!callback && typeof options === 'function') {
      callback = options;
      options = undefined;
    }
    let cb = callback as msRest.ServiceCallback<Models.ApplicationModel>;
    if (!callback) {
      return this.getApplicationByNameWithHttpOperationResponse(name, options).then((operationRes: msRest.HttpOperationResponse) => {
        return Promise.resolve(operationRes.bodyAsJson as Models.ApplicationModel);
      }).catch((err: Error) => {
        return Promise.reject(err);
      });
    } else {
      msRest.promiseToCallback(this.getApplicationByNameWithHttpOperationResponse(name, options))((err: Error, data: msRest.HttpOperationResponse) => {
        if (err) {
          return cb(err);
        }
        let result = data.bodyAsJson as Models.ApplicationModel;
        return cb(err, result, data.request, data.response);
      });
    }
  }

  /**
   * @summary Gets a list of drawer group associations.
   *
   * @param {number} drawerID The drawer identifier.
   *
   * @param {SoftheonEnterpriseAPIGetDrawerGroupAssociationsOptionalParams}
   * [options] Optional Parameters.
   *
   * @param {ServiceCallback} callback - The callback.
   *
   * @returns {ServiceCallback} callback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {Models.GroupDrawerModel[]} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {Response} [response] - The HTTP Response stream if an error did not occur.
   */
  getDrawerGroupAssociations(drawerID: number): Promise<Models.GroupDrawerModel[]>;
  getDrawerGroupAssociations(drawerID: number, options: Models.SoftheonEnterpriseAPIGetDrawerGroupAssociationsOptionalParams): Promise<Models.GroupDrawerModel[]>;
  getDrawerGroupAssociations(drawerID: number, callback: msRest.ServiceCallback<Models.GroupDrawerModel[]>): void;
  getDrawerGroupAssociations(drawerID: number, options: Models.SoftheonEnterpriseAPIGetDrawerGroupAssociationsOptionalParams, callback: msRest.ServiceCallback<Models.GroupDrawerModel[]>): void;
  getDrawerGroupAssociations(drawerID: number, options?: Models.SoftheonEnterpriseAPIGetDrawerGroupAssociationsOptionalParams, callback?: msRest.ServiceCallback<Models.GroupDrawerModel[]>): any {
    if (!callback && typeof options === 'function') {
      callback = options;
      options = undefined;
    }
    let cb = callback as msRest.ServiceCallback<Models.GroupDrawerModel[]>;
    if (!callback) {
      return this.getDrawerGroupAssociationsWithHttpOperationResponse(drawerID, options).then((operationRes: msRest.HttpOperationResponse) => {
        return Promise.resolve(operationRes.bodyAsJson as Models.GroupDrawerModel[]);
      }).catch((err: Error) => {
        return Promise.reject(err);
      });
    } else {
      msRest.promiseToCallback(this.getDrawerGroupAssociationsWithHttpOperationResponse(drawerID, options))((err: Error, data: msRest.HttpOperationResponse) => {
        if (err) {
          return cb(err);
        }
        let result = data.bodyAsJson as Models.GroupDrawerModel[];
        return cb(err, result, data.request, data.response);
      });
    }
  }

  /**
   * @summary Gets a list of group drawer associations.
   *
   * @param {number} groupID The group identifier.
   *
   * @param {SoftheonEnterpriseAPIGetGroupDrawerAssociationsOptionalParams}
   * [options] Optional Parameters.
   *
   * @param {ServiceCallback} callback - The callback.
   *
   * @returns {ServiceCallback} callback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {Models.GroupDrawerModel[]} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {Response} [response] - The HTTP Response stream if an error did not occur.
   */
  getGroupDrawerAssociations(groupID: number): Promise<Models.GroupDrawerModel[]>;
  getGroupDrawerAssociations(groupID: number, options: Models.SoftheonEnterpriseAPIGetGroupDrawerAssociationsOptionalParams): Promise<Models.GroupDrawerModel[]>;
  getGroupDrawerAssociations(groupID: number, callback: msRest.ServiceCallback<Models.GroupDrawerModel[]>): void;
  getGroupDrawerAssociations(groupID: number, options: Models.SoftheonEnterpriseAPIGetGroupDrawerAssociationsOptionalParams, callback: msRest.ServiceCallback<Models.GroupDrawerModel[]>): void;
  getGroupDrawerAssociations(groupID: number, options?: Models.SoftheonEnterpriseAPIGetGroupDrawerAssociationsOptionalParams, callback?: msRest.ServiceCallback<Models.GroupDrawerModel[]>): any {
    if (!callback && typeof options === 'function') {
      callback = options;
      options = undefined;
    }
    let cb = callback as msRest.ServiceCallback<Models.GroupDrawerModel[]>;
    if (!callback) {
      return this.getGroupDrawerAssociationsWithHttpOperationResponse(groupID, options).then((operationRes: msRest.HttpOperationResponse) => {
        return Promise.resolve(operationRes.bodyAsJson as Models.GroupDrawerModel[]);
      }).catch((err: Error) => {
        return Promise.reject(err);
      });
    } else {
      msRest.promiseToCallback(this.getGroupDrawerAssociationsWithHttpOperationResponse(groupID, options))((err: Error, data: msRest.HttpOperationResponse) => {
        if (err) {
          return cb(err);
        }
        let result = data.bodyAsJson as Models.GroupDrawerModel[];
        return cb(err, result, data.request, data.response);
      });
    }
  }

  /**
   * @summary Inserts/Updates the drawer group association.
   *
   * @param {number} groupID The group identifier.
   *
   * @param {number} drawerID The drawer identifier.
   *
   * @param {GroupDrawerModel} model The model.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @param {ServiceCallback} callback - The callback.
   *
   * @returns {ServiceCallback} callback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {any} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {Response} [response] - The HTTP Response stream if an error did not occur.
   */
  createOrUpdateDrawerGroupAssociation(groupID: number, drawerID: number, model: Models.GroupDrawerModel): Promise<any>;
  createOrUpdateDrawerGroupAssociation(groupID: number, drawerID: number, model: Models.GroupDrawerModel, options: msRest.RequestOptionsBase): Promise<any>;
  createOrUpdateDrawerGroupAssociation(groupID: number, drawerID: number, model: Models.GroupDrawerModel, callback: msRest.ServiceCallback<any>): void;
  createOrUpdateDrawerGroupAssociation(groupID: number, drawerID: number, model: Models.GroupDrawerModel, options: msRest.RequestOptionsBase, callback: msRest.ServiceCallback<any>): void;
  createOrUpdateDrawerGroupAssociation(groupID: number, drawerID: number, model: Models.GroupDrawerModel, options?: msRest.RequestOptionsBase, callback?: msRest.ServiceCallback<any>): any {
    if (!callback && typeof options === 'function') {
      callback = options;
      options = undefined;
    }
    let cb = callback as msRest.ServiceCallback<any>;
    if (!callback) {
      return this.createOrUpdateDrawerGroupAssociationWithHttpOperationResponse(groupID, drawerID, model, options).then((operationRes: msRest.HttpOperationResponse) => {
        return Promise.resolve(operationRes.bodyAsJson as any);
      }).catch((err: Error) => {
        return Promise.reject(err);
      });
    } else {
      msRest.promiseToCallback(this.createOrUpdateDrawerGroupAssociationWithHttpOperationResponse(groupID, drawerID, model, options))((err: Error, data: msRest.HttpOperationResponse) => {
        if (err) {
          return cb(err);
        }
        let result = data.bodyAsJson as any;
        return cb(err, result, data.request, data.response);
      });
    }
  }

  /**
   * @summary Deletes a drawer group association;
   *
   * @param {number} groupID The group identifier.
   *
   * @param {number} drawerID The drawer identifier.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @param {ServiceCallback} callback - The callback.
   *
   * @returns {ServiceCallback} callback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {any} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {Response} [response] - The HTTP Response stream if an error did not occur.
   */
  deleteDrawerGroupAssociation(groupID: number, drawerID: number): Promise<any>;
  deleteDrawerGroupAssociation(groupID: number, drawerID: number, options: msRest.RequestOptionsBase): Promise<any>;
  deleteDrawerGroupAssociation(groupID: number, drawerID: number, callback: msRest.ServiceCallback<any>): void;
  deleteDrawerGroupAssociation(groupID: number, drawerID: number, options: msRest.RequestOptionsBase, callback: msRest.ServiceCallback<any>): void;
  deleteDrawerGroupAssociation(groupID: number, drawerID: number, options?: msRest.RequestOptionsBase, callback?: msRest.ServiceCallback<any>): any {
    if (!callback && typeof options === 'function') {
      callback = options;
      options = undefined;
    }
    let cb = callback as msRest.ServiceCallback<any>;
    if (!callback) {
      return this.deleteDrawerGroupAssociationWithHttpOperationResponse(groupID, drawerID, options).then((operationRes: msRest.HttpOperationResponse) => {
        return Promise.resolve(operationRes.bodyAsJson as any);
      }).catch((err: Error) => {
        return Promise.reject(err);
      });
    } else {
      msRest.promiseToCallback(this.deleteDrawerGroupAssociationWithHttpOperationResponse(groupID, drawerID, options))((err: Error, data: msRest.HttpOperationResponse) => {
        if (err) {
          return cb(err);
        }
        let result = data.bodyAsJson as any;
        return cb(err, result, data.request, data.response);
      });
    }
  }

  /**
   * @summary Inserts/Updates the group drawer association.
   *
   * @param {number} groupID The group identifier.
   *
   * @param {number} drawerID The drawer identifier.
   *
   * @param {GroupDrawerModel} model The model.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @param {ServiceCallback} callback - The callback.
   *
   * @returns {ServiceCallback} callback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {any} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {Response} [response] - The HTTP Response stream if an error did not occur.
   */
  createOrUpdateGroupDrawerAssociation(groupID: number, drawerID: number, model: Models.GroupDrawerModel): Promise<any>;
  createOrUpdateGroupDrawerAssociation(groupID: number, drawerID: number, model: Models.GroupDrawerModel, options: msRest.RequestOptionsBase): Promise<any>;
  createOrUpdateGroupDrawerAssociation(groupID: number, drawerID: number, model: Models.GroupDrawerModel, callback: msRest.ServiceCallback<any>): void;
  createOrUpdateGroupDrawerAssociation(groupID: number, drawerID: number, model: Models.GroupDrawerModel, options: msRest.RequestOptionsBase, callback: msRest.ServiceCallback<any>): void;
  createOrUpdateGroupDrawerAssociation(groupID: number, drawerID: number, model: Models.GroupDrawerModel, options?: msRest.RequestOptionsBase, callback?: msRest.ServiceCallback<any>): any {
    if (!callback && typeof options === 'function') {
      callback = options;
      options = undefined;
    }
    let cb = callback as msRest.ServiceCallback<any>;
    if (!callback) {
      return this.createOrUpdateGroupDrawerAssociationWithHttpOperationResponse(groupID, drawerID, model, options).then((operationRes: msRest.HttpOperationResponse) => {
        return Promise.resolve(operationRes.bodyAsJson as any);
      }).catch((err: Error) => {
        return Promise.reject(err);
      });
    } else {
      msRest.promiseToCallback(this.createOrUpdateGroupDrawerAssociationWithHttpOperationResponse(groupID, drawerID, model, options))((err: Error, data: msRest.HttpOperationResponse) => {
        if (err) {
          return cb(err);
        }
        let result = data.bodyAsJson as any;
        return cb(err, result, data.request, data.response);
      });
    }
  }

  /**
   * @summary Deletes a group drawer association;
   *
   * @param {number} groupID The group identifier.
   *
   * @param {number} drawerID The drawer identifier.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @param {ServiceCallback} callback - The callback.
   *
   * @returns {ServiceCallback} callback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {any} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {Response} [response] - The HTTP Response stream if an error did not occur.
   */
  deleteGroupDrawerAssociation(groupID: number, drawerID: number): Promise<any>;
  deleteGroupDrawerAssociation(groupID: number, drawerID: number, options: msRest.RequestOptionsBase): Promise<any>;
  deleteGroupDrawerAssociation(groupID: number, drawerID: number, callback: msRest.ServiceCallback<any>): void;
  deleteGroupDrawerAssociation(groupID: number, drawerID: number, options: msRest.RequestOptionsBase, callback: msRest.ServiceCallback<any>): void;
  deleteGroupDrawerAssociation(groupID: number, drawerID: number, options?: msRest.RequestOptionsBase, callback?: msRest.ServiceCallback<any>): any {
    if (!callback && typeof options === 'function') {
      callback = options;
      options = undefined;
    }
    let cb = callback as msRest.ServiceCallback<any>;
    if (!callback) {
      return this.deleteGroupDrawerAssociationWithHttpOperationResponse(groupID, drawerID, options).then((operationRes: msRest.HttpOperationResponse) => {
        return Promise.resolve(operationRes.bodyAsJson as any);
      }).catch((err: Error) => {
        return Promise.reject(err);
      });
    } else {
      msRest.promiseToCallback(this.deleteGroupDrawerAssociationWithHttpOperationResponse(groupID, drawerID, options))((err: Error, data: msRest.HttpOperationResponse) => {
        if (err) {
          return cb(err);
        }
        let result = data.bodyAsJson as any;
        return cb(err, result, data.request, data.response);
      });
    }
  }

  /**
   * @summary Gets a list of user group associations.
   *
   * @param {number} userID The user identifier.
   *
   * @param {SoftheonEnterpriseAPIGetUserGroupAssociationsOptionalParams}
   * [options] Optional Parameters.
   *
   * @param {ServiceCallback} callback - The callback.
   *
   * @returns {ServiceCallback} callback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {Models.GroupUserModel[]} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {Response} [response] - The HTTP Response stream if an error did not occur.
   */
  getUserGroupAssociations(userID: number): Promise<Models.GroupUserModel[]>;
  getUserGroupAssociations(userID: number, options: Models.SoftheonEnterpriseAPIGetUserGroupAssociationsOptionalParams): Promise<Models.GroupUserModel[]>;
  getUserGroupAssociations(userID: number, callback: msRest.ServiceCallback<Models.GroupUserModel[]>): void;
  getUserGroupAssociations(userID: number, options: Models.SoftheonEnterpriseAPIGetUserGroupAssociationsOptionalParams, callback: msRest.ServiceCallback<Models.GroupUserModel[]>): void;
  getUserGroupAssociations(userID: number, options?: Models.SoftheonEnterpriseAPIGetUserGroupAssociationsOptionalParams, callback?: msRest.ServiceCallback<Models.GroupUserModel[]>): any {
    if (!callback && typeof options === 'function') {
      callback = options;
      options = undefined;
    }
    let cb = callback as msRest.ServiceCallback<Models.GroupUserModel[]>;
    if (!callback) {
      return this.getUserGroupAssociationsWithHttpOperationResponse(userID, options).then((operationRes: msRest.HttpOperationResponse) => {
        return Promise.resolve(operationRes.bodyAsJson as Models.GroupUserModel[]);
      }).catch((err: Error) => {
        return Promise.reject(err);
      });
    } else {
      msRest.promiseToCallback(this.getUserGroupAssociationsWithHttpOperationResponse(userID, options))((err: Error, data: msRest.HttpOperationResponse) => {
        if (err) {
          return cb(err);
        }
        let result = data.bodyAsJson as Models.GroupUserModel[];
        return cb(err, result, data.request, data.response);
      });
    }
  }

  /**
   * @summary Gets a list of group user associations.
   *
   * @param {number} groupID The group identifier.
   *
   * @param {SoftheonEnterpriseAPIGetGroupUserAssociationsOptionalParams}
   * [options] Optional Parameters.
   *
   * @param {ServiceCallback} callback - The callback.
   *
   * @returns {ServiceCallback} callback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {Models.GroupUserModel[]} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {Response} [response] - The HTTP Response stream if an error did not occur.
   */
  getGroupUserAssociations(groupID: number): Promise<Models.GroupUserModel[]>;
  getGroupUserAssociations(groupID: number, options: Models.SoftheonEnterpriseAPIGetGroupUserAssociationsOptionalParams): Promise<Models.GroupUserModel[]>;
  getGroupUserAssociations(groupID: number, callback: msRest.ServiceCallback<Models.GroupUserModel[]>): void;
  getGroupUserAssociations(groupID: number, options: Models.SoftheonEnterpriseAPIGetGroupUserAssociationsOptionalParams, callback: msRest.ServiceCallback<Models.GroupUserModel[]>): void;
  getGroupUserAssociations(groupID: number, options?: Models.SoftheonEnterpriseAPIGetGroupUserAssociationsOptionalParams, callback?: msRest.ServiceCallback<Models.GroupUserModel[]>): any {
    if (!callback && typeof options === 'function') {
      callback = options;
      options = undefined;
    }
    let cb = callback as msRest.ServiceCallback<Models.GroupUserModel[]>;
    if (!callback) {
      return this.getGroupUserAssociationsWithHttpOperationResponse(groupID, options).then((operationRes: msRest.HttpOperationResponse) => {
        return Promise.resolve(operationRes.bodyAsJson as Models.GroupUserModel[]);
      }).catch((err: Error) => {
        return Promise.reject(err);
      });
    } else {
      msRest.promiseToCallback(this.getGroupUserAssociationsWithHttpOperationResponse(groupID, options))((err: Error, data: msRest.HttpOperationResponse) => {
        if (err) {
          return cb(err);
        }
        let result = data.bodyAsJson as Models.GroupUserModel[];
        return cb(err, result, data.request, data.response);
      });
    }
  }

  /**
   * @summary Inserts the user group association.
   *
   * @param {number} groupID The group identifier.
   *
   * @param {number} userID The user identifier.
   *
   * @param {GroupUserModel} model The model.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @param {ServiceCallback} callback - The callback.
   *
   * @returns {ServiceCallback} callback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {any} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {Response} [response] - The HTTP Response stream if an error did not occur.
   */
  createUserGroupAssociation(groupID: number, userID: number, model: Models.GroupUserModel): Promise<any>;
  createUserGroupAssociation(groupID: number, userID: number, model: Models.GroupUserModel, options: msRest.RequestOptionsBase): Promise<any>;
  createUserGroupAssociation(groupID: number, userID: number, model: Models.GroupUserModel, callback: msRest.ServiceCallback<any>): void;
  createUserGroupAssociation(groupID: number, userID: number, model: Models.GroupUserModel, options: msRest.RequestOptionsBase, callback: msRest.ServiceCallback<any>): void;
  createUserGroupAssociation(groupID: number, userID: number, model: Models.GroupUserModel, options?: msRest.RequestOptionsBase, callback?: msRest.ServiceCallback<any>): any {
    if (!callback && typeof options === 'function') {
      callback = options;
      options = undefined;
    }
    let cb = callback as msRest.ServiceCallback<any>;
    if (!callback) {
      return this.createUserGroupAssociationWithHttpOperationResponse(groupID, userID, model, options).then((operationRes: msRest.HttpOperationResponse) => {
        return Promise.resolve(operationRes.bodyAsJson as any);
      }).catch((err: Error) => {
        return Promise.reject(err);
      });
    } else {
      msRest.promiseToCallback(this.createUserGroupAssociationWithHttpOperationResponse(groupID, userID, model, options))((err: Error, data: msRest.HttpOperationResponse) => {
        if (err) {
          return cb(err);
        }
        let result = data.bodyAsJson as any;
        return cb(err, result, data.request, data.response);
      });
    }
  }

  /**
   * @summary Deletes a user group association;
   *
   * @param {number} groupID The group identifier.
   *
   * @param {number} userID The user identifier.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @param {ServiceCallback} callback - The callback.
   *
   * @returns {ServiceCallback} callback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {any} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {Response} [response] - The HTTP Response stream if an error did not occur.
   */
  deleteUserGroupAssociation(groupID: number, userID: number): Promise<any>;
  deleteUserGroupAssociation(groupID: number, userID: number, options: msRest.RequestOptionsBase): Promise<any>;
  deleteUserGroupAssociation(groupID: number, userID: number, callback: msRest.ServiceCallback<any>): void;
  deleteUserGroupAssociation(groupID: number, userID: number, options: msRest.RequestOptionsBase, callback: msRest.ServiceCallback<any>): void;
  deleteUserGroupAssociation(groupID: number, userID: number, options?: msRest.RequestOptionsBase, callback?: msRest.ServiceCallback<any>): any {
    if (!callback && typeof options === 'function') {
      callback = options;
      options = undefined;
    }
    let cb = callback as msRest.ServiceCallback<any>;
    if (!callback) {
      return this.deleteUserGroupAssociationWithHttpOperationResponse(groupID, userID, options).then((operationRes: msRest.HttpOperationResponse) => {
        return Promise.resolve(operationRes.bodyAsJson as any);
      }).catch((err: Error) => {
        return Promise.reject(err);
      });
    } else {
      msRest.promiseToCallback(this.deleteUserGroupAssociationWithHttpOperationResponse(groupID, userID, options))((err: Error, data: msRest.HttpOperationResponse) => {
        if (err) {
          return cb(err);
        }
        let result = data.bodyAsJson as any;
        return cb(err, result, data.request, data.response);
      });
    }
  }

  /**
   * @summary Inserts the group user association.
   *
   * @param {number} groupID The group identifier.
   *
   * @param {number} userID The user identifier.
   *
   * @param {GroupUserModel} model The model.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @param {ServiceCallback} callback - The callback.
   *
   * @returns {ServiceCallback} callback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {any} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {Response} [response] - The HTTP Response stream if an error did not occur.
   */
  createGroupUserAssociation(groupID: number, userID: number, model: Models.GroupUserModel): Promise<any>;
  createGroupUserAssociation(groupID: number, userID: number, model: Models.GroupUserModel, options: msRest.RequestOptionsBase): Promise<any>;
  createGroupUserAssociation(groupID: number, userID: number, model: Models.GroupUserModel, callback: msRest.ServiceCallback<any>): void;
  createGroupUserAssociation(groupID: number, userID: number, model: Models.GroupUserModel, options: msRest.RequestOptionsBase, callback: msRest.ServiceCallback<any>): void;
  createGroupUserAssociation(groupID: number, userID: number, model: Models.GroupUserModel, options?: msRest.RequestOptionsBase, callback?: msRest.ServiceCallback<any>): any {
    if (!callback && typeof options === 'function') {
      callback = options;
      options = undefined;
    }
    let cb = callback as msRest.ServiceCallback<any>;
    if (!callback) {
      return this.createGroupUserAssociationWithHttpOperationResponse(groupID, userID, model, options).then((operationRes: msRest.HttpOperationResponse) => {
        return Promise.resolve(operationRes.bodyAsJson as any);
      }).catch((err: Error) => {
        return Promise.reject(err);
      });
    } else {
      msRest.promiseToCallback(this.createGroupUserAssociationWithHttpOperationResponse(groupID, userID, model, options))((err: Error, data: msRest.HttpOperationResponse) => {
        if (err) {
          return cb(err);
        }
        let result = data.bodyAsJson as any;
        return cb(err, result, data.request, data.response);
      });
    }
  }

  /**
   * @summary Deletes a group user association;
   *
   * @param {number} groupID The group identifier.
   *
   * @param {number} userID The user identifier.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @param {ServiceCallback} callback - The callback.
   *
   * @returns {ServiceCallback} callback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {any} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {Response} [response] - The HTTP Response stream if an error did not occur.
   */
  deleteGroupUserAssociation(groupID: number, userID: number): Promise<any>;
  deleteGroupUserAssociation(groupID: number, userID: number, options: msRest.RequestOptionsBase): Promise<any>;
  deleteGroupUserAssociation(groupID: number, userID: number, callback: msRest.ServiceCallback<any>): void;
  deleteGroupUserAssociation(groupID: number, userID: number, options: msRest.RequestOptionsBase, callback: msRest.ServiceCallback<any>): void;
  deleteGroupUserAssociation(groupID: number, userID: number, options?: msRest.RequestOptionsBase, callback?: msRest.ServiceCallback<any>): any {
    if (!callback && typeof options === 'function') {
      callback = options;
      options = undefined;
    }
    let cb = callback as msRest.ServiceCallback<any>;
    if (!callback) {
      return this.deleteGroupUserAssociationWithHttpOperationResponse(groupID, userID, options).then((operationRes: msRest.HttpOperationResponse) => {
        return Promise.resolve(operationRes.bodyAsJson as any);
      }).catch((err: Error) => {
        return Promise.reject(err);
      });
    } else {
      msRest.promiseToCallback(this.deleteGroupUserAssociationWithHttpOperationResponse(groupID, userID, options))((err: Error, data: msRest.HttpOperationResponse) => {
        if (err) {
          return cb(err);
        }
        let result = data.bodyAsJson as any;
        return cb(err, result, data.request, data.response);
      });
    }
  }

  /**
   * @summary Gets a list of queue group associations.
   *
   * @param {number} queueID The queue identifier.
   *
   * @param {SoftheonEnterpriseAPIGetQueueGroupAssociationsOptionalParams}
   * [options] Optional Parameters.
   *
   * @param {ServiceCallback} callback - The callback.
   *
   * @returns {ServiceCallback} callback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {Models.GroupQueueModel[]} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {Response} [response] - The HTTP Response stream if an error did not occur.
   */
  getQueueGroupAssociations(queueID: number): Promise<Models.GroupQueueModel[]>;
  getQueueGroupAssociations(queueID: number, options: Models.SoftheonEnterpriseAPIGetQueueGroupAssociationsOptionalParams): Promise<Models.GroupQueueModel[]>;
  getQueueGroupAssociations(queueID: number, callback: msRest.ServiceCallback<Models.GroupQueueModel[]>): void;
  getQueueGroupAssociations(queueID: number, options: Models.SoftheonEnterpriseAPIGetQueueGroupAssociationsOptionalParams, callback: msRest.ServiceCallback<Models.GroupQueueModel[]>): void;
  getQueueGroupAssociations(queueID: number, options?: Models.SoftheonEnterpriseAPIGetQueueGroupAssociationsOptionalParams, callback?: msRest.ServiceCallback<Models.GroupQueueModel[]>): any {
    if (!callback && typeof options === 'function') {
      callback = options;
      options = undefined;
    }
    let cb = callback as msRest.ServiceCallback<Models.GroupQueueModel[]>;
    if (!callback) {
      return this.getQueueGroupAssociationsWithHttpOperationResponse(queueID, options).then((operationRes: msRest.HttpOperationResponse) => {
        return Promise.resolve(operationRes.bodyAsJson as Models.GroupQueueModel[]);
      }).catch((err: Error) => {
        return Promise.reject(err);
      });
    } else {
      msRest.promiseToCallback(this.getQueueGroupAssociationsWithHttpOperationResponse(queueID, options))((err: Error, data: msRest.HttpOperationResponse) => {
        if (err) {
          return cb(err);
        }
        let result = data.bodyAsJson as Models.GroupQueueModel[];
        return cb(err, result, data.request, data.response);
      });
    }
  }

  /**
   * @summary Gets a list of group queue associations.
   *
   * @param {number} groupID The group identifier.
   *
   * @param {SoftheonEnterpriseAPIGetGroupQueueAssociationsOptionalParams}
   * [options] Optional Parameters.
   *
   * @param {ServiceCallback} callback - The callback.
   *
   * @returns {ServiceCallback} callback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {Models.GroupQueueModel[]} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {Response} [response] - The HTTP Response stream if an error did not occur.
   */
  getGroupQueueAssociations(groupID: number): Promise<Models.GroupQueueModel[]>;
  getGroupQueueAssociations(groupID: number, options: Models.SoftheonEnterpriseAPIGetGroupQueueAssociationsOptionalParams): Promise<Models.GroupQueueModel[]>;
  getGroupQueueAssociations(groupID: number, callback: msRest.ServiceCallback<Models.GroupQueueModel[]>): void;
  getGroupQueueAssociations(groupID: number, options: Models.SoftheonEnterpriseAPIGetGroupQueueAssociationsOptionalParams, callback: msRest.ServiceCallback<Models.GroupQueueModel[]>): void;
  getGroupQueueAssociations(groupID: number, options?: Models.SoftheonEnterpriseAPIGetGroupQueueAssociationsOptionalParams, callback?: msRest.ServiceCallback<Models.GroupQueueModel[]>): any {
    if (!callback && typeof options === 'function') {
      callback = options;
      options = undefined;
    }
    let cb = callback as msRest.ServiceCallback<Models.GroupQueueModel[]>;
    if (!callback) {
      return this.getGroupQueueAssociationsWithHttpOperationResponse(groupID, options).then((operationRes: msRest.HttpOperationResponse) => {
        return Promise.resolve(operationRes.bodyAsJson as Models.GroupQueueModel[]);
      }).catch((err: Error) => {
        return Promise.reject(err);
      });
    } else {
      msRest.promiseToCallback(this.getGroupQueueAssociationsWithHttpOperationResponse(groupID, options))((err: Error, data: msRest.HttpOperationResponse) => {
        if (err) {
          return cb(err);
        }
        let result = data.bodyAsJson as Models.GroupQueueModel[];
        return cb(err, result, data.request, data.response);
      });
    }
  }

  /**
   * @summary Inserts/Updates the queue group association.
   *
   * @param {number} groupID The group identifier.
   *
   * @param {number} queueID The queue identifier.
   *
   * @param {GroupQueueModel} model The model.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @param {ServiceCallback} callback - The callback.
   *
   * @returns {ServiceCallback} callback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {any} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {Response} [response] - The HTTP Response stream if an error did not occur.
   */
  createOrUpdateQueueGroupAssociation(groupID: number, queueID: number, model: Models.GroupQueueModel): Promise<any>;
  createOrUpdateQueueGroupAssociation(groupID: number, queueID: number, model: Models.GroupQueueModel, options: msRest.RequestOptionsBase): Promise<any>;
  createOrUpdateQueueGroupAssociation(groupID: number, queueID: number, model: Models.GroupQueueModel, callback: msRest.ServiceCallback<any>): void;
  createOrUpdateQueueGroupAssociation(groupID: number, queueID: number, model: Models.GroupQueueModel, options: msRest.RequestOptionsBase, callback: msRest.ServiceCallback<any>): void;
  createOrUpdateQueueGroupAssociation(groupID: number, queueID: number, model: Models.GroupQueueModel, options?: msRest.RequestOptionsBase, callback?: msRest.ServiceCallback<any>): any {
    if (!callback && typeof options === 'function') {
      callback = options;
      options = undefined;
    }
    let cb = callback as msRest.ServiceCallback<any>;
    if (!callback) {
      return this.createOrUpdateQueueGroupAssociationWithHttpOperationResponse(groupID, queueID, model, options).then((operationRes: msRest.HttpOperationResponse) => {
        return Promise.resolve(operationRes.bodyAsJson as any);
      }).catch((err: Error) => {
        return Promise.reject(err);
      });
    } else {
      msRest.promiseToCallback(this.createOrUpdateQueueGroupAssociationWithHttpOperationResponse(groupID, queueID, model, options))((err: Error, data: msRest.HttpOperationResponse) => {
        if (err) {
          return cb(err);
        }
        let result = data.bodyAsJson as any;
        return cb(err, result, data.request, data.response);
      });
    }
  }

  /**
   * @summary Deletes a queue group association;
   *
   * @param {number} groupID The group identifier.
   *
   * @param {number} queueID The queue identifier.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @param {ServiceCallback} callback - The callback.
   *
   * @returns {ServiceCallback} callback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {any} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {Response} [response] - The HTTP Response stream if an error did not occur.
   */
  deleteQueueGroupAssociation(groupID: number, queueID: number): Promise<any>;
  deleteQueueGroupAssociation(groupID: number, queueID: number, options: msRest.RequestOptionsBase): Promise<any>;
  deleteQueueGroupAssociation(groupID: number, queueID: number, callback: msRest.ServiceCallback<any>): void;
  deleteQueueGroupAssociation(groupID: number, queueID: number, options: msRest.RequestOptionsBase, callback: msRest.ServiceCallback<any>): void;
  deleteQueueGroupAssociation(groupID: number, queueID: number, options?: msRest.RequestOptionsBase, callback?: msRest.ServiceCallback<any>): any {
    if (!callback && typeof options === 'function') {
      callback = options;
      options = undefined;
    }
    let cb = callback as msRest.ServiceCallback<any>;
    if (!callback) {
      return this.deleteQueueGroupAssociationWithHttpOperationResponse(groupID, queueID, options).then((operationRes: msRest.HttpOperationResponse) => {
        return Promise.resolve(operationRes.bodyAsJson as any);
      }).catch((err: Error) => {
        return Promise.reject(err);
      });
    } else {
      msRest.promiseToCallback(this.deleteQueueGroupAssociationWithHttpOperationResponse(groupID, queueID, options))((err: Error, data: msRest.HttpOperationResponse) => {
        if (err) {
          return cb(err);
        }
        let result = data.bodyAsJson as any;
        return cb(err, result, data.request, data.response);
      });
    }
  }

  /**
   * @summary Inserts/Updates the group queue association.
   *
   * @param {number} groupID The group identifier.
   *
   * @param {number} queueID The queue identifier.
   *
   * @param {GroupQueueModel} model The model.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @param {ServiceCallback} callback - The callback.
   *
   * @returns {ServiceCallback} callback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {any} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {Response} [response] - The HTTP Response stream if an error did not occur.
   */
  createOrUpdateGroupQueueAssociation(groupID: number, queueID: number, model: Models.GroupQueueModel): Promise<any>;
  createOrUpdateGroupQueueAssociation(groupID: number, queueID: number, model: Models.GroupQueueModel, options: msRest.RequestOptionsBase): Promise<any>;
  createOrUpdateGroupQueueAssociation(groupID: number, queueID: number, model: Models.GroupQueueModel, callback: msRest.ServiceCallback<any>): void;
  createOrUpdateGroupQueueAssociation(groupID: number, queueID: number, model: Models.GroupQueueModel, options: msRest.RequestOptionsBase, callback: msRest.ServiceCallback<any>): void;
  createOrUpdateGroupQueueAssociation(groupID: number, queueID: number, model: Models.GroupQueueModel, options?: msRest.RequestOptionsBase, callback?: msRest.ServiceCallback<any>): any {
    if (!callback && typeof options === 'function') {
      callback = options;
      options = undefined;
    }
    let cb = callback as msRest.ServiceCallback<any>;
    if (!callback) {
      return this.createOrUpdateGroupQueueAssociationWithHttpOperationResponse(groupID, queueID, model, options).then((operationRes: msRest.HttpOperationResponse) => {
        return Promise.resolve(operationRes.bodyAsJson as any);
      }).catch((err: Error) => {
        return Promise.reject(err);
      });
    } else {
      msRest.promiseToCallback(this.createOrUpdateGroupQueueAssociationWithHttpOperationResponse(groupID, queueID, model, options))((err: Error, data: msRest.HttpOperationResponse) => {
        if (err) {
          return cb(err);
        }
        let result = data.bodyAsJson as any;
        return cb(err, result, data.request, data.response);
      });
    }
  }

  /**
   * @summary Deletes a group queue association;
   *
   * @param {number} groupID The group identifier.
   *
   * @param {number} queueID The queue identifier.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @param {ServiceCallback} callback - The callback.
   *
   * @returns {ServiceCallback} callback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {any} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {Response} [response] - The HTTP Response stream if an error did not occur.
   */
  deleteGroupQueueAssociation(groupID: number, queueID: number): Promise<any>;
  deleteGroupQueueAssociation(groupID: number, queueID: number, options: msRest.RequestOptionsBase): Promise<any>;
  deleteGroupQueueAssociation(groupID: number, queueID: number, callback: msRest.ServiceCallback<any>): void;
  deleteGroupQueueAssociation(groupID: number, queueID: number, options: msRest.RequestOptionsBase, callback: msRest.ServiceCallback<any>): void;
  deleteGroupQueueAssociation(groupID: number, queueID: number, options?: msRest.RequestOptionsBase, callback?: msRest.ServiceCallback<any>): any {
    if (!callback && typeof options === 'function') {
      callback = options;
      options = undefined;
    }
    let cb = callback as msRest.ServiceCallback<any>;
    if (!callback) {
      return this.deleteGroupQueueAssociationWithHttpOperationResponse(groupID, queueID, options).then((operationRes: msRest.HttpOperationResponse) => {
        return Promise.resolve(operationRes.bodyAsJson as any);
      }).catch((err: Error) => {
        return Promise.reject(err);
      });
    } else {
      msRest.promiseToCallback(this.deleteGroupQueueAssociationWithHttpOperationResponse(groupID, queueID, options))((err: Error, data: msRest.HttpOperationResponse) => {
        if (err) {
          return cb(err);
        }
        let result = data.bodyAsJson as any;
        return cb(err, result, data.request, data.response);
      });
    }
  }

  /**
   * @summary Gets a list of application group associations.
   *
   * @param {number} applicationID The application identifier.
   *
   * @param {SoftheonEnterpriseAPIGetApplicationGroupAssociationsOptionalParams}
   * [options] Optional Parameters.
   *
   * @param {ServiceCallback} callback - The callback.
   *
   * @returns {ServiceCallback} callback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {Models.GroupApplicationModel[]} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {Response} [response] - The HTTP Response stream if an error did not occur.
   */
  getApplicationGroupAssociations(applicationID: number): Promise<Models.GroupApplicationModel[]>;
  getApplicationGroupAssociations(applicationID: number, options: Models.SoftheonEnterpriseAPIGetApplicationGroupAssociationsOptionalParams): Promise<Models.GroupApplicationModel[]>;
  getApplicationGroupAssociations(applicationID: number, callback: msRest.ServiceCallback<Models.GroupApplicationModel[]>): void;
  getApplicationGroupAssociations(applicationID: number, options: Models.SoftheonEnterpriseAPIGetApplicationGroupAssociationsOptionalParams, callback: msRest.ServiceCallback<Models.GroupApplicationModel[]>): void;
  getApplicationGroupAssociations(applicationID: number, options?: Models.SoftheonEnterpriseAPIGetApplicationGroupAssociationsOptionalParams, callback?: msRest.ServiceCallback<Models.GroupApplicationModel[]>): any {
    if (!callback && typeof options === 'function') {
      callback = options;
      options = undefined;
    }
    let cb = callback as msRest.ServiceCallback<Models.GroupApplicationModel[]>;
    if (!callback) {
      return this.getApplicationGroupAssociationsWithHttpOperationResponse(applicationID, options).then((operationRes: msRest.HttpOperationResponse) => {
        return Promise.resolve(operationRes.bodyAsJson as Models.GroupApplicationModel[]);
      }).catch((err: Error) => {
        return Promise.reject(err);
      });
    } else {
      msRest.promiseToCallback(this.getApplicationGroupAssociationsWithHttpOperationResponse(applicationID, options))((err: Error, data: msRest.HttpOperationResponse) => {
        if (err) {
          return cb(err);
        }
        let result = data.bodyAsJson as Models.GroupApplicationModel[];
        return cb(err, result, data.request, data.response);
      });
    }
  }

  /**
   * @summary Gets a list of group application associations.
   *
   * @param {number} groupID The group identifier.
   *
   * @param {SoftheonEnterpriseAPIGetGroupApplicationAssociationsOptionalParams}
   * [options] Optional Parameters.
   *
   * @param {ServiceCallback} callback - The callback.
   *
   * @returns {ServiceCallback} callback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {Models.GroupApplicationModel[]} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {Response} [response] - The HTTP Response stream if an error did not occur.
   */
  getGroupApplicationAssociations(groupID: number): Promise<Models.GroupApplicationModel[]>;
  getGroupApplicationAssociations(groupID: number, options: Models.SoftheonEnterpriseAPIGetGroupApplicationAssociationsOptionalParams): Promise<Models.GroupApplicationModel[]>;
  getGroupApplicationAssociations(groupID: number, callback: msRest.ServiceCallback<Models.GroupApplicationModel[]>): void;
  getGroupApplicationAssociations(groupID: number, options: Models.SoftheonEnterpriseAPIGetGroupApplicationAssociationsOptionalParams, callback: msRest.ServiceCallback<Models.GroupApplicationModel[]>): void;
  getGroupApplicationAssociations(groupID: number, options?: Models.SoftheonEnterpriseAPIGetGroupApplicationAssociationsOptionalParams, callback?: msRest.ServiceCallback<Models.GroupApplicationModel[]>): any {
    if (!callback && typeof options === 'function') {
      callback = options;
      options = undefined;
    }
    let cb = callback as msRest.ServiceCallback<Models.GroupApplicationModel[]>;
    if (!callback) {
      return this.getGroupApplicationAssociationsWithHttpOperationResponse(groupID, options).then((operationRes: msRest.HttpOperationResponse) => {
        return Promise.resolve(operationRes.bodyAsJson as Models.GroupApplicationModel[]);
      }).catch((err: Error) => {
        return Promise.reject(err);
      });
    } else {
      msRest.promiseToCallback(this.getGroupApplicationAssociationsWithHttpOperationResponse(groupID, options))((err: Error, data: msRest.HttpOperationResponse) => {
        if (err) {
          return cb(err);
        }
        let result = data.bodyAsJson as Models.GroupApplicationModel[];
        return cb(err, result, data.request, data.response);
      });
    }
  }

  /**
   * @summary Inserts/Updates the application group association.
   *
   * @param {number} groupID The group identifier.
   *
   * @param {number} applicationID The application identifier.
   *
   * @param {GroupApplicationModel} model The model.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @param {ServiceCallback} callback - The callback.
   *
   * @returns {ServiceCallback} callback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {any} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {Response} [response] - The HTTP Response stream if an error did not occur.
   */
  createOrUpdateApplicationGroupAssociation(groupID: number, applicationID: number, model: Models.GroupApplicationModel): Promise<any>;
  createOrUpdateApplicationGroupAssociation(groupID: number, applicationID: number, model: Models.GroupApplicationModel, options: msRest.RequestOptionsBase): Promise<any>;
  createOrUpdateApplicationGroupAssociation(groupID: number, applicationID: number, model: Models.GroupApplicationModel, callback: msRest.ServiceCallback<any>): void;
  createOrUpdateApplicationGroupAssociation(groupID: number, applicationID: number, model: Models.GroupApplicationModel, options: msRest.RequestOptionsBase, callback: msRest.ServiceCallback<any>): void;
  createOrUpdateApplicationGroupAssociation(groupID: number, applicationID: number, model: Models.GroupApplicationModel, options?: msRest.RequestOptionsBase, callback?: msRest.ServiceCallback<any>): any {
    if (!callback && typeof options === 'function') {
      callback = options;
      options = undefined;
    }
    let cb = callback as msRest.ServiceCallback<any>;
    if (!callback) {
      return this.createOrUpdateApplicationGroupAssociationWithHttpOperationResponse(groupID, applicationID, model, options).then((operationRes: msRest.HttpOperationResponse) => {
        return Promise.resolve(operationRes.bodyAsJson as any);
      }).catch((err: Error) => {
        return Promise.reject(err);
      });
    } else {
      msRest.promiseToCallback(this.createOrUpdateApplicationGroupAssociationWithHttpOperationResponse(groupID, applicationID, model, options))((err: Error, data: msRest.HttpOperationResponse) => {
        if (err) {
          return cb(err);
        }
        let result = data.bodyAsJson as any;
        return cb(err, result, data.request, data.response);
      });
    }
  }

  /**
   * @summary Deletes a application group association;
   *
   * @param {number} groupID The group identifier.
   *
   * @param {number} applicationID The application identifier.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @param {ServiceCallback} callback - The callback.
   *
   * @returns {ServiceCallback} callback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {any} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {Response} [response] - The HTTP Response stream if an error did not occur.
   */
  deleteApplicationGroupAssociation(groupID: number, applicationID: number): Promise<any>;
  deleteApplicationGroupAssociation(groupID: number, applicationID: number, options: msRest.RequestOptionsBase): Promise<any>;
  deleteApplicationGroupAssociation(groupID: number, applicationID: number, callback: msRest.ServiceCallback<any>): void;
  deleteApplicationGroupAssociation(groupID: number, applicationID: number, options: msRest.RequestOptionsBase, callback: msRest.ServiceCallback<any>): void;
  deleteApplicationGroupAssociation(groupID: number, applicationID: number, options?: msRest.RequestOptionsBase, callback?: msRest.ServiceCallback<any>): any {
    if (!callback && typeof options === 'function') {
      callback = options;
      options = undefined;
    }
    let cb = callback as msRest.ServiceCallback<any>;
    if (!callback) {
      return this.deleteApplicationGroupAssociationWithHttpOperationResponse(groupID, applicationID, options).then((operationRes: msRest.HttpOperationResponse) => {
        return Promise.resolve(operationRes.bodyAsJson as any);
      }).catch((err: Error) => {
        return Promise.reject(err);
      });
    } else {
      msRest.promiseToCallback(this.deleteApplicationGroupAssociationWithHttpOperationResponse(groupID, applicationID, options))((err: Error, data: msRest.HttpOperationResponse) => {
        if (err) {
          return cb(err);
        }
        let result = data.bodyAsJson as any;
        return cb(err, result, data.request, data.response);
      });
    }
  }

  /**
   * @summary Inserts/Updates the group application association.
   *
   * @param {number} groupID The group identifier.
   *
   * @param {number} applicationID The application identifier.
   *
   * @param {GroupApplicationModel} model The model.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @param {ServiceCallback} callback - The callback.
   *
   * @returns {ServiceCallback} callback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {any} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {Response} [response] - The HTTP Response stream if an error did not occur.
   */
  createOrUpdateGroupApplicationAssociation(groupID: number, applicationID: number, model: Models.GroupApplicationModel): Promise<any>;
  createOrUpdateGroupApplicationAssociation(groupID: number, applicationID: number, model: Models.GroupApplicationModel, options: msRest.RequestOptionsBase): Promise<any>;
  createOrUpdateGroupApplicationAssociation(groupID: number, applicationID: number, model: Models.GroupApplicationModel, callback: msRest.ServiceCallback<any>): void;
  createOrUpdateGroupApplicationAssociation(groupID: number, applicationID: number, model: Models.GroupApplicationModel, options: msRest.RequestOptionsBase, callback: msRest.ServiceCallback<any>): void;
  createOrUpdateGroupApplicationAssociation(groupID: number, applicationID: number, model: Models.GroupApplicationModel, options?: msRest.RequestOptionsBase, callback?: msRest.ServiceCallback<any>): any {
    if (!callback && typeof options === 'function') {
      callback = options;
      options = undefined;
    }
    let cb = callback as msRest.ServiceCallback<any>;
    if (!callback) {
      return this.createOrUpdateGroupApplicationAssociationWithHttpOperationResponse(groupID, applicationID, model, options).then((operationRes: msRest.HttpOperationResponse) => {
        return Promise.resolve(operationRes.bodyAsJson as any);
      }).catch((err: Error) => {
        return Promise.reject(err);
      });
    } else {
      msRest.promiseToCallback(this.createOrUpdateGroupApplicationAssociationWithHttpOperationResponse(groupID, applicationID, model, options))((err: Error, data: msRest.HttpOperationResponse) => {
        if (err) {
          return cb(err);
        }
        let result = data.bodyAsJson as any;
        return cb(err, result, data.request, data.response);
      });
    }
  }

  /**
   * @summary Deletes a group application association;
   *
   * @param {number} groupID The group identifier.
   *
   * @param {number} applicationID The application identifier.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @param {ServiceCallback} callback - The callback.
   *
   * @returns {ServiceCallback} callback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {any} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {Response} [response] - The HTTP Response stream if an error did not occur.
   */
  deleteGroupApplicationAssociation(groupID: number, applicationID: number): Promise<any>;
  deleteGroupApplicationAssociation(groupID: number, applicationID: number, options: msRest.RequestOptionsBase): Promise<any>;
  deleteGroupApplicationAssociation(groupID: number, applicationID: number, callback: msRest.ServiceCallback<any>): void;
  deleteGroupApplicationAssociation(groupID: number, applicationID: number, options: msRest.RequestOptionsBase, callback: msRest.ServiceCallback<any>): void;
  deleteGroupApplicationAssociation(groupID: number, applicationID: number, options?: msRest.RequestOptionsBase, callback?: msRest.ServiceCallback<any>): any {
    if (!callback && typeof options === 'function') {
      callback = options;
      options = undefined;
    }
    let cb = callback as msRest.ServiceCallback<any>;
    if (!callback) {
      return this.deleteGroupApplicationAssociationWithHttpOperationResponse(groupID, applicationID, options).then((operationRes: msRest.HttpOperationResponse) => {
        return Promise.resolve(operationRes.bodyAsJson as any);
      }).catch((err: Error) => {
        return Promise.reject(err);
      });
    } else {
      msRest.promiseToCallback(this.deleteGroupApplicationAssociationWithHttpOperationResponse(groupID, applicationID, options))((err: Error, data: msRest.HttpOperationResponse) => {
        if (err) {
          return cb(err);
        }
        let result = data.bodyAsJson as any;
        return cb(err, result, data.request, data.response);
      });
    }
  }

  /**
   * @summary Gets a list of drawer user associations.
   *
   * @param {number} drawerID The drawer identifier.
   *
   * @param {SoftheonEnterpriseAPIGetDrawerUserAssociationsOptionalParams}
   * [options] Optional Parameters.
   *
   * @param {ServiceCallback} callback - The callback.
   *
   * @returns {ServiceCallback} callback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {Models.UserDrawerModel[]} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {Response} [response] - The HTTP Response stream if an error did not occur.
   */
  getDrawerUserAssociations(drawerID: number): Promise<Models.UserDrawerModel[]>;
  getDrawerUserAssociations(drawerID: number, options: Models.SoftheonEnterpriseAPIGetDrawerUserAssociationsOptionalParams): Promise<Models.UserDrawerModel[]>;
  getDrawerUserAssociations(drawerID: number, callback: msRest.ServiceCallback<Models.UserDrawerModel[]>): void;
  getDrawerUserAssociations(drawerID: number, options: Models.SoftheonEnterpriseAPIGetDrawerUserAssociationsOptionalParams, callback: msRest.ServiceCallback<Models.UserDrawerModel[]>): void;
  getDrawerUserAssociations(drawerID: number, options?: Models.SoftheonEnterpriseAPIGetDrawerUserAssociationsOptionalParams, callback?: msRest.ServiceCallback<Models.UserDrawerModel[]>): any {
    if (!callback && typeof options === 'function') {
      callback = options;
      options = undefined;
    }
    let cb = callback as msRest.ServiceCallback<Models.UserDrawerModel[]>;
    if (!callback) {
      return this.getDrawerUserAssociationsWithHttpOperationResponse(drawerID, options).then((operationRes: msRest.HttpOperationResponse) => {
        return Promise.resolve(operationRes.bodyAsJson as Models.UserDrawerModel[]);
      }).catch((err: Error) => {
        return Promise.reject(err);
      });
    } else {
      msRest.promiseToCallback(this.getDrawerUserAssociationsWithHttpOperationResponse(drawerID, options))((err: Error, data: msRest.HttpOperationResponse) => {
        if (err) {
          return cb(err);
        }
        let result = data.bodyAsJson as Models.UserDrawerModel[];
        return cb(err, result, data.request, data.response);
      });
    }
  }

  /**
   * @summary Gets a list of user drawer associations.
   *
   * @param {number} userID The user identifier.
   *
   * @param {SoftheonEnterpriseAPIGetUserDrawerAssociationsOptionalParams}
   * [options] Optional Parameters.
   *
   * @param {ServiceCallback} callback - The callback.
   *
   * @returns {ServiceCallback} callback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {Models.UserDrawerModel[]} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {Response} [response] - The HTTP Response stream if an error did not occur.
   */
  getUserDrawerAssociations(userID: number): Promise<Models.UserDrawerModel[]>;
  getUserDrawerAssociations(userID: number, options: Models.SoftheonEnterpriseAPIGetUserDrawerAssociationsOptionalParams): Promise<Models.UserDrawerModel[]>;
  getUserDrawerAssociations(userID: number, callback: msRest.ServiceCallback<Models.UserDrawerModel[]>): void;
  getUserDrawerAssociations(userID: number, options: Models.SoftheonEnterpriseAPIGetUserDrawerAssociationsOptionalParams, callback: msRest.ServiceCallback<Models.UserDrawerModel[]>): void;
  getUserDrawerAssociations(userID: number, options?: Models.SoftheonEnterpriseAPIGetUserDrawerAssociationsOptionalParams, callback?: msRest.ServiceCallback<Models.UserDrawerModel[]>): any {
    if (!callback && typeof options === 'function') {
      callback = options;
      options = undefined;
    }
    let cb = callback as msRest.ServiceCallback<Models.UserDrawerModel[]>;
    if (!callback) {
      return this.getUserDrawerAssociationsWithHttpOperationResponse(userID, options).then((operationRes: msRest.HttpOperationResponse) => {
        return Promise.resolve(operationRes.bodyAsJson as Models.UserDrawerModel[]);
      }).catch((err: Error) => {
        return Promise.reject(err);
      });
    } else {
      msRest.promiseToCallback(this.getUserDrawerAssociationsWithHttpOperationResponse(userID, options))((err: Error, data: msRest.HttpOperationResponse) => {
        if (err) {
          return cb(err);
        }
        let result = data.bodyAsJson as Models.UserDrawerModel[];
        return cb(err, result, data.request, data.response);
      });
    }
  }

  /**
   * @summary Inserts/Updates the drawer user association.
   *
   * @param {number} userID The user identifier.
   *
   * @param {number} drawerID The drawer identifier.
   *
   * @param {UserDrawerModel} model The model.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @param {ServiceCallback} callback - The callback.
   *
   * @returns {ServiceCallback} callback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {any} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {Response} [response] - The HTTP Response stream if an error did not occur.
   */
  createOrUpdateDrawerUserAssociation(userID: number, drawerID: number, model: Models.UserDrawerModel): Promise<any>;
  createOrUpdateDrawerUserAssociation(userID: number, drawerID: number, model: Models.UserDrawerModel, options: msRest.RequestOptionsBase): Promise<any>;
  createOrUpdateDrawerUserAssociation(userID: number, drawerID: number, model: Models.UserDrawerModel, callback: msRest.ServiceCallback<any>): void;
  createOrUpdateDrawerUserAssociation(userID: number, drawerID: number, model: Models.UserDrawerModel, options: msRest.RequestOptionsBase, callback: msRest.ServiceCallback<any>): void;
  createOrUpdateDrawerUserAssociation(userID: number, drawerID: number, model: Models.UserDrawerModel, options?: msRest.RequestOptionsBase, callback?: msRest.ServiceCallback<any>): any {
    if (!callback && typeof options === 'function') {
      callback = options;
      options = undefined;
    }
    let cb = callback as msRest.ServiceCallback<any>;
    if (!callback) {
      return this.createOrUpdateDrawerUserAssociationWithHttpOperationResponse(userID, drawerID, model, options).then((operationRes: msRest.HttpOperationResponse) => {
        return Promise.resolve(operationRes.bodyAsJson as any);
      }).catch((err: Error) => {
        return Promise.reject(err);
      });
    } else {
      msRest.promiseToCallback(this.createOrUpdateDrawerUserAssociationWithHttpOperationResponse(userID, drawerID, model, options))((err: Error, data: msRest.HttpOperationResponse) => {
        if (err) {
          return cb(err);
        }
        let result = data.bodyAsJson as any;
        return cb(err, result, data.request, data.response);
      });
    }
  }

  /**
   * @summary Deletes a drawer user association;
   *
   * @param {number} userID The user identifier.
   *
   * @param {number} drawerID The drawer identifier.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @param {ServiceCallback} callback - The callback.
   *
   * @returns {ServiceCallback} callback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {any} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {Response} [response] - The HTTP Response stream if an error did not occur.
   */
  deleteDrawerUserAssociation(userID: number, drawerID: number): Promise<any>;
  deleteDrawerUserAssociation(userID: number, drawerID: number, options: msRest.RequestOptionsBase): Promise<any>;
  deleteDrawerUserAssociation(userID: number, drawerID: number, callback: msRest.ServiceCallback<any>): void;
  deleteDrawerUserAssociation(userID: number, drawerID: number, options: msRest.RequestOptionsBase, callback: msRest.ServiceCallback<any>): void;
  deleteDrawerUserAssociation(userID: number, drawerID: number, options?: msRest.RequestOptionsBase, callback?: msRest.ServiceCallback<any>): any {
    if (!callback && typeof options === 'function') {
      callback = options;
      options = undefined;
    }
    let cb = callback as msRest.ServiceCallback<any>;
    if (!callback) {
      return this.deleteDrawerUserAssociationWithHttpOperationResponse(userID, drawerID, options).then((operationRes: msRest.HttpOperationResponse) => {
        return Promise.resolve(operationRes.bodyAsJson as any);
      }).catch((err: Error) => {
        return Promise.reject(err);
      });
    } else {
      msRest.promiseToCallback(this.deleteDrawerUserAssociationWithHttpOperationResponse(userID, drawerID, options))((err: Error, data: msRest.HttpOperationResponse) => {
        if (err) {
          return cb(err);
        }
        let result = data.bodyAsJson as any;
        return cb(err, result, data.request, data.response);
      });
    }
  }

  /**
   * @summary Inserts/Updates the user drawer association.
   *
   * @param {number} userID The user identifier.
   *
   * @param {number} drawerID The drawer identifier.
   *
   * @param {UserDrawerModel} model The model.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @param {ServiceCallback} callback - The callback.
   *
   * @returns {ServiceCallback} callback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {any} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {Response} [response] - The HTTP Response stream if an error did not occur.
   */
  createOrUpdateUserDrawerAssociation(userID: number, drawerID: number, model: Models.UserDrawerModel): Promise<any>;
  createOrUpdateUserDrawerAssociation(userID: number, drawerID: number, model: Models.UserDrawerModel, options: msRest.RequestOptionsBase): Promise<any>;
  createOrUpdateUserDrawerAssociation(userID: number, drawerID: number, model: Models.UserDrawerModel, callback: msRest.ServiceCallback<any>): void;
  createOrUpdateUserDrawerAssociation(userID: number, drawerID: number, model: Models.UserDrawerModel, options: msRest.RequestOptionsBase, callback: msRest.ServiceCallback<any>): void;
  createOrUpdateUserDrawerAssociation(userID: number, drawerID: number, model: Models.UserDrawerModel, options?: msRest.RequestOptionsBase, callback?: msRest.ServiceCallback<any>): any {
    if (!callback && typeof options === 'function') {
      callback = options;
      options = undefined;
    }
    let cb = callback as msRest.ServiceCallback<any>;
    if (!callback) {
      return this.createOrUpdateUserDrawerAssociationWithHttpOperationResponse(userID, drawerID, model, options).then((operationRes: msRest.HttpOperationResponse) => {
        return Promise.resolve(operationRes.bodyAsJson as any);
      }).catch((err: Error) => {
        return Promise.reject(err);
      });
    } else {
      msRest.promiseToCallback(this.createOrUpdateUserDrawerAssociationWithHttpOperationResponse(userID, drawerID, model, options))((err: Error, data: msRest.HttpOperationResponse) => {
        if (err) {
          return cb(err);
        }
        let result = data.bodyAsJson as any;
        return cb(err, result, data.request, data.response);
      });
    }
  }

  /**
   * @summary Deletes a user drawer association;
   *
   * @param {number} userID The user identifier.
   *
   * @param {number} drawerID The drawer identifier.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @param {ServiceCallback} callback - The callback.
   *
   * @returns {ServiceCallback} callback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {any} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {Response} [response] - The HTTP Response stream if an error did not occur.
   */
  deleteUserDrawerAssociation(userID: number, drawerID: number): Promise<any>;
  deleteUserDrawerAssociation(userID: number, drawerID: number, options: msRest.RequestOptionsBase): Promise<any>;
  deleteUserDrawerAssociation(userID: number, drawerID: number, callback: msRest.ServiceCallback<any>): void;
  deleteUserDrawerAssociation(userID: number, drawerID: number, options: msRest.RequestOptionsBase, callback: msRest.ServiceCallback<any>): void;
  deleteUserDrawerAssociation(userID: number, drawerID: number, options?: msRest.RequestOptionsBase, callback?: msRest.ServiceCallback<any>): any {
    if (!callback && typeof options === 'function') {
      callback = options;
      options = undefined;
    }
    let cb = callback as msRest.ServiceCallback<any>;
    if (!callback) {
      return this.deleteUserDrawerAssociationWithHttpOperationResponse(userID, drawerID, options).then((operationRes: msRest.HttpOperationResponse) => {
        return Promise.resolve(operationRes.bodyAsJson as any);
      }).catch((err: Error) => {
        return Promise.reject(err);
      });
    } else {
      msRest.promiseToCallback(this.deleteUserDrawerAssociationWithHttpOperationResponse(userID, drawerID, options))((err: Error, data: msRest.HttpOperationResponse) => {
        if (err) {
          return cb(err);
        }
        let result = data.bodyAsJson as any;
        return cb(err, result, data.request, data.response);
      });
    }
  }

  /**
   * @summary Gets a list of queue user associations.
   *
   * @param {number} queueID The queue identifier.
   *
   * @param {SoftheonEnterpriseAPIGetQueueUserAssociationsOptionalParams}
   * [options] Optional Parameters.
   *
   * @param {ServiceCallback} callback - The callback.
   *
   * @returns {ServiceCallback} callback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {Models.UserQueueModel[]} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {Response} [response] - The HTTP Response stream if an error did not occur.
   */
  getQueueUserAssociations(queueID: number): Promise<Models.UserQueueModel[]>;
  getQueueUserAssociations(queueID: number, options: Models.SoftheonEnterpriseAPIGetQueueUserAssociationsOptionalParams): Promise<Models.UserQueueModel[]>;
  getQueueUserAssociations(queueID: number, callback: msRest.ServiceCallback<Models.UserQueueModel[]>): void;
  getQueueUserAssociations(queueID: number, options: Models.SoftheonEnterpriseAPIGetQueueUserAssociationsOptionalParams, callback: msRest.ServiceCallback<Models.UserQueueModel[]>): void;
  getQueueUserAssociations(queueID: number, options?: Models.SoftheonEnterpriseAPIGetQueueUserAssociationsOptionalParams, callback?: msRest.ServiceCallback<Models.UserQueueModel[]>): any {
    if (!callback && typeof options === 'function') {
      callback = options;
      options = undefined;
    }
    let cb = callback as msRest.ServiceCallback<Models.UserQueueModel[]>;
    if (!callback) {
      return this.getQueueUserAssociationsWithHttpOperationResponse(queueID, options).then((operationRes: msRest.HttpOperationResponse) => {
        return Promise.resolve(operationRes.bodyAsJson as Models.UserQueueModel[]);
      }).catch((err: Error) => {
        return Promise.reject(err);
      });
    } else {
      msRest.promiseToCallback(this.getQueueUserAssociationsWithHttpOperationResponse(queueID, options))((err: Error, data: msRest.HttpOperationResponse) => {
        if (err) {
          return cb(err);
        }
        let result = data.bodyAsJson as Models.UserQueueModel[];
        return cb(err, result, data.request, data.response);
      });
    }
  }

  /**
   * @summary Gets a list of user queue associations.
   *
   * @param {number} userID The user identifier.
   *
   * @param {SoftheonEnterpriseAPIGetUserQueueAssociationsOptionalParams}
   * [options] Optional Parameters.
   *
   * @param {ServiceCallback} callback - The callback.
   *
   * @returns {ServiceCallback} callback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {Models.UserQueueModel[]} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {Response} [response] - The HTTP Response stream if an error did not occur.
   */
  getUserQueueAssociations(userID: number): Promise<Models.UserQueueModel[]>;
  getUserQueueAssociations(userID: number, options: Models.SoftheonEnterpriseAPIGetUserQueueAssociationsOptionalParams): Promise<Models.UserQueueModel[]>;
  getUserQueueAssociations(userID: number, callback: msRest.ServiceCallback<Models.UserQueueModel[]>): void;
  getUserQueueAssociations(userID: number, options: Models.SoftheonEnterpriseAPIGetUserQueueAssociationsOptionalParams, callback: msRest.ServiceCallback<Models.UserQueueModel[]>): void;
  getUserQueueAssociations(userID: number, options?: Models.SoftheonEnterpriseAPIGetUserQueueAssociationsOptionalParams, callback?: msRest.ServiceCallback<Models.UserQueueModel[]>): any {
    if (!callback && typeof options === 'function') {
      callback = options;
      options = undefined;
    }
    let cb = callback as msRest.ServiceCallback<Models.UserQueueModel[]>;
    if (!callback) {
      return this.getUserQueueAssociationsWithHttpOperationResponse(userID, options).then((operationRes: msRest.HttpOperationResponse) => {
        return Promise.resolve(operationRes.bodyAsJson as Models.UserQueueModel[]);
      }).catch((err: Error) => {
        return Promise.reject(err);
      });
    } else {
      msRest.promiseToCallback(this.getUserQueueAssociationsWithHttpOperationResponse(userID, options))((err: Error, data: msRest.HttpOperationResponse) => {
        if (err) {
          return cb(err);
        }
        let result = data.bodyAsJson as Models.UserQueueModel[];
        return cb(err, result, data.request, data.response);
      });
    }
  }

  /**
   * @summary Inserts/Updates the queue user association.
   *
   * @param {number} userID The user identifier.
   *
   * @param {number} queueID The queue identifier.
   *
   * @param {UserQueueModel} model The model.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @param {ServiceCallback} callback - The callback.
   *
   * @returns {ServiceCallback} callback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {any} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {Response} [response] - The HTTP Response stream if an error did not occur.
   */
  createOrUpdateQueueUserAssociation(userID: number, queueID: number, model: Models.UserQueueModel): Promise<any>;
  createOrUpdateQueueUserAssociation(userID: number, queueID: number, model: Models.UserQueueModel, options: msRest.RequestOptionsBase): Promise<any>;
  createOrUpdateQueueUserAssociation(userID: number, queueID: number, model: Models.UserQueueModel, callback: msRest.ServiceCallback<any>): void;
  createOrUpdateQueueUserAssociation(userID: number, queueID: number, model: Models.UserQueueModel, options: msRest.RequestOptionsBase, callback: msRest.ServiceCallback<any>): void;
  createOrUpdateQueueUserAssociation(userID: number, queueID: number, model: Models.UserQueueModel, options?: msRest.RequestOptionsBase, callback?: msRest.ServiceCallback<any>): any {
    if (!callback && typeof options === 'function') {
      callback = options;
      options = undefined;
    }
    let cb = callback as msRest.ServiceCallback<any>;
    if (!callback) {
      return this.createOrUpdateQueueUserAssociationWithHttpOperationResponse(userID, queueID, model, options).then((operationRes: msRest.HttpOperationResponse) => {
        return Promise.resolve(operationRes.bodyAsJson as any);
      }).catch((err: Error) => {
        return Promise.reject(err);
      });
    } else {
      msRest.promiseToCallback(this.createOrUpdateQueueUserAssociationWithHttpOperationResponse(userID, queueID, model, options))((err: Error, data: msRest.HttpOperationResponse) => {
        if (err) {
          return cb(err);
        }
        let result = data.bodyAsJson as any;
        return cb(err, result, data.request, data.response);
      });
    }
  }

  /**
   * @summary Deletes a queue user association;
   *
   * @param {number} userID The user identifier.
   *
   * @param {number} queueID The queue identifier.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @param {ServiceCallback} callback - The callback.
   *
   * @returns {ServiceCallback} callback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {any} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {Response} [response] - The HTTP Response stream if an error did not occur.
   */
  deleteQueueUserAssociation(userID: number, queueID: number): Promise<any>;
  deleteQueueUserAssociation(userID: number, queueID: number, options: msRest.RequestOptionsBase): Promise<any>;
  deleteQueueUserAssociation(userID: number, queueID: number, callback: msRest.ServiceCallback<any>): void;
  deleteQueueUserAssociation(userID: number, queueID: number, options: msRest.RequestOptionsBase, callback: msRest.ServiceCallback<any>): void;
  deleteQueueUserAssociation(userID: number, queueID: number, options?: msRest.RequestOptionsBase, callback?: msRest.ServiceCallback<any>): any {
    if (!callback && typeof options === 'function') {
      callback = options;
      options = undefined;
    }
    let cb = callback as msRest.ServiceCallback<any>;
    if (!callback) {
      return this.deleteQueueUserAssociationWithHttpOperationResponse(userID, queueID, options).then((operationRes: msRest.HttpOperationResponse) => {
        return Promise.resolve(operationRes.bodyAsJson as any);
      }).catch((err: Error) => {
        return Promise.reject(err);
      });
    } else {
      msRest.promiseToCallback(this.deleteQueueUserAssociationWithHttpOperationResponse(userID, queueID, options))((err: Error, data: msRest.HttpOperationResponse) => {
        if (err) {
          return cb(err);
        }
        let result = data.bodyAsJson as any;
        return cb(err, result, data.request, data.response);
      });
    }
  }

  /**
   * @summary Inserts/Updates the user queue association.
   *
   * @param {number} userID The user identifier.
   *
   * @param {number} queueID The queue identifier.
   *
   * @param {UserQueueModel} model The model.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @param {ServiceCallback} callback - The callback.
   *
   * @returns {ServiceCallback} callback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {any} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {Response} [response] - The HTTP Response stream if an error did not occur.
   */
  createOrUpdateUserQueueAssociation(userID: number, queueID: number, model: Models.UserQueueModel): Promise<any>;
  createOrUpdateUserQueueAssociation(userID: number, queueID: number, model: Models.UserQueueModel, options: msRest.RequestOptionsBase): Promise<any>;
  createOrUpdateUserQueueAssociation(userID: number, queueID: number, model: Models.UserQueueModel, callback: msRest.ServiceCallback<any>): void;
  createOrUpdateUserQueueAssociation(userID: number, queueID: number, model: Models.UserQueueModel, options: msRest.RequestOptionsBase, callback: msRest.ServiceCallback<any>): void;
  createOrUpdateUserQueueAssociation(userID: number, queueID: number, model: Models.UserQueueModel, options?: msRest.RequestOptionsBase, callback?: msRest.ServiceCallback<any>): any {
    if (!callback && typeof options === 'function') {
      callback = options;
      options = undefined;
    }
    let cb = callback as msRest.ServiceCallback<any>;
    if (!callback) {
      return this.createOrUpdateUserQueueAssociationWithHttpOperationResponse(userID, queueID, model, options).then((operationRes: msRest.HttpOperationResponse) => {
        return Promise.resolve(operationRes.bodyAsJson as any);
      }).catch((err: Error) => {
        return Promise.reject(err);
      });
    } else {
      msRest.promiseToCallback(this.createOrUpdateUserQueueAssociationWithHttpOperationResponse(userID, queueID, model, options))((err: Error, data: msRest.HttpOperationResponse) => {
        if (err) {
          return cb(err);
        }
        let result = data.bodyAsJson as any;
        return cb(err, result, data.request, data.response);
      });
    }
  }

  /**
   * @summary Deletes a user queue association;
   *
   * @param {number} userID The user identifier.
   *
   * @param {number} queueID The queue identifier.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @param {ServiceCallback} callback - The callback.
   *
   * @returns {ServiceCallback} callback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {any} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {Response} [response] - The HTTP Response stream if an error did not occur.
   */
  deleteUserQueueAssociation(userID: number, queueID: number): Promise<any>;
  deleteUserQueueAssociation(userID: number, queueID: number, options: msRest.RequestOptionsBase): Promise<any>;
  deleteUserQueueAssociation(userID: number, queueID: number, callback: msRest.ServiceCallback<any>): void;
  deleteUserQueueAssociation(userID: number, queueID: number, options: msRest.RequestOptionsBase, callback: msRest.ServiceCallback<any>): void;
  deleteUserQueueAssociation(userID: number, queueID: number, options?: msRest.RequestOptionsBase, callback?: msRest.ServiceCallback<any>): any {
    if (!callback && typeof options === 'function') {
      callback = options;
      options = undefined;
    }
    let cb = callback as msRest.ServiceCallback<any>;
    if (!callback) {
      return this.deleteUserQueueAssociationWithHttpOperationResponse(userID, queueID, options).then((operationRes: msRest.HttpOperationResponse) => {
        return Promise.resolve(operationRes.bodyAsJson as any);
      }).catch((err: Error) => {
        return Promise.reject(err);
      });
    } else {
      msRest.promiseToCallback(this.deleteUserQueueAssociationWithHttpOperationResponse(userID, queueID, options))((err: Error, data: msRest.HttpOperationResponse) => {
        if (err) {
          return cb(err);
        }
        let result = data.bodyAsJson as any;
        return cb(err, result, data.request, data.response);
      });
    }
  }

  /**
   * @summary Gets a list of application user associations.
   *
   * @param {number} applicationID The application identifier.
   *
   * @param {SoftheonEnterpriseAPIGetApplicationUserAssociationsOptionalParams}
   * [options] Optional Parameters.
   *
   * @param {ServiceCallback} callback - The callback.
   *
   * @returns {ServiceCallback} callback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {Models.UserApplicationModel[]} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {Response} [response] - The HTTP Response stream if an error did not occur.
   */
  getApplicationUserAssociations(applicationID: number): Promise<Models.UserApplicationModel[]>;
  getApplicationUserAssociations(applicationID: number, options: Models.SoftheonEnterpriseAPIGetApplicationUserAssociationsOptionalParams): Promise<Models.UserApplicationModel[]>;
  getApplicationUserAssociations(applicationID: number, callback: msRest.ServiceCallback<Models.UserApplicationModel[]>): void;
  getApplicationUserAssociations(applicationID: number, options: Models.SoftheonEnterpriseAPIGetApplicationUserAssociationsOptionalParams, callback: msRest.ServiceCallback<Models.UserApplicationModel[]>): void;
  getApplicationUserAssociations(applicationID: number, options?: Models.SoftheonEnterpriseAPIGetApplicationUserAssociationsOptionalParams, callback?: msRest.ServiceCallback<Models.UserApplicationModel[]>): any {
    if (!callback && typeof options === 'function') {
      callback = options;
      options = undefined;
    }
    let cb = callback as msRest.ServiceCallback<Models.UserApplicationModel[]>;
    if (!callback) {
      return this.getApplicationUserAssociationsWithHttpOperationResponse(applicationID, options).then((operationRes: msRest.HttpOperationResponse) => {
        return Promise.resolve(operationRes.bodyAsJson as Models.UserApplicationModel[]);
      }).catch((err: Error) => {
        return Promise.reject(err);
      });
    } else {
      msRest.promiseToCallback(this.getApplicationUserAssociationsWithHttpOperationResponse(applicationID, options))((err: Error, data: msRest.HttpOperationResponse) => {
        if (err) {
          return cb(err);
        }
        let result = data.bodyAsJson as Models.UserApplicationModel[];
        return cb(err, result, data.request, data.response);
      });
    }
  }

  /**
   * @summary Gets a list of user application associations.
   *
   * @param {number} userID The user identifier.
   *
   * @param {SoftheonEnterpriseAPIGetUserApplicationAssociationsOptionalParams}
   * [options] Optional Parameters.
   *
   * @param {ServiceCallback} callback - The callback.
   *
   * @returns {ServiceCallback} callback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {Models.UserApplicationModel[]} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {Response} [response] - The HTTP Response stream if an error did not occur.
   */
  getUserApplicationAssociations(userID: number): Promise<Models.UserApplicationModel[]>;
  getUserApplicationAssociations(userID: number, options: Models.SoftheonEnterpriseAPIGetUserApplicationAssociationsOptionalParams): Promise<Models.UserApplicationModel[]>;
  getUserApplicationAssociations(userID: number, callback: msRest.ServiceCallback<Models.UserApplicationModel[]>): void;
  getUserApplicationAssociations(userID: number, options: Models.SoftheonEnterpriseAPIGetUserApplicationAssociationsOptionalParams, callback: msRest.ServiceCallback<Models.UserApplicationModel[]>): void;
  getUserApplicationAssociations(userID: number, options?: Models.SoftheonEnterpriseAPIGetUserApplicationAssociationsOptionalParams, callback?: msRest.ServiceCallback<Models.UserApplicationModel[]>): any {
    if (!callback && typeof options === 'function') {
      callback = options;
      options = undefined;
    }
    let cb = callback as msRest.ServiceCallback<Models.UserApplicationModel[]>;
    if (!callback) {
      return this.getUserApplicationAssociationsWithHttpOperationResponse(userID, options).then((operationRes: msRest.HttpOperationResponse) => {
        return Promise.resolve(operationRes.bodyAsJson as Models.UserApplicationModel[]);
      }).catch((err: Error) => {
        return Promise.reject(err);
      });
    } else {
      msRest.promiseToCallback(this.getUserApplicationAssociationsWithHttpOperationResponse(userID, options))((err: Error, data: msRest.HttpOperationResponse) => {
        if (err) {
          return cb(err);
        }
        let result = data.bodyAsJson as Models.UserApplicationModel[];
        return cb(err, result, data.request, data.response);
      });
    }
  }

  /**
   * @summary Inserts/Updates the application user association.
   *
   * @param {number} userID The user identifier.
   *
   * @param {number} applicationID The application identifier.
   *
   * @param {UserApplicationModel} model The model.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @param {ServiceCallback} callback - The callback.
   *
   * @returns {ServiceCallback} callback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {any} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {Response} [response] - The HTTP Response stream if an error did not occur.
   */
  createOrUpdateApplicationUserAssociation(userID: number, applicationID: number, model: Models.UserApplicationModel): Promise<any>;
  createOrUpdateApplicationUserAssociation(userID: number, applicationID: number, model: Models.UserApplicationModel, options: msRest.RequestOptionsBase): Promise<any>;
  createOrUpdateApplicationUserAssociation(userID: number, applicationID: number, model: Models.UserApplicationModel, callback: msRest.ServiceCallback<any>): void;
  createOrUpdateApplicationUserAssociation(userID: number, applicationID: number, model: Models.UserApplicationModel, options: msRest.RequestOptionsBase, callback: msRest.ServiceCallback<any>): void;
  createOrUpdateApplicationUserAssociation(userID: number, applicationID: number, model: Models.UserApplicationModel, options?: msRest.RequestOptionsBase, callback?: msRest.ServiceCallback<any>): any {
    if (!callback && typeof options === 'function') {
      callback = options;
      options = undefined;
    }
    let cb = callback as msRest.ServiceCallback<any>;
    if (!callback) {
      return this.createOrUpdateApplicationUserAssociationWithHttpOperationResponse(userID, applicationID, model, options).then((operationRes: msRest.HttpOperationResponse) => {
        return Promise.resolve(operationRes.bodyAsJson as any);
      }).catch((err: Error) => {
        return Promise.reject(err);
      });
    } else {
      msRest.promiseToCallback(this.createOrUpdateApplicationUserAssociationWithHttpOperationResponse(userID, applicationID, model, options))((err: Error, data: msRest.HttpOperationResponse) => {
        if (err) {
          return cb(err);
        }
        let result = data.bodyAsJson as any;
        return cb(err, result, data.request, data.response);
      });
    }
  }

  /**
   * @summary Deletes an application user association;
   *
   * @param {number} userID The user identifier.
   *
   * @param {number} applicationID The application identifier.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @param {ServiceCallback} callback - The callback.
   *
   * @returns {ServiceCallback} callback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {any} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {Response} [response] - The HTTP Response stream if an error did not occur.
   */
  deleteApplicationUserAssociation(userID: number, applicationID: number): Promise<any>;
  deleteApplicationUserAssociation(userID: number, applicationID: number, options: msRest.RequestOptionsBase): Promise<any>;
  deleteApplicationUserAssociation(userID: number, applicationID: number, callback: msRest.ServiceCallback<any>): void;
  deleteApplicationUserAssociation(userID: number, applicationID: number, options: msRest.RequestOptionsBase, callback: msRest.ServiceCallback<any>): void;
  deleteApplicationUserAssociation(userID: number, applicationID: number, options?: msRest.RequestOptionsBase, callback?: msRest.ServiceCallback<any>): any {
    if (!callback && typeof options === 'function') {
      callback = options;
      options = undefined;
    }
    let cb = callback as msRest.ServiceCallback<any>;
    if (!callback) {
      return this.deleteApplicationUserAssociationWithHttpOperationResponse(userID, applicationID, options).then((operationRes: msRest.HttpOperationResponse) => {
        return Promise.resolve(operationRes.bodyAsJson as any);
      }).catch((err: Error) => {
        return Promise.reject(err);
      });
    } else {
      msRest.promiseToCallback(this.deleteApplicationUserAssociationWithHttpOperationResponse(userID, applicationID, options))((err: Error, data: msRest.HttpOperationResponse) => {
        if (err) {
          return cb(err);
        }
        let result = data.bodyAsJson as any;
        return cb(err, result, data.request, data.response);
      });
    }
  }

  /**
   * @summary Inserts/Updates the user application association.
   *
   * @param {number} userID The user identifier.
   *
   * @param {number} applicationID The application identifier.
   *
   * @param {UserApplicationModel} model The model.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @param {ServiceCallback} callback - The callback.
   *
   * @returns {ServiceCallback} callback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {any} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {Response} [response] - The HTTP Response stream if an error did not occur.
   */
  createOrUpdateUserApplicationAssociation(userID: number, applicationID: number, model: Models.UserApplicationModel): Promise<any>;
  createOrUpdateUserApplicationAssociation(userID: number, applicationID: number, model: Models.UserApplicationModel, options: msRest.RequestOptionsBase): Promise<any>;
  createOrUpdateUserApplicationAssociation(userID: number, applicationID: number, model: Models.UserApplicationModel, callback: msRest.ServiceCallback<any>): void;
  createOrUpdateUserApplicationAssociation(userID: number, applicationID: number, model: Models.UserApplicationModel, options: msRest.RequestOptionsBase, callback: msRest.ServiceCallback<any>): void;
  createOrUpdateUserApplicationAssociation(userID: number, applicationID: number, model: Models.UserApplicationModel, options?: msRest.RequestOptionsBase, callback?: msRest.ServiceCallback<any>): any {
    if (!callback && typeof options === 'function') {
      callback = options;
      options = undefined;
    }
    let cb = callback as msRest.ServiceCallback<any>;
    if (!callback) {
      return this.createOrUpdateUserApplicationAssociationWithHttpOperationResponse(userID, applicationID, model, options).then((operationRes: msRest.HttpOperationResponse) => {
        return Promise.resolve(operationRes.bodyAsJson as any);
      }).catch((err: Error) => {
        return Promise.reject(err);
      });
    } else {
      msRest.promiseToCallback(this.createOrUpdateUserApplicationAssociationWithHttpOperationResponse(userID, applicationID, model, options))((err: Error, data: msRest.HttpOperationResponse) => {
        if (err) {
          return cb(err);
        }
        let result = data.bodyAsJson as any;
        return cb(err, result, data.request, data.response);
      });
    }
  }

  /**
   * @summary Deletes a user application association;
   *
   * @param {number} userID The user identifier.
   *
   * @param {number} applicationID The application identifier.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @param {ServiceCallback} callback - The callback.
   *
   * @returns {ServiceCallback} callback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {any} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {Response} [response] - The HTTP Response stream if an error did not occur.
   */
  deleteUserApplicationAssociation(userID: number, applicationID: number): Promise<any>;
  deleteUserApplicationAssociation(userID: number, applicationID: number, options: msRest.RequestOptionsBase): Promise<any>;
  deleteUserApplicationAssociation(userID: number, applicationID: number, callback: msRest.ServiceCallback<any>): void;
  deleteUserApplicationAssociation(userID: number, applicationID: number, options: msRest.RequestOptionsBase, callback: msRest.ServiceCallback<any>): void;
  deleteUserApplicationAssociation(userID: number, applicationID: number, options?: msRest.RequestOptionsBase, callback?: msRest.ServiceCallback<any>): any {
    if (!callback && typeof options === 'function') {
      callback = options;
      options = undefined;
    }
    let cb = callback as msRest.ServiceCallback<any>;
    if (!callback) {
      return this.deleteUserApplicationAssociationWithHttpOperationResponse(userID, applicationID, options).then((operationRes: msRest.HttpOperationResponse) => {
        return Promise.resolve(operationRes.bodyAsJson as any);
      }).catch((err: Error) => {
        return Promise.reject(err);
      });
    } else {
      msRest.promiseToCallback(this.deleteUserApplicationAssociationWithHttpOperationResponse(userID, applicationID, options))((err: Error, data: msRest.HttpOperationResponse) => {
        if (err) {
          return cb(err);
        }
        let result = data.bodyAsJson as any;
        return cb(err, result, data.request, data.response);
      });
    }
  }

  /**
   * @summary Gets a paged list of attachment metadata.
   *
   * @param {SoftheonEnterpriseAPIGetAttachmentsByFilterOptionalParams} [options]
   * Optional Parameters.
   *
   * @param {ServiceCallback} callback - The callback.
   *
   * @returns {ServiceCallback} callback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {Models.AttachmentModel[]} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {Response} [response] - The HTTP Response stream if an error did not occur.
   */
  getAttachmentsByFilter(): Promise<Models.AttachmentModel[]>;
  getAttachmentsByFilter(options: Models.SoftheonEnterpriseAPIGetAttachmentsByFilterOptionalParams): Promise<Models.AttachmentModel[]>;
  getAttachmentsByFilter(callback: msRest.ServiceCallback<Models.AttachmentModel[]>): void;
  getAttachmentsByFilter(options: Models.SoftheonEnterpriseAPIGetAttachmentsByFilterOptionalParams, callback: msRest.ServiceCallback<Models.AttachmentModel[]>): void;
  getAttachmentsByFilter(options?: Models.SoftheonEnterpriseAPIGetAttachmentsByFilterOptionalParams, callback?: msRest.ServiceCallback<Models.AttachmentModel[]>): any {
    if (!callback && typeof options === 'function') {
      callback = options;
      options = undefined;
    }
    let cb = callback as msRest.ServiceCallback<Models.AttachmentModel[]>;
    if (!callback) {
      return this.getAttachmentsByFilterWithHttpOperationResponse(options).then((operationRes: msRest.HttpOperationResponse) => {
        return Promise.resolve(operationRes.bodyAsJson as Models.AttachmentModel[]);
      }).catch((err: Error) => {
        return Promise.reject(err);
      });
    } else {
      msRest.promiseToCallback(this.getAttachmentsByFilterWithHttpOperationResponse(options))((err: Error, data: msRest.HttpOperationResponse) => {
        if (err) {
          return cb(err);
        }
        let result = data.bodyAsJson as Models.AttachmentModel[];
        return cb(err, result, data.request, data.response);
      });
    }
  }

  /**
   * @summary Gets a single attachment metadata based on its unique identifier.
   *
   * @param {number} drawer The drawer identifier.
   *
   * @param {number} id The attachment identifier.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @param {ServiceCallback} callback - The callback.
   *
   * @returns {ServiceCallback} callback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {Models.AttachmentModel} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link Models.AttachmentModel} for more
   *                      information.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {Response} [response] - The HTTP Response stream if an error did not occur.
   */
  getAttachmentById(drawer: number, id: number): Promise<Models.AttachmentModel>;
  getAttachmentById(drawer: number, id: number, options: msRest.RequestOptionsBase): Promise<Models.AttachmentModel>;
  getAttachmentById(drawer: number, id: number, callback: msRest.ServiceCallback<Models.AttachmentModel>): void;
  getAttachmentById(drawer: number, id: number, options: msRest.RequestOptionsBase, callback: msRest.ServiceCallback<Models.AttachmentModel>): void;
  getAttachmentById(drawer: number, id: number, options?: msRest.RequestOptionsBase, callback?: msRest.ServiceCallback<Models.AttachmentModel>): any {
    if (!callback && typeof options === 'function') {
      callback = options;
      options = undefined;
    }
    let cb = callback as msRest.ServiceCallback<Models.AttachmentModel>;
    if (!callback) {
      return this.getAttachmentByIdWithHttpOperationResponse(drawer, id, options).then((operationRes: msRest.HttpOperationResponse) => {
        return Promise.resolve(operationRes.bodyAsJson as Models.AttachmentModel);
      }).catch((err: Error) => {
        return Promise.reject(err);
      });
    } else {
      msRest.promiseToCallback(this.getAttachmentByIdWithHttpOperationResponse(drawer, id, options))((err: Error, data: msRest.HttpOperationResponse) => {
        if (err) {
          return cb(err);
        }
        let result = data.bodyAsJson as Models.AttachmentModel;
        return cb(err, result, data.request, data.response);
      });
    }
  }

  /**
   * @summary Updates a specified attachment's metadata..
   *
   * @param {number} drawer The drawer identifier.
   *
   * @param {number} id The attachment identifier.
   *
   * @param {UpdateAttachmentRequestModel} model The model.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @param {ServiceCallback} callback - The callback.
   *
   * @returns {ServiceCallback} callback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {any} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {Response} [response] - The HTTP Response stream if an error did not occur.
   */
  updateAttachment(drawer: number, id: number, model: Models.UpdateAttachmentRequestModel): Promise<any>;
  updateAttachment(drawer: number, id: number, model: Models.UpdateAttachmentRequestModel, options: msRest.RequestOptionsBase): Promise<any>;
  updateAttachment(drawer: number, id: number, model: Models.UpdateAttachmentRequestModel, callback: msRest.ServiceCallback<any>): void;
  updateAttachment(drawer: number, id: number, model: Models.UpdateAttachmentRequestModel, options: msRest.RequestOptionsBase, callback: msRest.ServiceCallback<any>): void;
  updateAttachment(drawer: number, id: number, model: Models.UpdateAttachmentRequestModel, options?: msRest.RequestOptionsBase, callback?: msRest.ServiceCallback<any>): any {
    if (!callback && typeof options === 'function') {
      callback = options;
      options = undefined;
    }
    let cb = callback as msRest.ServiceCallback<any>;
    if (!callback) {
      return this.updateAttachmentWithHttpOperationResponse(drawer, id, model, options).then((operationRes: msRest.HttpOperationResponse) => {
        return Promise.resolve(operationRes.bodyAsJson as any);
      }).catch((err: Error) => {
        return Promise.reject(err);
      });
    } else {
      msRest.promiseToCallback(this.updateAttachmentWithHttpOperationResponse(drawer, id, model, options))((err: Error, data: msRest.HttpOperationResponse) => {
        if (err) {
          return cb(err);
        }
        let result = data.bodyAsJson as any;
        return cb(err, result, data.request, data.response);
      });
    }
  }

  /**
   * @summary Deletes an attachment
   *
   * @param {number} drawer The drawer identifier.
   *
   * @param {number} id The attachment identifier.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @param {ServiceCallback} callback - The callback.
   *
   * @returns {ServiceCallback} callback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {any} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {Response} [response] - The HTTP Response stream if an error did not occur.
   */
  deleteAttachment(drawer: number, id: number): Promise<any>;
  deleteAttachment(drawer: number, id: number, options: msRest.RequestOptionsBase): Promise<any>;
  deleteAttachment(drawer: number, id: number, callback: msRest.ServiceCallback<any>): void;
  deleteAttachment(drawer: number, id: number, options: msRest.RequestOptionsBase, callback: msRest.ServiceCallback<any>): void;
  deleteAttachment(drawer: number, id: number, options?: msRest.RequestOptionsBase, callback?: msRest.ServiceCallback<any>): any {
    if (!callback && typeof options === 'function') {
      callback = options;
      options = undefined;
    }
    let cb = callback as msRest.ServiceCallback<any>;
    if (!callback) {
      return this.deleteAttachmentWithHttpOperationResponse(drawer, id, options).then((operationRes: msRest.HttpOperationResponse) => {
        return Promise.resolve(operationRes.bodyAsJson as any);
      }).catch((err: Error) => {
        return Promise.reject(err);
      });
    } else {
      msRest.promiseToCallback(this.deleteAttachmentWithHttpOperationResponse(drawer, id, options))((err: Error, data: msRest.HttpOperationResponse) => {
        if (err) {
          return cb(err);
        }
        let result = data.bodyAsJson as any;
        return cb(err, result, data.request, data.response);
      });
    }
  }

  /**
   * @summary Gets an attachment's file content.
   *
   * @param {number} drawer The drawer identifier.
   *
   * @param {number} id The attachment identifier.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @param {ServiceCallback} callback - The callback.
   *
   * @returns {ServiceCallback} callback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {any} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {Response} [response] - The HTTP Response stream if an error did not occur.
   */
  getAttachmentFileContent(drawer: number, id: number): Promise<any>;
  getAttachmentFileContent(drawer: number, id: number, options: msRest.RequestOptionsBase): Promise<any>;
  getAttachmentFileContent(drawer: number, id: number, callback: msRest.ServiceCallback<any>): void;
  getAttachmentFileContent(drawer: number, id: number, options: msRest.RequestOptionsBase, callback: msRest.ServiceCallback<any>): void;
  getAttachmentFileContent(drawer: number, id: number, options?: msRest.RequestOptionsBase, callback?: msRest.ServiceCallback<any>): any {
    if (!callback && typeof options === 'function') {
      callback = options;
      options = undefined;
    }
    let cb = callback as msRest.ServiceCallback<any>;
    if (!callback) {
      return this.getAttachmentFileContentWithHttpOperationResponse(drawer, id, options).then((operationRes: msRest.HttpOperationResponse) => {
        return Promise.resolve(operationRes.bodyAsJson as any);
      }).catch((err: Error) => {
        return Promise.reject(err);
      });
    } else {
      msRest.promiseToCallback(this.getAttachmentFileContentWithHttpOperationResponse(drawer, id, options))((err: Error, data: msRest.HttpOperationResponse) => {
        if (err) {
          return cb(err);
        }
        let result = data.bodyAsJson as any;
        return cb(err, result, data.request, data.response);
      });
    }
  }

  /**
   * @summary Inserts a new file attachment.
   *
   * @param {number} drawer The drawer identifier.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @param {ServiceCallback} callback - The callback.
   *
   * @returns {ServiceCallback} callback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {Models.AttachmentModel} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link Models.AttachmentModel} for more
   *                      information.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {Response} [response] - The HTTP Response stream if an error did not occur.
   */
  createAttachment(drawer: number): Promise<Models.AttachmentModel>;
  createAttachment(drawer: number, options: msRest.RequestOptionsBase): Promise<Models.AttachmentModel>;
  createAttachment(drawer: number, callback: msRest.ServiceCallback<Models.AttachmentModel>): void;
  createAttachment(drawer: number, options: msRest.RequestOptionsBase, callback: msRest.ServiceCallback<Models.AttachmentModel>): void;
  createAttachment(drawer: number, options?: msRest.RequestOptionsBase, callback?: msRest.ServiceCallback<Models.AttachmentModel>): any {
    if (!callback && typeof options === 'function') {
      callback = options;
      options = undefined;
    }
    let cb = callback as msRest.ServiceCallback<Models.AttachmentModel>;
    if (!callback) {
      return this.createAttachmentWithHttpOperationResponse(drawer, options).then((operationRes: msRest.HttpOperationResponse) => {
        return Promise.resolve(operationRes.bodyAsJson as Models.AttachmentModel);
      }).catch((err: Error) => {
        return Promise.reject(err);
      });
    } else {
      msRest.promiseToCallback(this.createAttachmentWithHttpOperationResponse(drawer, options))((err: Error, data: msRest.HttpOperationResponse) => {
        if (err) {
          return cb(err);
        }
        let result = data.bodyAsJson as Models.AttachmentModel;
        return cb(err, result, data.request, data.response);
      });
    }
  }

  /**
   * @summary Archives an attachment
   *
   * @param {number} drawer The drawer identifier.
   *
   * @param {number} id The attachment identifier.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @param {ServiceCallback} callback - The callback.
   *
   * @returns {ServiceCallback} callback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {any} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {Response} [response] - The HTTP Response stream if an error did not occur.
   */
  archiveAttachment(drawer: number, id: number): Promise<any>;
  archiveAttachment(drawer: number, id: number, options: msRest.RequestOptionsBase): Promise<any>;
  archiveAttachment(drawer: number, id: number, callback: msRest.ServiceCallback<any>): void;
  archiveAttachment(drawer: number, id: number, options: msRest.RequestOptionsBase, callback: msRest.ServiceCallback<any>): void;
  archiveAttachment(drawer: number, id: number, options?: msRest.RequestOptionsBase, callback?: msRest.ServiceCallback<any>): any {
    if (!callback && typeof options === 'function') {
      callback = options;
      options = undefined;
    }
    let cb = callback as msRest.ServiceCallback<any>;
    if (!callback) {
      return this.archiveAttachmentWithHttpOperationResponse(drawer, id, options).then((operationRes: msRest.HttpOperationResponse) => {
        return Promise.resolve(operationRes.bodyAsJson as any);
      }).catch((err: Error) => {
        return Promise.reject(err);
      });
    } else {
      msRest.promiseToCallback(this.archiveAttachmentWithHttpOperationResponse(drawer, id, options))((err: Error, data: msRest.HttpOperationResponse) => {
        if (err) {
          return cb(err);
        }
        let result = data.bodyAsJson as any;
        return cb(err, result, data.request, data.response);
      });
    }
  }

  /**
   * @summary Gets the paged list of attachment versions.
   *
   * @param {number} drawer The drawer identifier.
   *
   * @param {number} id The attachment identifier.
   *
   * @param {SoftheonEnterpriseAPIGetAttachmentVersionsByFilterOptionalParams}
   * [options] Optional Parameters.
   *
   * @param {ServiceCallback} callback - The callback.
   *
   * @returns {ServiceCallback} callback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {Models.AttachmentVersionModel[]} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {Response} [response] - The HTTP Response stream if an error did not occur.
   */
  getAttachmentVersionsByFilter(drawer: number, id: number): Promise<Models.AttachmentVersionModel[]>;
  getAttachmentVersionsByFilter(drawer: number, id: number, options: Models.SoftheonEnterpriseAPIGetAttachmentVersionsByFilterOptionalParams): Promise<Models.AttachmentVersionModel[]>;
  getAttachmentVersionsByFilter(drawer: number, id: number, callback: msRest.ServiceCallback<Models.AttachmentVersionModel[]>): void;
  getAttachmentVersionsByFilter(drawer: number, id: number, options: Models.SoftheonEnterpriseAPIGetAttachmentVersionsByFilterOptionalParams, callback: msRest.ServiceCallback<Models.AttachmentVersionModel[]>): void;
  getAttachmentVersionsByFilter(drawer: number, id: number, options?: Models.SoftheonEnterpriseAPIGetAttachmentVersionsByFilterOptionalParams, callback?: msRest.ServiceCallback<Models.AttachmentVersionModel[]>): any {
    if (!callback && typeof options === 'function') {
      callback = options;
      options = undefined;
    }
    let cb = callback as msRest.ServiceCallback<Models.AttachmentVersionModel[]>;
    if (!callback) {
      return this.getAttachmentVersionsByFilterWithHttpOperationResponse(drawer, id, options).then((operationRes: msRest.HttpOperationResponse) => {
        return Promise.resolve(operationRes.bodyAsJson as Models.AttachmentVersionModel[]);
      }).catch((err: Error) => {
        return Promise.reject(err);
      });
    } else {
      msRest.promiseToCallback(this.getAttachmentVersionsByFilterWithHttpOperationResponse(drawer, id, options))((err: Error, data: msRest.HttpOperationResponse) => {
        if (err) {
          return cb(err);
        }
        let result = data.bodyAsJson as Models.AttachmentVersionModel[];
        return cb(err, result, data.request, data.response);
      });
    }
  }

  /**
   * @summary Gets a file for a specified attachment version.
   *
   * @param {number} drawer The drawer identifier.
   *
   * @param {number} id The attachment identifier.
   *
   * @param {number} versionID The version identifier.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @param {ServiceCallback} callback - The callback.
   *
   * @returns {ServiceCallback} callback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {any} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {Response} [response] - The HTTP Response stream if an error did not occur.
   */
  getAttachmentVersionFileContent(drawer: number, id: number, versionID: number): Promise<any>;
  getAttachmentVersionFileContent(drawer: number, id: number, versionID: number, options: msRest.RequestOptionsBase): Promise<any>;
  getAttachmentVersionFileContent(drawer: number, id: number, versionID: number, callback: msRest.ServiceCallback<any>): void;
  getAttachmentVersionFileContent(drawer: number, id: number, versionID: number, options: msRest.RequestOptionsBase, callback: msRest.ServiceCallback<any>): void;
  getAttachmentVersionFileContent(drawer: number, id: number, versionID: number, options?: msRest.RequestOptionsBase, callback?: msRest.ServiceCallback<any>): any {
    if (!callback && typeof options === 'function') {
      callback = options;
      options = undefined;
    }
    let cb = callback as msRest.ServiceCallback<any>;
    if (!callback) {
      return this.getAttachmentVersionFileContentWithHttpOperationResponse(drawer, id, versionID, options).then((operationRes: msRest.HttpOperationResponse) => {
        return Promise.resolve(operationRes.bodyAsJson as any);
      }).catch((err: Error) => {
        return Promise.reject(err);
      });
    } else {
      msRest.promiseToCallback(this.getAttachmentVersionFileContentWithHttpOperationResponse(drawer, id, versionID, options))((err: Error, data: msRest.HttpOperationResponse) => {
        if (err) {
          return cb(err);
        }
        let result = data.bodyAsJson as any;
        return cb(err, result, data.request, data.response);
      });
    }
  }

  /**
   * @summary Checks out the attachment file.
   *
   * @param {number} drawer The drawer identifier.
   *
   * @param {number} id The attachment identifier.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @param {ServiceCallback} callback - The callback.
   *
   * @returns {ServiceCallback} callback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {any} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {Response} [response] - The HTTP Response stream if an error did not occur.
   */
  checkOutAttachment(drawer: number, id: number): Promise<any>;
  checkOutAttachment(drawer: number, id: number, options: msRest.RequestOptionsBase): Promise<any>;
  checkOutAttachment(drawer: number, id: number, callback: msRest.ServiceCallback<any>): void;
  checkOutAttachment(drawer: number, id: number, options: msRest.RequestOptionsBase, callback: msRest.ServiceCallback<any>): void;
  checkOutAttachment(drawer: number, id: number, options?: msRest.RequestOptionsBase, callback?: msRest.ServiceCallback<any>): any {
    if (!callback && typeof options === 'function') {
      callback = options;
      options = undefined;
    }
    let cb = callback as msRest.ServiceCallback<any>;
    if (!callback) {
      return this.checkOutAttachmentWithHttpOperationResponse(drawer, id, options).then((operationRes: msRest.HttpOperationResponse) => {
        return Promise.resolve(operationRes.bodyAsJson as any);
      }).catch((err: Error) => {
        return Promise.reject(err);
      });
    } else {
      msRest.promiseToCallback(this.checkOutAttachmentWithHttpOperationResponse(drawer, id, options))((err: Error, data: msRest.HttpOperationResponse) => {
        if (err) {
          return cb(err);
        }
        let result = data.bodyAsJson as any;
        return cb(err, result, data.request, data.response);
      });
    }
  }

  /**
   * @summary Undoes the attachment check out of the attachment file.
   *
   * @param {number} drawer The drawer identifier.
   *
   * @param {number} id The attachment identifier.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @param {ServiceCallback} callback - The callback.
   *
   * @returns {ServiceCallback} callback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {any} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {Response} [response] - The HTTP Response stream if an error did not occur.
   */
  undoCheckOutAttachment(drawer: number, id: number): Promise<any>;
  undoCheckOutAttachment(drawer: number, id: number, options: msRest.RequestOptionsBase): Promise<any>;
  undoCheckOutAttachment(drawer: number, id: number, callback: msRest.ServiceCallback<any>): void;
  undoCheckOutAttachment(drawer: number, id: number, options: msRest.RequestOptionsBase, callback: msRest.ServiceCallback<any>): void;
  undoCheckOutAttachment(drawer: number, id: number, options?: msRest.RequestOptionsBase, callback?: msRest.ServiceCallback<any>): any {
    if (!callback && typeof options === 'function') {
      callback = options;
      options = undefined;
    }
    let cb = callback as msRest.ServiceCallback<any>;
    if (!callback) {
      return this.undoCheckOutAttachmentWithHttpOperationResponse(drawer, id, options).then((operationRes: msRest.HttpOperationResponse) => {
        return Promise.resolve(operationRes.bodyAsJson as any);
      }).catch((err: Error) => {
        return Promise.reject(err);
      });
    } else {
      msRest.promiseToCallback(this.undoCheckOutAttachmentWithHttpOperationResponse(drawer, id, options))((err: Error, data: msRest.HttpOperationResponse) => {
        if (err) {
          return cb(err);
        }
        let result = data.bodyAsJson as any;
        return cb(err, result, data.request, data.response);
      });
    }
  }

  /**
   * @summary Checks in the new version of attachment file.
   *
   * @param {number} drawer The drawer identifier.
   *
   * @param {number} id The attachment identifier.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @param {ServiceCallback} callback - The callback.
   *
   * @returns {ServiceCallback} callback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {any} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {Response} [response] - The HTTP Response stream if an error did not occur.
   */
  checkInAttachment(drawer: number, id: number): Promise<any>;
  checkInAttachment(drawer: number, id: number, options: msRest.RequestOptionsBase): Promise<any>;
  checkInAttachment(drawer: number, id: number, callback: msRest.ServiceCallback<any>): void;
  checkInAttachment(drawer: number, id: number, options: msRest.RequestOptionsBase, callback: msRest.ServiceCallback<any>): void;
  checkInAttachment(drawer: number, id: number, options?: msRest.RequestOptionsBase, callback?: msRest.ServiceCallback<any>): any {
    if (!callback && typeof options === 'function') {
      callback = options;
      options = undefined;
    }
    let cb = callback as msRest.ServiceCallback<any>;
    if (!callback) {
      return this.checkInAttachmentWithHttpOperationResponse(drawer, id, options).then((operationRes: msRest.HttpOperationResponse) => {
        return Promise.resolve(operationRes.bodyAsJson as any);
      }).catch((err: Error) => {
        return Promise.reject(err);
      });
    } else {
      msRest.promiseToCallback(this.checkInAttachmentWithHttpOperationResponse(drawer, id, options))((err: Error, data: msRest.HttpOperationResponse) => {
        if (err) {
          return cb(err);
        }
        let result = data.bodyAsJson as any;
        return cb(err, result, data.request, data.response);
      });
    }
  }

  /**
   * @summary Rolls back to a specified version the attachment file.
   *
   * @param {number} drawer The drawer identifier.
   *
   * @param {number} id The attachment identifier.
   *
   * @param {number} versionID The version identifier.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @param {ServiceCallback} callback - The callback.
   *
   * @returns {ServiceCallback} callback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {any} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {Response} [response] - The HTTP Response stream if an error did not occur.
   */
  rollbackAttachmentVersion(drawer: number, id: number, versionID: number): Promise<any>;
  rollbackAttachmentVersion(drawer: number, id: number, versionID: number, options: msRest.RequestOptionsBase): Promise<any>;
  rollbackAttachmentVersion(drawer: number, id: number, versionID: number, callback: msRest.ServiceCallback<any>): void;
  rollbackAttachmentVersion(drawer: number, id: number, versionID: number, options: msRest.RequestOptionsBase, callback: msRest.ServiceCallback<any>): void;
  rollbackAttachmentVersion(drawer: number, id: number, versionID: number, options?: msRest.RequestOptionsBase, callback?: msRest.ServiceCallback<any>): any {
    if (!callback && typeof options === 'function') {
      callback = options;
      options = undefined;
    }
    let cb = callback as msRest.ServiceCallback<any>;
    if (!callback) {
      return this.rollbackAttachmentVersionWithHttpOperationResponse(drawer, id, versionID, options).then((operationRes: msRest.HttpOperationResponse) => {
        return Promise.resolve(operationRes.bodyAsJson as any);
      }).catch((err: Error) => {
        return Promise.reject(err);
      });
    } else {
      msRest.promiseToCallback(this.rollbackAttachmentVersionWithHttpOperationResponse(drawer, id, versionID, options))((err: Error, data: msRest.HttpOperationResponse) => {
        if (err) {
          return cb(err);
        }
        let result = data.bodyAsJson as any;
        return cb(err, result, data.request, data.response);
      });
    }
  }

  /**
   * @summary Gets a list of all available drawers.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @param {ServiceCallback} callback - The callback.
   *
   * @returns {ServiceCallback} callback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {Models.DrawerModel[]} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {Response} [response] - The HTTP Response stream if an error did not occur.
   */
  getAllDrawers(): Promise<Models.DrawerModel[]>;
  getAllDrawers(options: msRest.RequestOptionsBase): Promise<Models.DrawerModel[]>;
  getAllDrawers(callback: msRest.ServiceCallback<Models.DrawerModel[]>): void;
  getAllDrawers(options: msRest.RequestOptionsBase, callback: msRest.ServiceCallback<Models.DrawerModel[]>): void;
  getAllDrawers(options?: msRest.RequestOptionsBase, callback?: msRest.ServiceCallback<Models.DrawerModel[]>): any {
    if (!callback && typeof options === 'function') {
      callback = options;
      options = undefined;
    }
    let cb = callback as msRest.ServiceCallback<Models.DrawerModel[]>;
    if (!callback) {
      return this.getAllDrawersWithHttpOperationResponse(options).then((operationRes: msRest.HttpOperationResponse) => {
        return Promise.resolve(operationRes.bodyAsJson as Models.DrawerModel[]);
      }).catch((err: Error) => {
        return Promise.reject(err);
      });
    } else {
      msRest.promiseToCallback(this.getAllDrawersWithHttpOperationResponse(options))((err: Error, data: msRest.HttpOperationResponse) => {
        if (err) {
          return cb(err);
        }
        let result = data.bodyAsJson as Models.DrawerModel[];
        return cb(err, result, data.request, data.response);
      });
    }
  }

  /**
   * @summary Gets a single drawer by its unique identifier.
   *
   * @param {number} id The drawer identifier.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @param {ServiceCallback} callback - The callback.
   *
   * @returns {ServiceCallback} callback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {Models.DrawerModel} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link Models.DrawerModel} for more information.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {Response} [response] - The HTTP Response stream if an error did not occur.
   */
  getDrawerById(id: number): Promise<Models.DrawerModel>;
  getDrawerById(id: number, options: msRest.RequestOptionsBase): Promise<Models.DrawerModel>;
  getDrawerById(id: number, callback: msRest.ServiceCallback<Models.DrawerModel>): void;
  getDrawerById(id: number, options: msRest.RequestOptionsBase, callback: msRest.ServiceCallback<Models.DrawerModel>): void;
  getDrawerById(id: number, options?: msRest.RequestOptionsBase, callback?: msRest.ServiceCallback<Models.DrawerModel>): any {
    if (!callback && typeof options === 'function') {
      callback = options;
      options = undefined;
    }
    let cb = callback as msRest.ServiceCallback<Models.DrawerModel>;
    if (!callback) {
      return this.getDrawerByIdWithHttpOperationResponse(id, options).then((operationRes: msRest.HttpOperationResponse) => {
        return Promise.resolve(operationRes.bodyAsJson as Models.DrawerModel);
      }).catch((err: Error) => {
        return Promise.reject(err);
      });
    } else {
      msRest.promiseToCallback(this.getDrawerByIdWithHttpOperationResponse(id, options))((err: Error, data: msRest.HttpOperationResponse) => {
        if (err) {
          return cb(err);
        }
        let result = data.bodyAsJson as Models.DrawerModel;
        return cb(err, result, data.request, data.response);
      });
    }
  }

  /**
   * @summary Updates a specified drawer.
   *
   * @param {number} id The drawer identifier.
   *
   * @param {DrawerBase} model The model.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @param {ServiceCallback} callback - The callback.
   *
   * @returns {ServiceCallback} callback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {any} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {Response} [response] - The HTTP Response stream if an error did not occur.
   */
  updateDrawer(id: number, model: Models.DrawerBase): Promise<any>;
  updateDrawer(id: number, model: Models.DrawerBase, options: msRest.RequestOptionsBase): Promise<any>;
  updateDrawer(id: number, model: Models.DrawerBase, callback: msRest.ServiceCallback<any>): void;
  updateDrawer(id: number, model: Models.DrawerBase, options: msRest.RequestOptionsBase, callback: msRest.ServiceCallback<any>): void;
  updateDrawer(id: number, model: Models.DrawerBase, options?: msRest.RequestOptionsBase, callback?: msRest.ServiceCallback<any>): any {
    if (!callback && typeof options === 'function') {
      callback = options;
      options = undefined;
    }
    let cb = callback as msRest.ServiceCallback<any>;
    if (!callback) {
      return this.updateDrawerWithHttpOperationResponse(id, model, options).then((operationRes: msRest.HttpOperationResponse) => {
        return Promise.resolve(operationRes.bodyAsJson as any);
      }).catch((err: Error) => {
        return Promise.reject(err);
      });
    } else {
      msRest.promiseToCallback(this.updateDrawerWithHttpOperationResponse(id, model, options))((err: Error, data: msRest.HttpOperationResponse) => {
        if (err) {
          return cb(err);
        }
        let result = data.bodyAsJson as any;
        return cb(err, result, data.request, data.response);
      });
    }
  }

  /**
   * @summary Gets a single drawer by its name.
   *
   * @param {string} name The drawer name.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @param {ServiceCallback} callback - The callback.
   *
   * @returns {ServiceCallback} callback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {Models.DrawerModel} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link Models.DrawerModel} for more information.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {Response} [response] - The HTTP Response stream if an error did not occur.
   */
  getDrawerByName(name: string): Promise<Models.DrawerModel>;
  getDrawerByName(name: string, options: msRest.RequestOptionsBase): Promise<Models.DrawerModel>;
  getDrawerByName(name: string, callback: msRest.ServiceCallback<Models.DrawerModel>): void;
  getDrawerByName(name: string, options: msRest.RequestOptionsBase, callback: msRest.ServiceCallback<Models.DrawerModel>): void;
  getDrawerByName(name: string, options?: msRest.RequestOptionsBase, callback?: msRest.ServiceCallback<Models.DrawerModel>): any {
    if (!callback && typeof options === 'function') {
      callback = options;
      options = undefined;
    }
    let cb = callback as msRest.ServiceCallback<Models.DrawerModel>;
    if (!callback) {
      return this.getDrawerByNameWithHttpOperationResponse(name, options).then((operationRes: msRest.HttpOperationResponse) => {
        return Promise.resolve(operationRes.bodyAsJson as Models.DrawerModel);
      }).catch((err: Error) => {
        return Promise.reject(err);
      });
    } else {
      msRest.promiseToCallback(this.getDrawerByNameWithHttpOperationResponse(name, options))((err: Error, data: msRest.HttpOperationResponse) => {
        if (err) {
          return cb(err);
        }
        let result = data.bodyAsJson as Models.DrawerModel;
        return cb(err, result, data.request, data.response);
      });
    }
  }

  /**
   * @summary Gets a paged list of entity summaries.
   *
   * @param {number} drawerID Gets or sets the drawer identifier.
   *
   * @param {SoftheonEnterpriseAPIGetEntitiesByFilterOptionalParams} [options]
   * Optional Parameters.
   *
   * @param {ServiceCallback} callback - The callback.
   *
   * @returns {ServiceCallback} callback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {Models.GetEntityBaseResponse[]} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {Response} [response] - The HTTP Response stream if an error did not occur.
   */
  getEntitiesByFilter(drawerID: number): Promise<Models.GetEntityBaseResponse[]>;
  getEntitiesByFilter(drawerID: number, options: Models.SoftheonEnterpriseAPIGetEntitiesByFilterOptionalParams): Promise<Models.GetEntityBaseResponse[]>;
  getEntitiesByFilter(drawerID: number, callback: msRest.ServiceCallback<Models.GetEntityBaseResponse[]>): void;
  getEntitiesByFilter(drawerID: number, options: Models.SoftheonEnterpriseAPIGetEntitiesByFilterOptionalParams, callback: msRest.ServiceCallback<Models.GetEntityBaseResponse[]>): void;
  getEntitiesByFilter(drawerID: number, options?: Models.SoftheonEnterpriseAPIGetEntitiesByFilterOptionalParams, callback?: msRest.ServiceCallback<Models.GetEntityBaseResponse[]>): any {
    if (!callback && typeof options === 'function') {
      callback = options;
      options = undefined;
    }
    let cb = callback as msRest.ServiceCallback<Models.GetEntityBaseResponse[]>;
    if (!callback) {
      return this.getEntitiesByFilterWithHttpOperationResponse(drawerID, options).then((operationRes: msRest.HttpOperationResponse) => {
        return Promise.resolve(operationRes.bodyAsJson as Models.GetEntityBaseResponse[]);
      }).catch((err: Error) => {
        return Promise.reject(err);
      });
    } else {
      msRest.promiseToCallback(this.getEntitiesByFilterWithHttpOperationResponse(drawerID, options))((err: Error, data: msRest.HttpOperationResponse) => {
        if (err) {
          return cb(err);
        }
        let result = data.bodyAsJson as Models.GetEntityBaseResponse[];
        return cb(err, result, data.request, data.response);
      });
    }
  }

  /**
   * @summary Gets a single entity complete with all profile metadata.
   *
   * @param {number} drawer The drawer identifier.
   *
   * @param {number} id The entity identifier.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @param {ServiceCallback} callback - The callback.
   *
   * @returns {ServiceCallback} callback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {Models.EntityModel} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link Models.EntityModel} for more information.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {Response} [response] - The HTTP Response stream if an error did not occur.
   */
  getEntityById(drawer: number, id: number): Promise<Models.EntityModel>;
  getEntityById(drawer: number, id: number, options: msRest.RequestOptionsBase): Promise<Models.EntityModel>;
  getEntityById(drawer: number, id: number, callback: msRest.ServiceCallback<Models.EntityModel>): void;
  getEntityById(drawer: number, id: number, options: msRest.RequestOptionsBase, callback: msRest.ServiceCallback<Models.EntityModel>): void;
  getEntityById(drawer: number, id: number, options?: msRest.RequestOptionsBase, callback?: msRest.ServiceCallback<Models.EntityModel>): any {
    if (!callback && typeof options === 'function') {
      callback = options;
      options = undefined;
    }
    let cb = callback as msRest.ServiceCallback<Models.EntityModel>;
    if (!callback) {
      return this.getEntityByIdWithHttpOperationResponse(drawer, id, options).then((operationRes: msRest.HttpOperationResponse) => {
        return Promise.resolve(operationRes.bodyAsJson as Models.EntityModel);
      }).catch((err: Error) => {
        return Promise.reject(err);
      });
    } else {
      msRest.promiseToCallback(this.getEntityByIdWithHttpOperationResponse(drawer, id, options))((err: Error, data: msRest.HttpOperationResponse) => {
        if (err) {
          return cb(err);
        }
        let result = data.bodyAsJson as Models.EntityModel;
        return cb(err, result, data.request, data.response);
      });
    }
  }

  /**
   * @summary Updates a specified entity.
   *
   * @param {number} drawer The drawer identifier.
   *
   * @param {number} id The entity identifier.
   *
   * @param {UpdateEntityRequestModel} model The entity model.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @param {ServiceCallback} callback - The callback.
   *
   * @returns {ServiceCallback} callback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {any} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {Response} [response] - The HTTP Response stream if an error did not occur.
   */
  updateEntity(drawer: number, id: number, model: Models.UpdateEntityRequestModel): Promise<any>;
  updateEntity(drawer: number, id: number, model: Models.UpdateEntityRequestModel, options: msRest.RequestOptionsBase): Promise<any>;
  updateEntity(drawer: number, id: number, model: Models.UpdateEntityRequestModel, callback: msRest.ServiceCallback<any>): void;
  updateEntity(drawer: number, id: number, model: Models.UpdateEntityRequestModel, options: msRest.RequestOptionsBase, callback: msRest.ServiceCallback<any>): void;
  updateEntity(drawer: number, id: number, model: Models.UpdateEntityRequestModel, options?: msRest.RequestOptionsBase, callback?: msRest.ServiceCallback<any>): any {
    if (!callback && typeof options === 'function') {
      callback = options;
      options = undefined;
    }
    let cb = callback as msRest.ServiceCallback<any>;
    if (!callback) {
      return this.updateEntityWithHttpOperationResponse(drawer, id, model, options).then((operationRes: msRest.HttpOperationResponse) => {
        return Promise.resolve(operationRes.bodyAsJson as any);
      }).catch((err: Error) => {
        return Promise.reject(err);
      });
    } else {
      msRest.promiseToCallback(this.updateEntityWithHttpOperationResponse(drawer, id, model, options))((err: Error, data: msRest.HttpOperationResponse) => {
        if (err) {
          return cb(err);
        }
        let result = data.bodyAsJson as any;
        return cb(err, result, data.request, data.response);
      });
    }
  }

  /**
   * @summary Deletes a specified entity.
   *
   * @param {number} drawer The drawer identifier.
   *
   * @param {number} id The entity identifier.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @param {ServiceCallback} callback - The callback.
   *
   * @returns {ServiceCallback} callback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {any} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {Response} [response] - The HTTP Response stream if an error did not occur.
   */
  deleteEntity(drawer: number, id: number): Promise<any>;
  deleteEntity(drawer: number, id: number, options: msRest.RequestOptionsBase): Promise<any>;
  deleteEntity(drawer: number, id: number, callback: msRest.ServiceCallback<any>): void;
  deleteEntity(drawer: number, id: number, options: msRest.RequestOptionsBase, callback: msRest.ServiceCallback<any>): void;
  deleteEntity(drawer: number, id: number, options?: msRest.RequestOptionsBase, callback?: msRest.ServiceCallback<any>): any {
    if (!callback && typeof options === 'function') {
      callback = options;
      options = undefined;
    }
    let cb = callback as msRest.ServiceCallback<any>;
    if (!callback) {
      return this.deleteEntityWithHttpOperationResponse(drawer, id, options).then((operationRes: msRest.HttpOperationResponse) => {
        return Promise.resolve(operationRes.bodyAsJson as any);
      }).catch((err: Error) => {
        return Promise.reject(err);
      });
    } else {
      msRest.promiseToCallback(this.deleteEntityWithHttpOperationResponse(drawer, id, options))((err: Error, data: msRest.HttpOperationResponse) => {
        if (err) {
          return cb(err);
        }
        let result = data.bodyAsJson as any;
        return cb(err, result, data.request, data.response);
      });
    }
  }

  /**
   * @summary Creates a new entity.
   *
   * @param {number} drawer The drawer identifier.
   *
   * @param {InsertEntityRequestModel} model The entity model.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @param {ServiceCallback} callback - The callback.
   *
   * @returns {ServiceCallback} callback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {Models.EntityModel} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link Models.EntityModel} for more information.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {Response} [response] - The HTTP Response stream if an error did not occur.
   */
  createEntity(drawer: number, model: Models.InsertEntityRequestModel): Promise<Models.EntityModel>;
  createEntity(drawer: number, model: Models.InsertEntityRequestModel, options: msRest.RequestOptionsBase): Promise<Models.EntityModel>;
  createEntity(drawer: number, model: Models.InsertEntityRequestModel, callback: msRest.ServiceCallback<Models.EntityModel>): void;
  createEntity(drawer: number, model: Models.InsertEntityRequestModel, options: msRest.RequestOptionsBase, callback: msRest.ServiceCallback<Models.EntityModel>): void;
  createEntity(drawer: number, model: Models.InsertEntityRequestModel, options?: msRest.RequestOptionsBase, callback?: msRest.ServiceCallback<Models.EntityModel>): any {
    if (!callback && typeof options === 'function') {
      callback = options;
      options = undefined;
    }
    let cb = callback as msRest.ServiceCallback<Models.EntityModel>;
    if (!callback) {
      return this.createEntityWithHttpOperationResponse(drawer, model, options).then((operationRes: msRest.HttpOperationResponse) => {
        return Promise.resolve(operationRes.bodyAsJson as Models.EntityModel);
      }).catch((err: Error) => {
        return Promise.reject(err);
      });
    } else {
      msRest.promiseToCallback(this.createEntityWithHttpOperationResponse(drawer, model, options))((err: Error, data: msRest.HttpOperationResponse) => {
        if (err) {
          return cb(err);
        }
        let result = data.bodyAsJson as Models.EntityModel;
        return cb(err, result, data.request, data.response);
      });
    }
  }

  /**
   * @summary Copies the contents of an entity.
   *
   * @param {number} drawer The drawer.
   *
   * @param {number} id The entity identifier.
   *
   * @param {EntityContentModel} model The model.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @param {ServiceCallback} callback - The callback.
   *
   * @returns {ServiceCallback} callback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {Models.EntityModel} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link Models.EntityModel} for more information.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {Response} [response] - The HTTP Response stream if an error did not occur.
   */
  copyEntity(drawer: number, id: number, model: Models.EntityContentModel): Promise<Models.EntityModel>;
  copyEntity(drawer: number, id: number, model: Models.EntityContentModel, options: msRest.RequestOptionsBase): Promise<Models.EntityModel>;
  copyEntity(drawer: number, id: number, model: Models.EntityContentModel, callback: msRest.ServiceCallback<Models.EntityModel>): void;
  copyEntity(drawer: number, id: number, model: Models.EntityContentModel, options: msRest.RequestOptionsBase, callback: msRest.ServiceCallback<Models.EntityModel>): void;
  copyEntity(drawer: number, id: number, model: Models.EntityContentModel, options?: msRest.RequestOptionsBase, callback?: msRest.ServiceCallback<Models.EntityModel>): any {
    if (!callback && typeof options === 'function') {
      callback = options;
      options = undefined;
    }
    let cb = callback as msRest.ServiceCallback<Models.EntityModel>;
    if (!callback) {
      return this.copyEntityWithHttpOperationResponse(drawer, id, model, options).then((operationRes: msRest.HttpOperationResponse) => {
        return Promise.resolve(operationRes.bodyAsJson as Models.EntityModel);
      }).catch((err: Error) => {
        return Promise.reject(err);
      });
    } else {
      msRest.promiseToCallback(this.copyEntityWithHttpOperationResponse(drawer, id, model, options))((err: Error, data: msRest.HttpOperationResponse) => {
        if (err) {
          return cb(err);
        }
        let result = data.bodyAsJson as Models.EntityModel;
        return cb(err, result, data.request, data.response);
      });
    }
  }

  /**
   * @summary Gets a paged list of events.
   *
   * @param {number} drawerID Gets or sets the drawer identifier.
   *
   * @param {number} entityID Gets or sets the entity identifier.
   *
   * @param {SoftheonEnterpriseAPIGetEventsByFilterOptionalParams} [options]
   * Optional Parameters.
   *
   * @param {ServiceCallback} callback - The callback.
   *
   * @returns {ServiceCallback} callback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {Models.EventModel[]} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {Response} [response] - The HTTP Response stream if an error did not occur.
   */
  getEventsByFilter(drawerID: number, entityID: number): Promise<Models.EventModel[]>;
  getEventsByFilter(drawerID: number, entityID: number, options: Models.SoftheonEnterpriseAPIGetEventsByFilterOptionalParams): Promise<Models.EventModel[]>;
  getEventsByFilter(drawerID: number, entityID: number, callback: msRest.ServiceCallback<Models.EventModel[]>): void;
  getEventsByFilter(drawerID: number, entityID: number, options: Models.SoftheonEnterpriseAPIGetEventsByFilterOptionalParams, callback: msRest.ServiceCallback<Models.EventModel[]>): void;
  getEventsByFilter(drawerID: number, entityID: number, options?: Models.SoftheonEnterpriseAPIGetEventsByFilterOptionalParams, callback?: msRest.ServiceCallback<Models.EventModel[]>): any {
    if (!callback && typeof options === 'function') {
      callback = options;
      options = undefined;
    }
    let cb = callback as msRest.ServiceCallback<Models.EventModel[]>;
    if (!callback) {
      return this.getEventsByFilterWithHttpOperationResponse(drawerID, entityID, options).then((operationRes: msRest.HttpOperationResponse) => {
        return Promise.resolve(operationRes.bodyAsJson as Models.EventModel[]);
      }).catch((err: Error) => {
        return Promise.reject(err);
      });
    } else {
      msRest.promiseToCallback(this.getEventsByFilterWithHttpOperationResponse(drawerID, entityID, options))((err: Error, data: msRest.HttpOperationResponse) => {
        if (err) {
          return cb(err);
        }
        let result = data.bodyAsJson as Models.EventModel[];
        return cb(err, result, data.request, data.response);
      });
    }
  }

  /**
   * @summary Retrieves a single event based on its unique identifier.
   *
   * @param {number} drawer The drawer identifier.
   *
   * @param {number} id The event identifier.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @param {ServiceCallback} callback - The callback.
   *
   * @returns {ServiceCallback} callback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {Models.EventModel} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link Models.EventModel} for more information.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {Response} [response] - The HTTP Response stream if an error did not occur.
   */
  getEventById(drawer: number, id: number): Promise<Models.EventModel>;
  getEventById(drawer: number, id: number, options: msRest.RequestOptionsBase): Promise<Models.EventModel>;
  getEventById(drawer: number, id: number, callback: msRest.ServiceCallback<Models.EventModel>): void;
  getEventById(drawer: number, id: number, options: msRest.RequestOptionsBase, callback: msRest.ServiceCallback<Models.EventModel>): void;
  getEventById(drawer: number, id: number, options?: msRest.RequestOptionsBase, callback?: msRest.ServiceCallback<Models.EventModel>): any {
    if (!callback && typeof options === 'function') {
      callback = options;
      options = undefined;
    }
    let cb = callback as msRest.ServiceCallback<Models.EventModel>;
    if (!callback) {
      return this.getEventByIdWithHttpOperationResponse(drawer, id, options).then((operationRes: msRest.HttpOperationResponse) => {
        return Promise.resolve(operationRes.bodyAsJson as Models.EventModel);
      }).catch((err: Error) => {
        return Promise.reject(err);
      });
    } else {
      msRest.promiseToCallback(this.getEventByIdWithHttpOperationResponse(drawer, id, options))((err: Error, data: msRest.HttpOperationResponse) => {
        if (err) {
          return cb(err);
        }
        let result = data.bodyAsJson as Models.EventModel;
        return cb(err, result, data.request, data.response);
      });
    }
  }

  /**
   * @summary Creates a new event.
   *
   * @param {number} drawer The drawer identifier.
   *
   * @param {EventModel} model The event model.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @param {ServiceCallback} callback - The callback.
   *
   * @returns {ServiceCallback} callback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {Models.EventModel} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link Models.EventModel} for more information.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {Response} [response] - The HTTP Response stream if an error did not occur.
   */
  createEvent(drawer: number, model: Models.EventModel): Promise<Models.EventModel>;
  createEvent(drawer: number, model: Models.EventModel, options: msRest.RequestOptionsBase): Promise<Models.EventModel>;
  createEvent(drawer: number, model: Models.EventModel, callback: msRest.ServiceCallback<Models.EventModel>): void;
  createEvent(drawer: number, model: Models.EventModel, options: msRest.RequestOptionsBase, callback: msRest.ServiceCallback<Models.EventModel>): void;
  createEvent(drawer: number, model: Models.EventModel, options?: msRest.RequestOptionsBase, callback?: msRest.ServiceCallback<Models.EventModel>): any {
    if (!callback && typeof options === 'function') {
      callback = options;
      options = undefined;
    }
    let cb = callback as msRest.ServiceCallback<Models.EventModel>;
    if (!callback) {
      return this.createEventWithHttpOperationResponse(drawer, model, options).then((operationRes: msRest.HttpOperationResponse) => {
        return Promise.resolve(operationRes.bodyAsJson as Models.EventModel);
      }).catch((err: Error) => {
        return Promise.reject(err);
      });
    } else {
      msRest.promiseToCallback(this.createEventWithHttpOperationResponse(drawer, model, options))((err: Error, data: msRest.HttpOperationResponse) => {
        if (err) {
          return cb(err);
        }
        let result = data.bodyAsJson as Models.EventModel;
        return cb(err, result, data.request, data.response);
      });
    }
  }

  /**
   * @summary Gets a paged list of extension rows
   *
   * @param {number} drawerID Gets or sets the drawer identifier.
   *
   * @param {number} entityID Gets or sets the entity identifier.
   *
   * @param {number} profileID Gets or sets the profile identifier.
   *
   * @param {SoftheonEnterpriseAPIGetExtensionsByFilterOptionalParams} [options]
   * Optional Parameters.
   *
   * @param {ServiceCallback} callback - The callback.
   *
   * @returns {ServiceCallback} callback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {Models.ExtensionModel[]} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {Response} [response] - The HTTP Response stream if an error did not occur.
   */
  getExtensionsByFilter(drawerID: number, entityID: number, profileID: number): Promise<Models.ExtensionModel[]>;
  getExtensionsByFilter(drawerID: number, entityID: number, profileID: number, options: Models.SoftheonEnterpriseAPIGetExtensionsByFilterOptionalParams): Promise<Models.ExtensionModel[]>;
  getExtensionsByFilter(drawerID: number, entityID: number, profileID: number, callback: msRest.ServiceCallback<Models.ExtensionModel[]>): void;
  getExtensionsByFilter(drawerID: number, entityID: number, profileID: number, options: Models.SoftheonEnterpriseAPIGetExtensionsByFilterOptionalParams, callback: msRest.ServiceCallback<Models.ExtensionModel[]>): void;
  getExtensionsByFilter(drawerID: number, entityID: number, profileID: number, options?: Models.SoftheonEnterpriseAPIGetExtensionsByFilterOptionalParams, callback?: msRest.ServiceCallback<Models.ExtensionModel[]>): any {
    if (!callback && typeof options === 'function') {
      callback = options;
      options = undefined;
    }
    let cb = callback as msRest.ServiceCallback<Models.ExtensionModel[]>;
    if (!callback) {
      return this.getExtensionsByFilterWithHttpOperationResponse(drawerID, entityID, profileID, options).then((operationRes: msRest.HttpOperationResponse) => {
        return Promise.resolve(operationRes.bodyAsJson as Models.ExtensionModel[]);
      }).catch((err: Error) => {
        return Promise.reject(err);
      });
    } else {
      msRest.promiseToCallback(this.getExtensionsByFilterWithHttpOperationResponse(drawerID, entityID, profileID, options))((err: Error, data: msRest.HttpOperationResponse) => {
        if (err) {
          return cb(err);
        }
        let result = data.bodyAsJson as Models.ExtensionModel[];
        return cb(err, result, data.request, data.response);
      });
    }
  }

  /**
   * @summary Gets a paged list of flows.
   *
   * @param {number} drawerID Gets or sets the drawer identifier.
   *
   * @param {number} entityID Gets or sets the entity identifier.
   *
   * @param {SoftheonEnterpriseAPIGetFlowsByFilterOptionalParams} [options]
   * Optional Parameters.
   *
   * @param {ServiceCallback} callback - The callback.
   *
   * @returns {ServiceCallback} callback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {Models.FlowModel[]} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {Response} [response] - The HTTP Response stream if an error did not occur.
   */
  getFlowsByFilter(drawerID: number, entityID: number): Promise<Models.FlowModel[]>;
  getFlowsByFilter(drawerID: number, entityID: number, options: Models.SoftheonEnterpriseAPIGetFlowsByFilterOptionalParams): Promise<Models.FlowModel[]>;
  getFlowsByFilter(drawerID: number, entityID: number, callback: msRest.ServiceCallback<Models.FlowModel[]>): void;
  getFlowsByFilter(drawerID: number, entityID: number, options: Models.SoftheonEnterpriseAPIGetFlowsByFilterOptionalParams, callback: msRest.ServiceCallback<Models.FlowModel[]>): void;
  getFlowsByFilter(drawerID: number, entityID: number, options?: Models.SoftheonEnterpriseAPIGetFlowsByFilterOptionalParams, callback?: msRest.ServiceCallback<Models.FlowModel[]>): any {
    if (!callback && typeof options === 'function') {
      callback = options;
      options = undefined;
    }
    let cb = callback as msRest.ServiceCallback<Models.FlowModel[]>;
    if (!callback) {
      return this.getFlowsByFilterWithHttpOperationResponse(drawerID, entityID, options).then((operationRes: msRest.HttpOperationResponse) => {
        return Promise.resolve(operationRes.bodyAsJson as Models.FlowModel[]);
      }).catch((err: Error) => {
        return Promise.reject(err);
      });
    } else {
      msRest.promiseToCallback(this.getFlowsByFilterWithHttpOperationResponse(drawerID, entityID, options))((err: Error, data: msRest.HttpOperationResponse) => {
        if (err) {
          return cb(err);
        }
        let result = data.bodyAsJson as Models.FlowModel[];
        return cb(err, result, data.request, data.response);
      });
    }
  }

  /**
   * @summary Gets a single flow based on its unique identifier.
   *
   * @param {number} drawer The drawer identifier.
   *
   * @param {number} id The flow identifier.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @param {ServiceCallback} callback - The callback.
   *
   * @returns {ServiceCallback} callback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {Models.FlowModel} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link Models.FlowModel} for more information.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {Response} [response] - The HTTP Response stream if an error did not occur.
   */
  getFlowById(drawer: number, id: number): Promise<Models.FlowModel>;
  getFlowById(drawer: number, id: number, options: msRest.RequestOptionsBase): Promise<Models.FlowModel>;
  getFlowById(drawer: number, id: number, callback: msRest.ServiceCallback<Models.FlowModel>): void;
  getFlowById(drawer: number, id: number, options: msRest.RequestOptionsBase, callback: msRest.ServiceCallback<Models.FlowModel>): void;
  getFlowById(drawer: number, id: number, options?: msRest.RequestOptionsBase, callback?: msRest.ServiceCallback<Models.FlowModel>): any {
    if (!callback && typeof options === 'function') {
      callback = options;
      options = undefined;
    }
    let cb = callback as msRest.ServiceCallback<Models.FlowModel>;
    if (!callback) {
      return this.getFlowByIdWithHttpOperationResponse(drawer, id, options).then((operationRes: msRest.HttpOperationResponse) => {
        return Promise.resolve(operationRes.bodyAsJson as Models.FlowModel);
      }).catch((err: Error) => {
        return Promise.reject(err);
      });
    } else {
      msRest.promiseToCallback(this.getFlowByIdWithHttpOperationResponse(drawer, id, options))((err: Error, data: msRest.HttpOperationResponse) => {
        if (err) {
          return cb(err);
        }
        let result = data.bodyAsJson as Models.FlowModel;
        return cb(err, result, data.request, data.response);
      });
    }
  }

  /**
   * @summary Gets a paged list of entity template definitions.
   *
   * @param {SoftheonEnterpriseAPIGetTemplatesByFilterOptionalParams} [options]
   * Optional Parameters.
   *
   * @param {ServiceCallback} callback - The callback.
   *
   * @returns {ServiceCallback} callback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {Models.EntityDefinitionModel[]} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {Response} [response] - The HTTP Response stream if an error did not occur.
   */
  getTemplatesByFilter(): Promise<Models.EntityDefinitionModel[]>;
  getTemplatesByFilter(options: Models.SoftheonEnterpriseAPIGetTemplatesByFilterOptionalParams): Promise<Models.EntityDefinitionModel[]>;
  getTemplatesByFilter(callback: msRest.ServiceCallback<Models.EntityDefinitionModel[]>): void;
  getTemplatesByFilter(options: Models.SoftheonEnterpriseAPIGetTemplatesByFilterOptionalParams, callback: msRest.ServiceCallback<Models.EntityDefinitionModel[]>): void;
  getTemplatesByFilter(options?: Models.SoftheonEnterpriseAPIGetTemplatesByFilterOptionalParams, callback?: msRest.ServiceCallback<Models.EntityDefinitionModel[]>): any {
    if (!callback && typeof options === 'function') {
      callback = options;
      options = undefined;
    }
    let cb = callback as msRest.ServiceCallback<Models.EntityDefinitionModel[]>;
    if (!callback) {
      return this.getTemplatesByFilterWithHttpOperationResponse(options).then((operationRes: msRest.HttpOperationResponse) => {
        return Promise.resolve(operationRes.bodyAsJson as Models.EntityDefinitionModel[]);
      }).catch((err: Error) => {
        return Promise.reject(err);
      });
    } else {
      msRest.promiseToCallback(this.getTemplatesByFilterWithHttpOperationResponse(options))((err: Error, data: msRest.HttpOperationResponse) => {
        if (err) {
          return cb(err);
        }
        let result = data.bodyAsJson as Models.EntityDefinitionModel[];
        return cb(err, result, data.request, data.response);
      });
    }
  }

  /**
   * @summary Creates a new entity template definition.
   *
   * @param {EntityDefinitionBase} model The entity template model.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @param {ServiceCallback} callback - The callback.
   *
   * @returns {ServiceCallback} callback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {Models.EntityDefinitionModel} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link Models.EntityDefinitionModel} for more
   *                      information.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {Response} [response] - The HTTP Response stream if an error did not occur.
   */
  createTemplate(model: Models.EntityDefinitionBase): Promise<Models.EntityDefinitionModel>;
  createTemplate(model: Models.EntityDefinitionBase, options: msRest.RequestOptionsBase): Promise<Models.EntityDefinitionModel>;
  createTemplate(model: Models.EntityDefinitionBase, callback: msRest.ServiceCallback<Models.EntityDefinitionModel>): void;
  createTemplate(model: Models.EntityDefinitionBase, options: msRest.RequestOptionsBase, callback: msRest.ServiceCallback<Models.EntityDefinitionModel>): void;
  createTemplate(model: Models.EntityDefinitionBase, options?: msRest.RequestOptionsBase, callback?: msRest.ServiceCallback<Models.EntityDefinitionModel>): any {
    if (!callback && typeof options === 'function') {
      callback = options;
      options = undefined;
    }
    let cb = callback as msRest.ServiceCallback<Models.EntityDefinitionModel>;
    if (!callback) {
      return this.createTemplateWithHttpOperationResponse(model, options).then((operationRes: msRest.HttpOperationResponse) => {
        return Promise.resolve(operationRes.bodyAsJson as Models.EntityDefinitionModel);
      }).catch((err: Error) => {
        return Promise.reject(err);
      });
    } else {
      msRest.promiseToCallback(this.createTemplateWithHttpOperationResponse(model, options))((err: Error, data: msRest.HttpOperationResponse) => {
        if (err) {
          return cb(err);
        }
        let result = data.bodyAsJson as Models.EntityDefinitionModel;
        return cb(err, result, data.request, data.response);
      });
    }
  }

  /**
   * @summary Gets a single entity template definition by its type.
   *
   * @param {number} type The unique template type.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @param {ServiceCallback} callback - The callback.
   *
   * @returns {ServiceCallback} callback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {Models.EntityDefinitionModel} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link Models.EntityDefinitionModel} for more
   *                      information.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {Response} [response] - The HTTP Response stream if an error did not occur.
   */
  getTemplateByType(type: number): Promise<Models.EntityDefinitionModel>;
  getTemplateByType(type: number, options: msRest.RequestOptionsBase): Promise<Models.EntityDefinitionModel>;
  getTemplateByType(type: number, callback: msRest.ServiceCallback<Models.EntityDefinitionModel>): void;
  getTemplateByType(type: number, options: msRest.RequestOptionsBase, callback: msRest.ServiceCallback<Models.EntityDefinitionModel>): void;
  getTemplateByType(type: number, options?: msRest.RequestOptionsBase, callback?: msRest.ServiceCallback<Models.EntityDefinitionModel>): any {
    if (!callback && typeof options === 'function') {
      callback = options;
      options = undefined;
    }
    let cb = callback as msRest.ServiceCallback<Models.EntityDefinitionModel>;
    if (!callback) {
      return this.getTemplateByTypeWithHttpOperationResponse(type, options).then((operationRes: msRest.HttpOperationResponse) => {
        return Promise.resolve(operationRes.bodyAsJson as Models.EntityDefinitionModel);
      }).catch((err: Error) => {
        return Promise.reject(err);
      });
    } else {
      msRest.promiseToCallback(this.getTemplateByTypeWithHttpOperationResponse(type, options))((err: Error, data: msRest.HttpOperationResponse) => {
        if (err) {
          return cb(err);
        }
        let result = data.bodyAsJson as Models.EntityDefinitionModel;
        return cb(err, result, data.request, data.response);
      });
    }
  }

  /**
   * @summary Updates a specified entity template definition by type.
   *
   * @param {number} type The unique template type.
   *
   * @param {UpdateEntityDefinitionRequestModel} model The entity template model.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @param {ServiceCallback} callback - The callback.
   *
   * @returns {ServiceCallback} callback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {any} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {Response} [response] - The HTTP Response stream if an error did not occur.
   */
  updateTemplateByType(type: number, model: Models.UpdateEntityDefinitionRequestModel): Promise<any>;
  updateTemplateByType(type: number, model: Models.UpdateEntityDefinitionRequestModel, options: msRest.RequestOptionsBase): Promise<any>;
  updateTemplateByType(type: number, model: Models.UpdateEntityDefinitionRequestModel, callback: msRest.ServiceCallback<any>): void;
  updateTemplateByType(type: number, model: Models.UpdateEntityDefinitionRequestModel, options: msRest.RequestOptionsBase, callback: msRest.ServiceCallback<any>): void;
  updateTemplateByType(type: number, model: Models.UpdateEntityDefinitionRequestModel, options?: msRest.RequestOptionsBase, callback?: msRest.ServiceCallback<any>): any {
    if (!callback && typeof options === 'function') {
      callback = options;
      options = undefined;
    }
    let cb = callback as msRest.ServiceCallback<any>;
    if (!callback) {
      return this.updateTemplateByTypeWithHttpOperationResponse(type, model, options).then((operationRes: msRest.HttpOperationResponse) => {
        return Promise.resolve(operationRes.bodyAsJson as any);
      }).catch((err: Error) => {
        return Promise.reject(err);
      });
    } else {
      msRest.promiseToCallback(this.updateTemplateByTypeWithHttpOperationResponse(type, model, options))((err: Error, data: msRest.HttpOperationResponse) => {
        if (err) {
          return cb(err);
        }
        let result = data.bodyAsJson as any;
        return cb(err, result, data.request, data.response);
      });
    }
  }

  /**
   * @summary Deletes a specified entity template definition by type.
   *
   * @param {number} type The unique template type.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @param {ServiceCallback} callback - The callback.
   *
   * @returns {ServiceCallback} callback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {any} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {Response} [response] - The HTTP Response stream if an error did not occur.
   */
  deleteTemplateByType(type: number): Promise<any>;
  deleteTemplateByType(type: number, options: msRest.RequestOptionsBase): Promise<any>;
  deleteTemplateByType(type: number, callback: msRest.ServiceCallback<any>): void;
  deleteTemplateByType(type: number, options: msRest.RequestOptionsBase, callback: msRest.ServiceCallback<any>): void;
  deleteTemplateByType(type: number, options?: msRest.RequestOptionsBase, callback?: msRest.ServiceCallback<any>): any {
    if (!callback && typeof options === 'function') {
      callback = options;
      options = undefined;
    }
    let cb = callback as msRest.ServiceCallback<any>;
    if (!callback) {
      return this.deleteTemplateByTypeWithHttpOperationResponse(type, options).then((operationRes: msRest.HttpOperationResponse) => {
        return Promise.resolve(operationRes.bodyAsJson as any);
      }).catch((err: Error) => {
        return Promise.reject(err);
      });
    } else {
      msRest.promiseToCallback(this.deleteTemplateByTypeWithHttpOperationResponse(type, options))((err: Error, data: msRest.HttpOperationResponse) => {
        if (err) {
          return cb(err);
        }
        let result = data.bodyAsJson as any;
        return cb(err, result, data.request, data.response);
      });
    }
  }

  /**
   * @summary Gets a single entity template definition by its unique identifier.
   *
   * @param {string} id The template identifier.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @param {ServiceCallback} callback - The callback.
   *
   * @returns {ServiceCallback} callback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {Models.EntityDefinitionModel} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link Models.EntityDefinitionModel} for more
   *                      information.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {Response} [response] - The HTTP Response stream if an error did not occur.
   */
  getTemplateById(id: string): Promise<Models.EntityDefinitionModel>;
  getTemplateById(id: string, options: msRest.RequestOptionsBase): Promise<Models.EntityDefinitionModel>;
  getTemplateById(id: string, callback: msRest.ServiceCallback<Models.EntityDefinitionModel>): void;
  getTemplateById(id: string, options: msRest.RequestOptionsBase, callback: msRest.ServiceCallback<Models.EntityDefinitionModel>): void;
  getTemplateById(id: string, options?: msRest.RequestOptionsBase, callback?: msRest.ServiceCallback<Models.EntityDefinitionModel>): any {
    if (!callback && typeof options === 'function') {
      callback = options;
      options = undefined;
    }
    let cb = callback as msRest.ServiceCallback<Models.EntityDefinitionModel>;
    if (!callback) {
      return this.getTemplateByIdWithHttpOperationResponse(id, options).then((operationRes: msRest.HttpOperationResponse) => {
        return Promise.resolve(operationRes.bodyAsJson as Models.EntityDefinitionModel);
      }).catch((err: Error) => {
        return Promise.reject(err);
      });
    } else {
      msRest.promiseToCallback(this.getTemplateByIdWithHttpOperationResponse(id, options))((err: Error, data: msRest.HttpOperationResponse) => {
        if (err) {
          return cb(err);
        }
        let result = data.bodyAsJson as Models.EntityDefinitionModel;
        return cb(err, result, data.request, data.response);
      });
    }
  }

  /**
   * @summary Updates a specified entity template definition by identifier.
   *
   * @param {string} id The unique template identifier.
   *
   * @param {UpdateEntityDefinitionRequestModel} model The entity template model.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @param {ServiceCallback} callback - The callback.
   *
   * @returns {ServiceCallback} callback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {any} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {Response} [response] - The HTTP Response stream if an error did not occur.
   */
  updateTemplateById(id: string, model: Models.UpdateEntityDefinitionRequestModel): Promise<any>;
  updateTemplateById(id: string, model: Models.UpdateEntityDefinitionRequestModel, options: msRest.RequestOptionsBase): Promise<any>;
  updateTemplateById(id: string, model: Models.UpdateEntityDefinitionRequestModel, callback: msRest.ServiceCallback<any>): void;
  updateTemplateById(id: string, model: Models.UpdateEntityDefinitionRequestModel, options: msRest.RequestOptionsBase, callback: msRest.ServiceCallback<any>): void;
  updateTemplateById(id: string, model: Models.UpdateEntityDefinitionRequestModel, options?: msRest.RequestOptionsBase, callback?: msRest.ServiceCallback<any>): any {
    if (!callback && typeof options === 'function') {
      callback = options;
      options = undefined;
    }
    let cb = callback as msRest.ServiceCallback<any>;
    if (!callback) {
      return this.updateTemplateByIdWithHttpOperationResponse(id, model, options).then((operationRes: msRest.HttpOperationResponse) => {
        return Promise.resolve(operationRes.bodyAsJson as any);
      }).catch((err: Error) => {
        return Promise.reject(err);
      });
    } else {
      msRest.promiseToCallback(this.updateTemplateByIdWithHttpOperationResponse(id, model, options))((err: Error, data: msRest.HttpOperationResponse) => {
        if (err) {
          return cb(err);
        }
        let result = data.bodyAsJson as any;
        return cb(err, result, data.request, data.response);
      });
    }
  }

  /**
   * @summary Deletes a specified entity template definition by identifier.
   *
   * @param {string} id The unique template identifier.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @param {ServiceCallback} callback - The callback.
   *
   * @returns {ServiceCallback} callback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {any} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {Response} [response] - The HTTP Response stream if an error did not occur.
   */
  deleteTemplateById(id: string): Promise<any>;
  deleteTemplateById(id: string, options: msRest.RequestOptionsBase): Promise<any>;
  deleteTemplateById(id: string, callback: msRest.ServiceCallback<any>): void;
  deleteTemplateById(id: string, options: msRest.RequestOptionsBase, callback: msRest.ServiceCallback<any>): void;
  deleteTemplateById(id: string, options?: msRest.RequestOptionsBase, callback?: msRest.ServiceCallback<any>): any {
    if (!callback && typeof options === 'function') {
      callback = options;
      options = undefined;
    }
    let cb = callback as msRest.ServiceCallback<any>;
    if (!callback) {
      return this.deleteTemplateByIdWithHttpOperationResponse(id, options).then((operationRes: msRest.HttpOperationResponse) => {
        return Promise.resolve(operationRes.bodyAsJson as any);
      }).catch((err: Error) => {
        return Promise.reject(err);
      });
    } else {
      msRest.promiseToCallback(this.deleteTemplateByIdWithHttpOperationResponse(id, options))((err: Error, data: msRest.HttpOperationResponse) => {
        if (err) {
          return cb(err);
        }
        let result = data.bodyAsJson as any;
        return cb(err, result, data.request, data.response);
      });
    }
  }

  /**
   * @summary Validates the specified template field.
   *
   * @param {number} type The template type.
   *
   * @param {string} fieldID The field name.
   *
   * @param {SoftheonEnterpriseAPIValidateTemplateFieldOptionalParams} [options]
   * Optional Parameters.
   *
   * @param {ServiceCallback} callback - The callback.
   *
   * @returns {ServiceCallback} callback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {Models.FieldValidationModel} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link Models.FieldValidationModel} for more
   *                      information.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {Response} [response] - The HTTP Response stream if an error did not occur.
   */
  validateTemplateField(type: number, fieldID: string): Promise<Models.FieldValidationModel>;
  validateTemplateField(type: number, fieldID: string, options: Models.SoftheonEnterpriseAPIValidateTemplateFieldOptionalParams): Promise<Models.FieldValidationModel>;
  validateTemplateField(type: number, fieldID: string, callback: msRest.ServiceCallback<Models.FieldValidationModel>): void;
  validateTemplateField(type: number, fieldID: string, options: Models.SoftheonEnterpriseAPIValidateTemplateFieldOptionalParams, callback: msRest.ServiceCallback<Models.FieldValidationModel>): void;
  validateTemplateField(type: number, fieldID: string, options?: Models.SoftheonEnterpriseAPIValidateTemplateFieldOptionalParams, callback?: msRest.ServiceCallback<Models.FieldValidationModel>): any {
    if (!callback && typeof options === 'function') {
      callback = options;
      options = undefined;
    }
    let cb = callback as msRest.ServiceCallback<Models.FieldValidationModel>;
    if (!callback) {
      return this.validateTemplateFieldWithHttpOperationResponse(type, fieldID, options).then((operationRes: msRest.HttpOperationResponse) => {
        return Promise.resolve(operationRes.bodyAsJson as Models.FieldValidationModel);
      }).catch((err: Error) => {
        return Promise.reject(err);
      });
    } else {
      msRest.promiseToCallback(this.validateTemplateFieldWithHttpOperationResponse(type, fieldID, options))((err: Error, data: msRest.HttpOperationResponse) => {
        if (err) {
          return cb(err);
        }
        let result = data.bodyAsJson as Models.FieldValidationModel;
        return cb(err, result, data.request, data.response);
      });
    }
  }

  /**
   * @summary Gets a paged list of groups.
   *
   * @param {SoftheonEnterpriseAPIGetGroupsByFilterOptionalParams} [options]
   * Optional Parameters.
   *
   * @param {ServiceCallback} callback - The callback.
   *
   * @returns {ServiceCallback} callback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {Models.GroupModel[]} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {Response} [response] - The HTTP Response stream if an error did not occur.
   */
  getGroupsByFilter(): Promise<Models.GroupModel[]>;
  getGroupsByFilter(options: Models.SoftheonEnterpriseAPIGetGroupsByFilterOptionalParams): Promise<Models.GroupModel[]>;
  getGroupsByFilter(callback: msRest.ServiceCallback<Models.GroupModel[]>): void;
  getGroupsByFilter(options: Models.SoftheonEnterpriseAPIGetGroupsByFilterOptionalParams, callback: msRest.ServiceCallback<Models.GroupModel[]>): void;
  getGroupsByFilter(options?: Models.SoftheonEnterpriseAPIGetGroupsByFilterOptionalParams, callback?: msRest.ServiceCallback<Models.GroupModel[]>): any {
    if (!callback && typeof options === 'function') {
      callback = options;
      options = undefined;
    }
    let cb = callback as msRest.ServiceCallback<Models.GroupModel[]>;
    if (!callback) {
      return this.getGroupsByFilterWithHttpOperationResponse(options).then((operationRes: msRest.HttpOperationResponse) => {
        return Promise.resolve(operationRes.bodyAsJson as Models.GroupModel[]);
      }).catch((err: Error) => {
        return Promise.reject(err);
      });
    } else {
      msRest.promiseToCallback(this.getGroupsByFilterWithHttpOperationResponse(options))((err: Error, data: msRest.HttpOperationResponse) => {
        if (err) {
          return cb(err);
        }
        let result = data.bodyAsJson as Models.GroupModel[];
        return cb(err, result, data.request, data.response);
      });
    }
  }

  /**
   * @summary Creates a new group.
   *
   * @param {InsertGroupRequestModel} model The group model.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @param {ServiceCallback} callback - The callback.
   *
   * @returns {ServiceCallback} callback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {Models.GroupModel} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link Models.GroupModel} for more information.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {Response} [response] - The HTTP Response stream if an error did not occur.
   */
  createGroup(model: Models.InsertGroupRequestModel): Promise<Models.GroupModel>;
  createGroup(model: Models.InsertGroupRequestModel, options: msRest.RequestOptionsBase): Promise<Models.GroupModel>;
  createGroup(model: Models.InsertGroupRequestModel, callback: msRest.ServiceCallback<Models.GroupModel>): void;
  createGroup(model: Models.InsertGroupRequestModel, options: msRest.RequestOptionsBase, callback: msRest.ServiceCallback<Models.GroupModel>): void;
  createGroup(model: Models.InsertGroupRequestModel, options?: msRest.RequestOptionsBase, callback?: msRest.ServiceCallback<Models.GroupModel>): any {
    if (!callback && typeof options === 'function') {
      callback = options;
      options = undefined;
    }
    let cb = callback as msRest.ServiceCallback<Models.GroupModel>;
    if (!callback) {
      return this.createGroupWithHttpOperationResponse(model, options).then((operationRes: msRest.HttpOperationResponse) => {
        return Promise.resolve(operationRes.bodyAsJson as Models.GroupModel);
      }).catch((err: Error) => {
        return Promise.reject(err);
      });
    } else {
      msRest.promiseToCallback(this.createGroupWithHttpOperationResponse(model, options))((err: Error, data: msRest.HttpOperationResponse) => {
        if (err) {
          return cb(err);
        }
        let result = data.bodyAsJson as Models.GroupModel;
        return cb(err, result, data.request, data.response);
      });
    }
  }

  /**
   * @summary Gets a single group by its unique identifier.
   *
   * @param {number} id The group identifier.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @param {ServiceCallback} callback - The callback.
   *
   * @returns {ServiceCallback} callback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {Models.GroupModel} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link Models.GroupModel} for more information.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {Response} [response] - The HTTP Response stream if an error did not occur.
   */
  getGroupById(id: number): Promise<Models.GroupModel>;
  getGroupById(id: number, options: msRest.RequestOptionsBase): Promise<Models.GroupModel>;
  getGroupById(id: number, callback: msRest.ServiceCallback<Models.GroupModel>): void;
  getGroupById(id: number, options: msRest.RequestOptionsBase, callback: msRest.ServiceCallback<Models.GroupModel>): void;
  getGroupById(id: number, options?: msRest.RequestOptionsBase, callback?: msRest.ServiceCallback<Models.GroupModel>): any {
    if (!callback && typeof options === 'function') {
      callback = options;
      options = undefined;
    }
    let cb = callback as msRest.ServiceCallback<Models.GroupModel>;
    if (!callback) {
      return this.getGroupByIdWithHttpOperationResponse(id, options).then((operationRes: msRest.HttpOperationResponse) => {
        return Promise.resolve(operationRes.bodyAsJson as Models.GroupModel);
      }).catch((err: Error) => {
        return Promise.reject(err);
      });
    } else {
      msRest.promiseToCallback(this.getGroupByIdWithHttpOperationResponse(id, options))((err: Error, data: msRest.HttpOperationResponse) => {
        if (err) {
          return cb(err);
        }
        let result = data.bodyAsJson as Models.GroupModel;
        return cb(err, result, data.request, data.response);
      });
    }
  }

  /**
   * @summary Updates a specified group.
   *
   * @param {number} id The group identifier.
   *
   * @param {GroupBase} model The group model.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @param {ServiceCallback} callback - The callback.
   *
   * @returns {ServiceCallback} callback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {any} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {Response} [response] - The HTTP Response stream if an error did not occur.
   */
  updateGroup(id: number, model: Models.GroupBase): Promise<any>;
  updateGroup(id: number, model: Models.GroupBase, options: msRest.RequestOptionsBase): Promise<any>;
  updateGroup(id: number, model: Models.GroupBase, callback: msRest.ServiceCallback<any>): void;
  updateGroup(id: number, model: Models.GroupBase, options: msRest.RequestOptionsBase, callback: msRest.ServiceCallback<any>): void;
  updateGroup(id: number, model: Models.GroupBase, options?: msRest.RequestOptionsBase, callback?: msRest.ServiceCallback<any>): any {
    if (!callback && typeof options === 'function') {
      callback = options;
      options = undefined;
    }
    let cb = callback as msRest.ServiceCallback<any>;
    if (!callback) {
      return this.updateGroupWithHttpOperationResponse(id, model, options).then((operationRes: msRest.HttpOperationResponse) => {
        return Promise.resolve(operationRes.bodyAsJson as any);
      }).catch((err: Error) => {
        return Promise.reject(err);
      });
    } else {
      msRest.promiseToCallback(this.updateGroupWithHttpOperationResponse(id, model, options))((err: Error, data: msRest.HttpOperationResponse) => {
        if (err) {
          return cb(err);
        }
        let result = data.bodyAsJson as any;
        return cb(err, result, data.request, data.response);
      });
    }
  }

  /**
   * @summary Deactivates a group and removes all group associations.
   *
   * @param {number} id The group identifier.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @param {ServiceCallback} callback - The callback.
   *
   * @returns {ServiceCallback} callback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {any} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {Response} [response] - The HTTP Response stream if an error did not occur.
   */
  deleteGroup(id: number): Promise<any>;
  deleteGroup(id: number, options: msRest.RequestOptionsBase): Promise<any>;
  deleteGroup(id: number, callback: msRest.ServiceCallback<any>): void;
  deleteGroup(id: number, options: msRest.RequestOptionsBase, callback: msRest.ServiceCallback<any>): void;
  deleteGroup(id: number, options?: msRest.RequestOptionsBase, callback?: msRest.ServiceCallback<any>): any {
    if (!callback && typeof options === 'function') {
      callback = options;
      options = undefined;
    }
    let cb = callback as msRest.ServiceCallback<any>;
    if (!callback) {
      return this.deleteGroupWithHttpOperationResponse(id, options).then((operationRes: msRest.HttpOperationResponse) => {
        return Promise.resolve(operationRes.bodyAsJson as any);
      }).catch((err: Error) => {
        return Promise.reject(err);
      });
    } else {
      msRest.promiseToCallback(this.deleteGroupWithHttpOperationResponse(id, options))((err: Error, data: msRest.HttpOperationResponse) => {
        if (err) {
          return cb(err);
        }
        let result = data.bodyAsJson as any;
        return cb(err, result, data.request, data.response);
      });
    }
  }

  /**
   * @summary Gets a paged list of entity links
   *
   * @param {SoftheonEnterpriseAPIGetLinksByFilterOptionalParams} [options]
   * Optional Parameters.
   *
   * @param {ServiceCallback} callback - The callback.
   *
   * @returns {ServiceCallback} callback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {Models.EntityLinkModel[]} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {Response} [response] - The HTTP Response stream if an error did not occur.
   */
  getLinksByFilter(): Promise<Models.EntityLinkModel[]>;
  getLinksByFilter(options: Models.SoftheonEnterpriseAPIGetLinksByFilterOptionalParams): Promise<Models.EntityLinkModel[]>;
  getLinksByFilter(callback: msRest.ServiceCallback<Models.EntityLinkModel[]>): void;
  getLinksByFilter(options: Models.SoftheonEnterpriseAPIGetLinksByFilterOptionalParams, callback: msRest.ServiceCallback<Models.EntityLinkModel[]>): void;
  getLinksByFilter(options?: Models.SoftheonEnterpriseAPIGetLinksByFilterOptionalParams, callback?: msRest.ServiceCallback<Models.EntityLinkModel[]>): any {
    if (!callback && typeof options === 'function') {
      callback = options;
      options = undefined;
    }
    let cb = callback as msRest.ServiceCallback<Models.EntityLinkModel[]>;
    if (!callback) {
      return this.getLinksByFilterWithHttpOperationResponse(options).then((operationRes: msRest.HttpOperationResponse) => {
        return Promise.resolve(operationRes.bodyAsJson as Models.EntityLinkModel[]);
      }).catch((err: Error) => {
        return Promise.reject(err);
      });
    } else {
      msRest.promiseToCallback(this.getLinksByFilterWithHttpOperationResponse(options))((err: Error, data: msRest.HttpOperationResponse) => {
        if (err) {
          return cb(err);
        }
        let result = data.bodyAsJson as Models.EntityLinkModel[];
        return cb(err, result, data.request, data.response);
      });
    }
  }

  /**
   * @summary Gets a link based on its unique identifier.
   *
   * @param {number} drawer The drawer identifier.
   *
   * @param {number} id The link identifier.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @param {ServiceCallback} callback - The callback.
   *
   * @returns {ServiceCallback} callback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {Models.EntityLinkModel} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link Models.EntityLinkModel} for more
   *                      information.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {Response} [response] - The HTTP Response stream if an error did not occur.
   */
  getLinkById(drawer: number, id: number): Promise<Models.EntityLinkModel>;
  getLinkById(drawer: number, id: number, options: msRest.RequestOptionsBase): Promise<Models.EntityLinkModel>;
  getLinkById(drawer: number, id: number, callback: msRest.ServiceCallback<Models.EntityLinkModel>): void;
  getLinkById(drawer: number, id: number, options: msRest.RequestOptionsBase, callback: msRest.ServiceCallback<Models.EntityLinkModel>): void;
  getLinkById(drawer: number, id: number, options?: msRest.RequestOptionsBase, callback?: msRest.ServiceCallback<Models.EntityLinkModel>): any {
    if (!callback && typeof options === 'function') {
      callback = options;
      options = undefined;
    }
    let cb = callback as msRest.ServiceCallback<Models.EntityLinkModel>;
    if (!callback) {
      return this.getLinkByIdWithHttpOperationResponse(drawer, id, options).then((operationRes: msRest.HttpOperationResponse) => {
        return Promise.resolve(operationRes.bodyAsJson as Models.EntityLinkModel);
      }).catch((err: Error) => {
        return Promise.reject(err);
      });
    } else {
      msRest.promiseToCallback(this.getLinkByIdWithHttpOperationResponse(drawer, id, options))((err: Error, data: msRest.HttpOperationResponse) => {
        if (err) {
          return cb(err);
        }
        let result = data.bodyAsJson as Models.EntityLinkModel;
        return cb(err, result, data.request, data.response);
      });
    }
  }

  /**
   * @summary Updates a specified link.
   *
   * @param {number} drawer The drawer identifier.
   *
   * @param {number} id The link identifier.
   *
   * @param {UpdateEntityLinkRequestModel} model The model.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @param {ServiceCallback} callback - The callback.
   *
   * @returns {ServiceCallback} callback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {any} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {Response} [response] - The HTTP Response stream if an error did not occur.
   */
  updateLink(drawer: number, id: number, model: Models.UpdateEntityLinkRequestModel): Promise<any>;
  updateLink(drawer: number, id: number, model: Models.UpdateEntityLinkRequestModel, options: msRest.RequestOptionsBase): Promise<any>;
  updateLink(drawer: number, id: number, model: Models.UpdateEntityLinkRequestModel, callback: msRest.ServiceCallback<any>): void;
  updateLink(drawer: number, id: number, model: Models.UpdateEntityLinkRequestModel, options: msRest.RequestOptionsBase, callback: msRest.ServiceCallback<any>): void;
  updateLink(drawer: number, id: number, model: Models.UpdateEntityLinkRequestModel, options?: msRest.RequestOptionsBase, callback?: msRest.ServiceCallback<any>): any {
    if (!callback && typeof options === 'function') {
      callback = options;
      options = undefined;
    }
    let cb = callback as msRest.ServiceCallback<any>;
    if (!callback) {
      return this.updateLinkWithHttpOperationResponse(drawer, id, model, options).then((operationRes: msRest.HttpOperationResponse) => {
        return Promise.resolve(operationRes.bodyAsJson as any);
      }).catch((err: Error) => {
        return Promise.reject(err);
      });
    } else {
      msRest.promiseToCallback(this.updateLinkWithHttpOperationResponse(drawer, id, model, options))((err: Error, data: msRest.HttpOperationResponse) => {
        if (err) {
          return cb(err);
        }
        let result = data.bodyAsJson as any;
        return cb(err, result, data.request, data.response);
      });
    }
  }

  /**
   * @summary Deletes a specified link.
   *
   * @param {number} drawer The drawer identifier.
   *
   * @param {number} id The link identifier.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @param {ServiceCallback} callback - The callback.
   *
   * @returns {ServiceCallback} callback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {any} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {Response} [response] - The HTTP Response stream if an error did not occur.
   */
  deleteLink(drawer: number, id: number): Promise<any>;
  deleteLink(drawer: number, id: number, options: msRest.RequestOptionsBase): Promise<any>;
  deleteLink(drawer: number, id: number, callback: msRest.ServiceCallback<any>): void;
  deleteLink(drawer: number, id: number, options: msRest.RequestOptionsBase, callback: msRest.ServiceCallback<any>): void;
  deleteLink(drawer: number, id: number, options?: msRest.RequestOptionsBase, callback?: msRest.ServiceCallback<any>): any {
    if (!callback && typeof options === 'function') {
      callback = options;
      options = undefined;
    }
    let cb = callback as msRest.ServiceCallback<any>;
    if (!callback) {
      return this.deleteLinkWithHttpOperationResponse(drawer, id, options).then((operationRes: msRest.HttpOperationResponse) => {
        return Promise.resolve(operationRes.bodyAsJson as any);
      }).catch((err: Error) => {
        return Promise.reject(err);
      });
    } else {
      msRest.promiseToCallback(this.deleteLinkWithHttpOperationResponse(drawer, id, options))((err: Error, data: msRest.HttpOperationResponse) => {
        if (err) {
          return cb(err);
        }
        let result = data.bodyAsJson as any;
        return cb(err, result, data.request, data.response);
      });
    }
  }

  /**
   * @summary Creates a new link.
   *
   * @param {number} drawer The drawer identifier.
   *
   * @param {InsertEntityLinkRequestModel} model The link model.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @param {ServiceCallback} callback - The callback.
   *
   * @returns {ServiceCallback} callback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {Models.EntityLinkModel} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link Models.EntityLinkModel} for more
   *                      information.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {Response} [response] - The HTTP Response stream if an error did not occur.
   */
  createLink(drawer: number, model: Models.InsertEntityLinkRequestModel): Promise<Models.EntityLinkModel>;
  createLink(drawer: number, model: Models.InsertEntityLinkRequestModel, options: msRest.RequestOptionsBase): Promise<Models.EntityLinkModel>;
  createLink(drawer: number, model: Models.InsertEntityLinkRequestModel, callback: msRest.ServiceCallback<Models.EntityLinkModel>): void;
  createLink(drawer: number, model: Models.InsertEntityLinkRequestModel, options: msRest.RequestOptionsBase, callback: msRest.ServiceCallback<Models.EntityLinkModel>): void;
  createLink(drawer: number, model: Models.InsertEntityLinkRequestModel, options?: msRest.RequestOptionsBase, callback?: msRest.ServiceCallback<Models.EntityLinkModel>): any {
    if (!callback && typeof options === 'function') {
      callback = options;
      options = undefined;
    }
    let cb = callback as msRest.ServiceCallback<Models.EntityLinkModel>;
    if (!callback) {
      return this.createLinkWithHttpOperationResponse(drawer, model, options).then((operationRes: msRest.HttpOperationResponse) => {
        return Promise.resolve(operationRes.bodyAsJson as Models.EntityLinkModel);
      }).catch((err: Error) => {
        return Promise.reject(err);
      });
    } else {
      msRest.promiseToCallback(this.createLinkWithHttpOperationResponse(drawer, model, options))((err: Error, data: msRest.HttpOperationResponse) => {
        if (err) {
          return cb(err);
        }
        let result = data.bodyAsJson as Models.EntityLinkModel;
        return cb(err, result, data.request, data.response);
      });
    }
  }

  /**
   * @summary Gets a lock for a single entity based on its unique identifier.
   *
   * @param {number} drawer The drawer identifier.
   *
   * @param {number} id The entity identifier.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @param {ServiceCallback} callback - The callback.
   *
   * @returns {ServiceCallback} callback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {Models.LockModel} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link Models.LockModel} for more information.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {Response} [response] - The HTTP Response stream if an error did not occur.
   */
  getLocksByFilter(drawer: number, id: number): Promise<Models.LockModel>;
  getLocksByFilter(drawer: number, id: number, options: msRest.RequestOptionsBase): Promise<Models.LockModel>;
  getLocksByFilter(drawer: number, id: number, callback: msRest.ServiceCallback<Models.LockModel>): void;
  getLocksByFilter(drawer: number, id: number, options: msRest.RequestOptionsBase, callback: msRest.ServiceCallback<Models.LockModel>): void;
  getLocksByFilter(drawer: number, id: number, options?: msRest.RequestOptionsBase, callback?: msRest.ServiceCallback<Models.LockModel>): any {
    if (!callback && typeof options === 'function') {
      callback = options;
      options = undefined;
    }
    let cb = callback as msRest.ServiceCallback<Models.LockModel>;
    if (!callback) {
      return this.getLocksByFilterWithHttpOperationResponse(drawer, id, options).then((operationRes: msRest.HttpOperationResponse) => {
        return Promise.resolve(operationRes.bodyAsJson as Models.LockModel);
      }).catch((err: Error) => {
        return Promise.reject(err);
      });
    } else {
      msRest.promiseToCallback(this.getLocksByFilterWithHttpOperationResponse(drawer, id, options))((err: Error, data: msRest.HttpOperationResponse) => {
        if (err) {
          return cb(err);
        }
        let result = data.bodyAsJson as Models.LockModel;
        return cb(err, result, data.request, data.response);
      });
    }
  }

  /**
   * @summary Inserts or updates lock on a specified entity.
   *
   * @param {number} drawer The drawer identifier.
   *
   * @param {number} id The entity identifier.
   *
   * @param {UpdateLockRequestModel} model The lock model.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @param {ServiceCallback} callback - The callback.
   *
   * @returns {ServiceCallback} callback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {any} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {Response} [response] - The HTTP Response stream if an error did not occur.
   */
  createOrUpdateLock(drawer: number, id: number, model: Models.UpdateLockRequestModel): Promise<any>;
  createOrUpdateLock(drawer: number, id: number, model: Models.UpdateLockRequestModel, options: msRest.RequestOptionsBase): Promise<any>;
  createOrUpdateLock(drawer: number, id: number, model: Models.UpdateLockRequestModel, callback: msRest.ServiceCallback<any>): void;
  createOrUpdateLock(drawer: number, id: number, model: Models.UpdateLockRequestModel, options: msRest.RequestOptionsBase, callback: msRest.ServiceCallback<any>): void;
  createOrUpdateLock(drawer: number, id: number, model: Models.UpdateLockRequestModel, options?: msRest.RequestOptionsBase, callback?: msRest.ServiceCallback<any>): any {
    if (!callback && typeof options === 'function') {
      callback = options;
      options = undefined;
    }
    let cb = callback as msRest.ServiceCallback<any>;
    if (!callback) {
      return this.createOrUpdateLockWithHttpOperationResponse(drawer, id, model, options).then((operationRes: msRest.HttpOperationResponse) => {
        return Promise.resolve(operationRes.bodyAsJson as any);
      }).catch((err: Error) => {
        return Promise.reject(err);
      });
    } else {
      msRest.promiseToCallback(this.createOrUpdateLockWithHttpOperationResponse(drawer, id, model, options))((err: Error, data: msRest.HttpOperationResponse) => {
        if (err) {
          return cb(err);
        }
        let result = data.bodyAsJson as any;
        return cb(err, result, data.request, data.response);
      });
    }
  }

  /**
   * @summary Deletes a lock on a specified entity.
   *
   * @param {number} drawer The drawer identifier.
   *
   * @param {number} id The entity identifier.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @param {ServiceCallback} callback - The callback.
   *
   * @returns {ServiceCallback} callback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {any} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {Response} [response] - The HTTP Response stream if an error did not occur.
   */
  deleteLock(drawer: number, id: number): Promise<any>;
  deleteLock(drawer: number, id: number, options: msRest.RequestOptionsBase): Promise<any>;
  deleteLock(drawer: number, id: number, callback: msRest.ServiceCallback<any>): void;
  deleteLock(drawer: number, id: number, options: msRest.RequestOptionsBase, callback: msRest.ServiceCallback<any>): void;
  deleteLock(drawer: number, id: number, options?: msRest.RequestOptionsBase, callback?: msRest.ServiceCallback<any>): any {
    if (!callback && typeof options === 'function') {
      callback = options;
      options = undefined;
    }
    let cb = callback as msRest.ServiceCallback<any>;
    if (!callback) {
      return this.deleteLockWithHttpOperationResponse(drawer, id, options).then((operationRes: msRest.HttpOperationResponse) => {
        return Promise.resolve(operationRes.bodyAsJson as any);
      }).catch((err: Error) => {
        return Promise.reject(err);
      });
    } else {
      msRest.promiseToCallback(this.deleteLockWithHttpOperationResponse(drawer, id, options))((err: Error, data: msRest.HttpOperationResponse) => {
        if (err) {
          return cb(err);
        }
        let result = data.bodyAsJson as any;
        return cb(err, result, data.request, data.response);
      });
    }
  }

  /**
   * @summary Gets a paged list of notes.
   *
   * @param {number} drawerID Gets or sets the drawer identifier.
   *
   * @param {SoftheonEnterpriseAPIGetNotesByFilterOptionalParams} [options]
   * Optional Parameters.
   *
   * @param {ServiceCallback} callback - The callback.
   *
   * @returns {ServiceCallback} callback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {Models.NoteModel[]} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {Response} [response] - The HTTP Response stream if an error did not occur.
   */
  getNotesByFilter(drawerID: number): Promise<Models.NoteModel[]>;
  getNotesByFilter(drawerID: number, options: Models.SoftheonEnterpriseAPIGetNotesByFilterOptionalParams): Promise<Models.NoteModel[]>;
  getNotesByFilter(drawerID: number, callback: msRest.ServiceCallback<Models.NoteModel[]>): void;
  getNotesByFilter(drawerID: number, options: Models.SoftheonEnterpriseAPIGetNotesByFilterOptionalParams, callback: msRest.ServiceCallback<Models.NoteModel[]>): void;
  getNotesByFilter(drawerID: number, options?: Models.SoftheonEnterpriseAPIGetNotesByFilterOptionalParams, callback?: msRest.ServiceCallback<Models.NoteModel[]>): any {
    if (!callback && typeof options === 'function') {
      callback = options;
      options = undefined;
    }
    let cb = callback as msRest.ServiceCallback<Models.NoteModel[]>;
    if (!callback) {
      return this.getNotesByFilterWithHttpOperationResponse(drawerID, options).then((operationRes: msRest.HttpOperationResponse) => {
        return Promise.resolve(operationRes.bodyAsJson as Models.NoteModel[]);
      }).catch((err: Error) => {
        return Promise.reject(err);
      });
    } else {
      msRest.promiseToCallback(this.getNotesByFilterWithHttpOperationResponse(drawerID, options))((err: Error, data: msRest.HttpOperationResponse) => {
        if (err) {
          return cb(err);
        }
        let result = data.bodyAsJson as Models.NoteModel[];
        return cb(err, result, data.request, data.response);
      });
    }
  }

  /**
   * @summary Gets a note by its unique identifier.
   *
   * @param {number} drawer The drawer identifier.
   *
   * @param {number} id The note identifier.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @param {ServiceCallback} callback - The callback.
   *
   * @returns {ServiceCallback} callback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {Models.NoteModel} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link Models.NoteModel} for more information.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {Response} [response] - The HTTP Response stream if an error did not occur.
   */
  getNoteById(drawer: number, id: number): Promise<Models.NoteModel>;
  getNoteById(drawer: number, id: number, options: msRest.RequestOptionsBase): Promise<Models.NoteModel>;
  getNoteById(drawer: number, id: number, callback: msRest.ServiceCallback<Models.NoteModel>): void;
  getNoteById(drawer: number, id: number, options: msRest.RequestOptionsBase, callback: msRest.ServiceCallback<Models.NoteModel>): void;
  getNoteById(drawer: number, id: number, options?: msRest.RequestOptionsBase, callback?: msRest.ServiceCallback<Models.NoteModel>): any {
    if (!callback && typeof options === 'function') {
      callback = options;
      options = undefined;
    }
    let cb = callback as msRest.ServiceCallback<Models.NoteModel>;
    if (!callback) {
      return this.getNoteByIdWithHttpOperationResponse(drawer, id, options).then((operationRes: msRest.HttpOperationResponse) => {
        return Promise.resolve(operationRes.bodyAsJson as Models.NoteModel);
      }).catch((err: Error) => {
        return Promise.reject(err);
      });
    } else {
      msRest.promiseToCallback(this.getNoteByIdWithHttpOperationResponse(drawer, id, options))((err: Error, data: msRest.HttpOperationResponse) => {
        if (err) {
          return cb(err);
        }
        let result = data.bodyAsJson as Models.NoteModel;
        return cb(err, result, data.request, data.response);
      });
    }
  }

  /**
   * @summary Updates a specified note.
   *
   * @param {number} drawer The drawer identifier.
   *
   * @param {number} id The note identifier.
   *
   * @param {NoteBase} model The note model.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @param {ServiceCallback} callback - The callback.
   *
   * @returns {ServiceCallback} callback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {any} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {Response} [response] - The HTTP Response stream if an error did not occur.
   */
  updateNote(drawer: number, id: number, model: Models.NoteBase): Promise<any>;
  updateNote(drawer: number, id: number, model: Models.NoteBase, options: msRest.RequestOptionsBase): Promise<any>;
  updateNote(drawer: number, id: number, model: Models.NoteBase, callback: msRest.ServiceCallback<any>): void;
  updateNote(drawer: number, id: number, model: Models.NoteBase, options: msRest.RequestOptionsBase, callback: msRest.ServiceCallback<any>): void;
  updateNote(drawer: number, id: number, model: Models.NoteBase, options?: msRest.RequestOptionsBase, callback?: msRest.ServiceCallback<any>): any {
    if (!callback && typeof options === 'function') {
      callback = options;
      options = undefined;
    }
    let cb = callback as msRest.ServiceCallback<any>;
    if (!callback) {
      return this.updateNoteWithHttpOperationResponse(drawer, id, model, options).then((operationRes: msRest.HttpOperationResponse) => {
        return Promise.resolve(operationRes.bodyAsJson as any);
      }).catch((err: Error) => {
        return Promise.reject(err);
      });
    } else {
      msRest.promiseToCallback(this.updateNoteWithHttpOperationResponse(drawer, id, model, options))((err: Error, data: msRest.HttpOperationResponse) => {
        if (err) {
          return cb(err);
        }
        let result = data.bodyAsJson as any;
        return cb(err, result, data.request, data.response);
      });
    }
  }

  /**
   * @summary Deletes a specified note.
   *
   * @param {number} drawer The drawer identifier.
   *
   * @param {number} id The note identifier.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @param {ServiceCallback} callback - The callback.
   *
   * @returns {ServiceCallback} callback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {any} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {Response} [response] - The HTTP Response stream if an error did not occur.
   */
  deleteNote(drawer: number, id: number): Promise<any>;
  deleteNote(drawer: number, id: number, options: msRest.RequestOptionsBase): Promise<any>;
  deleteNote(drawer: number, id: number, callback: msRest.ServiceCallback<any>): void;
  deleteNote(drawer: number, id: number, options: msRest.RequestOptionsBase, callback: msRest.ServiceCallback<any>): void;
  deleteNote(drawer: number, id: number, options?: msRest.RequestOptionsBase, callback?: msRest.ServiceCallback<any>): any {
    if (!callback && typeof options === 'function') {
      callback = options;
      options = undefined;
    }
    let cb = callback as msRest.ServiceCallback<any>;
    if (!callback) {
      return this.deleteNoteWithHttpOperationResponse(drawer, id, options).then((operationRes: msRest.HttpOperationResponse) => {
        return Promise.resolve(operationRes.bodyAsJson as any);
      }).catch((err: Error) => {
        return Promise.reject(err);
      });
    } else {
      msRest.promiseToCallback(this.deleteNoteWithHttpOperationResponse(drawer, id, options))((err: Error, data: msRest.HttpOperationResponse) => {
        if (err) {
          return cb(err);
        }
        let result = data.bodyAsJson as any;
        return cb(err, result, data.request, data.response);
      });
    }
  }

  /**
   * @summary Creates a new note.
   *
   * @param {number} drawer The drawer identifier.
   *
   * @param {InsertNoteRequestModel} model The note model.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @param {ServiceCallback} callback - The callback.
   *
   * @returns {ServiceCallback} callback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {Models.NoteModel} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link Models.NoteModel} for more information.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {Response} [response] - The HTTP Response stream if an error did not occur.
   */
  createNote(drawer: number, model: Models.InsertNoteRequestModel): Promise<Models.NoteModel>;
  createNote(drawer: number, model: Models.InsertNoteRequestModel, options: msRest.RequestOptionsBase): Promise<Models.NoteModel>;
  createNote(drawer: number, model: Models.InsertNoteRequestModel, callback: msRest.ServiceCallback<Models.NoteModel>): void;
  createNote(drawer: number, model: Models.InsertNoteRequestModel, options: msRest.RequestOptionsBase, callback: msRest.ServiceCallback<Models.NoteModel>): void;
  createNote(drawer: number, model: Models.InsertNoteRequestModel, options?: msRest.RequestOptionsBase, callback?: msRest.ServiceCallback<Models.NoteModel>): any {
    if (!callback && typeof options === 'function') {
      callback = options;
      options = undefined;
    }
    let cb = callback as msRest.ServiceCallback<Models.NoteModel>;
    if (!callback) {
      return this.createNoteWithHttpOperationResponse(drawer, model, options).then((operationRes: msRest.HttpOperationResponse) => {
        return Promise.resolve(operationRes.bodyAsJson as Models.NoteModel);
      }).catch((err: Error) => {
        return Promise.reject(err);
      });
    } else {
      msRest.promiseToCallback(this.createNoteWithHttpOperationResponse(drawer, model, options))((err: Error, data: msRest.HttpOperationResponse) => {
        if (err) {
          return cb(err);
        }
        let result = data.bodyAsJson as Models.NoteModel;
        return cb(err, result, data.request, data.response);
      });
    }
  }

  /**
   * @summary Gets a paged list of queue assignments.
   *
   * @param {SoftheonEnterpriseAPIGetQueueAssignmentsByFilterOptionalParams}
   * [options] Optional Parameters.
   *
   * @param {ServiceCallback} callback - The callback.
   *
   * @returns {ServiceCallback} callback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {Models.QueueAssignmentModel[]} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {Response} [response] - The HTTP Response stream if an error did not occur.
   */
  getQueueAssignmentsByFilter(): Promise<Models.QueueAssignmentModel[]>;
  getQueueAssignmentsByFilter(options: Models.SoftheonEnterpriseAPIGetQueueAssignmentsByFilterOptionalParams): Promise<Models.QueueAssignmentModel[]>;
  getQueueAssignmentsByFilter(callback: msRest.ServiceCallback<Models.QueueAssignmentModel[]>): void;
  getQueueAssignmentsByFilter(options: Models.SoftheonEnterpriseAPIGetQueueAssignmentsByFilterOptionalParams, callback: msRest.ServiceCallback<Models.QueueAssignmentModel[]>): void;
  getQueueAssignmentsByFilter(options?: Models.SoftheonEnterpriseAPIGetQueueAssignmentsByFilterOptionalParams, callback?: msRest.ServiceCallback<Models.QueueAssignmentModel[]>): any {
    if (!callback && typeof options === 'function') {
      callback = options;
      options = undefined;
    }
    let cb = callback as msRest.ServiceCallback<Models.QueueAssignmentModel[]>;
    if (!callback) {
      return this.getQueueAssignmentsByFilterWithHttpOperationResponse(options).then((operationRes: msRest.HttpOperationResponse) => {
        return Promise.resolve(operationRes.bodyAsJson as Models.QueueAssignmentModel[]);
      }).catch((err: Error) => {
        return Promise.reject(err);
      });
    } else {
      msRest.promiseToCallback(this.getQueueAssignmentsByFilterWithHttpOperationResponse(options))((err: Error, data: msRest.HttpOperationResponse) => {
        if (err) {
          return cb(err);
        }
        let result = data.bodyAsJson as Models.QueueAssignmentModel[];
        return cb(err, result, data.request, data.response);
      });
    }
  }

  /**
   * @summary Updates the specified queue assignment.
   *
   * @param {QueueAssignmentModel} model The model.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @param {ServiceCallback} callback - The callback.
   *
   * @returns {ServiceCallback} callback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {any} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {Response} [response] - The HTTP Response stream if an error did not occur.
   */
  updateQueueAssignemnt(model: Models.QueueAssignmentModel): Promise<any>;
  updateQueueAssignemnt(model: Models.QueueAssignmentModel, options: msRest.RequestOptionsBase): Promise<any>;
  updateQueueAssignemnt(model: Models.QueueAssignmentModel, callback: msRest.ServiceCallback<any>): void;
  updateQueueAssignemnt(model: Models.QueueAssignmentModel, options: msRest.RequestOptionsBase, callback: msRest.ServiceCallback<any>): void;
  updateQueueAssignemnt(model: Models.QueueAssignmentModel, options?: msRest.RequestOptionsBase, callback?: msRest.ServiceCallback<any>): any {
    if (!callback && typeof options === 'function') {
      callback = options;
      options = undefined;
    }
    let cb = callback as msRest.ServiceCallback<any>;
    if (!callback) {
      return this.updateQueueAssignemntWithHttpOperationResponse(model, options).then((operationRes: msRest.HttpOperationResponse) => {
        return Promise.resolve(operationRes.bodyAsJson as any);
      }).catch((err: Error) => {
        return Promise.reject(err);
      });
    } else {
      msRest.promiseToCallback(this.updateQueueAssignemntWithHttpOperationResponse(model, options))((err: Error, data: msRest.HttpOperationResponse) => {
        if (err) {
          return cb(err);
        }
        let result = data.bodyAsJson as any;
        return cb(err, result, data.request, data.response);
      });
    }
  }

  /**
   * @summary Creates a new queue assignment.
   *
   * @param {InsertQueueAssignmentRequestModel} model The model.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @param {ServiceCallback} callback - The callback.
   *
   * @returns {ServiceCallback} callback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {Models.QueueAssignmentModel} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link Models.QueueAssignmentModel} for more
   *                      information.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {Response} [response] - The HTTP Response stream if an error did not occur.
   */
  createQueueAssignment(model: Models.InsertQueueAssignmentRequestModel): Promise<Models.QueueAssignmentModel>;
  createQueueAssignment(model: Models.InsertQueueAssignmentRequestModel, options: msRest.RequestOptionsBase): Promise<Models.QueueAssignmentModel>;
  createQueueAssignment(model: Models.InsertQueueAssignmentRequestModel, callback: msRest.ServiceCallback<Models.QueueAssignmentModel>): void;
  createQueueAssignment(model: Models.InsertQueueAssignmentRequestModel, options: msRest.RequestOptionsBase, callback: msRest.ServiceCallback<Models.QueueAssignmentModel>): void;
  createQueueAssignment(model: Models.InsertQueueAssignmentRequestModel, options?: msRest.RequestOptionsBase, callback?: msRest.ServiceCallback<Models.QueueAssignmentModel>): any {
    if (!callback && typeof options === 'function') {
      callback = options;
      options = undefined;
    }
    let cb = callback as msRest.ServiceCallback<Models.QueueAssignmentModel>;
    if (!callback) {
      return this.createQueueAssignmentWithHttpOperationResponse(model, options).then((operationRes: msRest.HttpOperationResponse) => {
        return Promise.resolve(operationRes.bodyAsJson as Models.QueueAssignmentModel);
      }).catch((err: Error) => {
        return Promise.reject(err);
      });
    } else {
      msRest.promiseToCallback(this.createQueueAssignmentWithHttpOperationResponse(model, options))((err: Error, data: msRest.HttpOperationResponse) => {
        if (err) {
          return cb(err);
        }
        let result = data.bodyAsJson as Models.QueueAssignmentModel;
        return cb(err, result, data.request, data.response);
      });
    }
  }

  /**
   * @summary Gets a single queue assignment based on user and queue identifiers.
   *
   * @param {number} userId The user identifier.
   *
   * @param {number} queueId The queue identifier.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @param {ServiceCallback} callback - The callback.
   *
   * @returns {ServiceCallback} callback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {Models.QueueAssignmentModel} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link Models.QueueAssignmentModel} for more
   *                      information.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {Response} [response] - The HTTP Response stream if an error did not occur.
   */
  getQueueAssignmentsById(userId: number, queueId: number): Promise<Models.QueueAssignmentModel>;
  getQueueAssignmentsById(userId: number, queueId: number, options: msRest.RequestOptionsBase): Promise<Models.QueueAssignmentModel>;
  getQueueAssignmentsById(userId: number, queueId: number, callback: msRest.ServiceCallback<Models.QueueAssignmentModel>): void;
  getQueueAssignmentsById(userId: number, queueId: number, options: msRest.RequestOptionsBase, callback: msRest.ServiceCallback<Models.QueueAssignmentModel>): void;
  getQueueAssignmentsById(userId: number, queueId: number, options?: msRest.RequestOptionsBase, callback?: msRest.ServiceCallback<Models.QueueAssignmentModel>): any {
    if (!callback && typeof options === 'function') {
      callback = options;
      options = undefined;
    }
    let cb = callback as msRest.ServiceCallback<Models.QueueAssignmentModel>;
    if (!callback) {
      return this.getQueueAssignmentsByIdWithHttpOperationResponse(userId, queueId, options).then((operationRes: msRest.HttpOperationResponse) => {
        return Promise.resolve(operationRes.bodyAsJson as Models.QueueAssignmentModel);
      }).catch((err: Error) => {
        return Promise.reject(err);
      });
    } else {
      msRest.promiseToCallback(this.getQueueAssignmentsByIdWithHttpOperationResponse(userId, queueId, options))((err: Error, data: msRest.HttpOperationResponse) => {
        if (err) {
          return cb(err);
        }
        let result = data.bodyAsJson as Models.QueueAssignmentModel;
        return cb(err, result, data.request, data.response);
      });
    }
  }

  /**
   * @summary Deletes the specified queue assignment.
   *
   * @param {number} userId The user identifier.
   *
   * @param {number} queueId The queue identifier.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @param {ServiceCallback} callback - The callback.
   *
   * @returns {ServiceCallback} callback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {any} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {Response} [response] - The HTTP Response stream if an error did not occur.
   */
  deleteQueueAssignment(userId: number, queueId: number): Promise<any>;
  deleteQueueAssignment(userId: number, queueId: number, options: msRest.RequestOptionsBase): Promise<any>;
  deleteQueueAssignment(userId: number, queueId: number, callback: msRest.ServiceCallback<any>): void;
  deleteQueueAssignment(userId: number, queueId: number, options: msRest.RequestOptionsBase, callback: msRest.ServiceCallback<any>): void;
  deleteQueueAssignment(userId: number, queueId: number, options?: msRest.RequestOptionsBase, callback?: msRest.ServiceCallback<any>): any {
    if (!callback && typeof options === 'function') {
      callback = options;
      options = undefined;
    }
    let cb = callback as msRest.ServiceCallback<any>;
    if (!callback) {
      return this.deleteQueueAssignmentWithHttpOperationResponse(userId, queueId, options).then((operationRes: msRest.HttpOperationResponse) => {
        return Promise.resolve(operationRes.bodyAsJson as any);
      }).catch((err: Error) => {
        return Promise.reject(err);
      });
    } else {
      msRest.promiseToCallback(this.deleteQueueAssignmentWithHttpOperationResponse(userId, queueId, options))((err: Error, data: msRest.HttpOperationResponse) => {
        if (err) {
          return cb(err);
        }
        let result = data.bodyAsJson as any;
        return cb(err, result, data.request, data.response);
      });
    }
  }

  /**
   * @summary Gets a paged list of queues.
   *
   * @param {SoftheonEnterpriseAPIGetQueuesByFilterOptionalParams} [options]
   * Optional Parameters.
   *
   * @param {ServiceCallback} callback - The callback.
   *
   * @returns {ServiceCallback} callback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {Models.QueueModel[]} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {Response} [response] - The HTTP Response stream if an error did not occur.
   */
  getQueuesByFilter(): Promise<Models.QueueModel[]>;
  getQueuesByFilter(options: Models.SoftheonEnterpriseAPIGetQueuesByFilterOptionalParams): Promise<Models.QueueModel[]>;
  getQueuesByFilter(callback: msRest.ServiceCallback<Models.QueueModel[]>): void;
  getQueuesByFilter(options: Models.SoftheonEnterpriseAPIGetQueuesByFilterOptionalParams, callback: msRest.ServiceCallback<Models.QueueModel[]>): void;
  getQueuesByFilter(options?: Models.SoftheonEnterpriseAPIGetQueuesByFilterOptionalParams, callback?: msRest.ServiceCallback<Models.QueueModel[]>): any {
    if (!callback && typeof options === 'function') {
      callback = options;
      options = undefined;
    }
    let cb = callback as msRest.ServiceCallback<Models.QueueModel[]>;
    if (!callback) {
      return this.getQueuesByFilterWithHttpOperationResponse(options).then((operationRes: msRest.HttpOperationResponse) => {
        return Promise.resolve(operationRes.bodyAsJson as Models.QueueModel[]);
      }).catch((err: Error) => {
        return Promise.reject(err);
      });
    } else {
      msRest.promiseToCallback(this.getQueuesByFilterWithHttpOperationResponse(options))((err: Error, data: msRest.HttpOperationResponse) => {
        if (err) {
          return cb(err);
        }
        let result = data.bodyAsJson as Models.QueueModel[];
        return cb(err, result, data.request, data.response);
      });
    }
  }

  /**
   * @summary Creates a new queue.
   *
   * @param {InsertQueueRequestModel} model The queue model.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @param {ServiceCallback} callback - The callback.
   *
   * @returns {ServiceCallback} callback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {Models.QueueModel} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link Models.QueueModel} for more information.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {Response} [response] - The HTTP Response stream if an error did not occur.
   */
  createQueue(model: Models.InsertQueueRequestModel): Promise<Models.QueueModel>;
  createQueue(model: Models.InsertQueueRequestModel, options: msRest.RequestOptionsBase): Promise<Models.QueueModel>;
  createQueue(model: Models.InsertQueueRequestModel, callback: msRest.ServiceCallback<Models.QueueModel>): void;
  createQueue(model: Models.InsertQueueRequestModel, options: msRest.RequestOptionsBase, callback: msRest.ServiceCallback<Models.QueueModel>): void;
  createQueue(model: Models.InsertQueueRequestModel, options?: msRest.RequestOptionsBase, callback?: msRest.ServiceCallback<Models.QueueModel>): any {
    if (!callback && typeof options === 'function') {
      callback = options;
      options = undefined;
    }
    let cb = callback as msRest.ServiceCallback<Models.QueueModel>;
    if (!callback) {
      return this.createQueueWithHttpOperationResponse(model, options).then((operationRes: msRest.HttpOperationResponse) => {
        return Promise.resolve(operationRes.bodyAsJson as Models.QueueModel);
      }).catch((err: Error) => {
        return Promise.reject(err);
      });
    } else {
      msRest.promiseToCallback(this.createQueueWithHttpOperationResponse(model, options))((err: Error, data: msRest.HttpOperationResponse) => {
        if (err) {
          return cb(err);
        }
        let result = data.bodyAsJson as Models.QueueModel;
        return cb(err, result, data.request, data.response);
      });
    }
  }

  /**
   * @summary Gets a single queue by its unique identifier.
   *
   * @param {number} id The queue identifier.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @param {ServiceCallback} callback - The callback.
   *
   * @returns {ServiceCallback} callback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {Models.QueueModel} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link Models.QueueModel} for more information.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {Response} [response] - The HTTP Response stream if an error did not occur.
   */
  getQueueById(id: number): Promise<Models.QueueModel>;
  getQueueById(id: number, options: msRest.RequestOptionsBase): Promise<Models.QueueModel>;
  getQueueById(id: number, callback: msRest.ServiceCallback<Models.QueueModel>): void;
  getQueueById(id: number, options: msRest.RequestOptionsBase, callback: msRest.ServiceCallback<Models.QueueModel>): void;
  getQueueById(id: number, options?: msRest.RequestOptionsBase, callback?: msRest.ServiceCallback<Models.QueueModel>): any {
    if (!callback && typeof options === 'function') {
      callback = options;
      options = undefined;
    }
    let cb = callback as msRest.ServiceCallback<Models.QueueModel>;
    if (!callback) {
      return this.getQueueByIdWithHttpOperationResponse(id, options).then((operationRes: msRest.HttpOperationResponse) => {
        return Promise.resolve(operationRes.bodyAsJson as Models.QueueModel);
      }).catch((err: Error) => {
        return Promise.reject(err);
      });
    } else {
      msRest.promiseToCallback(this.getQueueByIdWithHttpOperationResponse(id, options))((err: Error, data: msRest.HttpOperationResponse) => {
        if (err) {
          return cb(err);
        }
        let result = data.bodyAsJson as Models.QueueModel;
        return cb(err, result, data.request, data.response);
      });
    }
  }

  /**
   * @summary Updates a specified queue.
   *
   * @param {number} id The unique queue identifier.
   *
   * @param {QueueBase} model The queue model.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @param {ServiceCallback} callback - The callback.
   *
   * @returns {ServiceCallback} callback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {any} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {Response} [response] - The HTTP Response stream if an error did not occur.
   */
  updateQueue(id: number, model: Models.QueueBase): Promise<any>;
  updateQueue(id: number, model: Models.QueueBase, options: msRest.RequestOptionsBase): Promise<any>;
  updateQueue(id: number, model: Models.QueueBase, callback: msRest.ServiceCallback<any>): void;
  updateQueue(id: number, model: Models.QueueBase, options: msRest.RequestOptionsBase, callback: msRest.ServiceCallback<any>): void;
  updateQueue(id: number, model: Models.QueueBase, options?: msRest.RequestOptionsBase, callback?: msRest.ServiceCallback<any>): any {
    if (!callback && typeof options === 'function') {
      callback = options;
      options = undefined;
    }
    let cb = callback as msRest.ServiceCallback<any>;
    if (!callback) {
      return this.updateQueueWithHttpOperationResponse(id, model, options).then((operationRes: msRest.HttpOperationResponse) => {
        return Promise.resolve(operationRes.bodyAsJson as any);
      }).catch((err: Error) => {
        return Promise.reject(err);
      });
    } else {
      msRest.promiseToCallback(this.updateQueueWithHttpOperationResponse(id, model, options))((err: Error, data: msRest.HttpOperationResponse) => {
        if (err) {
          return cb(err);
        }
        let result = data.bodyAsJson as any;
        return cb(err, result, data.request, data.response);
      });
    }
  }

  /**
   * @summary Deletes a specified queue.
   *
   * @param {number} id The queue identifier.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @param {ServiceCallback} callback - The callback.
   *
   * @returns {ServiceCallback} callback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {any} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {Response} [response] - The HTTP Response stream if an error did not occur.
   */
  deleteQueue(id: number): Promise<any>;
  deleteQueue(id: number, options: msRest.RequestOptionsBase): Promise<any>;
  deleteQueue(id: number, callback: msRest.ServiceCallback<any>): void;
  deleteQueue(id: number, options: msRest.RequestOptionsBase, callback: msRest.ServiceCallback<any>): void;
  deleteQueue(id: number, options?: msRest.RequestOptionsBase, callback?: msRest.ServiceCallback<any>): any {
    if (!callback && typeof options === 'function') {
      callback = options;
      options = undefined;
    }
    let cb = callback as msRest.ServiceCallback<any>;
    if (!callback) {
      return this.deleteQueueWithHttpOperationResponse(id, options).then((operationRes: msRest.HttpOperationResponse) => {
        return Promise.resolve(operationRes.bodyAsJson as any);
      }).catch((err: Error) => {
        return Promise.reject(err);
      });
    } else {
      msRest.promiseToCallback(this.deleteQueueWithHttpOperationResponse(id, options))((err: Error, data: msRest.HttpOperationResponse) => {
        if (err) {
          return cb(err);
        }
        let result = data.bodyAsJson as any;
        return cb(err, result, data.request, data.response);
      });
    }
  }

  /**
   * @summary Gets a single queue by its name.
   *
   * @param {string} name The queue name.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @param {ServiceCallback} callback - The callback.
   *
   * @returns {ServiceCallback} callback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {Models.QueueModel} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link Models.QueueModel} for more information.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {Response} [response] - The HTTP Response stream if an error did not occur.
   */
  getQueueByName(name: string): Promise<Models.QueueModel>;
  getQueueByName(name: string, options: msRest.RequestOptionsBase): Promise<Models.QueueModel>;
  getQueueByName(name: string, callback: msRest.ServiceCallback<Models.QueueModel>): void;
  getQueueByName(name: string, options: msRest.RequestOptionsBase, callback: msRest.ServiceCallback<Models.QueueModel>): void;
  getQueueByName(name: string, options?: msRest.RequestOptionsBase, callback?: msRest.ServiceCallback<Models.QueueModel>): any {
    if (!callback && typeof options === 'function') {
      callback = options;
      options = undefined;
    }
    let cb = callback as msRest.ServiceCallback<Models.QueueModel>;
    if (!callback) {
      return this.getQueueByNameWithHttpOperationResponse(name, options).then((operationRes: msRest.HttpOperationResponse) => {
        return Promise.resolve(operationRes.bodyAsJson as Models.QueueModel);
      }).catch((err: Error) => {
        return Promise.reject(err);
      });
    } else {
      msRest.promiseToCallback(this.getQueueByNameWithHttpOperationResponse(name, options))((err: Error, data: msRest.HttpOperationResponse) => {
        if (err) {
          return cb(err);
        }
        let result = data.bodyAsJson as Models.QueueModel;
        return cb(err, result, data.request, data.response);
      });
    }
  }

  /**
   * @summary Gets a paged list of tasks.
   *
   * @param {SoftheonEnterpriseAPIGetTasksByFilterOptionalParams} [options]
   * Optional Parameters.
   *
   * @param {ServiceCallback} callback - The callback.
   *
   * @returns {ServiceCallback} callback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {Models.TaskModel[]} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {Response} [response] - The HTTP Response stream if an error did not occur.
   */
  getTasksByFilter(): Promise<Models.TaskModel[]>;
  getTasksByFilter(options: Models.SoftheonEnterpriseAPIGetTasksByFilterOptionalParams): Promise<Models.TaskModel[]>;
  getTasksByFilter(callback: msRest.ServiceCallback<Models.TaskModel[]>): void;
  getTasksByFilter(options: Models.SoftheonEnterpriseAPIGetTasksByFilterOptionalParams, callback: msRest.ServiceCallback<Models.TaskModel[]>): void;
  getTasksByFilter(options?: Models.SoftheonEnterpriseAPIGetTasksByFilterOptionalParams, callback?: msRest.ServiceCallback<Models.TaskModel[]>): any {
    if (!callback && typeof options === 'function') {
      callback = options;
      options = undefined;
    }
    let cb = callback as msRest.ServiceCallback<Models.TaskModel[]>;
    if (!callback) {
      return this.getTasksByFilterWithHttpOperationResponse(options).then((operationRes: msRest.HttpOperationResponse) => {
        return Promise.resolve(operationRes.bodyAsJson as Models.TaskModel[]);
      }).catch((err: Error) => {
        return Promise.reject(err);
      });
    } else {
      msRest.promiseToCallback(this.getTasksByFilterWithHttpOperationResponse(options))((err: Error, data: msRest.HttpOperationResponse) => {
        if (err) {
          return cb(err);
        }
        let result = data.bodyAsJson as Models.TaskModel[];
        return cb(err, result, data.request, data.response);
      });
    }
  }

  /**
   * @summary Creates a new task.
   *
   * @param {InsertTaskRequestModel} model The task model.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @param {ServiceCallback} callback - The callback.
   *
   * @returns {ServiceCallback} callback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {any} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {Response} [response] - The HTTP Response stream if an error did not occur.
   */
  createTask(model: Models.InsertTaskRequestModel): Promise<any>;
  createTask(model: Models.InsertTaskRequestModel, options: msRest.RequestOptionsBase): Promise<any>;
  createTask(model: Models.InsertTaskRequestModel, callback: msRest.ServiceCallback<any>): void;
  createTask(model: Models.InsertTaskRequestModel, options: msRest.RequestOptionsBase, callback: msRest.ServiceCallback<any>): void;
  createTask(model: Models.InsertTaskRequestModel, options?: msRest.RequestOptionsBase, callback?: msRest.ServiceCallback<any>): any {
    if (!callback && typeof options === 'function') {
      callback = options;
      options = undefined;
    }
    let cb = callback as msRest.ServiceCallback<any>;
    if (!callback) {
      return this.createTaskWithHttpOperationResponse(model, options).then((operationRes: msRest.HttpOperationResponse) => {
        return Promise.resolve(operationRes.bodyAsJson as any);
      }).catch((err: Error) => {
        return Promise.reject(err);
      });
    } else {
      msRest.promiseToCallback(this.createTaskWithHttpOperationResponse(model, options))((err: Error, data: msRest.HttpOperationResponse) => {
        if (err) {
          return cb(err);
        }
        let result = data.bodyAsJson as any;
        return cb(err, result, data.request, data.response);
      });
    }
  }

  /**
   * @summary Gets a single task based on its unique identifier.
   *
   * @param {number} id The identifier.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @param {ServiceCallback} callback - The callback.
   *
   * @returns {ServiceCallback} callback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {Models.TaskModel} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link Models.TaskModel} for more information.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {Response} [response] - The HTTP Response stream if an error did not occur.
   */
  getTaskById(id: number): Promise<Models.TaskModel>;
  getTaskById(id: number, options: msRest.RequestOptionsBase): Promise<Models.TaskModel>;
  getTaskById(id: number, callback: msRest.ServiceCallback<Models.TaskModel>): void;
  getTaskById(id: number, options: msRest.RequestOptionsBase, callback: msRest.ServiceCallback<Models.TaskModel>): void;
  getTaskById(id: number, options?: msRest.RequestOptionsBase, callback?: msRest.ServiceCallback<Models.TaskModel>): any {
    if (!callback && typeof options === 'function') {
      callback = options;
      options = undefined;
    }
    let cb = callback as msRest.ServiceCallback<Models.TaskModel>;
    if (!callback) {
      return this.getTaskByIdWithHttpOperationResponse(id, options).then((operationRes: msRest.HttpOperationResponse) => {
        return Promise.resolve(operationRes.bodyAsJson as Models.TaskModel);
      }).catch((err: Error) => {
        return Promise.reject(err);
      });
    } else {
      msRest.promiseToCallback(this.getTaskByIdWithHttpOperationResponse(id, options))((err: Error, data: msRest.HttpOperationResponse) => {
        if (err) {
          return cb(err);
        }
        let result = data.bodyAsJson as Models.TaskModel;
        return cb(err, result, data.request, data.response);
      });
    }
  }

  /**
   * @summary Updates a specified task.
   *
   * @param {number} id The identifier.
   *
   * @param {TaskBase} model The task model.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @param {ServiceCallback} callback - The callback.
   *
   * @returns {ServiceCallback} callback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {any} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {Response} [response] - The HTTP Response stream if an error did not occur.
   */
  updateTask(id: number, model: Models.TaskBase): Promise<any>;
  updateTask(id: number, model: Models.TaskBase, options: msRest.RequestOptionsBase): Promise<any>;
  updateTask(id: number, model: Models.TaskBase, callback: msRest.ServiceCallback<any>): void;
  updateTask(id: number, model: Models.TaskBase, options: msRest.RequestOptionsBase, callback: msRest.ServiceCallback<any>): void;
  updateTask(id: number, model: Models.TaskBase, options?: msRest.RequestOptionsBase, callback?: msRest.ServiceCallback<any>): any {
    if (!callback && typeof options === 'function') {
      callback = options;
      options = undefined;
    }
    let cb = callback as msRest.ServiceCallback<any>;
    if (!callback) {
      return this.updateTaskWithHttpOperationResponse(id, model, options).then((operationRes: msRest.HttpOperationResponse) => {
        return Promise.resolve(operationRes.bodyAsJson as any);
      }).catch((err: Error) => {
        return Promise.reject(err);
      });
    } else {
      msRest.promiseToCallback(this.updateTaskWithHttpOperationResponse(id, model, options))((err: Error, data: msRest.HttpOperationResponse) => {
        if (err) {
          return cb(err);
        }
        let result = data.bodyAsJson as any;
        return cb(err, result, data.request, data.response);
      });
    }
  }

  /**
   * @summary Deletes a specified task.
   *
   * @param {number} id The identifier.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @param {ServiceCallback} callback - The callback.
   *
   * @returns {ServiceCallback} callback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {any} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {Response} [response] - The HTTP Response stream if an error did not occur.
   */
  deleteTask(id: number): Promise<any>;
  deleteTask(id: number, options: msRest.RequestOptionsBase): Promise<any>;
  deleteTask(id: number, callback: msRest.ServiceCallback<any>): void;
  deleteTask(id: number, options: msRest.RequestOptionsBase, callback: msRest.ServiceCallback<any>): void;
  deleteTask(id: number, options?: msRest.RequestOptionsBase, callback?: msRest.ServiceCallback<any>): any {
    if (!callback && typeof options === 'function') {
      callback = options;
      options = undefined;
    }
    let cb = callback as msRest.ServiceCallback<any>;
    if (!callback) {
      return this.deleteTaskWithHttpOperationResponse(id, options).then((operationRes: msRest.HttpOperationResponse) => {
        return Promise.resolve(operationRes.bodyAsJson as any);
      }).catch((err: Error) => {
        return Promise.reject(err);
      });
    } else {
      msRest.promiseToCallback(this.deleteTaskWithHttpOperationResponse(id, options))((err: Error, data: msRest.HttpOperationResponse) => {
        if (err) {
          return cb(err);
        }
        let result = data.bodyAsJson as any;
        return cb(err, result, data.request, data.response);
      });
    }
  }

  /**
   * @summary Gets a single task based on user predefined queue assignment
   * criteria.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @param {ServiceCallback} callback - The callback.
   *
   * @returns {ServiceCallback} callback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {Models.TaskModel} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link Models.TaskModel} for more information.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {Response} [response] - The HTTP Response stream if an error did not occur.
   */
  fetchTaskFromQueueAssignment(): Promise<Models.TaskModel>;
  fetchTaskFromQueueAssignment(options: msRest.RequestOptionsBase): Promise<Models.TaskModel>;
  fetchTaskFromQueueAssignment(callback: msRest.ServiceCallback<Models.TaskModel>): void;
  fetchTaskFromQueueAssignment(options: msRest.RequestOptionsBase, callback: msRest.ServiceCallback<Models.TaskModel>): void;
  fetchTaskFromQueueAssignment(options?: msRest.RequestOptionsBase, callback?: msRest.ServiceCallback<Models.TaskModel>): any {
    if (!callback && typeof options === 'function') {
      callback = options;
      options = undefined;
    }
    let cb = callback as msRest.ServiceCallback<Models.TaskModel>;
    if (!callback) {
      return this.fetchTaskFromQueueAssignmentWithHttpOperationResponse(options).then((operationRes: msRest.HttpOperationResponse) => {
        return Promise.resolve(operationRes.bodyAsJson as Models.TaskModel);
      }).catch((err: Error) => {
        return Promise.reject(err);
      });
    } else {
      msRest.promiseToCallback(this.fetchTaskFromQueueAssignmentWithHttpOperationResponse(options))((err: Error, data: msRest.HttpOperationResponse) => {
        if (err) {
          return cb(err);
        }
        let result = data.bodyAsJson as Models.TaskModel;
        return cb(err, result, data.request, data.response);
      });
    }
  }

  /**
   * @summary Gets a paged list of users.Gets a paged list of users.
   *
   * @param {SoftheonEnterpriseAPIGetUsersByFilterOptionalParams} [options]
   * Optional Parameters.
   *
   * @param {ServiceCallback} callback - The callback.
   *
   * @returns {ServiceCallback} callback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {Models.UserModel[]} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {Response} [response] - The HTTP Response stream if an error did not occur.
   */
  getUsersByFilter(): Promise<Models.UserModel[]>;
  getUsersByFilter(options: Models.SoftheonEnterpriseAPIGetUsersByFilterOptionalParams): Promise<Models.UserModel[]>;
  getUsersByFilter(callback: msRest.ServiceCallback<Models.UserModel[]>): void;
  getUsersByFilter(options: Models.SoftheonEnterpriseAPIGetUsersByFilterOptionalParams, callback: msRest.ServiceCallback<Models.UserModel[]>): void;
  getUsersByFilter(options?: Models.SoftheonEnterpriseAPIGetUsersByFilterOptionalParams, callback?: msRest.ServiceCallback<Models.UserModel[]>): any {
    if (!callback && typeof options === 'function') {
      callback = options;
      options = undefined;
    }
    let cb = callback as msRest.ServiceCallback<Models.UserModel[]>;
    if (!callback) {
      return this.getUsersByFilterWithHttpOperationResponse(options).then((operationRes: msRest.HttpOperationResponse) => {
        return Promise.resolve(operationRes.bodyAsJson as Models.UserModel[]);
      }).catch((err: Error) => {
        return Promise.reject(err);
      });
    } else {
      msRest.promiseToCallback(this.getUsersByFilterWithHttpOperationResponse(options))((err: Error, data: msRest.HttpOperationResponse) => {
        if (err) {
          return cb(err);
        }
        let result = data.bodyAsJson as Models.UserModel[];
        return cb(err, result, data.request, data.response);
      });
    }
  }

  /**
   * @summary Creates a new user.
   *
   * @param {InsertUserRequestModel} model The user model.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @param {ServiceCallback} callback - The callback.
   *
   * @returns {ServiceCallback} callback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {Models.UserModel} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link Models.UserModel} for more information.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {Response} [response] - The HTTP Response stream if an error did not occur.
   */
  createUser(model: Models.InsertUserRequestModel): Promise<Models.UserModel>;
  createUser(model: Models.InsertUserRequestModel, options: msRest.RequestOptionsBase): Promise<Models.UserModel>;
  createUser(model: Models.InsertUserRequestModel, callback: msRest.ServiceCallback<Models.UserModel>): void;
  createUser(model: Models.InsertUserRequestModel, options: msRest.RequestOptionsBase, callback: msRest.ServiceCallback<Models.UserModel>): void;
  createUser(model: Models.InsertUserRequestModel, options?: msRest.RequestOptionsBase, callback?: msRest.ServiceCallback<Models.UserModel>): any {
    if (!callback && typeof options === 'function') {
      callback = options;
      options = undefined;
    }
    let cb = callback as msRest.ServiceCallback<Models.UserModel>;
    if (!callback) {
      return this.createUserWithHttpOperationResponse(model, options).then((operationRes: msRest.HttpOperationResponse) => {
        return Promise.resolve(operationRes.bodyAsJson as Models.UserModel);
      }).catch((err: Error) => {
        return Promise.reject(err);
      });
    } else {
      msRest.promiseToCallback(this.createUserWithHttpOperationResponse(model, options))((err: Error, data: msRest.HttpOperationResponse) => {
        if (err) {
          return cb(err);
        }
        let result = data.bodyAsJson as Models.UserModel;
        return cb(err, result, data.request, data.response);
      });
    }
  }

  /**
   * @summary Gets a single user by its unique identifier.
   *
   * @param {number} id The user identifier.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @param {ServiceCallback} callback - The callback.
   *
   * @returns {ServiceCallback} callback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {Models.UserModel} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link Models.UserModel} for more information.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {Response} [response] - The HTTP Response stream if an error did not occur.
   */
  getUserById(id: number): Promise<Models.UserModel>;
  getUserById(id: number, options: msRest.RequestOptionsBase): Promise<Models.UserModel>;
  getUserById(id: number, callback: msRest.ServiceCallback<Models.UserModel>): void;
  getUserById(id: number, options: msRest.RequestOptionsBase, callback: msRest.ServiceCallback<Models.UserModel>): void;
  getUserById(id: number, options?: msRest.RequestOptionsBase, callback?: msRest.ServiceCallback<Models.UserModel>): any {
    if (!callback && typeof options === 'function') {
      callback = options;
      options = undefined;
    }
    let cb = callback as msRest.ServiceCallback<Models.UserModel>;
    if (!callback) {
      return this.getUserByIdWithHttpOperationResponse(id, options).then((operationRes: msRest.HttpOperationResponse) => {
        return Promise.resolve(operationRes.bodyAsJson as Models.UserModel);
      }).catch((err: Error) => {
        return Promise.reject(err);
      });
    } else {
      msRest.promiseToCallback(this.getUserByIdWithHttpOperationResponse(id, options))((err: Error, data: msRest.HttpOperationResponse) => {
        if (err) {
          return cb(err);
        }
        let result = data.bodyAsJson as Models.UserModel;
        return cb(err, result, data.request, data.response);
      });
    }
  }

  /**
   * @summary Updates a specified user.
   *
   * @param {number} id The user identifier.
   *
   * @param {UserBase} model The user model.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @param {ServiceCallback} callback - The callback.
   *
   * @returns {ServiceCallback} callback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {any} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {Response} [response] - The HTTP Response stream if an error did not occur.
   */
  updateUser(id: number, model: Models.UserBase): Promise<any>;
  updateUser(id: number, model: Models.UserBase, options: msRest.RequestOptionsBase): Promise<any>;
  updateUser(id: number, model: Models.UserBase, callback: msRest.ServiceCallback<any>): void;
  updateUser(id: number, model: Models.UserBase, options: msRest.RequestOptionsBase, callback: msRest.ServiceCallback<any>): void;
  updateUser(id: number, model: Models.UserBase, options?: msRest.RequestOptionsBase, callback?: msRest.ServiceCallback<any>): any {
    if (!callback && typeof options === 'function') {
      callback = options;
      options = undefined;
    }
    let cb = callback as msRest.ServiceCallback<any>;
    if (!callback) {
      return this.updateUserWithHttpOperationResponse(id, model, options).then((operationRes: msRest.HttpOperationResponse) => {
        return Promise.resolve(operationRes.bodyAsJson as any);
      }).catch((err: Error) => {
        return Promise.reject(err);
      });
    } else {
      msRest.promiseToCallback(this.updateUserWithHttpOperationResponse(id, model, options))((err: Error, data: msRest.HttpOperationResponse) => {
        if (err) {
          return cb(err);
        }
        let result = data.bodyAsJson as any;
        return cb(err, result, data.request, data.response);
      });
    }
  }

  /**
   * @summary Deactivates a specified user and removes all user associations.
   *
   * @param {number} id The user identifier.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @param {ServiceCallback} callback - The callback.
   *
   * @returns {ServiceCallback} callback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {any} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {Response} [response] - The HTTP Response stream if an error did not occur.
   */
  deleteUser(id: number): Promise<any>;
  deleteUser(id: number, options: msRest.RequestOptionsBase): Promise<any>;
  deleteUser(id: number, callback: msRest.ServiceCallback<any>): void;
  deleteUser(id: number, options: msRest.RequestOptionsBase, callback: msRest.ServiceCallback<any>): void;
  deleteUser(id: number, options?: msRest.RequestOptionsBase, callback?: msRest.ServiceCallback<any>): any {
    if (!callback && typeof options === 'function') {
      callback = options;
      options = undefined;
    }
    let cb = callback as msRest.ServiceCallback<any>;
    if (!callback) {
      return this.deleteUserWithHttpOperationResponse(id, options).then((operationRes: msRest.HttpOperationResponse) => {
        return Promise.resolve(operationRes.bodyAsJson as any);
      }).catch((err: Error) => {
        return Promise.reject(err);
      });
    } else {
      msRest.promiseToCallback(this.deleteUserWithHttpOperationResponse(id, options))((err: Error, data: msRest.HttpOperationResponse) => {
        if (err) {
          return cb(err);
        }
        let result = data.bodyAsJson as any;
        return cb(err, result, data.request, data.response);
      });
    }
  }

  /**
   * @summary Gets a paged list of workflows.
   *
   * @param {SoftheonEnterpriseAPIGetWorkflowsByFilterOptionalParams} [options]
   * Optional Parameters.
   *
   * @param {ServiceCallback} callback - The callback.
   *
   * @returns {ServiceCallback} callback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {Models.WorkflowModel[]} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {Response} [response] - The HTTP Response stream if an error did not occur.
   */
  getWorkflowsByFilter(): Promise<Models.WorkflowModel[]>;
  getWorkflowsByFilter(options: Models.SoftheonEnterpriseAPIGetWorkflowsByFilterOptionalParams): Promise<Models.WorkflowModel[]>;
  getWorkflowsByFilter(callback: msRest.ServiceCallback<Models.WorkflowModel[]>): void;
  getWorkflowsByFilter(options: Models.SoftheonEnterpriseAPIGetWorkflowsByFilterOptionalParams, callback: msRest.ServiceCallback<Models.WorkflowModel[]>): void;
  getWorkflowsByFilter(options?: Models.SoftheonEnterpriseAPIGetWorkflowsByFilterOptionalParams, callback?: msRest.ServiceCallback<Models.WorkflowModel[]>): any {
    if (!callback && typeof options === 'function') {
      callback = options;
      options = undefined;
    }
    let cb = callback as msRest.ServiceCallback<Models.WorkflowModel[]>;
    if (!callback) {
      return this.getWorkflowsByFilterWithHttpOperationResponse(options).then((operationRes: msRest.HttpOperationResponse) => {
        return Promise.resolve(operationRes.bodyAsJson as Models.WorkflowModel[]);
      }).catch((err: Error) => {
        return Promise.reject(err);
      });
    } else {
      msRest.promiseToCallback(this.getWorkflowsByFilterWithHttpOperationResponse(options))((err: Error, data: msRest.HttpOperationResponse) => {
        if (err) {
          return cb(err);
        }
        let result = data.bodyAsJson as Models.WorkflowModel[];
        return cb(err, result, data.request, data.response);
      });
    }
  }

  /**
   * @summary Gets a single workflow based on its unique identifier.
   *
   * @param {number} id The workflow identifier.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @param {ServiceCallback} callback - The callback.
   *
   * @returns {ServiceCallback} callback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {Models.WorkflowModel} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link Models.WorkflowModel} for more information.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {Response} [response] - The HTTP Response stream if an error did not occur.
   */
  getWorkflowById(id: number): Promise<Models.WorkflowModel>;
  getWorkflowById(id: number, options: msRest.RequestOptionsBase): Promise<Models.WorkflowModel>;
  getWorkflowById(id: number, callback: msRest.ServiceCallback<Models.WorkflowModel>): void;
  getWorkflowById(id: number, options: msRest.RequestOptionsBase, callback: msRest.ServiceCallback<Models.WorkflowModel>): void;
  getWorkflowById(id: number, options?: msRest.RequestOptionsBase, callback?: msRest.ServiceCallback<Models.WorkflowModel>): any {
    if (!callback && typeof options === 'function') {
      callback = options;
      options = undefined;
    }
    let cb = callback as msRest.ServiceCallback<Models.WorkflowModel>;
    if (!callback) {
      return this.getWorkflowByIdWithHttpOperationResponse(id, options).then((operationRes: msRest.HttpOperationResponse) => {
        return Promise.resolve(operationRes.bodyAsJson as Models.WorkflowModel);
      }).catch((err: Error) => {
        return Promise.reject(err);
      });
    } else {
      msRest.promiseToCallback(this.getWorkflowByIdWithHttpOperationResponse(id, options))((err: Error, data: msRest.HttpOperationResponse) => {
        if (err) {
          return cb(err);
        }
        let result = data.bodyAsJson as Models.WorkflowModel;
        return cb(err, result, data.request, data.response);
      });
    }
  }

  /**
   * @summary Gets queues for a specific workflow.
   *
   * @param {number} id The workflow identifier.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @param {ServiceCallback} callback - The callback.
   *
   * @returns {ServiceCallback} callback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {Models.WorkflowQueueModel[]} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {Response} [response] - The HTTP Response stream if an error did not occur.
   */
  getWorkflowQueuesById(id: number): Promise<Models.WorkflowQueueModel[]>;
  getWorkflowQueuesById(id: number, options: msRest.RequestOptionsBase): Promise<Models.WorkflowQueueModel[]>;
  getWorkflowQueuesById(id: number, callback: msRest.ServiceCallback<Models.WorkflowQueueModel[]>): void;
  getWorkflowQueuesById(id: number, options: msRest.RequestOptionsBase, callback: msRest.ServiceCallback<Models.WorkflowQueueModel[]>): void;
  getWorkflowQueuesById(id: number, options?: msRest.RequestOptionsBase, callback?: msRest.ServiceCallback<Models.WorkflowQueueModel[]>): any {
    if (!callback && typeof options === 'function') {
      callback = options;
      options = undefined;
    }
    let cb = callback as msRest.ServiceCallback<Models.WorkflowQueueModel[]>;
    if (!callback) {
      return this.getWorkflowQueuesByIdWithHttpOperationResponse(id, options).then((operationRes: msRest.HttpOperationResponse) => {
        return Promise.resolve(operationRes.bodyAsJson as Models.WorkflowQueueModel[]);
      }).catch((err: Error) => {
        return Promise.reject(err);
      });
    } else {
      msRest.promiseToCallback(this.getWorkflowQueuesByIdWithHttpOperationResponse(id, options))((err: Error, data: msRest.HttpOperationResponse) => {
        if (err) {
          return cb(err);
        }
        let result = data.bodyAsJson as Models.WorkflowQueueModel[];
        return cb(err, result, data.request, data.response);
      });
    }
  }

  /**
   * @summary Gets a single entity template definition completed with all
   * profiles definitions as XML entity definition.
   *
   * @param {number} type The unique template type.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @param {ServiceCallback} callback - The callback.
   *
   * @returns {ServiceCallback} callback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {string} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {Response} [response] - The HTTP Response stream if an error did not occur.
   */
  getXMLTemplateByType(type: number): Promise<string>;
  getXMLTemplateByType(type: number, options: msRest.RequestOptionsBase): Promise<string>;
  getXMLTemplateByType(type: number, callback: msRest.ServiceCallback<string>): void;
  getXMLTemplateByType(type: number, options: msRest.RequestOptionsBase, callback: msRest.ServiceCallback<string>): void;
  getXMLTemplateByType(type: number, options?: msRest.RequestOptionsBase, callback?: msRest.ServiceCallback<string>): any {
    if (!callback && typeof options === 'function') {
      callback = options;
      options = undefined;
    }
    let cb = callback as msRest.ServiceCallback<string>;
    if (!callback) {
      return this.getXMLTemplateByTypeWithHttpOperationResponse(type, options).then((operationRes: msRest.HttpOperationResponse) => {
        return Promise.resolve(operationRes.bodyAsJson as string);
      }).catch((err: Error) => {
        return Promise.reject(err);
      });
    } else {
      msRest.promiseToCallback(this.getXMLTemplateByTypeWithHttpOperationResponse(type, options))((err: Error, data: msRest.HttpOperationResponse) => {
        if (err) {
          return cb(err);
        }
        let result = data.bodyAsJson as string;
        return cb(err, result, data.request, data.response);
      });
    }
  }

  /**
   * @summary Creates a new entity template definition.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @param {ServiceCallback} callback - The callback.
   *
   * @returns {ServiceCallback} callback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {string} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {Response} [response] - The HTTP Response stream if an error did not occur.
   */
  createXMLTemplate(): Promise<string>;
  createXMLTemplate(options: msRest.RequestOptionsBase): Promise<string>;
  createXMLTemplate(callback: msRest.ServiceCallback<string>): void;
  createXMLTemplate(options: msRest.RequestOptionsBase, callback: msRest.ServiceCallback<string>): void;
  createXMLTemplate(options?: msRest.RequestOptionsBase, callback?: msRest.ServiceCallback<string>): any {
    if (!callback && typeof options === 'function') {
      callback = options;
      options = undefined;
    }
    let cb = callback as msRest.ServiceCallback<string>;
    if (!callback) {
      return this.createXMLTemplateWithHttpOperationResponse(options).then((operationRes: msRest.HttpOperationResponse) => {
        return Promise.resolve(operationRes.bodyAsJson as string);
      }).catch((err: Error) => {
        return Promise.reject(err);
      });
    } else {
      msRest.promiseToCallback(this.createXMLTemplateWithHttpOperationResponse(options))((err: Error, data: msRest.HttpOperationResponse) => {
        if (err) {
          return cb(err);
        }
        let result = data.bodyAsJson as string;
        return cb(err, result, data.request, data.response);
      });
    }
  }
}

export { SoftheonEnterpriseAPI, Models as SoftheonEnterpriseAPIModels, Mappers as SoftheonEnterpriseAPIMappers };
