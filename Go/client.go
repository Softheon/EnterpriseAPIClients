// Package softheonenterpriseapiclient implements the Azure ARM Softheonenterpriseapiclient service API version v1.
//
//
package softheonenterpriseapiclient

// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

import (
    "context"
    "github.com/Azure/go-autorest/autorest"
    "github.com/Azure/go-autorest/autorest/azure"
    "github.com/Azure/go-autorest/autorest/date"
    "github.com/Azure/go-autorest/autorest/validation"
    "net/http"
)

const (
// DefaultBaseURI is the default URI used for the service Softheonenterpriseapiclient
DefaultBaseURI = "http://localhost:54963")

// BaseClient is the base client for Softheonenterpriseapiclient.
type BaseClient struct {
    autorest.Client
    BaseURI string
}

// New creates an instance of the BaseClient client.
func New()BaseClient {
    return NewWithBaseURI(DefaultBaseURI, )
}

// NewWithBaseURI creates an instance of the BaseClient client.
func NewWithBaseURI(baseURI string, ) BaseClient {
    return BaseClient{
        Client: autorest.NewClientWithUserAgent(UserAgent()),
        BaseURI: baseURI,
    }
}

    // AcceptTask sends the accept task request.
    //
    // model is the model.
    func (client BaseClient) AcceptTask(ctx context.Context, model WorkflowActionModel) (result SetObject, err error) {
        if err := validation.Validate([]validation.Validation{
        { TargetValue: model,
         Constraints: []validation.Constraint{	{Target: "model.TaskID", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "model.TaskID", Name: validation.InclusiveMaximum, Rule: 2147483647, Chain: nil },
        	{Target: "model.TaskID", Name: validation.InclusiveMinimum, Rule: 0, Chain: nil },
        }},
        	{Target: "model.TargetID", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "model.TargetID", Name: validation.InclusiveMaximum, Rule: 2147483647, Chain: nil },
        	{Target: "model.TargetID", Name: validation.InclusiveMinimum, Rule: 0, Chain: nil },
        }},
        	{Target: "model.QueueName", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "model.QueueName", Name: validation.MaxLength, Rule: 255, Chain: nil },
        	{Target: "model.QueueName", Name: validation.MinLength, Rule: 0, Chain: nil },
        }},
        	{Target: "model.Source", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "model.Source", Name: validation.MaxLength, Rule: 255, Chain: nil },
        	{Target: "model.Source", Name: validation.MinLength, Rule: 0, Chain: nil },
        }},
        	{Target: "model.Computer", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "model.Computer", Name: validation.MaxLength, Rule: 255, Chain: nil },
        	{Target: "model.Computer", Name: validation.MinLength, Rule: 0, Chain: nil },
        }},
        	{Target: "model.IPAddress", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "model.IPAddress", Name: validation.MaxLength, Rule: 255, Chain: nil },
        	{Target: "model.IPAddress", Name: validation.MinLength, Rule: 0, Chain: nil },
        }}}}}); err != nil {
            return result, validation.NewErrorWithValidationError(err, "softheonenterpriseapiclient.BaseClient","AcceptTask")
        }

        req, err := client.AcceptTaskPreparer(ctx, model)
        if err != nil {
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "AcceptTask", nil , "Failure preparing request")
            return
        }

        resp, err := client.AcceptTaskSender(req)
        if err != nil {
            result.Response = autorest.Response{Response: resp}
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "AcceptTask", resp, "Failure sending request")
            return
        }

        result, err = client.AcceptTaskResponder(resp)
        if err != nil {
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "AcceptTask", resp, "Failure responding to request")
        }

        return
    }

    // AcceptTaskPreparer prepares the AcceptTask request.
    func (client BaseClient) AcceptTaskPreparer(ctx context.Context, model WorkflowActionModel) (*http.Request, error) {
        preparer := autorest.CreatePreparer(
            autorest.AsJSON(),
            autorest.AsPost(),
            autorest.WithBaseURL(client.BaseURI),
            autorest.WithPath("/v1/workflow/actions/accept"),
            autorest.WithJSON(model))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
    }

    // AcceptTaskSender sends the AcceptTask request. The method will close the
    // http.Response Body if it receives an error.
    func (client BaseClient) AcceptTaskSender(req *http.Request) (*http.Response, error) {
        return autorest.SendWithSender(client, req,
            autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
    }

    // AcceptTaskResponder handles the response to the AcceptTask request. The method always
    // closes the http.Response Body.
    func (client BaseClient) AcceptTaskResponder(resp *http.Response) (result SetObject, err error) {
        err = autorest.Respond(
            resp,
            client.ByInspecting(),
            azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusNoContent,http.StatusForbidden,http.StatusNotFound),
            autorest.ByUnmarshallingJSON(&result.Value),
            autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
        return
    }

    // ArchiveAttachment sends the archive attachment request.
    //
    // drawer is the drawer identifier. ID is the attachment identifier.
    func (client BaseClient) ArchiveAttachment(ctx context.Context, drawer int32, ID int32) (result SetObject, err error) {
        req, err := client.ArchiveAttachmentPreparer(ctx, drawer, ID)
        if err != nil {
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "ArchiveAttachment", nil , "Failure preparing request")
            return
        }

        resp, err := client.ArchiveAttachmentSender(req)
        if err != nil {
            result.Response = autorest.Response{Response: resp}
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "ArchiveAttachment", resp, "Failure sending request")
            return
        }

        result, err = client.ArchiveAttachmentResponder(resp)
        if err != nil {
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "ArchiveAttachment", resp, "Failure responding to request")
        }

        return
    }

    // ArchiveAttachmentPreparer prepares the ArchiveAttachment request.
    func (client BaseClient) ArchiveAttachmentPreparer(ctx context.Context, drawer int32, ID int32) (*http.Request, error) {
        pathParameters := map[string]interface{} {
        "drawer": autorest.Encode("path",drawer),
        "id": autorest.Encode("path",ID),
        }

        preparer := autorest.CreatePreparer(
            autorest.AsPut(),
            autorest.WithBaseURL(client.BaseURI),
            autorest.WithPathParameters("/v1/content/attachments/{drawer}/{id}/archive",pathParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
    }

    // ArchiveAttachmentSender sends the ArchiveAttachment request. The method will close the
    // http.Response Body if it receives an error.
    func (client BaseClient) ArchiveAttachmentSender(req *http.Request) (*http.Response, error) {
        return autorest.SendWithSender(client, req,
            autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
    }

    // ArchiveAttachmentResponder handles the response to the ArchiveAttachment request. The method always
    // closes the http.Response Body.
    func (client BaseClient) ArchiveAttachmentResponder(resp *http.Response) (result SetObject, err error) {
        err = autorest.Respond(
            resp,
            client.ByInspecting(),
            azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusNoContent,http.StatusBadRequest,http.StatusForbidden,http.StatusNotFound),
            autorest.ByUnmarshallingJSON(&result.Value),
            autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
        return
    }

    // CheckInAttachment sends the check in attachment request.
    //
    // drawer is the drawer identifier. ID is the attachment identifier.
    func (client BaseClient) CheckInAttachment(ctx context.Context, drawer int32, ID int32) (result SetObject, err error) {
        req, err := client.CheckInAttachmentPreparer(ctx, drawer, ID)
        if err != nil {
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "CheckInAttachment", nil , "Failure preparing request")
            return
        }

        resp, err := client.CheckInAttachmentSender(req)
        if err != nil {
            result.Response = autorest.Response{Response: resp}
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "CheckInAttachment", resp, "Failure sending request")
            return
        }

        result, err = client.CheckInAttachmentResponder(resp)
        if err != nil {
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "CheckInAttachment", resp, "Failure responding to request")
        }

        return
    }

    // CheckInAttachmentPreparer prepares the CheckInAttachment request.
    func (client BaseClient) CheckInAttachmentPreparer(ctx context.Context, drawer int32, ID int32) (*http.Request, error) {
        pathParameters := map[string]interface{} {
        "drawer": autorest.Encode("path",drawer),
        "id": autorest.Encode("path",ID),
        }

        preparer := autorest.CreatePreparer(
            autorest.AsPut(),
            autorest.WithBaseURL(client.BaseURI),
            autorest.WithPathParameters("/v1/content/attachments/{drawer}/{id}/checkin",pathParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
    }

    // CheckInAttachmentSender sends the CheckInAttachment request. The method will close the
    // http.Response Body if it receives an error.
    func (client BaseClient) CheckInAttachmentSender(req *http.Request) (*http.Response, error) {
        return autorest.SendWithSender(client, req,
            autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
    }

    // CheckInAttachmentResponder handles the response to the CheckInAttachment request. The method always
    // closes the http.Response Body.
    func (client BaseClient) CheckInAttachmentResponder(resp *http.Response) (result SetObject, err error) {
        err = autorest.Respond(
            resp,
            client.ByInspecting(),
            azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusNoContent,http.StatusBadRequest,http.StatusForbidden,http.StatusNotFound),
            autorest.ByUnmarshallingJSON(&result.Value),
            autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
        return
    }

    // CheckOutAttachment sends the check out attachment request.
    //
    // drawer is the drawer identifier. ID is the attachment identifier.
    func (client BaseClient) CheckOutAttachment(ctx context.Context, drawer int32, ID int32) (result SetObject, err error) {
        req, err := client.CheckOutAttachmentPreparer(ctx, drawer, ID)
        if err != nil {
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "CheckOutAttachment", nil , "Failure preparing request")
            return
        }

        resp, err := client.CheckOutAttachmentSender(req)
        if err != nil {
            result.Response = autorest.Response{Response: resp}
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "CheckOutAttachment", resp, "Failure sending request")
            return
        }

        result, err = client.CheckOutAttachmentResponder(resp)
        if err != nil {
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "CheckOutAttachment", resp, "Failure responding to request")
        }

        return
    }

    // CheckOutAttachmentPreparer prepares the CheckOutAttachment request.
    func (client BaseClient) CheckOutAttachmentPreparer(ctx context.Context, drawer int32, ID int32) (*http.Request, error) {
        pathParameters := map[string]interface{} {
        "drawer": autorest.Encode("path",drawer),
        "id": autorest.Encode("path",ID),
        }

        preparer := autorest.CreatePreparer(
            autorest.AsPut(),
            autorest.WithBaseURL(client.BaseURI),
            autorest.WithPathParameters("/v1/content/attachments/{drawer}/{id}/checkout",pathParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
    }

    // CheckOutAttachmentSender sends the CheckOutAttachment request. The method will close the
    // http.Response Body if it receives an error.
    func (client BaseClient) CheckOutAttachmentSender(req *http.Request) (*http.Response, error) {
        return autorest.SendWithSender(client, req,
            autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
    }

    // CheckOutAttachmentResponder handles the response to the CheckOutAttachment request. The method always
    // closes the http.Response Body.
    func (client BaseClient) CheckOutAttachmentResponder(resp *http.Response) (result SetObject, err error) {
        err = autorest.Respond(
            resp,
            client.ByInspecting(),
            azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusNoContent,http.StatusBadRequest,http.StatusForbidden,http.StatusNotFound),
            autorest.ByUnmarshallingJSON(&result.Value),
            autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
        return
    }

    // CopyEntity sends the copy entity request.
    //
    // drawer is the drawer. ID is the entity identifier. model is the model.
    func (client BaseClient) CopyEntity(ctx context.Context, drawer int32, ID int32, model EntityContentModel) (result EntityModel, err error) {
        req, err := client.CopyEntityPreparer(ctx, drawer, ID, model)
        if err != nil {
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "CopyEntity", nil , "Failure preparing request")
            return
        }

        resp, err := client.CopyEntitySender(req)
        if err != nil {
            result.Response = autorest.Response{Response: resp}
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "CopyEntity", resp, "Failure sending request")
            return
        }

        result, err = client.CopyEntityResponder(resp)
        if err != nil {
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "CopyEntity", resp, "Failure responding to request")
        }

        return
    }

    // CopyEntityPreparer prepares the CopyEntity request.
    func (client BaseClient) CopyEntityPreparer(ctx context.Context, drawer int32, ID int32, model EntityContentModel) (*http.Request, error) {
        pathParameters := map[string]interface{} {
        "drawer": autorest.Encode("path",drawer),
        "id": autorest.Encode("path",ID),
        }

        preparer := autorest.CreatePreparer(
            autorest.AsJSON(),
            autorest.AsPost(),
            autorest.WithBaseURL(client.BaseURI),
            autorest.WithPathParameters("/v1/content/entities/{drawer}/{id}/copy",pathParameters),
            autorest.WithJSON(model))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
    }

    // CopyEntitySender sends the CopyEntity request. The method will close the
    // http.Response Body if it receives an error.
    func (client BaseClient) CopyEntitySender(req *http.Request) (*http.Response, error) {
        return autorest.SendWithSender(client, req,
            autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
    }

    // CopyEntityResponder handles the response to the CopyEntity request. The method always
    // closes the http.Response Body.
    func (client BaseClient) CopyEntityResponder(resp *http.Response) (result EntityModel, err error) {
        err = autorest.Respond(
            resp,
            client.ByInspecting(),
            azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusCreated,http.StatusNotFound),
            autorest.ByUnmarshallingJSON(&result),
            autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
        return
    }

    // CreateAttachment sends the create attachment request.
    //
    // drawer is the drawer identifier.
    func (client BaseClient) CreateAttachment(ctx context.Context, drawer int32) (result AttachmentModel, err error) {
        req, err := client.CreateAttachmentPreparer(ctx, drawer)
        if err != nil {
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "CreateAttachment", nil , "Failure preparing request")
            return
        }

        resp, err := client.CreateAttachmentSender(req)
        if err != nil {
            result.Response = autorest.Response{Response: resp}
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "CreateAttachment", resp, "Failure sending request")
            return
        }

        result, err = client.CreateAttachmentResponder(resp)
        if err != nil {
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "CreateAttachment", resp, "Failure responding to request")
        }

        return
    }

    // CreateAttachmentPreparer prepares the CreateAttachment request.
    func (client BaseClient) CreateAttachmentPreparer(ctx context.Context, drawer int32) (*http.Request, error) {
        pathParameters := map[string]interface{} {
        "drawer": autorest.Encode("path",drawer),
        }

        preparer := autorest.CreatePreparer(
            autorest.AsPost(),
            autorest.WithBaseURL(client.BaseURI),
            autorest.WithPathParameters("/v1/content/attachments/{drawer}",pathParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
    }

    // CreateAttachmentSender sends the CreateAttachment request. The method will close the
    // http.Response Body if it receives an error.
    func (client BaseClient) CreateAttachmentSender(req *http.Request) (*http.Response, error) {
        return autorest.SendWithSender(client, req,
            autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
    }

    // CreateAttachmentResponder handles the response to the CreateAttachment request. The method always
    // closes the http.Response Body.
    func (client BaseClient) CreateAttachmentResponder(resp *http.Response) (result AttachmentModel, err error) {
        err = autorest.Respond(
            resp,
            client.ByInspecting(),
            azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusCreated,http.StatusBadRequest,http.StatusForbidden,http.StatusNotFound),
            autorest.ByUnmarshallingJSON(&result),
            autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
        return
    }

    // CreateEntity sends the create entity request.
    //
    // drawer is the drawer identifier. model is the entity model.
    func (client BaseClient) CreateEntity(ctx context.Context, drawer int32, model InsertEntityRequestModel) (result EntityModel, err error) {
        if err := validation.Validate([]validation.Validation{
        { TargetValue: model,
         Constraints: []validation.Constraint{	{Target: "model.Type", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "model.Type", Name: validation.InclusiveMaximum, Rule: 2147483647, Chain: nil },
        	{Target: "model.Type", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil },
        }},
        	{Target: "model.Name", Name: validation.Null, Rule: true, Chain: nil }}}}); err != nil {
            return result, validation.NewErrorWithValidationError(err, "softheonenterpriseapiclient.BaseClient","CreateEntity")
        }

        req, err := client.CreateEntityPreparer(ctx, drawer, model)
        if err != nil {
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "CreateEntity", nil , "Failure preparing request")
            return
        }

        resp, err := client.CreateEntitySender(req)
        if err != nil {
            result.Response = autorest.Response{Response: resp}
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "CreateEntity", resp, "Failure sending request")
            return
        }

        result, err = client.CreateEntityResponder(resp)
        if err != nil {
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "CreateEntity", resp, "Failure responding to request")
        }

        return
    }

    // CreateEntityPreparer prepares the CreateEntity request.
    func (client BaseClient) CreateEntityPreparer(ctx context.Context, drawer int32, model InsertEntityRequestModel) (*http.Request, error) {
        pathParameters := map[string]interface{} {
        "drawer": autorest.Encode("path",drawer),
        }

        preparer := autorest.CreatePreparer(
            autorest.AsJSON(),
            autorest.AsPost(),
            autorest.WithBaseURL(client.BaseURI),
            autorest.WithPathParameters("/v1/content/entities/{drawer}",pathParameters),
            autorest.WithJSON(model))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
    }

    // CreateEntitySender sends the CreateEntity request. The method will close the
    // http.Response Body if it receives an error.
    func (client BaseClient) CreateEntitySender(req *http.Request) (*http.Response, error) {
        return autorest.SendWithSender(client, req,
            autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
    }

    // CreateEntityResponder handles the response to the CreateEntity request. The method always
    // closes the http.Response Body.
    func (client BaseClient) CreateEntityResponder(resp *http.Response) (result EntityModel, err error) {
        err = autorest.Respond(
            resp,
            client.ByInspecting(),
            azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusCreated,http.StatusNotFound),
            autorest.ByUnmarshallingJSON(&result),
            autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
        return
    }

    // CreateEvent sends the create event request.
    //
    // drawer is the drawer identifier. model is the event model.
    func (client BaseClient) CreateEvent(ctx context.Context, drawer int32, model EventModel) (result EventModel, err error) {
        if err := validation.Validate([]validation.Validation{
        { TargetValue: model,
         Constraints: []validation.Constraint{	{Target: "model.EntityID", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "model.EntityID", Name: validation.InclusiveMaximum, Rule: 2147483647, Chain: nil },
        	{Target: "model.EntityID", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil },
        }},
        	{Target: "model.Source", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "model.Source", Name: validation.MaxLength, Rule: 255, Chain: nil },
        	{Target: "model.Source", Name: validation.MinLength, Rule: 0, Chain: nil },
        }},
        	{Target: "model.Computer", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "model.Computer", Name: validation.MaxLength, Rule: 255, Chain: nil },
        	{Target: "model.Computer", Name: validation.MinLength, Rule: 0, Chain: nil },
        }},
        	{Target: "model.IPAddress", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "model.IPAddress", Name: validation.MaxLength, Rule: 255, Chain: nil },
        	{Target: "model.IPAddress", Name: validation.MinLength, Rule: 0, Chain: nil },
        }},
        	{Target: "model.Description", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "model.Description", Name: validation.MaxLength, Rule: 255, Chain: nil },
        	{Target: "model.Description", Name: validation.MinLength, Rule: 0, Chain: nil },
        }}}}}); err != nil {
            return result, validation.NewErrorWithValidationError(err, "softheonenterpriseapiclient.BaseClient","CreateEvent")
        }

        req, err := client.CreateEventPreparer(ctx, drawer, model)
        if err != nil {
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "CreateEvent", nil , "Failure preparing request")
            return
        }

        resp, err := client.CreateEventSender(req)
        if err != nil {
            result.Response = autorest.Response{Response: resp}
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "CreateEvent", resp, "Failure sending request")
            return
        }

        result, err = client.CreateEventResponder(resp)
        if err != nil {
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "CreateEvent", resp, "Failure responding to request")
        }

        return
    }

    // CreateEventPreparer prepares the CreateEvent request.
    func (client BaseClient) CreateEventPreparer(ctx context.Context, drawer int32, model EventModel) (*http.Request, error) {
        pathParameters := map[string]interface{} {
        "drawer": autorest.Encode("path",drawer),
        }

        preparer := autorest.CreatePreparer(
            autorest.AsJSON(),
            autorest.AsPost(),
            autorest.WithBaseURL(client.BaseURI),
            autorest.WithPathParameters("/v1/content/events/{drawer}",pathParameters),
            autorest.WithJSON(model))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
    }

    // CreateEventSender sends the CreateEvent request. The method will close the
    // http.Response Body if it receives an error.
    func (client BaseClient) CreateEventSender(req *http.Request) (*http.Response, error) {
        return autorest.SendWithSender(client, req,
            autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
    }

    // CreateEventResponder handles the response to the CreateEvent request. The method always
    // closes the http.Response Body.
    func (client BaseClient) CreateEventResponder(resp *http.Response) (result EventModel, err error) {
        err = autorest.Respond(
            resp,
            client.ByInspecting(),
            azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusCreated,http.StatusNotFound),
            autorest.ByUnmarshallingJSON(&result),
            autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
        return
    }

    // CreateGroup sends the create group request.
    //
    // model is the group model.
    func (client BaseClient) CreateGroup(ctx context.Context, model InsertGroupRequestModel) (result GroupModel, err error) {
        if err := validation.Validate([]validation.Validation{
        { TargetValue: model,
         Constraints: []validation.Constraint{	{Target: "model.Name", Name: validation.Null, Rule: true, Chain: nil }}}}); err != nil {
            return result, validation.NewErrorWithValidationError(err, "softheonenterpriseapiclient.BaseClient","CreateGroup")
        }

        req, err := client.CreateGroupPreparer(ctx, model)
        if err != nil {
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "CreateGroup", nil , "Failure preparing request")
            return
        }

        resp, err := client.CreateGroupSender(req)
        if err != nil {
            result.Response = autorest.Response{Response: resp}
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "CreateGroup", resp, "Failure sending request")
            return
        }

        result, err = client.CreateGroupResponder(resp)
        if err != nil {
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "CreateGroup", resp, "Failure responding to request")
        }

        return
    }

    // CreateGroupPreparer prepares the CreateGroup request.
    func (client BaseClient) CreateGroupPreparer(ctx context.Context, model InsertGroupRequestModel) (*http.Request, error) {
        preparer := autorest.CreatePreparer(
            autorest.AsJSON(),
            autorest.AsPost(),
            autorest.WithBaseURL(client.BaseURI),
            autorest.WithPath("/v1/directory/groups"),
            autorest.WithJSON(model))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
    }

    // CreateGroupSender sends the CreateGroup request. The method will close the
    // http.Response Body if it receives an error.
    func (client BaseClient) CreateGroupSender(req *http.Request) (*http.Response, error) {
        return autorest.SendWithSender(client, req,
            autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
    }

    // CreateGroupResponder handles the response to the CreateGroup request. The method always
    // closes the http.Response Body.
    func (client BaseClient) CreateGroupResponder(resp *http.Response) (result GroupModel, err error) {
        err = autorest.Respond(
            resp,
            client.ByInspecting(),
            azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusCreated,http.StatusForbidden,http.StatusConflict),
            autorest.ByUnmarshallingJSON(&result),
            autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
        return
    }

    // CreateGroupUserAssociation sends the create group user association request.
    //
    // groupID is the group identifier. userID is the user identifier. model is the model.
    func (client BaseClient) CreateGroupUserAssociation(ctx context.Context, groupID int32, userID int32, model GroupUserModel) (result SetObject, err error) {
        if err := validation.Validate([]validation.Validation{
        { TargetValue: model,
         Constraints: []validation.Constraint{	{Target: "model.GroupName", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "model.GroupName", Name: validation.MaxLength, Rule: 255, Chain: nil },
        	{Target: "model.GroupName", Name: validation.MinLength, Rule: 0, Chain: nil },
        }},
        	{Target: "model.UserFullName", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "model.UserFullName", Name: validation.MaxLength, Rule: 255, Chain: nil },
        	{Target: "model.UserFullName", Name: validation.MinLength, Rule: 0, Chain: nil },
        }}}}}); err != nil {
            return result, validation.NewErrorWithValidationError(err, "softheonenterpriseapiclient.BaseClient","CreateGroupUserAssociation")
        }

        req, err := client.CreateGroupUserAssociationPreparer(ctx, groupID, userID, model)
        if err != nil {
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "CreateGroupUserAssociation", nil , "Failure preparing request")
            return
        }

        resp, err := client.CreateGroupUserAssociationSender(req)
        if err != nil {
            result.Response = autorest.Response{Response: resp}
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "CreateGroupUserAssociation", resp, "Failure sending request")
            return
        }

        result, err = client.CreateGroupUserAssociationResponder(resp)
        if err != nil {
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "CreateGroupUserAssociation", resp, "Failure responding to request")
        }

        return
    }

    // CreateGroupUserAssociationPreparer prepares the CreateGroupUserAssociation request.
    func (client BaseClient) CreateGroupUserAssociationPreparer(ctx context.Context, groupID int32, userID int32, model GroupUserModel) (*http.Request, error) {
        pathParameters := map[string]interface{} {
        "groupID": autorest.Encode("path",groupID),
        "userID": autorest.Encode("path",userID),
        }

        preparer := autorest.CreatePreparer(
            autorest.AsJSON(),
            autorest.AsPost(),
            autorest.WithBaseURL(client.BaseURI),
            autorest.WithPathParameters("/v1/directory/groups/{groupID}/users/{userID}",pathParameters),
            autorest.WithJSON(model))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
    }

    // CreateGroupUserAssociationSender sends the CreateGroupUserAssociation request. The method will close the
    // http.Response Body if it receives an error.
    func (client BaseClient) CreateGroupUserAssociationSender(req *http.Request) (*http.Response, error) {
        return autorest.SendWithSender(client, req,
            autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
    }

    // CreateGroupUserAssociationResponder handles the response to the CreateGroupUserAssociation request. The method always
    // closes the http.Response Body.
    func (client BaseClient) CreateGroupUserAssociationResponder(resp *http.Response) (result SetObject, err error) {
        err = autorest.Respond(
            resp,
            client.ByInspecting(),
            azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusForbidden,http.StatusConflict),
            autorest.ByUnmarshallingJSON(&result.Value),
            autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
        return
    }

    // CreateLink sends the create link request.
    //
    // drawer is the drawer identifier. model is the link model.
    func (client BaseClient) CreateLink(ctx context.Context, drawer int32, model InsertEntityLinkRequestModel) (result EntityLinkModel, err error) {
        if err := validation.Validate([]validation.Validation{
        { TargetValue: model,
         Constraints: []validation.Constraint{	{Target: "model.Name", Name: validation.Null, Rule: true ,
        Chain: []validation.Constraint{	{Target: "model.Name", Name: validation.MaxLength, Rule: 255, Chain: nil },
        	{Target: "model.Name", Name: validation.MinLength, Rule: 0, Chain: nil },
        }},
        	{Target: "model.PageNumber", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "model.PageNumber", Name: validation.InclusiveMaximum, Rule: 2147483647, Chain: nil },
        	{Target: "model.PageNumber", Name: validation.InclusiveMinimum, Rule: 0, Chain: nil },
        }},
        	{Target: "model.Note", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "model.Note", Name: validation.MaxLength, Rule: 255, Chain: nil },
        	{Target: "model.Note", Name: validation.MinLength, Rule: 0, Chain: nil },
        }},
        	{Target: "model.ChildDrawerID", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "model.ChildDrawerID", Name: validation.InclusiveMaximum, Rule: 2147483647, Chain: nil },
        	{Target: "model.ChildDrawerID", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil },
        }},
        	{Target: "model.ChildEntityID", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "model.ChildEntityID", Name: validation.InclusiveMaximum, Rule: 2147483647, Chain: nil },
        	{Target: "model.ChildEntityID", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil },
        }},
        	{Target: "model.ChildType", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "model.ChildType", Name: validation.InclusiveMaximum, Rule: 2147483647, Chain: nil },
        	{Target: "model.ChildType", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil },
        }},
        	{Target: "model.EntityID", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "model.EntityID", Name: validation.InclusiveMaximum, Rule: 2147483647, Chain: nil },
        	{Target: "model.EntityID", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil },
        }},
        	{Target: "model.VirtualName", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "model.VirtualName", Name: validation.MaxLength, Rule: 255, Chain: nil },
        	{Target: "model.VirtualName", Name: validation.MinLength, Rule: 0, Chain: nil },
        }}}}}); err != nil {
            return result, validation.NewErrorWithValidationError(err, "softheonenterpriseapiclient.BaseClient","CreateLink")
        }

        req, err := client.CreateLinkPreparer(ctx, drawer, model)
        if err != nil {
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "CreateLink", nil , "Failure preparing request")
            return
        }

        resp, err := client.CreateLinkSender(req)
        if err != nil {
            result.Response = autorest.Response{Response: resp}
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "CreateLink", resp, "Failure sending request")
            return
        }

        result, err = client.CreateLinkResponder(resp)
        if err != nil {
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "CreateLink", resp, "Failure responding to request")
        }

        return
    }

    // CreateLinkPreparer prepares the CreateLink request.
    func (client BaseClient) CreateLinkPreparer(ctx context.Context, drawer int32, model InsertEntityLinkRequestModel) (*http.Request, error) {
        pathParameters := map[string]interface{} {
        "drawer": autorest.Encode("path",drawer),
        }

        preparer := autorest.CreatePreparer(
            autorest.AsJSON(),
            autorest.AsPost(),
            autorest.WithBaseURL(client.BaseURI),
            autorest.WithPathParameters("/v1/content/links/{drawer}",pathParameters),
            autorest.WithJSON(model))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
    }

    // CreateLinkSender sends the CreateLink request. The method will close the
    // http.Response Body if it receives an error.
    func (client BaseClient) CreateLinkSender(req *http.Request) (*http.Response, error) {
        return autorest.SendWithSender(client, req,
            autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
    }

    // CreateLinkResponder handles the response to the CreateLink request. The method always
    // closes the http.Response Body.
    func (client BaseClient) CreateLinkResponder(resp *http.Response) (result EntityLinkModel, err error) {
        err = autorest.Respond(
            resp,
            client.ByInspecting(),
            azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusCreated,http.StatusForbidden,http.StatusNotFound,http.StatusConflict),
            autorest.ByUnmarshallingJSON(&result),
            autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
        return
    }

    // CreateNote sends the create note request.
    //
    // drawer is the drawer identifier. model is the note model.
    func (client BaseClient) CreateNote(ctx context.Context, drawer int32, model InsertNoteRequestModel) (result NoteModel, err error) {
        if err := validation.Validate([]validation.Validation{
        { TargetValue: model,
         Constraints: []validation.Constraint{	{Target: "model.EntityID", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "model.EntityID", Name: validation.InclusiveMaximum, Rule: 2147483647, Chain: nil },
        	{Target: "model.EntityID", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil },
        }},
        	{Target: "model.Name", Name: validation.Null, Rule: true ,
        Chain: []validation.Constraint{	{Target: "model.Name", Name: validation.MaxLength, Rule: 255, Chain: nil },
        	{Target: "model.Name", Name: validation.MinLength, Rule: 0, Chain: nil },
        }},
        	{Target: "model.Note", Name: validation.Null, Rule: true ,
        Chain: []validation.Constraint{	{Target: "model.Note", Name: validation.MaxLength, Rule: 8000, Chain: nil },
        	{Target: "model.Note", Name: validation.MinLength, Rule: 0, Chain: nil },
        }},
        	{Target: "model.ParentID", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "model.ParentID", Name: validation.InclusiveMaximum, Rule: 2147483647, Chain: nil },
        	{Target: "model.ParentID", Name: validation.InclusiveMinimum, Rule: 0, Chain: nil },
        }}}}}); err != nil {
            return result, validation.NewErrorWithValidationError(err, "softheonenterpriseapiclient.BaseClient","CreateNote")
        }

        req, err := client.CreateNotePreparer(ctx, drawer, model)
        if err != nil {
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "CreateNote", nil , "Failure preparing request")
            return
        }

        resp, err := client.CreateNoteSender(req)
        if err != nil {
            result.Response = autorest.Response{Response: resp}
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "CreateNote", resp, "Failure sending request")
            return
        }

        result, err = client.CreateNoteResponder(resp)
        if err != nil {
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "CreateNote", resp, "Failure responding to request")
        }

        return
    }

    // CreateNotePreparer prepares the CreateNote request.
    func (client BaseClient) CreateNotePreparer(ctx context.Context, drawer int32, model InsertNoteRequestModel) (*http.Request, error) {
        pathParameters := map[string]interface{} {
        "drawer": autorest.Encode("path",drawer),
        }

        preparer := autorest.CreatePreparer(
            autorest.AsJSON(),
            autorest.AsPost(),
            autorest.WithBaseURL(client.BaseURI),
            autorest.WithPathParameters("/v1/content/notes/{drawer}",pathParameters),
            autorest.WithJSON(model))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
    }

    // CreateNoteSender sends the CreateNote request. The method will close the
    // http.Response Body if it receives an error.
    func (client BaseClient) CreateNoteSender(req *http.Request) (*http.Response, error) {
        return autorest.SendWithSender(client, req,
            autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
    }

    // CreateNoteResponder handles the response to the CreateNote request. The method always
    // closes the http.Response Body.
    func (client BaseClient) CreateNoteResponder(resp *http.Response) (result NoteModel, err error) {
        err = autorest.Respond(
            resp,
            client.ByInspecting(),
            azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusCreated,http.StatusForbidden,http.StatusNotFound),
            autorest.ByUnmarshallingJSON(&result),
            autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
        return
    }

    // CreateOrUpdateApplicationGroupAssociation sends the create or update application group association request.
    //
    // groupID is the group identifier. applicationID is the application identifier. model is the model.
    func (client BaseClient) CreateOrUpdateApplicationGroupAssociation(ctx context.Context, groupID int32, applicationID int32, model GroupApplicationModel) (result SetObject, err error) {
        if err := validation.Validate([]validation.Validation{
        { TargetValue: model,
         Constraints: []validation.Constraint{	{Target: "model.GroupName", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "model.GroupName", Name: validation.MaxLength, Rule: 255, Chain: nil },
        	{Target: "model.GroupName", Name: validation.MinLength, Rule: 0, Chain: nil },
        }},
        	{Target: "model.ApplicationName", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "model.ApplicationName", Name: validation.MaxLength, Rule: 255, Chain: nil },
        	{Target: "model.ApplicationName", Name: validation.MinLength, Rule: 0, Chain: nil },
        }}}}}); err != nil {
            return result, validation.NewErrorWithValidationError(err, "softheonenterpriseapiclient.BaseClient","CreateOrUpdateApplicationGroupAssociation")
        }

        req, err := client.CreateOrUpdateApplicationGroupAssociationPreparer(ctx, groupID, applicationID, model)
        if err != nil {
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "CreateOrUpdateApplicationGroupAssociation", nil , "Failure preparing request")
            return
        }

        resp, err := client.CreateOrUpdateApplicationGroupAssociationSender(req)
        if err != nil {
            result.Response = autorest.Response{Response: resp}
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "CreateOrUpdateApplicationGroupAssociation", resp, "Failure sending request")
            return
        }

        result, err = client.CreateOrUpdateApplicationGroupAssociationResponder(resp)
        if err != nil {
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "CreateOrUpdateApplicationGroupAssociation", resp, "Failure responding to request")
        }

        return
    }

    // CreateOrUpdateApplicationGroupAssociationPreparer prepares the CreateOrUpdateApplicationGroupAssociation request.
    func (client BaseClient) CreateOrUpdateApplicationGroupAssociationPreparer(ctx context.Context, groupID int32, applicationID int32, model GroupApplicationModel) (*http.Request, error) {
        pathParameters := map[string]interface{} {
        "applicationID": autorest.Encode("path",applicationID),
        "groupID": autorest.Encode("path",groupID),
        }

        preparer := autorest.CreatePreparer(
            autorest.AsJSON(),
            autorest.AsPut(),
            autorest.WithBaseURL(client.BaseURI),
            autorest.WithPathParameters("/v1/directory/applications/{applicationID}/groups/{groupID}",pathParameters),
            autorest.WithJSON(model))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
    }

    // CreateOrUpdateApplicationGroupAssociationSender sends the CreateOrUpdateApplicationGroupAssociation request. The method will close the
    // http.Response Body if it receives an error.
    func (client BaseClient) CreateOrUpdateApplicationGroupAssociationSender(req *http.Request) (*http.Response, error) {
        return autorest.SendWithSender(client, req,
            autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
    }

    // CreateOrUpdateApplicationGroupAssociationResponder handles the response to the CreateOrUpdateApplicationGroupAssociation request. The method always
    // closes the http.Response Body.
    func (client BaseClient) CreateOrUpdateApplicationGroupAssociationResponder(resp *http.Response) (result SetObject, err error) {
        err = autorest.Respond(
            resp,
            client.ByInspecting(),
            azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusNoContent,http.StatusForbidden),
            autorest.ByUnmarshallingJSON(&result.Value),
            autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
        return
    }

    // CreateOrUpdateApplicationUserAssociation sends the create or update application user association request.
    //
    // userID is the user identifier. applicationID is the application identifier. model is the model.
    func (client BaseClient) CreateOrUpdateApplicationUserAssociation(ctx context.Context, userID int32, applicationID int32, model UserApplicationModel) (result SetObject, err error) {
        if err := validation.Validate([]validation.Validation{
        { TargetValue: model,
         Constraints: []validation.Constraint{	{Target: "model.UserFullName", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "model.UserFullName", Name: validation.MaxLength, Rule: 255, Chain: nil },
        	{Target: "model.UserFullName", Name: validation.MinLength, Rule: 0, Chain: nil },
        }},
        	{Target: "model.ApplicationName", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "model.ApplicationName", Name: validation.MaxLength, Rule: 255, Chain: nil },
        	{Target: "model.ApplicationName", Name: validation.MinLength, Rule: 0, Chain: nil },
        }}}}}); err != nil {
            return result, validation.NewErrorWithValidationError(err, "softheonenterpriseapiclient.BaseClient","CreateOrUpdateApplicationUserAssociation")
        }

        req, err := client.CreateOrUpdateApplicationUserAssociationPreparer(ctx, userID, applicationID, model)
        if err != nil {
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "CreateOrUpdateApplicationUserAssociation", nil , "Failure preparing request")
            return
        }

        resp, err := client.CreateOrUpdateApplicationUserAssociationSender(req)
        if err != nil {
            result.Response = autorest.Response{Response: resp}
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "CreateOrUpdateApplicationUserAssociation", resp, "Failure sending request")
            return
        }

        result, err = client.CreateOrUpdateApplicationUserAssociationResponder(resp)
        if err != nil {
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "CreateOrUpdateApplicationUserAssociation", resp, "Failure responding to request")
        }

        return
    }

    // CreateOrUpdateApplicationUserAssociationPreparer prepares the CreateOrUpdateApplicationUserAssociation request.
    func (client BaseClient) CreateOrUpdateApplicationUserAssociationPreparer(ctx context.Context, userID int32, applicationID int32, model UserApplicationModel) (*http.Request, error) {
        pathParameters := map[string]interface{} {
        "applicationID": autorest.Encode("path",applicationID),
        "userID": autorest.Encode("path",userID),
        }

        preparer := autorest.CreatePreparer(
            autorest.AsJSON(),
            autorest.AsPut(),
            autorest.WithBaseURL(client.BaseURI),
            autorest.WithPathParameters("/v1/directory/applications/{applicationID}/users/{userID}",pathParameters),
            autorest.WithJSON(model))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
    }

    // CreateOrUpdateApplicationUserAssociationSender sends the CreateOrUpdateApplicationUserAssociation request. The method will close the
    // http.Response Body if it receives an error.
    func (client BaseClient) CreateOrUpdateApplicationUserAssociationSender(req *http.Request) (*http.Response, error) {
        return autorest.SendWithSender(client, req,
            autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
    }

    // CreateOrUpdateApplicationUserAssociationResponder handles the response to the CreateOrUpdateApplicationUserAssociation request. The method always
    // closes the http.Response Body.
    func (client BaseClient) CreateOrUpdateApplicationUserAssociationResponder(resp *http.Response) (result SetObject, err error) {
        err = autorest.Respond(
            resp,
            client.ByInspecting(),
            azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusNoContent,http.StatusForbidden),
            autorest.ByUnmarshallingJSON(&result.Value),
            autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
        return
    }

    // CreateOrUpdateDrawerGroupAssociation sends the create or update drawer group association request.
    //
    // groupID is the group identifier. drawerID is the drawer identifier. model is the model.
    func (client BaseClient) CreateOrUpdateDrawerGroupAssociation(ctx context.Context, groupID int32, drawerID int32, model GroupDrawerModel) (result SetObject, err error) {
        if err := validation.Validate([]validation.Validation{
        { TargetValue: model,
         Constraints: []validation.Constraint{	{Target: "model.GroupName", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "model.GroupName", Name: validation.MaxLength, Rule: 255, Chain: nil },
        	{Target: "model.GroupName", Name: validation.MinLength, Rule: 0, Chain: nil },
        }},
        	{Target: "model.DrawerName", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "model.DrawerName", Name: validation.MaxLength, Rule: 255, Chain: nil },
        	{Target: "model.DrawerName", Name: validation.MinLength, Rule: 0, Chain: nil },
        }}}}}); err != nil {
            return result, validation.NewErrorWithValidationError(err, "softheonenterpriseapiclient.BaseClient","CreateOrUpdateDrawerGroupAssociation")
        }

        req, err := client.CreateOrUpdateDrawerGroupAssociationPreparer(ctx, groupID, drawerID, model)
        if err != nil {
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "CreateOrUpdateDrawerGroupAssociation", nil , "Failure preparing request")
            return
        }

        resp, err := client.CreateOrUpdateDrawerGroupAssociationSender(req)
        if err != nil {
            result.Response = autorest.Response{Response: resp}
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "CreateOrUpdateDrawerGroupAssociation", resp, "Failure sending request")
            return
        }

        result, err = client.CreateOrUpdateDrawerGroupAssociationResponder(resp)
        if err != nil {
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "CreateOrUpdateDrawerGroupAssociation", resp, "Failure responding to request")
        }

        return
    }

    // CreateOrUpdateDrawerGroupAssociationPreparer prepares the CreateOrUpdateDrawerGroupAssociation request.
    func (client BaseClient) CreateOrUpdateDrawerGroupAssociationPreparer(ctx context.Context, groupID int32, drawerID int32, model GroupDrawerModel) (*http.Request, error) {
        pathParameters := map[string]interface{} {
        "drawerID": autorest.Encode("path",drawerID),
        "groupID": autorest.Encode("path",groupID),
        }

        preparer := autorest.CreatePreparer(
            autorest.AsJSON(),
            autorest.AsPut(),
            autorest.WithBaseURL(client.BaseURI),
            autorest.WithPathParameters("/v1/directory/drawers/{drawerID}/groups/{groupID}",pathParameters),
            autorest.WithJSON(model))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
    }

    // CreateOrUpdateDrawerGroupAssociationSender sends the CreateOrUpdateDrawerGroupAssociation request. The method will close the
    // http.Response Body if it receives an error.
    func (client BaseClient) CreateOrUpdateDrawerGroupAssociationSender(req *http.Request) (*http.Response, error) {
        return autorest.SendWithSender(client, req,
            autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
    }

    // CreateOrUpdateDrawerGroupAssociationResponder handles the response to the CreateOrUpdateDrawerGroupAssociation request. The method always
    // closes the http.Response Body.
    func (client BaseClient) CreateOrUpdateDrawerGroupAssociationResponder(resp *http.Response) (result SetObject, err error) {
        err = autorest.Respond(
            resp,
            client.ByInspecting(),
            azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusNoContent,http.StatusForbidden),
            autorest.ByUnmarshallingJSON(&result.Value),
            autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
        return
    }

    // CreateOrUpdateDrawerUserAssociation sends the create or update drawer user association request.
    //
    // userID is the user identifier. drawerID is the drawer identifier. model is the model.
    func (client BaseClient) CreateOrUpdateDrawerUserAssociation(ctx context.Context, userID int32, drawerID int32, model UserDrawerModel) (result SetObject, err error) {
        if err := validation.Validate([]validation.Validation{
        { TargetValue: model,
         Constraints: []validation.Constraint{	{Target: "model.UserFullName", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "model.UserFullName", Name: validation.MaxLength, Rule: 255, Chain: nil },
        	{Target: "model.UserFullName", Name: validation.MinLength, Rule: 0, Chain: nil },
        }},
        	{Target: "model.DrawerName", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "model.DrawerName", Name: validation.MaxLength, Rule: 255, Chain: nil },
        	{Target: "model.DrawerName", Name: validation.MinLength, Rule: 0, Chain: nil },
        }}}}}); err != nil {
            return result, validation.NewErrorWithValidationError(err, "softheonenterpriseapiclient.BaseClient","CreateOrUpdateDrawerUserAssociation")
        }

        req, err := client.CreateOrUpdateDrawerUserAssociationPreparer(ctx, userID, drawerID, model)
        if err != nil {
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "CreateOrUpdateDrawerUserAssociation", nil , "Failure preparing request")
            return
        }

        resp, err := client.CreateOrUpdateDrawerUserAssociationSender(req)
        if err != nil {
            result.Response = autorest.Response{Response: resp}
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "CreateOrUpdateDrawerUserAssociation", resp, "Failure sending request")
            return
        }

        result, err = client.CreateOrUpdateDrawerUserAssociationResponder(resp)
        if err != nil {
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "CreateOrUpdateDrawerUserAssociation", resp, "Failure responding to request")
        }

        return
    }

    // CreateOrUpdateDrawerUserAssociationPreparer prepares the CreateOrUpdateDrawerUserAssociation request.
    func (client BaseClient) CreateOrUpdateDrawerUserAssociationPreparer(ctx context.Context, userID int32, drawerID int32, model UserDrawerModel) (*http.Request, error) {
        pathParameters := map[string]interface{} {
        "drawerID": autorest.Encode("path",drawerID),
        "userID": autorest.Encode("path",userID),
        }

        preparer := autorest.CreatePreparer(
            autorest.AsJSON(),
            autorest.AsPut(),
            autorest.WithBaseURL(client.BaseURI),
            autorest.WithPathParameters("/v1/directory/drawers/{drawerID}/users/{userID}",pathParameters),
            autorest.WithJSON(model))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
    }

    // CreateOrUpdateDrawerUserAssociationSender sends the CreateOrUpdateDrawerUserAssociation request. The method will close the
    // http.Response Body if it receives an error.
    func (client BaseClient) CreateOrUpdateDrawerUserAssociationSender(req *http.Request) (*http.Response, error) {
        return autorest.SendWithSender(client, req,
            autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
    }

    // CreateOrUpdateDrawerUserAssociationResponder handles the response to the CreateOrUpdateDrawerUserAssociation request. The method always
    // closes the http.Response Body.
    func (client BaseClient) CreateOrUpdateDrawerUserAssociationResponder(resp *http.Response) (result SetObject, err error) {
        err = autorest.Respond(
            resp,
            client.ByInspecting(),
            azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusNoContent,http.StatusForbidden),
            autorest.ByUnmarshallingJSON(&result.Value),
            autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
        return
    }

    // CreateOrUpdateGroupApplicationAssociation sends the create or update group application association request.
    //
    // groupID is the group identifier. applicationID is the application identifier. model is the model.
    func (client BaseClient) CreateOrUpdateGroupApplicationAssociation(ctx context.Context, groupID int32, applicationID int32, model GroupApplicationModel) (result SetObject, err error) {
        if err := validation.Validate([]validation.Validation{
        { TargetValue: model,
         Constraints: []validation.Constraint{	{Target: "model.GroupName", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "model.GroupName", Name: validation.MaxLength, Rule: 255, Chain: nil },
        	{Target: "model.GroupName", Name: validation.MinLength, Rule: 0, Chain: nil },
        }},
        	{Target: "model.ApplicationName", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "model.ApplicationName", Name: validation.MaxLength, Rule: 255, Chain: nil },
        	{Target: "model.ApplicationName", Name: validation.MinLength, Rule: 0, Chain: nil },
        }}}}}); err != nil {
            return result, validation.NewErrorWithValidationError(err, "softheonenterpriseapiclient.BaseClient","CreateOrUpdateGroupApplicationAssociation")
        }

        req, err := client.CreateOrUpdateGroupApplicationAssociationPreparer(ctx, groupID, applicationID, model)
        if err != nil {
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "CreateOrUpdateGroupApplicationAssociation", nil , "Failure preparing request")
            return
        }

        resp, err := client.CreateOrUpdateGroupApplicationAssociationSender(req)
        if err != nil {
            result.Response = autorest.Response{Response: resp}
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "CreateOrUpdateGroupApplicationAssociation", resp, "Failure sending request")
            return
        }

        result, err = client.CreateOrUpdateGroupApplicationAssociationResponder(resp)
        if err != nil {
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "CreateOrUpdateGroupApplicationAssociation", resp, "Failure responding to request")
        }

        return
    }

    // CreateOrUpdateGroupApplicationAssociationPreparer prepares the CreateOrUpdateGroupApplicationAssociation request.
    func (client BaseClient) CreateOrUpdateGroupApplicationAssociationPreparer(ctx context.Context, groupID int32, applicationID int32, model GroupApplicationModel) (*http.Request, error) {
        pathParameters := map[string]interface{} {
        "applicationID": autorest.Encode("path",applicationID),
        "groupID": autorest.Encode("path",groupID),
        }

        preparer := autorest.CreatePreparer(
            autorest.AsJSON(),
            autorest.AsPut(),
            autorest.WithBaseURL(client.BaseURI),
            autorest.WithPathParameters("/v1/directory/groups/{groupID}/applications/{applicationID}",pathParameters),
            autorest.WithJSON(model))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
    }

    // CreateOrUpdateGroupApplicationAssociationSender sends the CreateOrUpdateGroupApplicationAssociation request. The method will close the
    // http.Response Body if it receives an error.
    func (client BaseClient) CreateOrUpdateGroupApplicationAssociationSender(req *http.Request) (*http.Response, error) {
        return autorest.SendWithSender(client, req,
            autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
    }

    // CreateOrUpdateGroupApplicationAssociationResponder handles the response to the CreateOrUpdateGroupApplicationAssociation request. The method always
    // closes the http.Response Body.
    func (client BaseClient) CreateOrUpdateGroupApplicationAssociationResponder(resp *http.Response) (result SetObject, err error) {
        err = autorest.Respond(
            resp,
            client.ByInspecting(),
            azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusNoContent,http.StatusForbidden),
            autorest.ByUnmarshallingJSON(&result.Value),
            autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
        return
    }

    // CreateOrUpdateGroupDrawerAssociation sends the create or update group drawer association request.
    //
    // groupID is the group identifier. drawerID is the drawer identifier. model is the model.
    func (client BaseClient) CreateOrUpdateGroupDrawerAssociation(ctx context.Context, groupID int32, drawerID int32, model GroupDrawerModel) (result SetObject, err error) {
        if err := validation.Validate([]validation.Validation{
        { TargetValue: model,
         Constraints: []validation.Constraint{	{Target: "model.GroupName", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "model.GroupName", Name: validation.MaxLength, Rule: 255, Chain: nil },
        	{Target: "model.GroupName", Name: validation.MinLength, Rule: 0, Chain: nil },
        }},
        	{Target: "model.DrawerName", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "model.DrawerName", Name: validation.MaxLength, Rule: 255, Chain: nil },
        	{Target: "model.DrawerName", Name: validation.MinLength, Rule: 0, Chain: nil },
        }}}}}); err != nil {
            return result, validation.NewErrorWithValidationError(err, "softheonenterpriseapiclient.BaseClient","CreateOrUpdateGroupDrawerAssociation")
        }

        req, err := client.CreateOrUpdateGroupDrawerAssociationPreparer(ctx, groupID, drawerID, model)
        if err != nil {
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "CreateOrUpdateGroupDrawerAssociation", nil , "Failure preparing request")
            return
        }

        resp, err := client.CreateOrUpdateGroupDrawerAssociationSender(req)
        if err != nil {
            result.Response = autorest.Response{Response: resp}
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "CreateOrUpdateGroupDrawerAssociation", resp, "Failure sending request")
            return
        }

        result, err = client.CreateOrUpdateGroupDrawerAssociationResponder(resp)
        if err != nil {
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "CreateOrUpdateGroupDrawerAssociation", resp, "Failure responding to request")
        }

        return
    }

    // CreateOrUpdateGroupDrawerAssociationPreparer prepares the CreateOrUpdateGroupDrawerAssociation request.
    func (client BaseClient) CreateOrUpdateGroupDrawerAssociationPreparer(ctx context.Context, groupID int32, drawerID int32, model GroupDrawerModel) (*http.Request, error) {
        pathParameters := map[string]interface{} {
        "drawerID": autorest.Encode("path",drawerID),
        "groupID": autorest.Encode("path",groupID),
        }

        preparer := autorest.CreatePreparer(
            autorest.AsJSON(),
            autorest.AsPut(),
            autorest.WithBaseURL(client.BaseURI),
            autorest.WithPathParameters("/v1/directory/groups/{groupID}/drawers/{drawerID}",pathParameters),
            autorest.WithJSON(model))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
    }

    // CreateOrUpdateGroupDrawerAssociationSender sends the CreateOrUpdateGroupDrawerAssociation request. The method will close the
    // http.Response Body if it receives an error.
    func (client BaseClient) CreateOrUpdateGroupDrawerAssociationSender(req *http.Request) (*http.Response, error) {
        return autorest.SendWithSender(client, req,
            autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
    }

    // CreateOrUpdateGroupDrawerAssociationResponder handles the response to the CreateOrUpdateGroupDrawerAssociation request. The method always
    // closes the http.Response Body.
    func (client BaseClient) CreateOrUpdateGroupDrawerAssociationResponder(resp *http.Response) (result SetObject, err error) {
        err = autorest.Respond(
            resp,
            client.ByInspecting(),
            azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusNoContent,http.StatusForbidden),
            autorest.ByUnmarshallingJSON(&result.Value),
            autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
        return
    }

    // CreateOrUpdateGroupQueueAssociation sends the create or update group queue association request.
    //
    // groupID is the group identifier. queueID is the queue identifier. model is the model.
    func (client BaseClient) CreateOrUpdateGroupQueueAssociation(ctx context.Context, groupID int32, queueID int32, model GroupQueueModel) (result SetObject, err error) {
        if err := validation.Validate([]validation.Validation{
        { TargetValue: model,
         Constraints: []validation.Constraint{	{Target: "model.GroupName", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "model.GroupName", Name: validation.MaxLength, Rule: 255, Chain: nil },
        	{Target: "model.GroupName", Name: validation.MinLength, Rule: 0, Chain: nil },
        }},
        	{Target: "model.QueueName", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "model.QueueName", Name: validation.MaxLength, Rule: 255, Chain: nil },
        	{Target: "model.QueueName", Name: validation.MinLength, Rule: 0, Chain: nil },
        }}}}}); err != nil {
            return result, validation.NewErrorWithValidationError(err, "softheonenterpriseapiclient.BaseClient","CreateOrUpdateGroupQueueAssociation")
        }

        req, err := client.CreateOrUpdateGroupQueueAssociationPreparer(ctx, groupID, queueID, model)
        if err != nil {
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "CreateOrUpdateGroupQueueAssociation", nil , "Failure preparing request")
            return
        }

        resp, err := client.CreateOrUpdateGroupQueueAssociationSender(req)
        if err != nil {
            result.Response = autorest.Response{Response: resp}
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "CreateOrUpdateGroupQueueAssociation", resp, "Failure sending request")
            return
        }

        result, err = client.CreateOrUpdateGroupQueueAssociationResponder(resp)
        if err != nil {
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "CreateOrUpdateGroupQueueAssociation", resp, "Failure responding to request")
        }

        return
    }

    // CreateOrUpdateGroupQueueAssociationPreparer prepares the CreateOrUpdateGroupQueueAssociation request.
    func (client BaseClient) CreateOrUpdateGroupQueueAssociationPreparer(ctx context.Context, groupID int32, queueID int32, model GroupQueueModel) (*http.Request, error) {
        pathParameters := map[string]interface{} {
        "groupID": autorest.Encode("path",groupID),
        "queueID": autorest.Encode("path",queueID),
        }

        preparer := autorest.CreatePreparer(
            autorest.AsJSON(),
            autorest.AsPut(),
            autorest.WithBaseURL(client.BaseURI),
            autorest.WithPathParameters("/v1/directory/groups/{groupID}/queues/{queueID}",pathParameters),
            autorest.WithJSON(model))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
    }

    // CreateOrUpdateGroupQueueAssociationSender sends the CreateOrUpdateGroupQueueAssociation request. The method will close the
    // http.Response Body if it receives an error.
    func (client BaseClient) CreateOrUpdateGroupQueueAssociationSender(req *http.Request) (*http.Response, error) {
        return autorest.SendWithSender(client, req,
            autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
    }

    // CreateOrUpdateGroupQueueAssociationResponder handles the response to the CreateOrUpdateGroupQueueAssociation request. The method always
    // closes the http.Response Body.
    func (client BaseClient) CreateOrUpdateGroupQueueAssociationResponder(resp *http.Response) (result SetObject, err error) {
        err = autorest.Respond(
            resp,
            client.ByInspecting(),
            azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusNoContent,http.StatusForbidden),
            autorest.ByUnmarshallingJSON(&result.Value),
            autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
        return
    }

    // CreateOrUpdateLock sends the create or update lock request.
    //
    // drawer is the drawer identifier. ID is the entity identifier. model is the lock model.
    func (client BaseClient) CreateOrUpdateLock(ctx context.Context, drawer int32, ID int32, model UpdateLockRequestModel) (result SetObject, err error) {
        if err := validation.Validate([]validation.Validation{
        { TargetValue: model,
         Constraints: []validation.Constraint{	{Target: "model.ExpirationDuration", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "model.ExpirationDuration", Name: validation.InclusiveMaximum, Rule: 2147483647, Chain: nil },
        	{Target: "model.ExpirationDuration", Name: validation.InclusiveMinimum, Rule: 0, Chain: nil },
        }},
        	{Target: "model.ApplicationName", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "model.ApplicationName", Name: validation.MaxLength, Rule: 255, Chain: nil },
        	{Target: "model.ApplicationName", Name: validation.MinLength, Rule: 0, Chain: nil },
        }}}}}); err != nil {
            return result, validation.NewErrorWithValidationError(err, "softheonenterpriseapiclient.BaseClient","CreateOrUpdateLock")
        }

        req, err := client.CreateOrUpdateLockPreparer(ctx, drawer, ID, model)
        if err != nil {
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "CreateOrUpdateLock", nil , "Failure preparing request")
            return
        }

        resp, err := client.CreateOrUpdateLockSender(req)
        if err != nil {
            result.Response = autorest.Response{Response: resp}
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "CreateOrUpdateLock", resp, "Failure sending request")
            return
        }

        result, err = client.CreateOrUpdateLockResponder(resp)
        if err != nil {
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "CreateOrUpdateLock", resp, "Failure responding to request")
        }

        return
    }

    // CreateOrUpdateLockPreparer prepares the CreateOrUpdateLock request.
    func (client BaseClient) CreateOrUpdateLockPreparer(ctx context.Context, drawer int32, ID int32, model UpdateLockRequestModel) (*http.Request, error) {
        pathParameters := map[string]interface{} {
        "drawer": autorest.Encode("path",drawer),
        "id": autorest.Encode("path",ID),
        }

        preparer := autorest.CreatePreparer(
            autorest.AsJSON(),
            autorest.AsPut(),
            autorest.WithBaseURL(client.BaseURI),
            autorest.WithPathParameters("/v1/content/entities/{drawer}/{id}/locks",pathParameters),
            autorest.WithJSON(model))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
    }

    // CreateOrUpdateLockSender sends the CreateOrUpdateLock request. The method will close the
    // http.Response Body if it receives an error.
    func (client BaseClient) CreateOrUpdateLockSender(req *http.Request) (*http.Response, error) {
        return autorest.SendWithSender(client, req,
            autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
    }

    // CreateOrUpdateLockResponder handles the response to the CreateOrUpdateLock request. The method always
    // closes the http.Response Body.
    func (client BaseClient) CreateOrUpdateLockResponder(resp *http.Response) (result SetObject, err error) {
        err = autorest.Respond(
            resp,
            client.ByInspecting(),
            azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusCreated,http.StatusForbidden,http.StatusNotFound),
            autorest.ByUnmarshallingJSON(&result.Value),
            autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
        return
    }

    // CreateOrUpdateQueueGroupAssociation sends the create or update queue group association request.
    //
    // groupID is the group identifier. queueID is the queue identifier. model is the model.
    func (client BaseClient) CreateOrUpdateQueueGroupAssociation(ctx context.Context, groupID int32, queueID int32, model GroupQueueModel) (result SetObject, err error) {
        if err := validation.Validate([]validation.Validation{
        { TargetValue: model,
         Constraints: []validation.Constraint{	{Target: "model.GroupName", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "model.GroupName", Name: validation.MaxLength, Rule: 255, Chain: nil },
        	{Target: "model.GroupName", Name: validation.MinLength, Rule: 0, Chain: nil },
        }},
        	{Target: "model.QueueName", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "model.QueueName", Name: validation.MaxLength, Rule: 255, Chain: nil },
        	{Target: "model.QueueName", Name: validation.MinLength, Rule: 0, Chain: nil },
        }}}}}); err != nil {
            return result, validation.NewErrorWithValidationError(err, "softheonenterpriseapiclient.BaseClient","CreateOrUpdateQueueGroupAssociation")
        }

        req, err := client.CreateOrUpdateQueueGroupAssociationPreparer(ctx, groupID, queueID, model)
        if err != nil {
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "CreateOrUpdateQueueGroupAssociation", nil , "Failure preparing request")
            return
        }

        resp, err := client.CreateOrUpdateQueueGroupAssociationSender(req)
        if err != nil {
            result.Response = autorest.Response{Response: resp}
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "CreateOrUpdateQueueGroupAssociation", resp, "Failure sending request")
            return
        }

        result, err = client.CreateOrUpdateQueueGroupAssociationResponder(resp)
        if err != nil {
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "CreateOrUpdateQueueGroupAssociation", resp, "Failure responding to request")
        }

        return
    }

    // CreateOrUpdateQueueGroupAssociationPreparer prepares the CreateOrUpdateQueueGroupAssociation request.
    func (client BaseClient) CreateOrUpdateQueueGroupAssociationPreparer(ctx context.Context, groupID int32, queueID int32, model GroupQueueModel) (*http.Request, error) {
        pathParameters := map[string]interface{} {
        "groupID": autorest.Encode("path",groupID),
        "queueID": autorest.Encode("path",queueID),
        }

        preparer := autorest.CreatePreparer(
            autorest.AsJSON(),
            autorest.AsPut(),
            autorest.WithBaseURL(client.BaseURI),
            autorest.WithPathParameters("/v1/workflow/queues/{queueID}/groups/{groupID}",pathParameters),
            autorest.WithJSON(model))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
    }

    // CreateOrUpdateQueueGroupAssociationSender sends the CreateOrUpdateQueueGroupAssociation request. The method will close the
    // http.Response Body if it receives an error.
    func (client BaseClient) CreateOrUpdateQueueGroupAssociationSender(req *http.Request) (*http.Response, error) {
        return autorest.SendWithSender(client, req,
            autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
    }

    // CreateOrUpdateQueueGroupAssociationResponder handles the response to the CreateOrUpdateQueueGroupAssociation request. The method always
    // closes the http.Response Body.
    func (client BaseClient) CreateOrUpdateQueueGroupAssociationResponder(resp *http.Response) (result SetObject, err error) {
        err = autorest.Respond(
            resp,
            client.ByInspecting(),
            azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusNoContent,http.StatusForbidden),
            autorest.ByUnmarshallingJSON(&result.Value),
            autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
        return
    }

    // CreateOrUpdateQueueUserAssociation sends the create or update queue user association request.
    //
    // userID is the user identifier. queueID is the queue identifier. model is the model.
    func (client BaseClient) CreateOrUpdateQueueUserAssociation(ctx context.Context, userID int32, queueID int32, model UserQueueModel) (result SetObject, err error) {
        if err := validation.Validate([]validation.Validation{
        { TargetValue: model,
         Constraints: []validation.Constraint{	{Target: "model.UserFullName", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "model.UserFullName", Name: validation.MaxLength, Rule: 255, Chain: nil },
        	{Target: "model.UserFullName", Name: validation.MinLength, Rule: 0, Chain: nil },
        }},
        	{Target: "model.QueueName", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "model.QueueName", Name: validation.MaxLength, Rule: 255, Chain: nil },
        	{Target: "model.QueueName", Name: validation.MinLength, Rule: 0, Chain: nil },
        }}}}}); err != nil {
            return result, validation.NewErrorWithValidationError(err, "softheonenterpriseapiclient.BaseClient","CreateOrUpdateQueueUserAssociation")
        }

        req, err := client.CreateOrUpdateQueueUserAssociationPreparer(ctx, userID, queueID, model)
        if err != nil {
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "CreateOrUpdateQueueUserAssociation", nil , "Failure preparing request")
            return
        }

        resp, err := client.CreateOrUpdateQueueUserAssociationSender(req)
        if err != nil {
            result.Response = autorest.Response{Response: resp}
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "CreateOrUpdateQueueUserAssociation", resp, "Failure sending request")
            return
        }

        result, err = client.CreateOrUpdateQueueUserAssociationResponder(resp)
        if err != nil {
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "CreateOrUpdateQueueUserAssociation", resp, "Failure responding to request")
        }

        return
    }

    // CreateOrUpdateQueueUserAssociationPreparer prepares the CreateOrUpdateQueueUserAssociation request.
    func (client BaseClient) CreateOrUpdateQueueUserAssociationPreparer(ctx context.Context, userID int32, queueID int32, model UserQueueModel) (*http.Request, error) {
        pathParameters := map[string]interface{} {
        "queueID": autorest.Encode("path",queueID),
        "userID": autorest.Encode("path",userID),
        }

        preparer := autorest.CreatePreparer(
            autorest.AsJSON(),
            autorest.AsPut(),
            autorest.WithBaseURL(client.BaseURI),
            autorest.WithPathParameters("/v1/workflow/queues/{queueID}/users/{userID}",pathParameters),
            autorest.WithJSON(model))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
    }

    // CreateOrUpdateQueueUserAssociationSender sends the CreateOrUpdateQueueUserAssociation request. The method will close the
    // http.Response Body if it receives an error.
    func (client BaseClient) CreateOrUpdateQueueUserAssociationSender(req *http.Request) (*http.Response, error) {
        return autorest.SendWithSender(client, req,
            autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
    }

    // CreateOrUpdateQueueUserAssociationResponder handles the response to the CreateOrUpdateQueueUserAssociation request. The method always
    // closes the http.Response Body.
    func (client BaseClient) CreateOrUpdateQueueUserAssociationResponder(resp *http.Response) (result SetObject, err error) {
        err = autorest.Respond(
            resp,
            client.ByInspecting(),
            azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusNoContent,http.StatusForbidden),
            autorest.ByUnmarshallingJSON(&result.Value),
            autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
        return
    }

    // CreateOrUpdateUserApplicationAssociation sends the create or update user application association request.
    //
    // userID is the user identifier. applicationID is the application identifier. model is the model.
    func (client BaseClient) CreateOrUpdateUserApplicationAssociation(ctx context.Context, userID int32, applicationID int32, model UserApplicationModel) (result SetObject, err error) {
        if err := validation.Validate([]validation.Validation{
        { TargetValue: model,
         Constraints: []validation.Constraint{	{Target: "model.UserFullName", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "model.UserFullName", Name: validation.MaxLength, Rule: 255, Chain: nil },
        	{Target: "model.UserFullName", Name: validation.MinLength, Rule: 0, Chain: nil },
        }},
        	{Target: "model.ApplicationName", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "model.ApplicationName", Name: validation.MaxLength, Rule: 255, Chain: nil },
        	{Target: "model.ApplicationName", Name: validation.MinLength, Rule: 0, Chain: nil },
        }}}}}); err != nil {
            return result, validation.NewErrorWithValidationError(err, "softheonenterpriseapiclient.BaseClient","CreateOrUpdateUserApplicationAssociation")
        }

        req, err := client.CreateOrUpdateUserApplicationAssociationPreparer(ctx, userID, applicationID, model)
        if err != nil {
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "CreateOrUpdateUserApplicationAssociation", nil , "Failure preparing request")
            return
        }

        resp, err := client.CreateOrUpdateUserApplicationAssociationSender(req)
        if err != nil {
            result.Response = autorest.Response{Response: resp}
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "CreateOrUpdateUserApplicationAssociation", resp, "Failure sending request")
            return
        }

        result, err = client.CreateOrUpdateUserApplicationAssociationResponder(resp)
        if err != nil {
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "CreateOrUpdateUserApplicationAssociation", resp, "Failure responding to request")
        }

        return
    }

    // CreateOrUpdateUserApplicationAssociationPreparer prepares the CreateOrUpdateUserApplicationAssociation request.
    func (client BaseClient) CreateOrUpdateUserApplicationAssociationPreparer(ctx context.Context, userID int32, applicationID int32, model UserApplicationModel) (*http.Request, error) {
        pathParameters := map[string]interface{} {
        "applicationID": autorest.Encode("path",applicationID),
        "userID": autorest.Encode("path",userID),
        }

        preparer := autorest.CreatePreparer(
            autorest.AsJSON(),
            autorest.AsPut(),
            autorest.WithBaseURL(client.BaseURI),
            autorest.WithPathParameters("/v1/directory/users/{userID}/applications/{applicationID}",pathParameters),
            autorest.WithJSON(model))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
    }

    // CreateOrUpdateUserApplicationAssociationSender sends the CreateOrUpdateUserApplicationAssociation request. The method will close the
    // http.Response Body if it receives an error.
    func (client BaseClient) CreateOrUpdateUserApplicationAssociationSender(req *http.Request) (*http.Response, error) {
        return autorest.SendWithSender(client, req,
            autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
    }

    // CreateOrUpdateUserApplicationAssociationResponder handles the response to the CreateOrUpdateUserApplicationAssociation request. The method always
    // closes the http.Response Body.
    func (client BaseClient) CreateOrUpdateUserApplicationAssociationResponder(resp *http.Response) (result SetObject, err error) {
        err = autorest.Respond(
            resp,
            client.ByInspecting(),
            azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusNoContent,http.StatusForbidden),
            autorest.ByUnmarshallingJSON(&result.Value),
            autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
        return
    }

    // CreateOrUpdateUserDrawerAssociation sends the create or update user drawer association request.
    //
    // userID is the user identifier. drawerID is the drawer identifier. model is the model.
    func (client BaseClient) CreateOrUpdateUserDrawerAssociation(ctx context.Context, userID int32, drawerID int32, model UserDrawerModel) (result SetObject, err error) {
        if err := validation.Validate([]validation.Validation{
        { TargetValue: model,
         Constraints: []validation.Constraint{	{Target: "model.UserFullName", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "model.UserFullName", Name: validation.MaxLength, Rule: 255, Chain: nil },
        	{Target: "model.UserFullName", Name: validation.MinLength, Rule: 0, Chain: nil },
        }},
        	{Target: "model.DrawerName", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "model.DrawerName", Name: validation.MaxLength, Rule: 255, Chain: nil },
        	{Target: "model.DrawerName", Name: validation.MinLength, Rule: 0, Chain: nil },
        }}}}}); err != nil {
            return result, validation.NewErrorWithValidationError(err, "softheonenterpriseapiclient.BaseClient","CreateOrUpdateUserDrawerAssociation")
        }

        req, err := client.CreateOrUpdateUserDrawerAssociationPreparer(ctx, userID, drawerID, model)
        if err != nil {
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "CreateOrUpdateUserDrawerAssociation", nil , "Failure preparing request")
            return
        }

        resp, err := client.CreateOrUpdateUserDrawerAssociationSender(req)
        if err != nil {
            result.Response = autorest.Response{Response: resp}
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "CreateOrUpdateUserDrawerAssociation", resp, "Failure sending request")
            return
        }

        result, err = client.CreateOrUpdateUserDrawerAssociationResponder(resp)
        if err != nil {
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "CreateOrUpdateUserDrawerAssociation", resp, "Failure responding to request")
        }

        return
    }

    // CreateOrUpdateUserDrawerAssociationPreparer prepares the CreateOrUpdateUserDrawerAssociation request.
    func (client BaseClient) CreateOrUpdateUserDrawerAssociationPreparer(ctx context.Context, userID int32, drawerID int32, model UserDrawerModel) (*http.Request, error) {
        pathParameters := map[string]interface{} {
        "drawerID": autorest.Encode("path",drawerID),
        "userID": autorest.Encode("path",userID),
        }

        preparer := autorest.CreatePreparer(
            autorest.AsJSON(),
            autorest.AsPut(),
            autorest.WithBaseURL(client.BaseURI),
            autorest.WithPathParameters("/v1/directory/users/{userID}/drawers/{drawerID}",pathParameters),
            autorest.WithJSON(model))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
    }

    // CreateOrUpdateUserDrawerAssociationSender sends the CreateOrUpdateUserDrawerAssociation request. The method will close the
    // http.Response Body if it receives an error.
    func (client BaseClient) CreateOrUpdateUserDrawerAssociationSender(req *http.Request) (*http.Response, error) {
        return autorest.SendWithSender(client, req,
            autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
    }

    // CreateOrUpdateUserDrawerAssociationResponder handles the response to the CreateOrUpdateUserDrawerAssociation request. The method always
    // closes the http.Response Body.
    func (client BaseClient) CreateOrUpdateUserDrawerAssociationResponder(resp *http.Response) (result SetObject, err error) {
        err = autorest.Respond(
            resp,
            client.ByInspecting(),
            azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusNoContent,http.StatusForbidden),
            autorest.ByUnmarshallingJSON(&result.Value),
            autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
        return
    }

    // CreateOrUpdateUserQueueAssociation sends the create or update user queue association request.
    //
    // userID is the user identifier. queueID is the queue identifier. model is the model.
    func (client BaseClient) CreateOrUpdateUserQueueAssociation(ctx context.Context, userID int32, queueID int32, model UserQueueModel) (result SetObject, err error) {
        if err := validation.Validate([]validation.Validation{
        { TargetValue: model,
         Constraints: []validation.Constraint{	{Target: "model.UserFullName", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "model.UserFullName", Name: validation.MaxLength, Rule: 255, Chain: nil },
        	{Target: "model.UserFullName", Name: validation.MinLength, Rule: 0, Chain: nil },
        }},
        	{Target: "model.QueueName", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "model.QueueName", Name: validation.MaxLength, Rule: 255, Chain: nil },
        	{Target: "model.QueueName", Name: validation.MinLength, Rule: 0, Chain: nil },
        }}}}}); err != nil {
            return result, validation.NewErrorWithValidationError(err, "softheonenterpriseapiclient.BaseClient","CreateOrUpdateUserQueueAssociation")
        }

        req, err := client.CreateOrUpdateUserQueueAssociationPreparer(ctx, userID, queueID, model)
        if err != nil {
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "CreateOrUpdateUserQueueAssociation", nil , "Failure preparing request")
            return
        }

        resp, err := client.CreateOrUpdateUserQueueAssociationSender(req)
        if err != nil {
            result.Response = autorest.Response{Response: resp}
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "CreateOrUpdateUserQueueAssociation", resp, "Failure sending request")
            return
        }

        result, err = client.CreateOrUpdateUserQueueAssociationResponder(resp)
        if err != nil {
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "CreateOrUpdateUserQueueAssociation", resp, "Failure responding to request")
        }

        return
    }

    // CreateOrUpdateUserQueueAssociationPreparer prepares the CreateOrUpdateUserQueueAssociation request.
    func (client BaseClient) CreateOrUpdateUserQueueAssociationPreparer(ctx context.Context, userID int32, queueID int32, model UserQueueModel) (*http.Request, error) {
        pathParameters := map[string]interface{} {
        "queueID": autorest.Encode("path",queueID),
        "userID": autorest.Encode("path",userID),
        }

        preparer := autorest.CreatePreparer(
            autorest.AsJSON(),
            autorest.AsPut(),
            autorest.WithBaseURL(client.BaseURI),
            autorest.WithPathParameters("/v1/directory/users/{userID}/queues/{queueID}",pathParameters),
            autorest.WithJSON(model))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
    }

    // CreateOrUpdateUserQueueAssociationSender sends the CreateOrUpdateUserQueueAssociation request. The method will close the
    // http.Response Body if it receives an error.
    func (client BaseClient) CreateOrUpdateUserQueueAssociationSender(req *http.Request) (*http.Response, error) {
        return autorest.SendWithSender(client, req,
            autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
    }

    // CreateOrUpdateUserQueueAssociationResponder handles the response to the CreateOrUpdateUserQueueAssociation request. The method always
    // closes the http.Response Body.
    func (client BaseClient) CreateOrUpdateUserQueueAssociationResponder(resp *http.Response) (result SetObject, err error) {
        err = autorest.Respond(
            resp,
            client.ByInspecting(),
            azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusNoContent,http.StatusForbidden),
            autorest.ByUnmarshallingJSON(&result.Value),
            autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
        return
    }

    // CreateQueue sends the create queue request.
    //
    // model is the queue model.
    func (client BaseClient) CreateQueue(ctx context.Context, model InsertQueueRequestModel) (result QueueModel, err error) {
        if err := validation.Validate([]validation.Validation{
        { TargetValue: model,
         Constraints: []validation.Constraint{	{Target: "model.Name", Name: validation.Null, Rule: true ,
        Chain: []validation.Constraint{	{Target: "model.Name", Name: validation.MaxLength, Rule: 255, Chain: nil },
        	{Target: "model.Name", Name: validation.MinLength, Rule: 0, Chain: nil },
        }},
        	{Target: "model.Alias", Name: validation.Null, Rule: true ,
        Chain: []validation.Constraint{	{Target: "model.Alias", Name: validation.MaxLength, Rule: 255, Chain: nil },
        	{Target: "model.Alias", Name: validation.MinLength, Rule: 0, Chain: nil },
        }}}}}); err != nil {
            return result, validation.NewErrorWithValidationError(err, "softheonenterpriseapiclient.BaseClient","CreateQueue")
        }

        req, err := client.CreateQueuePreparer(ctx, model)
        if err != nil {
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "CreateQueue", nil , "Failure preparing request")
            return
        }

        resp, err := client.CreateQueueSender(req)
        if err != nil {
            result.Response = autorest.Response{Response: resp}
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "CreateQueue", resp, "Failure sending request")
            return
        }

        result, err = client.CreateQueueResponder(resp)
        if err != nil {
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "CreateQueue", resp, "Failure responding to request")
        }

        return
    }

    // CreateQueuePreparer prepares the CreateQueue request.
    func (client BaseClient) CreateQueuePreparer(ctx context.Context, model InsertQueueRequestModel) (*http.Request, error) {
        preparer := autorest.CreatePreparer(
            autorest.AsJSON(),
            autorest.AsPost(),
            autorest.WithBaseURL(client.BaseURI),
            autorest.WithPath("/v1/workflow/queues"),
            autorest.WithJSON(model))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
    }

    // CreateQueueSender sends the CreateQueue request. The method will close the
    // http.Response Body if it receives an error.
    func (client BaseClient) CreateQueueSender(req *http.Request) (*http.Response, error) {
        return autorest.SendWithSender(client, req,
            autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
    }

    // CreateQueueResponder handles the response to the CreateQueue request. The method always
    // closes the http.Response Body.
    func (client BaseClient) CreateQueueResponder(resp *http.Response) (result QueueModel, err error) {
        err = autorest.Respond(
            resp,
            client.ByInspecting(),
            azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusCreated,http.StatusForbidden),
            autorest.ByUnmarshallingJSON(&result),
            autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
        return
    }

    // CreateQueueAssignment sends the create queue assignment request.
    //
    // model is the model.
    func (client BaseClient) CreateQueueAssignment(ctx context.Context, model InsertQueueAssignmentRequestModel) (result QueueAssignmentModel, err error) {
        if err := validation.Validate([]validation.Validation{
        { TargetValue: model,
         Constraints: []validation.Constraint{	{Target: "model.QueueID", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "model.QueueID", Name: validation.InclusiveMaximum, Rule: 2147483647, Chain: nil },
        	{Target: "model.QueueID", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil },
        }},
        	{Target: "model.UserID", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "model.UserID", Name: validation.InclusiveMaximum, Rule: 2147483647, Chain: nil },
        	{Target: "model.UserID", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil },
        }}}}}); err != nil {
            return result, validation.NewErrorWithValidationError(err, "softheonenterpriseapiclient.BaseClient","CreateQueueAssignment")
        }

        req, err := client.CreateQueueAssignmentPreparer(ctx, model)
        if err != nil {
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "CreateQueueAssignment", nil , "Failure preparing request")
            return
        }

        resp, err := client.CreateQueueAssignmentSender(req)
        if err != nil {
            result.Response = autorest.Response{Response: resp}
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "CreateQueueAssignment", resp, "Failure sending request")
            return
        }

        result, err = client.CreateQueueAssignmentResponder(resp)
        if err != nil {
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "CreateQueueAssignment", resp, "Failure responding to request")
        }

        return
    }

    // CreateQueueAssignmentPreparer prepares the CreateQueueAssignment request.
    func (client BaseClient) CreateQueueAssignmentPreparer(ctx context.Context, model InsertQueueAssignmentRequestModel) (*http.Request, error) {
        preparer := autorest.CreatePreparer(
            autorest.AsJSON(),
            autorest.AsPost(),
            autorest.WithBaseURL(client.BaseURI),
            autorest.WithPath("/v1/workflow/assignments"),
            autorest.WithJSON(model))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
    }

    // CreateQueueAssignmentSender sends the CreateQueueAssignment request. The method will close the
    // http.Response Body if it receives an error.
    func (client BaseClient) CreateQueueAssignmentSender(req *http.Request) (*http.Response, error) {
        return autorest.SendWithSender(client, req,
            autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
    }

    // CreateQueueAssignmentResponder handles the response to the CreateQueueAssignment request. The method always
    // closes the http.Response Body.
    func (client BaseClient) CreateQueueAssignmentResponder(resp *http.Response) (result QueueAssignmentModel, err error) {
        err = autorest.Respond(
            resp,
            client.ByInspecting(),
            azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusCreated,http.StatusForbidden,http.StatusNotFound,http.StatusConflict),
            autorest.ByUnmarshallingJSON(&result),
            autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
        return
    }

    // CreateTask sends the create task request.
    //
    // model is the task model.
    func (client BaseClient) CreateTask(ctx context.Context, model InsertTaskRequestModel) (result SetObject, err error) {
        if err := validation.Validate([]validation.Validation{
        { TargetValue: model,
         Constraints: []validation.Constraint{	{Target: "model.QueueID", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "model.QueueID", Name: validation.InclusiveMaximum, Rule: 2147483647, Chain: nil },
        	{Target: "model.QueueID", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil },
        }},
        	{Target: "model.DrawerID", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "model.DrawerID", Name: validation.InclusiveMaximum, Rule: 2147483647, Chain: nil },
        	{Target: "model.DrawerID", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil },
        }},
        	{Target: "model.ObjectID", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "model.ObjectID", Name: validation.InclusiveMaximum, Rule: 2147483647, Chain: nil },
        	{Target: "model.ObjectID", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil },
        }},
        	{Target: "model.ObjectType", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "model.ObjectType", Name: validation.InclusiveMaximum, Rule: 2147483647, Chain: nil },
        	{Target: "model.ObjectType", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil },
        }},
        	{Target: "model.PrevQueueID", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "model.PrevQueueID", Name: validation.InclusiveMaximum, Rule: 2147483647, Chain: nil },
        	{Target: "model.PrevQueueID", Name: validation.InclusiveMinimum, Rule: 0, Chain: nil },
        }},
        	{Target: "model.NextQueueID", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "model.NextQueueID", Name: validation.InclusiveMaximum, Rule: 2147483647, Chain: nil },
        	{Target: "model.NextQueueID", Name: validation.InclusiveMinimum, Rule: 0, Chain: nil },
        }},
        	{Target: "model.AddressID", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "model.AddressID", Name: validation.InclusiveMaximum, Rule: 2147483647, Chain: nil },
        	{Target: "model.AddressID", Name: validation.InclusiveMinimum, Rule: 0, Chain: nil },
        }},
        	{Target: "model.Description", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "model.Description", Name: validation.MaxLength, Rule: 255, Chain: nil },
        	{Target: "model.Description", Name: validation.MinLength, Rule: 0, Chain: nil },
        }},
        	{Target: "model.Message1", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "model.Message1", Name: validation.MaxLength, Rule: 255, Chain: nil },
        	{Target: "model.Message1", Name: validation.MinLength, Rule: 0, Chain: nil },
        }},
        	{Target: "model.Message2", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "model.Message2", Name: validation.MaxLength, Rule: 255, Chain: nil },
        	{Target: "model.Message2", Name: validation.MinLength, Rule: 0, Chain: nil },
        }},
        	{Target: "model.Message3", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "model.Message3", Name: validation.MaxLength, Rule: 255, Chain: nil },
        	{Target: "model.Message3", Name: validation.MinLength, Rule: 0, Chain: nil },
        }},
        	{Target: "model.Message4", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "model.Message4", Name: validation.MaxLength, Rule: 255, Chain: nil },
        	{Target: "model.Message4", Name: validation.MinLength, Rule: 0, Chain: nil },
        }},
        	{Target: "model.Message5", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "model.Message5", Name: validation.MaxLength, Rule: 255, Chain: nil },
        	{Target: "model.Message5", Name: validation.MinLength, Rule: 0, Chain: nil },
        }},
        	{Target: "model.Message6", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "model.Message6", Name: validation.MaxLength, Rule: 255, Chain: nil },
        	{Target: "model.Message6", Name: validation.MinLength, Rule: 0, Chain: nil },
        }},
        	{Target: "model.Message7", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "model.Message7", Name: validation.MaxLength, Rule: 255, Chain: nil },
        	{Target: "model.Message7", Name: validation.MinLength, Rule: 0, Chain: nil },
        }},
        	{Target: "model.Message8", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "model.Message8", Name: validation.MaxLength, Rule: 255, Chain: nil },
        	{Target: "model.Message8", Name: validation.MinLength, Rule: 0, Chain: nil },
        }},
        	{Target: "model.Message9", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "model.Message9", Name: validation.MaxLength, Rule: 255, Chain: nil },
        	{Target: "model.Message9", Name: validation.MinLength, Rule: 0, Chain: nil },
        }},
        	{Target: "model.Message10", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "model.Message10", Name: validation.MaxLength, Rule: 255, Chain: nil },
        	{Target: "model.Message10", Name: validation.MinLength, Rule: 0, Chain: nil },
        }},
        	{Target: "model.Message11", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "model.Message11", Name: validation.MaxLength, Rule: 255, Chain: nil },
        	{Target: "model.Message11", Name: validation.MinLength, Rule: 0, Chain: nil },
        }},
        	{Target: "model.Message12", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "model.Message12", Name: validation.MaxLength, Rule: 255, Chain: nil },
        	{Target: "model.Message12", Name: validation.MinLength, Rule: 0, Chain: nil },
        }},
        	{Target: "model.Message13", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "model.Message13", Name: validation.MaxLength, Rule: 255, Chain: nil },
        	{Target: "model.Message13", Name: validation.MinLength, Rule: 0, Chain: nil },
        }},
        	{Target: "model.Message14", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "model.Message14", Name: validation.MaxLength, Rule: 255, Chain: nil },
        	{Target: "model.Message14", Name: validation.MinLength, Rule: 0, Chain: nil },
        }},
        	{Target: "model.Message15", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "model.Message15", Name: validation.MaxLength, Rule: 255, Chain: nil },
        	{Target: "model.Message15", Name: validation.MinLength, Rule: 0, Chain: nil },
        }},
        	{Target: "model.Message16", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "model.Message16", Name: validation.MaxLength, Rule: 255, Chain: nil },
        	{Target: "model.Message16", Name: validation.MinLength, Rule: 0, Chain: nil },
        }},
        	{Target: "model.TaskFileAttachment", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "model.TaskFileAttachment", Name: validation.MaxLength, Rule: 255, Chain: nil },
        	{Target: "model.TaskFileAttachment", Name: validation.MinLength, Rule: 0, Chain: nil },
        }},
        	{Target: "model.ReservedString1", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "model.ReservedString1", Name: validation.MaxLength, Rule: 255, Chain: nil },
        	{Target: "model.ReservedString1", Name: validation.MinLength, Rule: 0, Chain: nil },
        }}}}}); err != nil {
            return result, validation.NewErrorWithValidationError(err, "softheonenterpriseapiclient.BaseClient","CreateTask")
        }

        req, err := client.CreateTaskPreparer(ctx, model)
        if err != nil {
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "CreateTask", nil , "Failure preparing request")
            return
        }

        resp, err := client.CreateTaskSender(req)
        if err != nil {
            result.Response = autorest.Response{Response: resp}
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "CreateTask", resp, "Failure sending request")
            return
        }

        result, err = client.CreateTaskResponder(resp)
        if err != nil {
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "CreateTask", resp, "Failure responding to request")
        }

        return
    }

    // CreateTaskPreparer prepares the CreateTask request.
    func (client BaseClient) CreateTaskPreparer(ctx context.Context, model InsertTaskRequestModel) (*http.Request, error) {
        preparer := autorest.CreatePreparer(
            autorest.AsJSON(),
            autorest.AsPost(),
            autorest.WithBaseURL(client.BaseURI),
            autorest.WithPath("/v1/workflow/tasks"),
            autorest.WithJSON(model))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
    }

    // CreateTaskSender sends the CreateTask request. The method will close the
    // http.Response Body if it receives an error.
    func (client BaseClient) CreateTaskSender(req *http.Request) (*http.Response, error) {
        return autorest.SendWithSender(client, req,
            autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
    }

    // CreateTaskResponder handles the response to the CreateTask request. The method always
    // closes the http.Response Body.
    func (client BaseClient) CreateTaskResponder(resp *http.Response) (result SetObject, err error) {
        err = autorest.Respond(
            resp,
            client.ByInspecting(),
            azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusCreated,http.StatusForbidden,http.StatusNotFound,http.StatusConflict),
            autorest.ByUnmarshallingJSON(&result.Value),
            autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
        return
    }

    // CreateTemplate sends the create template request.
    //
    // model is the entity template model.
    func (client BaseClient) CreateTemplate(ctx context.Context, model EntityDefinitionBase) (result EntityDefinitionModel, err error) {
        if err := validation.Validate([]validation.Validation{
        { TargetValue: model,
         Constraints: []validation.Constraint{	{Target: "model.Type", Name: validation.Null, Rule: true ,
        Chain: []validation.Constraint{	{Target: "model.Type", Name: validation.InclusiveMaximum, Rule: 2147483647, Chain: nil },
        	{Target: "model.Type", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil },
        }},
        	{Target: "model.Category", Name: validation.Null, Rule: true ,
        Chain: []validation.Constraint{	{Target: "model.Category", Name: validation.MaxLength, Rule: 255, Chain: nil },
        	{Target: "model.Category", Name: validation.MinLength, Rule: 0, Chain: nil },
        }},
        	{Target: "model.Name", Name: validation.Null, Rule: true ,
        Chain: []validation.Constraint{	{Target: "model.Name", Name: validation.MaxLength, Rule: 255, Chain: nil },
        	{Target: "model.Name", Name: validation.MinLength, Rule: 0, Chain: nil },
        }},
        	{Target: "model.SmallImage", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "model.SmallImage", Name: validation.MaxLength, Rule: 255, Chain: nil },
        	{Target: "model.SmallImage", Name: validation.MinLength, Rule: 0, Chain: nil },
        }},
        	{Target: "model.LargeImage", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "model.LargeImage", Name: validation.MaxLength, Rule: 255, Chain: nil },
        	{Target: "model.LargeImage", Name: validation.MinLength, Rule: 0, Chain: nil },
        }},
        	{Target: "model.ReservedString1", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "model.ReservedString1", Name: validation.MaxLength, Rule: 255, Chain: nil },
        	{Target: "model.ReservedString1", Name: validation.MinLength, Rule: 0, Chain: nil },
        }},
        	{Target: "model.ReservedString2", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "model.ReservedString2", Name: validation.MaxLength, Rule: 255, Chain: nil },
        	{Target: "model.ReservedString2", Name: validation.MinLength, Rule: 0, Chain: nil },
        }}}}}); err != nil {
            return result, validation.NewErrorWithValidationError(err, "softheonenterpriseapiclient.BaseClient","CreateTemplate")
        }

        req, err := client.CreateTemplatePreparer(ctx, model)
        if err != nil {
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "CreateTemplate", nil , "Failure preparing request")
            return
        }

        resp, err := client.CreateTemplateSender(req)
        if err != nil {
            result.Response = autorest.Response{Response: resp}
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "CreateTemplate", resp, "Failure sending request")
            return
        }

        result, err = client.CreateTemplateResponder(resp)
        if err != nil {
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "CreateTemplate", resp, "Failure responding to request")
        }

        return
    }

    // CreateTemplatePreparer prepares the CreateTemplate request.
    func (client BaseClient) CreateTemplatePreparer(ctx context.Context, model EntityDefinitionBase) (*http.Request, error) {
        preparer := autorest.CreatePreparer(
            autorest.AsJSON(),
            autorest.AsPost(),
            autorest.WithBaseURL(client.BaseURI),
            autorest.WithPath("/v1/template/ftl"),
            autorest.WithJSON(model))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
    }

    // CreateTemplateSender sends the CreateTemplate request. The method will close the
    // http.Response Body if it receives an error.
    func (client BaseClient) CreateTemplateSender(req *http.Request) (*http.Response, error) {
        return autorest.SendWithSender(client, req,
            autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
    }

    // CreateTemplateResponder handles the response to the CreateTemplate request. The method always
    // closes the http.Response Body.
    func (client BaseClient) CreateTemplateResponder(resp *http.Response) (result EntityDefinitionModel, err error) {
        err = autorest.Respond(
            resp,
            client.ByInspecting(),
            azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusCreated,http.StatusForbidden,http.StatusNotFound,http.StatusConflict),
            autorest.ByUnmarshallingJSON(&result),
            autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
        return
    }

    // CreateUser sends the create user request.
    //
    // model is the user model.
    func (client BaseClient) CreateUser(ctx context.Context, model InsertUserRequestModel) (result UserModel, err error) {
        if err := validation.Validate([]validation.Validation{
        { TargetValue: model,
         Constraints: []validation.Constraint{	{Target: "model.Username", Name: validation.Null, Rule: true ,
        Chain: []validation.Constraint{	{Target: "model.Username", Name: validation.MaxLength, Rule: 255, Chain: nil },
        	{Target: "model.Username", Name: validation.MinLength, Rule: 0, Chain: nil },
        }},
        	{Target: "model.FullName", Name: validation.Null, Rule: true ,
        Chain: []validation.Constraint{	{Target: "model.FullName", Name: validation.MaxLength, Rule: 255, Chain: nil },
        	{Target: "model.FullName", Name: validation.MinLength, Rule: 0, Chain: nil },
        }},
        	{Target: "model.IPAddress", Name: validation.Null, Rule: true ,
        Chain: []validation.Constraint{	{Target: "model.IPAddress", Name: validation.MaxLength, Rule: 255, Chain: nil },
        	{Target: "model.IPAddress", Name: validation.MinLength, Rule: 0, Chain: nil },
        }},
        	{Target: "model.Address", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "model.Address", Name: validation.MaxLength, Rule: 255, Chain: nil },
        	{Target: "model.Address", Name: validation.MinLength, Rule: 0, Chain: nil },
        }}}}}); err != nil {
            return result, validation.NewErrorWithValidationError(err, "softheonenterpriseapiclient.BaseClient","CreateUser")
        }

        req, err := client.CreateUserPreparer(ctx, model)
        if err != nil {
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "CreateUser", nil , "Failure preparing request")
            return
        }

        resp, err := client.CreateUserSender(req)
        if err != nil {
            result.Response = autorest.Response{Response: resp}
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "CreateUser", resp, "Failure sending request")
            return
        }

        result, err = client.CreateUserResponder(resp)
        if err != nil {
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "CreateUser", resp, "Failure responding to request")
        }

        return
    }

    // CreateUserPreparer prepares the CreateUser request.
    func (client BaseClient) CreateUserPreparer(ctx context.Context, model InsertUserRequestModel) (*http.Request, error) {
        preparer := autorest.CreatePreparer(
            autorest.AsJSON(),
            autorest.AsPost(),
            autorest.WithBaseURL(client.BaseURI),
            autorest.WithPath("/v1/directory/users"),
            autorest.WithJSON(model))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
    }

    // CreateUserSender sends the CreateUser request. The method will close the
    // http.Response Body if it receives an error.
    func (client BaseClient) CreateUserSender(req *http.Request) (*http.Response, error) {
        return autorest.SendWithSender(client, req,
            autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
    }

    // CreateUserResponder handles the response to the CreateUser request. The method always
    // closes the http.Response Body.
    func (client BaseClient) CreateUserResponder(resp *http.Response) (result UserModel, err error) {
        err = autorest.Respond(
            resp,
            client.ByInspecting(),
            azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusCreated,http.StatusForbidden,http.StatusConflict),
            autorest.ByUnmarshallingJSON(&result),
            autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
        return
    }

    // CreateUserGroupAssociation sends the create user group association request.
    //
    // groupID is the group identifier. userID is the user identifier. model is the model.
    func (client BaseClient) CreateUserGroupAssociation(ctx context.Context, groupID int32, userID int32, model GroupUserModel) (result SetObject, err error) {
        if err := validation.Validate([]validation.Validation{
        { TargetValue: model,
         Constraints: []validation.Constraint{	{Target: "model.GroupName", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "model.GroupName", Name: validation.MaxLength, Rule: 255, Chain: nil },
        	{Target: "model.GroupName", Name: validation.MinLength, Rule: 0, Chain: nil },
        }},
        	{Target: "model.UserFullName", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "model.UserFullName", Name: validation.MaxLength, Rule: 255, Chain: nil },
        	{Target: "model.UserFullName", Name: validation.MinLength, Rule: 0, Chain: nil },
        }}}}}); err != nil {
            return result, validation.NewErrorWithValidationError(err, "softheonenterpriseapiclient.BaseClient","CreateUserGroupAssociation")
        }

        req, err := client.CreateUserGroupAssociationPreparer(ctx, groupID, userID, model)
        if err != nil {
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "CreateUserGroupAssociation", nil , "Failure preparing request")
            return
        }

        resp, err := client.CreateUserGroupAssociationSender(req)
        if err != nil {
            result.Response = autorest.Response{Response: resp}
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "CreateUserGroupAssociation", resp, "Failure sending request")
            return
        }

        result, err = client.CreateUserGroupAssociationResponder(resp)
        if err != nil {
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "CreateUserGroupAssociation", resp, "Failure responding to request")
        }

        return
    }

    // CreateUserGroupAssociationPreparer prepares the CreateUserGroupAssociation request.
    func (client BaseClient) CreateUserGroupAssociationPreparer(ctx context.Context, groupID int32, userID int32, model GroupUserModel) (*http.Request, error) {
        pathParameters := map[string]interface{} {
        "groupID": autorest.Encode("path",groupID),
        "userID": autorest.Encode("path",userID),
        }

        preparer := autorest.CreatePreparer(
            autorest.AsJSON(),
            autorest.AsPost(),
            autorest.WithBaseURL(client.BaseURI),
            autorest.WithPathParameters("/v1/directory/users/{userID}/groups/{groupID}",pathParameters),
            autorest.WithJSON(model))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
    }

    // CreateUserGroupAssociationSender sends the CreateUserGroupAssociation request. The method will close the
    // http.Response Body if it receives an error.
    func (client BaseClient) CreateUserGroupAssociationSender(req *http.Request) (*http.Response, error) {
        return autorest.SendWithSender(client, req,
            autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
    }

    // CreateUserGroupAssociationResponder handles the response to the CreateUserGroupAssociation request. The method always
    // closes the http.Response Body.
    func (client BaseClient) CreateUserGroupAssociationResponder(resp *http.Response) (result SetObject, err error) {
        err = autorest.Respond(
            resp,
            client.ByInspecting(),
            azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusForbidden,http.StatusConflict),
            autorest.ByUnmarshallingJSON(&result.Value),
            autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
        return
    }

    // CreateXMLTemplate sends the create xml template request.
    func (client BaseClient) CreateXMLTemplate(ctx context.Context) (result String, err error) {
        req, err := client.CreateXMLTemplatePreparer(ctx)
        if err != nil {
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "CreateXMLTemplate", nil , "Failure preparing request")
            return
        }

        resp, err := client.CreateXMLTemplateSender(req)
        if err != nil {
            result.Response = autorest.Response{Response: resp}
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "CreateXMLTemplate", resp, "Failure sending request")
            return
        }

        result, err = client.CreateXMLTemplateResponder(resp)
        if err != nil {
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "CreateXMLTemplate", resp, "Failure responding to request")
        }

        return
    }

    // CreateXMLTemplatePreparer prepares the CreateXMLTemplate request.
    func (client BaseClient) CreateXMLTemplatePreparer(ctx context.Context) (*http.Request, error) {
        preparer := autorest.CreatePreparer(
            autorest.AsPost(),
            autorest.WithBaseURL(client.BaseURI),
            autorest.WithPath("/v1/template/xml"))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
    }

    // CreateXMLTemplateSender sends the CreateXMLTemplate request. The method will close the
    // http.Response Body if it receives an error.
    func (client BaseClient) CreateXMLTemplateSender(req *http.Request) (*http.Response, error) {
        return autorest.SendWithSender(client, req,
            autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
    }

    // CreateXMLTemplateResponder handles the response to the CreateXMLTemplate request. The method always
    // closes the http.Response Body.
    func (client BaseClient) CreateXMLTemplateResponder(resp *http.Response) (result String, err error) {
        err = autorest.Respond(
            resp,
            client.ByInspecting(),
            azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusCreated,http.StatusBadRequest,http.StatusForbidden,http.StatusConflict),
            autorest.ByUnmarshallingJSON(&result.Value),
            autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
        return
    }

    // DeleteApplicationGroupAssociation sends the delete application group association request.
    //
    // groupID is the group identifier. applicationID is the application identifier.
    func (client BaseClient) DeleteApplicationGroupAssociation(ctx context.Context, groupID int32, applicationID int32) (result SetObject, err error) {
        req, err := client.DeleteApplicationGroupAssociationPreparer(ctx, groupID, applicationID)
        if err != nil {
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "DeleteApplicationGroupAssociation", nil , "Failure preparing request")
            return
        }

        resp, err := client.DeleteApplicationGroupAssociationSender(req)
        if err != nil {
            result.Response = autorest.Response{Response: resp}
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "DeleteApplicationGroupAssociation", resp, "Failure sending request")
            return
        }

        result, err = client.DeleteApplicationGroupAssociationResponder(resp)
        if err != nil {
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "DeleteApplicationGroupAssociation", resp, "Failure responding to request")
        }

        return
    }

    // DeleteApplicationGroupAssociationPreparer prepares the DeleteApplicationGroupAssociation request.
    func (client BaseClient) DeleteApplicationGroupAssociationPreparer(ctx context.Context, groupID int32, applicationID int32) (*http.Request, error) {
        pathParameters := map[string]interface{} {
        "applicationID": autorest.Encode("path",applicationID),
        "groupID": autorest.Encode("path",groupID),
        }

        preparer := autorest.CreatePreparer(
            autorest.AsDelete(),
            autorest.WithBaseURL(client.BaseURI),
            autorest.WithPathParameters("/v1/directory/applications/{applicationID}/groups/{groupID}",pathParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
    }

    // DeleteApplicationGroupAssociationSender sends the DeleteApplicationGroupAssociation request. The method will close the
    // http.Response Body if it receives an error.
    func (client BaseClient) DeleteApplicationGroupAssociationSender(req *http.Request) (*http.Response, error) {
        return autorest.SendWithSender(client, req,
            autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
    }

    // DeleteApplicationGroupAssociationResponder handles the response to the DeleteApplicationGroupAssociation request. The method always
    // closes the http.Response Body.
    func (client BaseClient) DeleteApplicationGroupAssociationResponder(resp *http.Response) (result SetObject, err error) {
        err = autorest.Respond(
            resp,
            client.ByInspecting(),
            azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusNoContent,http.StatusForbidden,http.StatusNotFound,http.StatusInternalServerError),
            autorest.ByUnmarshallingJSON(&result.Value),
            autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
        return
    }

    // DeleteApplicationUserAssociation sends the delete application user association request.
    //
    // userID is the user identifier. applicationID is the application identifier.
    func (client BaseClient) DeleteApplicationUserAssociation(ctx context.Context, userID int32, applicationID int32) (result SetObject, err error) {
        req, err := client.DeleteApplicationUserAssociationPreparer(ctx, userID, applicationID)
        if err != nil {
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "DeleteApplicationUserAssociation", nil , "Failure preparing request")
            return
        }

        resp, err := client.DeleteApplicationUserAssociationSender(req)
        if err != nil {
            result.Response = autorest.Response{Response: resp}
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "DeleteApplicationUserAssociation", resp, "Failure sending request")
            return
        }

        result, err = client.DeleteApplicationUserAssociationResponder(resp)
        if err != nil {
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "DeleteApplicationUserAssociation", resp, "Failure responding to request")
        }

        return
    }

    // DeleteApplicationUserAssociationPreparer prepares the DeleteApplicationUserAssociation request.
    func (client BaseClient) DeleteApplicationUserAssociationPreparer(ctx context.Context, userID int32, applicationID int32) (*http.Request, error) {
        pathParameters := map[string]interface{} {
        "applicationID": autorest.Encode("path",applicationID),
        "userID": autorest.Encode("path",userID),
        }

        preparer := autorest.CreatePreparer(
            autorest.AsDelete(),
            autorest.WithBaseURL(client.BaseURI),
            autorest.WithPathParameters("/v1/directory/applications/{applicationID}/users/{userID}",pathParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
    }

    // DeleteApplicationUserAssociationSender sends the DeleteApplicationUserAssociation request. The method will close the
    // http.Response Body if it receives an error.
    func (client BaseClient) DeleteApplicationUserAssociationSender(req *http.Request) (*http.Response, error) {
        return autorest.SendWithSender(client, req,
            autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
    }

    // DeleteApplicationUserAssociationResponder handles the response to the DeleteApplicationUserAssociation request. The method always
    // closes the http.Response Body.
    func (client BaseClient) DeleteApplicationUserAssociationResponder(resp *http.Response) (result SetObject, err error) {
        err = autorest.Respond(
            resp,
            client.ByInspecting(),
            azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusNoContent,http.StatusForbidden,http.StatusNotFound),
            autorest.ByUnmarshallingJSON(&result.Value),
            autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
        return
    }

    // DeleteAttachment sends the delete attachment request.
    //
    // drawer is the drawer identifier. ID is the attachment identifier.
    func (client BaseClient) DeleteAttachment(ctx context.Context, drawer int32, ID int32) (result SetObject, err error) {
        req, err := client.DeleteAttachmentPreparer(ctx, drawer, ID)
        if err != nil {
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "DeleteAttachment", nil , "Failure preparing request")
            return
        }

        resp, err := client.DeleteAttachmentSender(req)
        if err != nil {
            result.Response = autorest.Response{Response: resp}
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "DeleteAttachment", resp, "Failure sending request")
            return
        }

        result, err = client.DeleteAttachmentResponder(resp)
        if err != nil {
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "DeleteAttachment", resp, "Failure responding to request")
        }

        return
    }

    // DeleteAttachmentPreparer prepares the DeleteAttachment request.
    func (client BaseClient) DeleteAttachmentPreparer(ctx context.Context, drawer int32, ID int32) (*http.Request, error) {
        pathParameters := map[string]interface{} {
        "drawer": autorest.Encode("path",drawer),
        "id": autorest.Encode("path",ID),
        }

        preparer := autorest.CreatePreparer(
            autorest.AsDelete(),
            autorest.WithBaseURL(client.BaseURI),
            autorest.WithPathParameters("/v1/content/attachments/{drawer}/{id}",pathParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
    }

    // DeleteAttachmentSender sends the DeleteAttachment request. The method will close the
    // http.Response Body if it receives an error.
    func (client BaseClient) DeleteAttachmentSender(req *http.Request) (*http.Response, error) {
        return autorest.SendWithSender(client, req,
            autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
    }

    // DeleteAttachmentResponder handles the response to the DeleteAttachment request. The method always
    // closes the http.Response Body.
    func (client BaseClient) DeleteAttachmentResponder(resp *http.Response) (result SetObject, err error) {
        err = autorest.Respond(
            resp,
            client.ByInspecting(),
            azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusNoContent,http.StatusForbidden,http.StatusNotFound),
            autorest.ByUnmarshallingJSON(&result.Value),
            autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
        return
    }

    // DeleteDrawerGroupAssociation sends the delete drawer group association request.
    //
    // groupID is the group identifier. drawerID is the drawer identifier.
    func (client BaseClient) DeleteDrawerGroupAssociation(ctx context.Context, groupID int32, drawerID int32) (result SetObject, err error) {
        req, err := client.DeleteDrawerGroupAssociationPreparer(ctx, groupID, drawerID)
        if err != nil {
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "DeleteDrawerGroupAssociation", nil , "Failure preparing request")
            return
        }

        resp, err := client.DeleteDrawerGroupAssociationSender(req)
        if err != nil {
            result.Response = autorest.Response{Response: resp}
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "DeleteDrawerGroupAssociation", resp, "Failure sending request")
            return
        }

        result, err = client.DeleteDrawerGroupAssociationResponder(resp)
        if err != nil {
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "DeleteDrawerGroupAssociation", resp, "Failure responding to request")
        }

        return
    }

    // DeleteDrawerGroupAssociationPreparer prepares the DeleteDrawerGroupAssociation request.
    func (client BaseClient) DeleteDrawerGroupAssociationPreparer(ctx context.Context, groupID int32, drawerID int32) (*http.Request, error) {
        pathParameters := map[string]interface{} {
        "drawerID": autorest.Encode("path",drawerID),
        "groupID": autorest.Encode("path",groupID),
        }

        preparer := autorest.CreatePreparer(
            autorest.AsDelete(),
            autorest.WithBaseURL(client.BaseURI),
            autorest.WithPathParameters("/v1/directory/drawers/{drawerID}/groups/{groupID}",pathParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
    }

    // DeleteDrawerGroupAssociationSender sends the DeleteDrawerGroupAssociation request. The method will close the
    // http.Response Body if it receives an error.
    func (client BaseClient) DeleteDrawerGroupAssociationSender(req *http.Request) (*http.Response, error) {
        return autorest.SendWithSender(client, req,
            autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
    }

    // DeleteDrawerGroupAssociationResponder handles the response to the DeleteDrawerGroupAssociation request. The method always
    // closes the http.Response Body.
    func (client BaseClient) DeleteDrawerGroupAssociationResponder(resp *http.Response) (result SetObject, err error) {
        err = autorest.Respond(
            resp,
            client.ByInspecting(),
            azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusNoContent,http.StatusForbidden,http.StatusNotFound),
            autorest.ByUnmarshallingJSON(&result.Value),
            autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
        return
    }

    // DeleteDrawerUserAssociation sends the delete drawer user association request.
    //
    // userID is the user identifier. drawerID is the drawer identifier.
    func (client BaseClient) DeleteDrawerUserAssociation(ctx context.Context, userID int32, drawerID int32) (result SetObject, err error) {
        req, err := client.DeleteDrawerUserAssociationPreparer(ctx, userID, drawerID)
        if err != nil {
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "DeleteDrawerUserAssociation", nil , "Failure preparing request")
            return
        }

        resp, err := client.DeleteDrawerUserAssociationSender(req)
        if err != nil {
            result.Response = autorest.Response{Response: resp}
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "DeleteDrawerUserAssociation", resp, "Failure sending request")
            return
        }

        result, err = client.DeleteDrawerUserAssociationResponder(resp)
        if err != nil {
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "DeleteDrawerUserAssociation", resp, "Failure responding to request")
        }

        return
    }

    // DeleteDrawerUserAssociationPreparer prepares the DeleteDrawerUserAssociation request.
    func (client BaseClient) DeleteDrawerUserAssociationPreparer(ctx context.Context, userID int32, drawerID int32) (*http.Request, error) {
        pathParameters := map[string]interface{} {
        "drawerID": autorest.Encode("path",drawerID),
        "userID": autorest.Encode("path",userID),
        }

        preparer := autorest.CreatePreparer(
            autorest.AsDelete(),
            autorest.WithBaseURL(client.BaseURI),
            autorest.WithPathParameters("/v1/directory/drawers/{drawerID}/users/{userID}",pathParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
    }

    // DeleteDrawerUserAssociationSender sends the DeleteDrawerUserAssociation request. The method will close the
    // http.Response Body if it receives an error.
    func (client BaseClient) DeleteDrawerUserAssociationSender(req *http.Request) (*http.Response, error) {
        return autorest.SendWithSender(client, req,
            autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
    }

    // DeleteDrawerUserAssociationResponder handles the response to the DeleteDrawerUserAssociation request. The method always
    // closes the http.Response Body.
    func (client BaseClient) DeleteDrawerUserAssociationResponder(resp *http.Response) (result SetObject, err error) {
        err = autorest.Respond(
            resp,
            client.ByInspecting(),
            azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusNoContent,http.StatusForbidden,http.StatusNotFound),
            autorest.ByUnmarshallingJSON(&result.Value),
            autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
        return
    }

    // DeleteEntity sends the delete entity request.
    //
    // drawer is the drawer identifier. ID is the entity identifier.
    func (client BaseClient) DeleteEntity(ctx context.Context, drawer int32, ID int32) (result SetObject, err error) {
        req, err := client.DeleteEntityPreparer(ctx, drawer, ID)
        if err != nil {
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "DeleteEntity", nil , "Failure preparing request")
            return
        }

        resp, err := client.DeleteEntitySender(req)
        if err != nil {
            result.Response = autorest.Response{Response: resp}
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "DeleteEntity", resp, "Failure sending request")
            return
        }

        result, err = client.DeleteEntityResponder(resp)
        if err != nil {
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "DeleteEntity", resp, "Failure responding to request")
        }

        return
    }

    // DeleteEntityPreparer prepares the DeleteEntity request.
    func (client BaseClient) DeleteEntityPreparer(ctx context.Context, drawer int32, ID int32) (*http.Request, error) {
        pathParameters := map[string]interface{} {
        "drawer": autorest.Encode("path",drawer),
        "id": autorest.Encode("path",ID),
        }

        preparer := autorest.CreatePreparer(
            autorest.AsDelete(),
            autorest.WithBaseURL(client.BaseURI),
            autorest.WithPathParameters("/v1/content/entities/{drawer}/{id}",pathParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
    }

    // DeleteEntitySender sends the DeleteEntity request. The method will close the
    // http.Response Body if it receives an error.
    func (client BaseClient) DeleteEntitySender(req *http.Request) (*http.Response, error) {
        return autorest.SendWithSender(client, req,
            autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
    }

    // DeleteEntityResponder handles the response to the DeleteEntity request. The method always
    // closes the http.Response Body.
    func (client BaseClient) DeleteEntityResponder(resp *http.Response) (result SetObject, err error) {
        err = autorest.Respond(
            resp,
            client.ByInspecting(),
            azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusNoContent,http.StatusForbidden,http.StatusNotFound),
            autorest.ByUnmarshallingJSON(&result.Value),
            autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
        return
    }

    // DeleteGroup sends the delete group request.
    //
    // ID is the group identifier.
    func (client BaseClient) DeleteGroup(ctx context.Context, ID int32) (result SetObject, err error) {
        req, err := client.DeleteGroupPreparer(ctx, ID)
        if err != nil {
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "DeleteGroup", nil , "Failure preparing request")
            return
        }

        resp, err := client.DeleteGroupSender(req)
        if err != nil {
            result.Response = autorest.Response{Response: resp}
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "DeleteGroup", resp, "Failure sending request")
            return
        }

        result, err = client.DeleteGroupResponder(resp)
        if err != nil {
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "DeleteGroup", resp, "Failure responding to request")
        }

        return
    }

    // DeleteGroupPreparer prepares the DeleteGroup request.
    func (client BaseClient) DeleteGroupPreparer(ctx context.Context, ID int32) (*http.Request, error) {
        pathParameters := map[string]interface{} {
        "id": autorest.Encode("path",ID),
        }

        preparer := autorest.CreatePreparer(
            autorest.AsDelete(),
            autorest.WithBaseURL(client.BaseURI),
            autorest.WithPathParameters("/v1/directory/groups/{id}",pathParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
    }

    // DeleteGroupSender sends the DeleteGroup request. The method will close the
    // http.Response Body if it receives an error.
    func (client BaseClient) DeleteGroupSender(req *http.Request) (*http.Response, error) {
        return autorest.SendWithSender(client, req,
            autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
    }

    // DeleteGroupResponder handles the response to the DeleteGroup request. The method always
    // closes the http.Response Body.
    func (client BaseClient) DeleteGroupResponder(resp *http.Response) (result SetObject, err error) {
        err = autorest.Respond(
            resp,
            client.ByInspecting(),
            azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusNoContent,http.StatusForbidden,http.StatusNotFound,http.StatusInternalServerError),
            autorest.ByUnmarshallingJSON(&result.Value),
            autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
        return
    }

    // DeleteGroupApplicationAssociation sends the delete group application association request.
    //
    // groupID is the group identifier. applicationID is the application identifier.
    func (client BaseClient) DeleteGroupApplicationAssociation(ctx context.Context, groupID int32, applicationID int32) (result SetObject, err error) {
        req, err := client.DeleteGroupApplicationAssociationPreparer(ctx, groupID, applicationID)
        if err != nil {
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "DeleteGroupApplicationAssociation", nil , "Failure preparing request")
            return
        }

        resp, err := client.DeleteGroupApplicationAssociationSender(req)
        if err != nil {
            result.Response = autorest.Response{Response: resp}
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "DeleteGroupApplicationAssociation", resp, "Failure sending request")
            return
        }

        result, err = client.DeleteGroupApplicationAssociationResponder(resp)
        if err != nil {
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "DeleteGroupApplicationAssociation", resp, "Failure responding to request")
        }

        return
    }

    // DeleteGroupApplicationAssociationPreparer prepares the DeleteGroupApplicationAssociation request.
    func (client BaseClient) DeleteGroupApplicationAssociationPreparer(ctx context.Context, groupID int32, applicationID int32) (*http.Request, error) {
        pathParameters := map[string]interface{} {
        "applicationID": autorest.Encode("path",applicationID),
        "groupID": autorest.Encode("path",groupID),
        }

        preparer := autorest.CreatePreparer(
            autorest.AsDelete(),
            autorest.WithBaseURL(client.BaseURI),
            autorest.WithPathParameters("/v1/directory/groups/{groupID}/applications/{applicationID}",pathParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
    }

    // DeleteGroupApplicationAssociationSender sends the DeleteGroupApplicationAssociation request. The method will close the
    // http.Response Body if it receives an error.
    func (client BaseClient) DeleteGroupApplicationAssociationSender(req *http.Request) (*http.Response, error) {
        return autorest.SendWithSender(client, req,
            autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
    }

    // DeleteGroupApplicationAssociationResponder handles the response to the DeleteGroupApplicationAssociation request. The method always
    // closes the http.Response Body.
    func (client BaseClient) DeleteGroupApplicationAssociationResponder(resp *http.Response) (result SetObject, err error) {
        err = autorest.Respond(
            resp,
            client.ByInspecting(),
            azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusNoContent,http.StatusForbidden,http.StatusNotFound,http.StatusInternalServerError),
            autorest.ByUnmarshallingJSON(&result.Value),
            autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
        return
    }

    // DeleteGroupDrawerAssociation sends the delete group drawer association request.
    //
    // groupID is the group identifier. drawerID is the drawer identifier.
    func (client BaseClient) DeleteGroupDrawerAssociation(ctx context.Context, groupID int32, drawerID int32) (result SetObject, err error) {
        req, err := client.DeleteGroupDrawerAssociationPreparer(ctx, groupID, drawerID)
        if err != nil {
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "DeleteGroupDrawerAssociation", nil , "Failure preparing request")
            return
        }

        resp, err := client.DeleteGroupDrawerAssociationSender(req)
        if err != nil {
            result.Response = autorest.Response{Response: resp}
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "DeleteGroupDrawerAssociation", resp, "Failure sending request")
            return
        }

        result, err = client.DeleteGroupDrawerAssociationResponder(resp)
        if err != nil {
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "DeleteGroupDrawerAssociation", resp, "Failure responding to request")
        }

        return
    }

    // DeleteGroupDrawerAssociationPreparer prepares the DeleteGroupDrawerAssociation request.
    func (client BaseClient) DeleteGroupDrawerAssociationPreparer(ctx context.Context, groupID int32, drawerID int32) (*http.Request, error) {
        pathParameters := map[string]interface{} {
        "drawerID": autorest.Encode("path",drawerID),
        "groupID": autorest.Encode("path",groupID),
        }

        preparer := autorest.CreatePreparer(
            autorest.AsDelete(),
            autorest.WithBaseURL(client.BaseURI),
            autorest.WithPathParameters("/v1/directory/groups/{groupID}/drawers/{drawerID}",pathParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
    }

    // DeleteGroupDrawerAssociationSender sends the DeleteGroupDrawerAssociation request. The method will close the
    // http.Response Body if it receives an error.
    func (client BaseClient) DeleteGroupDrawerAssociationSender(req *http.Request) (*http.Response, error) {
        return autorest.SendWithSender(client, req,
            autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
    }

    // DeleteGroupDrawerAssociationResponder handles the response to the DeleteGroupDrawerAssociation request. The method always
    // closes the http.Response Body.
    func (client BaseClient) DeleteGroupDrawerAssociationResponder(resp *http.Response) (result SetObject, err error) {
        err = autorest.Respond(
            resp,
            client.ByInspecting(),
            azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusNoContent,http.StatusForbidden,http.StatusNotFound),
            autorest.ByUnmarshallingJSON(&result.Value),
            autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
        return
    }

    // DeleteGroupQueueAssociation sends the delete group queue association request.
    //
    // groupID is the group identifier. queueID is the queue identifier.
    func (client BaseClient) DeleteGroupQueueAssociation(ctx context.Context, groupID int32, queueID int32) (result SetObject, err error) {
        req, err := client.DeleteGroupQueueAssociationPreparer(ctx, groupID, queueID)
        if err != nil {
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "DeleteGroupQueueAssociation", nil , "Failure preparing request")
            return
        }

        resp, err := client.DeleteGroupQueueAssociationSender(req)
        if err != nil {
            result.Response = autorest.Response{Response: resp}
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "DeleteGroupQueueAssociation", resp, "Failure sending request")
            return
        }

        result, err = client.DeleteGroupQueueAssociationResponder(resp)
        if err != nil {
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "DeleteGroupQueueAssociation", resp, "Failure responding to request")
        }

        return
    }

    // DeleteGroupQueueAssociationPreparer prepares the DeleteGroupQueueAssociation request.
    func (client BaseClient) DeleteGroupQueueAssociationPreparer(ctx context.Context, groupID int32, queueID int32) (*http.Request, error) {
        pathParameters := map[string]interface{} {
        "groupID": autorest.Encode("path",groupID),
        "queueID": autorest.Encode("path",queueID),
        }

        preparer := autorest.CreatePreparer(
            autorest.AsDelete(),
            autorest.WithBaseURL(client.BaseURI),
            autorest.WithPathParameters("/v1/directory/groups/{groupID}/queues/{queueID}",pathParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
    }

    // DeleteGroupQueueAssociationSender sends the DeleteGroupQueueAssociation request. The method will close the
    // http.Response Body if it receives an error.
    func (client BaseClient) DeleteGroupQueueAssociationSender(req *http.Request) (*http.Response, error) {
        return autorest.SendWithSender(client, req,
            autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
    }

    // DeleteGroupQueueAssociationResponder handles the response to the DeleteGroupQueueAssociation request. The method always
    // closes the http.Response Body.
    func (client BaseClient) DeleteGroupQueueAssociationResponder(resp *http.Response) (result SetObject, err error) {
        err = autorest.Respond(
            resp,
            client.ByInspecting(),
            azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusNoContent,http.StatusForbidden,http.StatusNotFound),
            autorest.ByUnmarshallingJSON(&result.Value),
            autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
        return
    }

    // DeleteGroupUserAssociation sends the delete group user association request.
    //
    // groupID is the group identifier. userID is the user identifier.
    func (client BaseClient) DeleteGroupUserAssociation(ctx context.Context, groupID int32, userID int32) (result SetObject, err error) {
        req, err := client.DeleteGroupUserAssociationPreparer(ctx, groupID, userID)
        if err != nil {
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "DeleteGroupUserAssociation", nil , "Failure preparing request")
            return
        }

        resp, err := client.DeleteGroupUserAssociationSender(req)
        if err != nil {
            result.Response = autorest.Response{Response: resp}
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "DeleteGroupUserAssociation", resp, "Failure sending request")
            return
        }

        result, err = client.DeleteGroupUserAssociationResponder(resp)
        if err != nil {
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "DeleteGroupUserAssociation", resp, "Failure responding to request")
        }

        return
    }

    // DeleteGroupUserAssociationPreparer prepares the DeleteGroupUserAssociation request.
    func (client BaseClient) DeleteGroupUserAssociationPreparer(ctx context.Context, groupID int32, userID int32) (*http.Request, error) {
        pathParameters := map[string]interface{} {
        "groupID": autorest.Encode("path",groupID),
        "userID": autorest.Encode("path",userID),
        }

        preparer := autorest.CreatePreparer(
            autorest.AsDelete(),
            autorest.WithBaseURL(client.BaseURI),
            autorest.WithPathParameters("/v1/directory/groups/{groupID}/users/{userID}",pathParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
    }

    // DeleteGroupUserAssociationSender sends the DeleteGroupUserAssociation request. The method will close the
    // http.Response Body if it receives an error.
    func (client BaseClient) DeleteGroupUserAssociationSender(req *http.Request) (*http.Response, error) {
        return autorest.SendWithSender(client, req,
            autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
    }

    // DeleteGroupUserAssociationResponder handles the response to the DeleteGroupUserAssociation request. The method always
    // closes the http.Response Body.
    func (client BaseClient) DeleteGroupUserAssociationResponder(resp *http.Response) (result SetObject, err error) {
        err = autorest.Respond(
            resp,
            client.ByInspecting(),
            azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusNoContent,http.StatusForbidden,http.StatusNotFound),
            autorest.ByUnmarshallingJSON(&result.Value),
            autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
        return
    }

    // DeleteLink sends the delete link request.
    //
    // drawer is the drawer identifier. ID is the link identifier.
    func (client BaseClient) DeleteLink(ctx context.Context, drawer int32, ID int32) (result SetObject, err error) {
        req, err := client.DeleteLinkPreparer(ctx, drawer, ID)
        if err != nil {
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "DeleteLink", nil , "Failure preparing request")
            return
        }

        resp, err := client.DeleteLinkSender(req)
        if err != nil {
            result.Response = autorest.Response{Response: resp}
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "DeleteLink", resp, "Failure sending request")
            return
        }

        result, err = client.DeleteLinkResponder(resp)
        if err != nil {
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "DeleteLink", resp, "Failure responding to request")
        }

        return
    }

    // DeleteLinkPreparer prepares the DeleteLink request.
    func (client BaseClient) DeleteLinkPreparer(ctx context.Context, drawer int32, ID int32) (*http.Request, error) {
        pathParameters := map[string]interface{} {
        "drawer": autorest.Encode("path",drawer),
        "id": autorest.Encode("path",ID),
        }

        preparer := autorest.CreatePreparer(
            autorest.AsDelete(),
            autorest.WithBaseURL(client.BaseURI),
            autorest.WithPathParameters("/v1/content/links/{drawer}/{id}",pathParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
    }

    // DeleteLinkSender sends the DeleteLink request. The method will close the
    // http.Response Body if it receives an error.
    func (client BaseClient) DeleteLinkSender(req *http.Request) (*http.Response, error) {
        return autorest.SendWithSender(client, req,
            autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
    }

    // DeleteLinkResponder handles the response to the DeleteLink request. The method always
    // closes the http.Response Body.
    func (client BaseClient) DeleteLinkResponder(resp *http.Response) (result SetObject, err error) {
        err = autorest.Respond(
            resp,
            client.ByInspecting(),
            azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusNoContent,http.StatusForbidden,http.StatusNotFound),
            autorest.ByUnmarshallingJSON(&result.Value),
            autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
        return
    }

    // DeleteLock sends the delete lock request.
    //
    // drawer is the drawer identifier. ID is the entity identifier.
    func (client BaseClient) DeleteLock(ctx context.Context, drawer int32, ID int32) (result SetObject, err error) {
        req, err := client.DeleteLockPreparer(ctx, drawer, ID)
        if err != nil {
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "DeleteLock", nil , "Failure preparing request")
            return
        }

        resp, err := client.DeleteLockSender(req)
        if err != nil {
            result.Response = autorest.Response{Response: resp}
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "DeleteLock", resp, "Failure sending request")
            return
        }

        result, err = client.DeleteLockResponder(resp)
        if err != nil {
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "DeleteLock", resp, "Failure responding to request")
        }

        return
    }

    // DeleteLockPreparer prepares the DeleteLock request.
    func (client BaseClient) DeleteLockPreparer(ctx context.Context, drawer int32, ID int32) (*http.Request, error) {
        pathParameters := map[string]interface{} {
        "drawer": autorest.Encode("path",drawer),
        "id": autorest.Encode("path",ID),
        }

        preparer := autorest.CreatePreparer(
            autorest.AsDelete(),
            autorest.WithBaseURL(client.BaseURI),
            autorest.WithPathParameters("/v1/content/entities/{drawer}/{id}/locks",pathParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
    }

    // DeleteLockSender sends the DeleteLock request. The method will close the
    // http.Response Body if it receives an error.
    func (client BaseClient) DeleteLockSender(req *http.Request) (*http.Response, error) {
        return autorest.SendWithSender(client, req,
            autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
    }

    // DeleteLockResponder handles the response to the DeleteLock request. The method always
    // closes the http.Response Body.
    func (client BaseClient) DeleteLockResponder(resp *http.Response) (result SetObject, err error) {
        err = autorest.Respond(
            resp,
            client.ByInspecting(),
            azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusNoContent,http.StatusForbidden,http.StatusNotFound),
            autorest.ByUnmarshallingJSON(&result.Value),
            autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
        return
    }

    // DeleteNote sends the delete note request.
    //
    // drawer is the drawer identifier. ID is the note identifier.
    func (client BaseClient) DeleteNote(ctx context.Context, drawer int32, ID int32) (result SetObject, err error) {
        req, err := client.DeleteNotePreparer(ctx, drawer, ID)
        if err != nil {
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "DeleteNote", nil , "Failure preparing request")
            return
        }

        resp, err := client.DeleteNoteSender(req)
        if err != nil {
            result.Response = autorest.Response{Response: resp}
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "DeleteNote", resp, "Failure sending request")
            return
        }

        result, err = client.DeleteNoteResponder(resp)
        if err != nil {
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "DeleteNote", resp, "Failure responding to request")
        }

        return
    }

    // DeleteNotePreparer prepares the DeleteNote request.
    func (client BaseClient) DeleteNotePreparer(ctx context.Context, drawer int32, ID int32) (*http.Request, error) {
        pathParameters := map[string]interface{} {
        "drawer": autorest.Encode("path",drawer),
        "id": autorest.Encode("path",ID),
        }

        preparer := autorest.CreatePreparer(
            autorest.AsDelete(),
            autorest.WithBaseURL(client.BaseURI),
            autorest.WithPathParameters("/v1/content/notes/{drawer}/{id}",pathParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
    }

    // DeleteNoteSender sends the DeleteNote request. The method will close the
    // http.Response Body if it receives an error.
    func (client BaseClient) DeleteNoteSender(req *http.Request) (*http.Response, error) {
        return autorest.SendWithSender(client, req,
            autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
    }

    // DeleteNoteResponder handles the response to the DeleteNote request. The method always
    // closes the http.Response Body.
    func (client BaseClient) DeleteNoteResponder(resp *http.Response) (result SetObject, err error) {
        err = autorest.Respond(
            resp,
            client.ByInspecting(),
            azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusNoContent,http.StatusForbidden,http.StatusNotFound),
            autorest.ByUnmarshallingJSON(&result.Value),
            autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
        return
    }

    // DeleteQueue sends the delete queue request.
    //
    // ID is the queue identifier.
    func (client BaseClient) DeleteQueue(ctx context.Context, ID int32) (result SetObject, err error) {
        req, err := client.DeleteQueuePreparer(ctx, ID)
        if err != nil {
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "DeleteQueue", nil , "Failure preparing request")
            return
        }

        resp, err := client.DeleteQueueSender(req)
        if err != nil {
            result.Response = autorest.Response{Response: resp}
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "DeleteQueue", resp, "Failure sending request")
            return
        }

        result, err = client.DeleteQueueResponder(resp)
        if err != nil {
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "DeleteQueue", resp, "Failure responding to request")
        }

        return
    }

    // DeleteQueuePreparer prepares the DeleteQueue request.
    func (client BaseClient) DeleteQueuePreparer(ctx context.Context, ID int32) (*http.Request, error) {
        pathParameters := map[string]interface{} {
        "id": autorest.Encode("path",ID),
        }

        preparer := autorest.CreatePreparer(
            autorest.AsDelete(),
            autorest.WithBaseURL(client.BaseURI),
            autorest.WithPathParameters("/v1/workflow/queues/{id}",pathParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
    }

    // DeleteQueueSender sends the DeleteQueue request. The method will close the
    // http.Response Body if it receives an error.
    func (client BaseClient) DeleteQueueSender(req *http.Request) (*http.Response, error) {
        return autorest.SendWithSender(client, req,
            autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
    }

    // DeleteQueueResponder handles the response to the DeleteQueue request. The method always
    // closes the http.Response Body.
    func (client BaseClient) DeleteQueueResponder(resp *http.Response) (result SetObject, err error) {
        err = autorest.Respond(
            resp,
            client.ByInspecting(),
            azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusNoContent,http.StatusForbidden,http.StatusNotFound),
            autorest.ByUnmarshallingJSON(&result.Value),
            autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
        return
    }

    // DeleteQueueAssignment sends the delete queue assignment request.
    //
    // userID is the user identifier. queueID is the queue identifier.
    func (client BaseClient) DeleteQueueAssignment(ctx context.Context, userID int32, queueID int32) (result SetObject, err error) {
        req, err := client.DeleteQueueAssignmentPreparer(ctx, userID, queueID)
        if err != nil {
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "DeleteQueueAssignment", nil , "Failure preparing request")
            return
        }

        resp, err := client.DeleteQueueAssignmentSender(req)
        if err != nil {
            result.Response = autorest.Response{Response: resp}
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "DeleteQueueAssignment", resp, "Failure sending request")
            return
        }

        result, err = client.DeleteQueueAssignmentResponder(resp)
        if err != nil {
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "DeleteQueueAssignment", resp, "Failure responding to request")
        }

        return
    }

    // DeleteQueueAssignmentPreparer prepares the DeleteQueueAssignment request.
    func (client BaseClient) DeleteQueueAssignmentPreparer(ctx context.Context, userID int32, queueID int32) (*http.Request, error) {
        pathParameters := map[string]interface{} {
        "queueId": autorest.Encode("path",queueID),
        "userId": autorest.Encode("path",userID),
        }

        preparer := autorest.CreatePreparer(
            autorest.AsDelete(),
            autorest.WithBaseURL(client.BaseURI),
            autorest.WithPathParameters("/v1/workflow/assignments/users/{userId}/queues/{queueId}",pathParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
    }

    // DeleteQueueAssignmentSender sends the DeleteQueueAssignment request. The method will close the
    // http.Response Body if it receives an error.
    func (client BaseClient) DeleteQueueAssignmentSender(req *http.Request) (*http.Response, error) {
        return autorest.SendWithSender(client, req,
            autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
    }

    // DeleteQueueAssignmentResponder handles the response to the DeleteQueueAssignment request. The method always
    // closes the http.Response Body.
    func (client BaseClient) DeleteQueueAssignmentResponder(resp *http.Response) (result SetObject, err error) {
        err = autorest.Respond(
            resp,
            client.ByInspecting(),
            azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusNoContent,http.StatusForbidden,http.StatusNotFound),
            autorest.ByUnmarshallingJSON(&result.Value),
            autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
        return
    }

    // DeleteQueueGroupAssociation sends the delete queue group association request.
    //
    // groupID is the group identifier. queueID is the queue identifier.
    func (client BaseClient) DeleteQueueGroupAssociation(ctx context.Context, groupID int32, queueID int32) (result SetObject, err error) {
        req, err := client.DeleteQueueGroupAssociationPreparer(ctx, groupID, queueID)
        if err != nil {
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "DeleteQueueGroupAssociation", nil , "Failure preparing request")
            return
        }

        resp, err := client.DeleteQueueGroupAssociationSender(req)
        if err != nil {
            result.Response = autorest.Response{Response: resp}
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "DeleteQueueGroupAssociation", resp, "Failure sending request")
            return
        }

        result, err = client.DeleteQueueGroupAssociationResponder(resp)
        if err != nil {
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "DeleteQueueGroupAssociation", resp, "Failure responding to request")
        }

        return
    }

    // DeleteQueueGroupAssociationPreparer prepares the DeleteQueueGroupAssociation request.
    func (client BaseClient) DeleteQueueGroupAssociationPreparer(ctx context.Context, groupID int32, queueID int32) (*http.Request, error) {
        pathParameters := map[string]interface{} {
        "groupID": autorest.Encode("path",groupID),
        "queueID": autorest.Encode("path",queueID),
        }

        preparer := autorest.CreatePreparer(
            autorest.AsDelete(),
            autorest.WithBaseURL(client.BaseURI),
            autorest.WithPathParameters("/v1/workflow/queues/{queueID}/groups/{groupID}",pathParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
    }

    // DeleteQueueGroupAssociationSender sends the DeleteQueueGroupAssociation request. The method will close the
    // http.Response Body if it receives an error.
    func (client BaseClient) DeleteQueueGroupAssociationSender(req *http.Request) (*http.Response, error) {
        return autorest.SendWithSender(client, req,
            autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
    }

    // DeleteQueueGroupAssociationResponder handles the response to the DeleteQueueGroupAssociation request. The method always
    // closes the http.Response Body.
    func (client BaseClient) DeleteQueueGroupAssociationResponder(resp *http.Response) (result SetObject, err error) {
        err = autorest.Respond(
            resp,
            client.ByInspecting(),
            azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusNoContent,http.StatusForbidden,http.StatusNotFound),
            autorest.ByUnmarshallingJSON(&result.Value),
            autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
        return
    }

    // DeleteQueueUserAssociation sends the delete queue user association request.
    //
    // userID is the user identifier. queueID is the queue identifier.
    func (client BaseClient) DeleteQueueUserAssociation(ctx context.Context, userID int32, queueID int32) (result SetObject, err error) {
        req, err := client.DeleteQueueUserAssociationPreparer(ctx, userID, queueID)
        if err != nil {
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "DeleteQueueUserAssociation", nil , "Failure preparing request")
            return
        }

        resp, err := client.DeleteQueueUserAssociationSender(req)
        if err != nil {
            result.Response = autorest.Response{Response: resp}
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "DeleteQueueUserAssociation", resp, "Failure sending request")
            return
        }

        result, err = client.DeleteQueueUserAssociationResponder(resp)
        if err != nil {
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "DeleteQueueUserAssociation", resp, "Failure responding to request")
        }

        return
    }

    // DeleteQueueUserAssociationPreparer prepares the DeleteQueueUserAssociation request.
    func (client BaseClient) DeleteQueueUserAssociationPreparer(ctx context.Context, userID int32, queueID int32) (*http.Request, error) {
        pathParameters := map[string]interface{} {
        "queueID": autorest.Encode("path",queueID),
        "userID": autorest.Encode("path",userID),
        }

        preparer := autorest.CreatePreparer(
            autorest.AsDelete(),
            autorest.WithBaseURL(client.BaseURI),
            autorest.WithPathParameters("/v1/workflow/queues/{queueID}/users/{userID}",pathParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
    }

    // DeleteQueueUserAssociationSender sends the DeleteQueueUserAssociation request. The method will close the
    // http.Response Body if it receives an error.
    func (client BaseClient) DeleteQueueUserAssociationSender(req *http.Request) (*http.Response, error) {
        return autorest.SendWithSender(client, req,
            autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
    }

    // DeleteQueueUserAssociationResponder handles the response to the DeleteQueueUserAssociation request. The method always
    // closes the http.Response Body.
    func (client BaseClient) DeleteQueueUserAssociationResponder(resp *http.Response) (result SetObject, err error) {
        err = autorest.Respond(
            resp,
            client.ByInspecting(),
            azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusNoContent,http.StatusForbidden,http.StatusNotFound),
            autorest.ByUnmarshallingJSON(&result.Value),
            autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
        return
    }

    // DeleteTask sends the delete task request.
    //
    // ID is the identifier.
    func (client BaseClient) DeleteTask(ctx context.Context, ID int32) (result SetObject, err error) {
        req, err := client.DeleteTaskPreparer(ctx, ID)
        if err != nil {
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "DeleteTask", nil , "Failure preparing request")
            return
        }

        resp, err := client.DeleteTaskSender(req)
        if err != nil {
            result.Response = autorest.Response{Response: resp}
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "DeleteTask", resp, "Failure sending request")
            return
        }

        result, err = client.DeleteTaskResponder(resp)
        if err != nil {
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "DeleteTask", resp, "Failure responding to request")
        }

        return
    }

    // DeleteTaskPreparer prepares the DeleteTask request.
    func (client BaseClient) DeleteTaskPreparer(ctx context.Context, ID int32) (*http.Request, error) {
        pathParameters := map[string]interface{} {
        "id": autorest.Encode("path",ID),
        }

        preparer := autorest.CreatePreparer(
            autorest.AsDelete(),
            autorest.WithBaseURL(client.BaseURI),
            autorest.WithPathParameters("/v1/workflow/tasks/{id}",pathParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
    }

    // DeleteTaskSender sends the DeleteTask request. The method will close the
    // http.Response Body if it receives an error.
    func (client BaseClient) DeleteTaskSender(req *http.Request) (*http.Response, error) {
        return autorest.SendWithSender(client, req,
            autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
    }

    // DeleteTaskResponder handles the response to the DeleteTask request. The method always
    // closes the http.Response Body.
    func (client BaseClient) DeleteTaskResponder(resp *http.Response) (result SetObject, err error) {
        err = autorest.Respond(
            resp,
            client.ByInspecting(),
            azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusNoContent,http.StatusForbidden,http.StatusNotFound),
            autorest.ByUnmarshallingJSON(&result.Value),
            autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
        return
    }

    // DeleteTemplateByID sends the delete template by id request.
    //
    // ID is the unique template identifier.
    func (client BaseClient) DeleteTemplateByID(ctx context.Context, ID string) (result SetObject, err error) {
        req, err := client.DeleteTemplateByIDPreparer(ctx, ID)
        if err != nil {
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "DeleteTemplateByID", nil , "Failure preparing request")
            return
        }

        resp, err := client.DeleteTemplateByIDSender(req)
        if err != nil {
            result.Response = autorest.Response{Response: resp}
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "DeleteTemplateByID", resp, "Failure sending request")
            return
        }

        result, err = client.DeleteTemplateByIDResponder(resp)
        if err != nil {
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "DeleteTemplateByID", resp, "Failure responding to request")
        }

        return
    }

    // DeleteTemplateByIDPreparer prepares the DeleteTemplateByID request.
    func (client BaseClient) DeleteTemplateByIDPreparer(ctx context.Context, ID string) (*http.Request, error) {
        pathParameters := map[string]interface{} {
        "id": autorest.Encode("path",ID),
        }

        preparer := autorest.CreatePreparer(
            autorest.AsDelete(),
            autorest.WithBaseURL(client.BaseURI),
            autorest.WithPathParameters("/v1/template/ftl/{id}",pathParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
    }

    // DeleteTemplateByIDSender sends the DeleteTemplateByID request. The method will close the
    // http.Response Body if it receives an error.
    func (client BaseClient) DeleteTemplateByIDSender(req *http.Request) (*http.Response, error) {
        return autorest.SendWithSender(client, req,
            autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
    }

    // DeleteTemplateByIDResponder handles the response to the DeleteTemplateByID request. The method always
    // closes the http.Response Body.
    func (client BaseClient) DeleteTemplateByIDResponder(resp *http.Response) (result SetObject, err error) {
        err = autorest.Respond(
            resp,
            client.ByInspecting(),
            azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusNoContent,http.StatusForbidden,http.StatusNotFound),
            autorest.ByUnmarshallingJSON(&result.Value),
            autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
        return
    }

    // DeleteTemplateByType sends the delete template by type request.
    //
    // typeParameter is the unique template type.
    func (client BaseClient) DeleteTemplateByType(ctx context.Context, typeParameter int32) (result SetObject, err error) {
        req, err := client.DeleteTemplateByTypePreparer(ctx, typeParameter)
        if err != nil {
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "DeleteTemplateByType", nil , "Failure preparing request")
            return
        }

        resp, err := client.DeleteTemplateByTypeSender(req)
        if err != nil {
            result.Response = autorest.Response{Response: resp}
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "DeleteTemplateByType", resp, "Failure sending request")
            return
        }

        result, err = client.DeleteTemplateByTypeResponder(resp)
        if err != nil {
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "DeleteTemplateByType", resp, "Failure responding to request")
        }

        return
    }

    // DeleteTemplateByTypePreparer prepares the DeleteTemplateByType request.
    func (client BaseClient) DeleteTemplateByTypePreparer(ctx context.Context, typeParameter int32) (*http.Request, error) {
        pathParameters := map[string]interface{} {
        "type": autorest.Encode("path",typeParameter),
        }

        preparer := autorest.CreatePreparer(
            autorest.AsDelete(),
            autorest.WithBaseURL(client.BaseURI),
            autorest.WithPathParameters("/v1/template/ftl/{type}",pathParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
    }

    // DeleteTemplateByTypeSender sends the DeleteTemplateByType request. The method will close the
    // http.Response Body if it receives an error.
    func (client BaseClient) DeleteTemplateByTypeSender(req *http.Request) (*http.Response, error) {
        return autorest.SendWithSender(client, req,
            autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
    }

    // DeleteTemplateByTypeResponder handles the response to the DeleteTemplateByType request. The method always
    // closes the http.Response Body.
    func (client BaseClient) DeleteTemplateByTypeResponder(resp *http.Response) (result SetObject, err error) {
        err = autorest.Respond(
            resp,
            client.ByInspecting(),
            azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusNoContent,http.StatusForbidden,http.StatusNotFound),
            autorest.ByUnmarshallingJSON(&result.Value),
            autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
        return
    }

    // DeleteUser sends the delete user request.
    //
    // ID is the user identifier.
    func (client BaseClient) DeleteUser(ctx context.Context, ID int32) (result SetObject, err error) {
        req, err := client.DeleteUserPreparer(ctx, ID)
        if err != nil {
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "DeleteUser", nil , "Failure preparing request")
            return
        }

        resp, err := client.DeleteUserSender(req)
        if err != nil {
            result.Response = autorest.Response{Response: resp}
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "DeleteUser", resp, "Failure sending request")
            return
        }

        result, err = client.DeleteUserResponder(resp)
        if err != nil {
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "DeleteUser", resp, "Failure responding to request")
        }

        return
    }

    // DeleteUserPreparer prepares the DeleteUser request.
    func (client BaseClient) DeleteUserPreparer(ctx context.Context, ID int32) (*http.Request, error) {
        pathParameters := map[string]interface{} {
        "id": autorest.Encode("path",ID),
        }

        preparer := autorest.CreatePreparer(
            autorest.AsDelete(),
            autorest.WithBaseURL(client.BaseURI),
            autorest.WithPathParameters("/v1/directory/users/{id}",pathParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
    }

    // DeleteUserSender sends the DeleteUser request. The method will close the
    // http.Response Body if it receives an error.
    func (client BaseClient) DeleteUserSender(req *http.Request) (*http.Response, error) {
        return autorest.SendWithSender(client, req,
            autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
    }

    // DeleteUserResponder handles the response to the DeleteUser request. The method always
    // closes the http.Response Body.
    func (client BaseClient) DeleteUserResponder(resp *http.Response) (result SetObject, err error) {
        err = autorest.Respond(
            resp,
            client.ByInspecting(),
            azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusNoContent,http.StatusForbidden,http.StatusNotFound),
            autorest.ByUnmarshallingJSON(&result.Value),
            autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
        return
    }

    // DeleteUserApplicationAssociation sends the delete user application association request.
    //
    // userID is the user identifier. applicationID is the application identifier.
    func (client BaseClient) DeleteUserApplicationAssociation(ctx context.Context, userID int32, applicationID int32) (result SetObject, err error) {
        req, err := client.DeleteUserApplicationAssociationPreparer(ctx, userID, applicationID)
        if err != nil {
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "DeleteUserApplicationAssociation", nil , "Failure preparing request")
            return
        }

        resp, err := client.DeleteUserApplicationAssociationSender(req)
        if err != nil {
            result.Response = autorest.Response{Response: resp}
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "DeleteUserApplicationAssociation", resp, "Failure sending request")
            return
        }

        result, err = client.DeleteUserApplicationAssociationResponder(resp)
        if err != nil {
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "DeleteUserApplicationAssociation", resp, "Failure responding to request")
        }

        return
    }

    // DeleteUserApplicationAssociationPreparer prepares the DeleteUserApplicationAssociation request.
    func (client BaseClient) DeleteUserApplicationAssociationPreparer(ctx context.Context, userID int32, applicationID int32) (*http.Request, error) {
        pathParameters := map[string]interface{} {
        "applicationID": autorest.Encode("path",applicationID),
        "userID": autorest.Encode("path",userID),
        }

        preparer := autorest.CreatePreparer(
            autorest.AsDelete(),
            autorest.WithBaseURL(client.BaseURI),
            autorest.WithPathParameters("/v1/directory/users/{userID}/applications/{applicationID}",pathParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
    }

    // DeleteUserApplicationAssociationSender sends the DeleteUserApplicationAssociation request. The method will close the
    // http.Response Body if it receives an error.
    func (client BaseClient) DeleteUserApplicationAssociationSender(req *http.Request) (*http.Response, error) {
        return autorest.SendWithSender(client, req,
            autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
    }

    // DeleteUserApplicationAssociationResponder handles the response to the DeleteUserApplicationAssociation request. The method always
    // closes the http.Response Body.
    func (client BaseClient) DeleteUserApplicationAssociationResponder(resp *http.Response) (result SetObject, err error) {
        err = autorest.Respond(
            resp,
            client.ByInspecting(),
            azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusNoContent,http.StatusForbidden,http.StatusNotFound),
            autorest.ByUnmarshallingJSON(&result.Value),
            autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
        return
    }

    // DeleteUserDrawerAssociation sends the delete user drawer association request.
    //
    // userID is the user identifier. drawerID is the drawer identifier.
    func (client BaseClient) DeleteUserDrawerAssociation(ctx context.Context, userID int32, drawerID int32) (result SetObject, err error) {
        req, err := client.DeleteUserDrawerAssociationPreparer(ctx, userID, drawerID)
        if err != nil {
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "DeleteUserDrawerAssociation", nil , "Failure preparing request")
            return
        }

        resp, err := client.DeleteUserDrawerAssociationSender(req)
        if err != nil {
            result.Response = autorest.Response{Response: resp}
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "DeleteUserDrawerAssociation", resp, "Failure sending request")
            return
        }

        result, err = client.DeleteUserDrawerAssociationResponder(resp)
        if err != nil {
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "DeleteUserDrawerAssociation", resp, "Failure responding to request")
        }

        return
    }

    // DeleteUserDrawerAssociationPreparer prepares the DeleteUserDrawerAssociation request.
    func (client BaseClient) DeleteUserDrawerAssociationPreparer(ctx context.Context, userID int32, drawerID int32) (*http.Request, error) {
        pathParameters := map[string]interface{} {
        "drawerID": autorest.Encode("path",drawerID),
        "userID": autorest.Encode("path",userID),
        }

        preparer := autorest.CreatePreparer(
            autorest.AsDelete(),
            autorest.WithBaseURL(client.BaseURI),
            autorest.WithPathParameters("/v1/directory/users/{userID}/drawers/{drawerID}",pathParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
    }

    // DeleteUserDrawerAssociationSender sends the DeleteUserDrawerAssociation request. The method will close the
    // http.Response Body if it receives an error.
    func (client BaseClient) DeleteUserDrawerAssociationSender(req *http.Request) (*http.Response, error) {
        return autorest.SendWithSender(client, req,
            autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
    }

    // DeleteUserDrawerAssociationResponder handles the response to the DeleteUserDrawerAssociation request. The method always
    // closes the http.Response Body.
    func (client BaseClient) DeleteUserDrawerAssociationResponder(resp *http.Response) (result SetObject, err error) {
        err = autorest.Respond(
            resp,
            client.ByInspecting(),
            azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusNoContent,http.StatusForbidden,http.StatusNotFound),
            autorest.ByUnmarshallingJSON(&result.Value),
            autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
        return
    }

    // DeleteUserGroupAssociation sends the delete user group association request.
    //
    // groupID is the group identifier. userID is the user identifier.
    func (client BaseClient) DeleteUserGroupAssociation(ctx context.Context, groupID int32, userID int32) (result SetObject, err error) {
        req, err := client.DeleteUserGroupAssociationPreparer(ctx, groupID, userID)
        if err != nil {
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "DeleteUserGroupAssociation", nil , "Failure preparing request")
            return
        }

        resp, err := client.DeleteUserGroupAssociationSender(req)
        if err != nil {
            result.Response = autorest.Response{Response: resp}
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "DeleteUserGroupAssociation", resp, "Failure sending request")
            return
        }

        result, err = client.DeleteUserGroupAssociationResponder(resp)
        if err != nil {
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "DeleteUserGroupAssociation", resp, "Failure responding to request")
        }

        return
    }

    // DeleteUserGroupAssociationPreparer prepares the DeleteUserGroupAssociation request.
    func (client BaseClient) DeleteUserGroupAssociationPreparer(ctx context.Context, groupID int32, userID int32) (*http.Request, error) {
        pathParameters := map[string]interface{} {
        "groupID": autorest.Encode("path",groupID),
        "userID": autorest.Encode("path",userID),
        }

        preparer := autorest.CreatePreparer(
            autorest.AsDelete(),
            autorest.WithBaseURL(client.BaseURI),
            autorest.WithPathParameters("/v1/directory/users/{userID}/groups/{groupID}",pathParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
    }

    // DeleteUserGroupAssociationSender sends the DeleteUserGroupAssociation request. The method will close the
    // http.Response Body if it receives an error.
    func (client BaseClient) DeleteUserGroupAssociationSender(req *http.Request) (*http.Response, error) {
        return autorest.SendWithSender(client, req,
            autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
    }

    // DeleteUserGroupAssociationResponder handles the response to the DeleteUserGroupAssociation request. The method always
    // closes the http.Response Body.
    func (client BaseClient) DeleteUserGroupAssociationResponder(resp *http.Response) (result SetObject, err error) {
        err = autorest.Respond(
            resp,
            client.ByInspecting(),
            azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusNoContent,http.StatusForbidden,http.StatusNotFound),
            autorest.ByUnmarshallingJSON(&result.Value),
            autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
        return
    }

    // DeleteUserQueueAssociation sends the delete user queue association request.
    //
    // userID is the user identifier. queueID is the queue identifier.
    func (client BaseClient) DeleteUserQueueAssociation(ctx context.Context, userID int32, queueID int32) (result SetObject, err error) {
        req, err := client.DeleteUserQueueAssociationPreparer(ctx, userID, queueID)
        if err != nil {
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "DeleteUserQueueAssociation", nil , "Failure preparing request")
            return
        }

        resp, err := client.DeleteUserQueueAssociationSender(req)
        if err != nil {
            result.Response = autorest.Response{Response: resp}
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "DeleteUserQueueAssociation", resp, "Failure sending request")
            return
        }

        result, err = client.DeleteUserQueueAssociationResponder(resp)
        if err != nil {
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "DeleteUserQueueAssociation", resp, "Failure responding to request")
        }

        return
    }

    // DeleteUserQueueAssociationPreparer prepares the DeleteUserQueueAssociation request.
    func (client BaseClient) DeleteUserQueueAssociationPreparer(ctx context.Context, userID int32, queueID int32) (*http.Request, error) {
        pathParameters := map[string]interface{} {
        "queueID": autorest.Encode("path",queueID),
        "userID": autorest.Encode("path",userID),
        }

        preparer := autorest.CreatePreparer(
            autorest.AsDelete(),
            autorest.WithBaseURL(client.BaseURI),
            autorest.WithPathParameters("/v1/directory/users/{userID}/queues/{queueID}",pathParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
    }

    // DeleteUserQueueAssociationSender sends the DeleteUserQueueAssociation request. The method will close the
    // http.Response Body if it receives an error.
    func (client BaseClient) DeleteUserQueueAssociationSender(req *http.Request) (*http.Response, error) {
        return autorest.SendWithSender(client, req,
            autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
    }

    // DeleteUserQueueAssociationResponder handles the response to the DeleteUserQueueAssociation request. The method always
    // closes the http.Response Body.
    func (client BaseClient) DeleteUserQueueAssociationResponder(resp *http.Response) (result SetObject, err error) {
        err = autorest.Respond(
            resp,
            client.ByInspecting(),
            azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusNoContent,http.StatusForbidden,http.StatusNotFound),
            autorest.ByUnmarshallingJSON(&result.Value),
            autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
        return
    }

    // FetchTaskFromQueueAssignment sends the fetch task from queue assignment request.
    func (client BaseClient) FetchTaskFromQueueAssignment(ctx context.Context) (result TaskModel, err error) {
        req, err := client.FetchTaskFromQueueAssignmentPreparer(ctx)
        if err != nil {
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "FetchTaskFromQueueAssignment", nil , "Failure preparing request")
            return
        }

        resp, err := client.FetchTaskFromQueueAssignmentSender(req)
        if err != nil {
            result.Response = autorest.Response{Response: resp}
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "FetchTaskFromQueueAssignment", resp, "Failure sending request")
            return
        }

        result, err = client.FetchTaskFromQueueAssignmentResponder(resp)
        if err != nil {
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "FetchTaskFromQueueAssignment", resp, "Failure responding to request")
        }

        return
    }

    // FetchTaskFromQueueAssignmentPreparer prepares the FetchTaskFromQueueAssignment request.
    func (client BaseClient) FetchTaskFromQueueAssignmentPreparer(ctx context.Context) (*http.Request, error) {
        preparer := autorest.CreatePreparer(
            autorest.AsGet(),
            autorest.WithBaseURL(client.BaseURI),
            autorest.WithPath("/v1/workflow/tasks/fetch"))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
    }

    // FetchTaskFromQueueAssignmentSender sends the FetchTaskFromQueueAssignment request. The method will close the
    // http.Response Body if it receives an error.
    func (client BaseClient) FetchTaskFromQueueAssignmentSender(req *http.Request) (*http.Response, error) {
        return autorest.SendWithSender(client, req,
            autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
    }

    // FetchTaskFromQueueAssignmentResponder handles the response to the FetchTaskFromQueueAssignment request. The method always
    // closes the http.Response Body.
    func (client BaseClient) FetchTaskFromQueueAssignmentResponder(resp *http.Response) (result TaskModel, err error) {
        err = autorest.Respond(
            resp,
            client.ByInspecting(),
            azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusNotFound),
            autorest.ByUnmarshallingJSON(&result),
            autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
        return
    }

    // GetAllApplications sends the get all applications request.
    func (client BaseClient) GetAllApplications(ctx context.Context) (result ListApplicationModel, err error) {
        req, err := client.GetAllApplicationsPreparer(ctx)
        if err != nil {
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "GetAllApplications", nil , "Failure preparing request")
            return
        }

        resp, err := client.GetAllApplicationsSender(req)
        if err != nil {
            result.Response = autorest.Response{Response: resp}
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "GetAllApplications", resp, "Failure sending request")
            return
        }

        result, err = client.GetAllApplicationsResponder(resp)
        if err != nil {
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "GetAllApplications", resp, "Failure responding to request")
        }

        return
    }

    // GetAllApplicationsPreparer prepares the GetAllApplications request.
    func (client BaseClient) GetAllApplicationsPreparer(ctx context.Context) (*http.Request, error) {
        preparer := autorest.CreatePreparer(
            autorest.AsGet(),
            autorest.WithBaseURL(client.BaseURI),
            autorest.WithPath("/v1/directory/applications"))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
    }

    // GetAllApplicationsSender sends the GetAllApplications request. The method will close the
    // http.Response Body if it receives an error.
    func (client BaseClient) GetAllApplicationsSender(req *http.Request) (*http.Response, error) {
        return autorest.SendWithSender(client, req,
            autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
    }

    // GetAllApplicationsResponder handles the response to the GetAllApplications request. The method always
    // closes the http.Response Body.
    func (client BaseClient) GetAllApplicationsResponder(resp *http.Response) (result ListApplicationModel, err error) {
        err = autorest.Respond(
            resp,
            client.ByInspecting(),
            azure.WithErrorUnlessStatusCode(http.StatusOK),
            autorest.ByUnmarshallingJSON(&result.Value),
            autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
        return
    }

    // GetAllDrawers sends the get all drawers request.
    func (client BaseClient) GetAllDrawers(ctx context.Context) (result ListDrawerModel, err error) {
        req, err := client.GetAllDrawersPreparer(ctx)
        if err != nil {
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "GetAllDrawers", nil , "Failure preparing request")
            return
        }

        resp, err := client.GetAllDrawersSender(req)
        if err != nil {
            result.Response = autorest.Response{Response: resp}
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "GetAllDrawers", resp, "Failure sending request")
            return
        }

        result, err = client.GetAllDrawersResponder(resp)
        if err != nil {
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "GetAllDrawers", resp, "Failure responding to request")
        }

        return
    }

    // GetAllDrawersPreparer prepares the GetAllDrawers request.
    func (client BaseClient) GetAllDrawersPreparer(ctx context.Context) (*http.Request, error) {
        preparer := autorest.CreatePreparer(
            autorest.AsGet(),
            autorest.WithBaseURL(client.BaseURI),
            autorest.WithPath("/v1/directory/drawers"))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
    }

    // GetAllDrawersSender sends the GetAllDrawers request. The method will close the
    // http.Response Body if it receives an error.
    func (client BaseClient) GetAllDrawersSender(req *http.Request) (*http.Response, error) {
        return autorest.SendWithSender(client, req,
            autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
    }

    // GetAllDrawersResponder handles the response to the GetAllDrawers request. The method always
    // closes the http.Response Body.
    func (client BaseClient) GetAllDrawersResponder(resp *http.Response) (result ListDrawerModel, err error) {
        err = autorest.Respond(
            resp,
            client.ByInspecting(),
            azure.WithErrorUnlessStatusCode(http.StatusOK),
            autorest.ByUnmarshallingJSON(&result.Value),
            autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
        return
    }

    // GetApplicationByID sends the get application by id request.
    //
    // ID is the unique application identifier.
    func (client BaseClient) GetApplicationByID(ctx context.Context, ID int32) (result ApplicationModel, err error) {
        req, err := client.GetApplicationByIDPreparer(ctx, ID)
        if err != nil {
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "GetApplicationByID", nil , "Failure preparing request")
            return
        }

        resp, err := client.GetApplicationByIDSender(req)
        if err != nil {
            result.Response = autorest.Response{Response: resp}
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "GetApplicationByID", resp, "Failure sending request")
            return
        }

        result, err = client.GetApplicationByIDResponder(resp)
        if err != nil {
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "GetApplicationByID", resp, "Failure responding to request")
        }

        return
    }

    // GetApplicationByIDPreparer prepares the GetApplicationByID request.
    func (client BaseClient) GetApplicationByIDPreparer(ctx context.Context, ID int32) (*http.Request, error) {
        pathParameters := map[string]interface{} {
        "id": autorest.Encode("path",ID),
        }

        preparer := autorest.CreatePreparer(
            autorest.AsGet(),
            autorest.WithBaseURL(client.BaseURI),
            autorest.WithPathParameters("/v1/directory/applications/{id}",pathParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
    }

    // GetApplicationByIDSender sends the GetApplicationByID request. The method will close the
    // http.Response Body if it receives an error.
    func (client BaseClient) GetApplicationByIDSender(req *http.Request) (*http.Response, error) {
        return autorest.SendWithSender(client, req,
            autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
    }

    // GetApplicationByIDResponder handles the response to the GetApplicationByID request. The method always
    // closes the http.Response Body.
    func (client BaseClient) GetApplicationByIDResponder(resp *http.Response) (result ApplicationModel, err error) {
        err = autorest.Respond(
            resp,
            client.ByInspecting(),
            azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusNotFound),
            autorest.ByUnmarshallingJSON(&result),
            autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
        return
    }

    // GetApplicationByName sends the get application by name request.
    //
    // name is the unique application name.
    func (client BaseClient) GetApplicationByName(ctx context.Context, name string) (result ApplicationModel, err error) {
        req, err := client.GetApplicationByNamePreparer(ctx, name)
        if err != nil {
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "GetApplicationByName", nil , "Failure preparing request")
            return
        }

        resp, err := client.GetApplicationByNameSender(req)
        if err != nil {
            result.Response = autorest.Response{Response: resp}
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "GetApplicationByName", resp, "Failure sending request")
            return
        }

        result, err = client.GetApplicationByNameResponder(resp)
        if err != nil {
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "GetApplicationByName", resp, "Failure responding to request")
        }

        return
    }

    // GetApplicationByNamePreparer prepares the GetApplicationByName request.
    func (client BaseClient) GetApplicationByNamePreparer(ctx context.Context, name string) (*http.Request, error) {
        pathParameters := map[string]interface{} {
        "name": autorest.Encode("path",name),
        }

        preparer := autorest.CreatePreparer(
            autorest.AsGet(),
            autorest.WithBaseURL(client.BaseURI),
            autorest.WithPathParameters("/v1/directory/applications/{name}",pathParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
    }

    // GetApplicationByNameSender sends the GetApplicationByName request. The method will close the
    // http.Response Body if it receives an error.
    func (client BaseClient) GetApplicationByNameSender(req *http.Request) (*http.Response, error) {
        return autorest.SendWithSender(client, req,
            autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
    }

    // GetApplicationByNameResponder handles the response to the GetApplicationByName request. The method always
    // closes the http.Response Body.
    func (client BaseClient) GetApplicationByNameResponder(resp *http.Response) (result ApplicationModel, err error) {
        err = autorest.Respond(
            resp,
            client.ByInspecting(),
            azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusNotFound),
            autorest.ByUnmarshallingJSON(&result),
            autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
        return
    }

    // GetApplicationGroupAssociations sends the get application group associations request.
    //
    // applicationID is the application identifier. groupID is the group identifier. ACL is gets or sets the access control
    // level permissions. page is gets or sets the page number. pageSize is gets or sets the size of the page. sortOrder is
    // gets or sets the order. sortBy is gets or sets the column to order by.
    func (client BaseClient) GetApplicationGroupAssociations(ctx context.Context, applicationID int32, groupID *int32, ACL *int32, page *int32, pageSize *int32, sortOrder string, sortBy string) (result ListGroupApplicationModel, err error) {
        if err := validation.Validate([]validation.Validation{
        { TargetValue: page,
         Constraints: []validation.Constraint{	{Target: "page", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "page", Name: validation.InclusiveMaximum, Rule: 2147483647, Chain: nil },
        	{Target: "page", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil },
        }}}},
        { TargetValue: pageSize,
         Constraints: []validation.Constraint{	{Target: "pageSize", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "pageSize", Name: validation.InclusiveMaximum, Rule: 1000, Chain: nil },
        	{Target: "pageSize", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil },
        }}}}}); err != nil {
            return result, validation.NewErrorWithValidationError(err, "softheonenterpriseapiclient.BaseClient","GetApplicationGroupAssociations")
        }

        req, err := client.GetApplicationGroupAssociationsPreparer(ctx, applicationID, groupID, ACL, page, pageSize, sortOrder, sortBy)
        if err != nil {
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "GetApplicationGroupAssociations", nil , "Failure preparing request")
            return
        }

        resp, err := client.GetApplicationGroupAssociationsSender(req)
        if err != nil {
            result.Response = autorest.Response{Response: resp}
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "GetApplicationGroupAssociations", resp, "Failure sending request")
            return
        }

        result, err = client.GetApplicationGroupAssociationsResponder(resp)
        if err != nil {
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "GetApplicationGroupAssociations", resp, "Failure responding to request")
        }

        return
    }

    // GetApplicationGroupAssociationsPreparer prepares the GetApplicationGroupAssociations request.
    func (client BaseClient) GetApplicationGroupAssociationsPreparer(ctx context.Context, applicationID int32, groupID *int32, ACL *int32, page *int32, pageSize *int32, sortOrder string, sortBy string) (*http.Request, error) {
        pathParameters := map[string]interface{} {
        "applicationID": autorest.Encode("path",applicationID),
        }

        queryParameters := map[string]interface{} {
        }
        if groupID != nil {
            queryParameters["groupID"] = autorest.Encode("query",*groupID)
        }
        if ACL != nil {
            queryParameters["acl"] = autorest.Encode("query",*ACL)
        }
        if page != nil {
            queryParameters["page"] = autorest.Encode("query",*page)
        }
        if pageSize != nil {
            queryParameters["pageSize"] = autorest.Encode("query",*pageSize)
        }
        if len(string(sortOrder)) > 0 {
            queryParameters["sortOrder"] = autorest.Encode("query",sortOrder)
        }
        if len(string(sortBy)) > 0 {
            queryParameters["sortBy"] = autorest.Encode("query",sortBy)
        }

        preparer := autorest.CreatePreparer(
            autorest.AsGet(),
            autorest.WithBaseURL(client.BaseURI),
            autorest.WithPathParameters("/v1/directory/applications/{applicationID}/groups",pathParameters),
            autorest.WithQueryParameters(queryParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
    }

    // GetApplicationGroupAssociationsSender sends the GetApplicationGroupAssociations request. The method will close the
    // http.Response Body if it receives an error.
    func (client BaseClient) GetApplicationGroupAssociationsSender(req *http.Request) (*http.Response, error) {
        return autorest.SendWithSender(client, req,
            autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
    }

    // GetApplicationGroupAssociationsResponder handles the response to the GetApplicationGroupAssociations request. The method always
    // closes the http.Response Body.
    func (client BaseClient) GetApplicationGroupAssociationsResponder(resp *http.Response) (result ListGroupApplicationModel, err error) {
        err = autorest.Respond(
            resp,
            client.ByInspecting(),
            azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusForbidden),
            autorest.ByUnmarshallingJSON(&result.Value),
            autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
        return
    }

    // GetApplicationUserAssociations sends the get application user associations request.
    //
    // applicationID is the application identifier. userID is the user identifier. ACL is gets or sets the access control
    // level permissions. page is gets or sets the page number. pageSize is gets or sets the size of the page. sortOrder is
    // gets or sets the order. sortBy is gets or sets the column to order by.
    func (client BaseClient) GetApplicationUserAssociations(ctx context.Context, applicationID int32, userID *int32, ACL *int32, page *int32, pageSize *int32, sortOrder string, sortBy string) (result ListUserApplicationModel, err error) {
        if err := validation.Validate([]validation.Validation{
        { TargetValue: page,
         Constraints: []validation.Constraint{	{Target: "page", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "page", Name: validation.InclusiveMaximum, Rule: 2147483647, Chain: nil },
        	{Target: "page", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil },
        }}}},
        { TargetValue: pageSize,
         Constraints: []validation.Constraint{	{Target: "pageSize", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "pageSize", Name: validation.InclusiveMaximum, Rule: 1000, Chain: nil },
        	{Target: "pageSize", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil },
        }}}}}); err != nil {
            return result, validation.NewErrorWithValidationError(err, "softheonenterpriseapiclient.BaseClient","GetApplicationUserAssociations")
        }

        req, err := client.GetApplicationUserAssociationsPreparer(ctx, applicationID, userID, ACL, page, pageSize, sortOrder, sortBy)
        if err != nil {
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "GetApplicationUserAssociations", nil , "Failure preparing request")
            return
        }

        resp, err := client.GetApplicationUserAssociationsSender(req)
        if err != nil {
            result.Response = autorest.Response{Response: resp}
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "GetApplicationUserAssociations", resp, "Failure sending request")
            return
        }

        result, err = client.GetApplicationUserAssociationsResponder(resp)
        if err != nil {
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "GetApplicationUserAssociations", resp, "Failure responding to request")
        }

        return
    }

    // GetApplicationUserAssociationsPreparer prepares the GetApplicationUserAssociations request.
    func (client BaseClient) GetApplicationUserAssociationsPreparer(ctx context.Context, applicationID int32, userID *int32, ACL *int32, page *int32, pageSize *int32, sortOrder string, sortBy string) (*http.Request, error) {
        pathParameters := map[string]interface{} {
        "applicationID": autorest.Encode("path",applicationID),
        }

        queryParameters := map[string]interface{} {
        }
        if userID != nil {
            queryParameters["userID"] = autorest.Encode("query",*userID)
        }
        if ACL != nil {
            queryParameters["acl"] = autorest.Encode("query",*ACL)
        }
        if page != nil {
            queryParameters["page"] = autorest.Encode("query",*page)
        }
        if pageSize != nil {
            queryParameters["pageSize"] = autorest.Encode("query",*pageSize)
        }
        if len(string(sortOrder)) > 0 {
            queryParameters["sortOrder"] = autorest.Encode("query",sortOrder)
        }
        if len(string(sortBy)) > 0 {
            queryParameters["sortBy"] = autorest.Encode("query",sortBy)
        }

        preparer := autorest.CreatePreparer(
            autorest.AsGet(),
            autorest.WithBaseURL(client.BaseURI),
            autorest.WithPathParameters("/v1/directory/applications/{applicationID}/users",pathParameters),
            autorest.WithQueryParameters(queryParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
    }

    // GetApplicationUserAssociationsSender sends the GetApplicationUserAssociations request. The method will close the
    // http.Response Body if it receives an error.
    func (client BaseClient) GetApplicationUserAssociationsSender(req *http.Request) (*http.Response, error) {
        return autorest.SendWithSender(client, req,
            autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
    }

    // GetApplicationUserAssociationsResponder handles the response to the GetApplicationUserAssociations request. The method always
    // closes the http.Response Body.
    func (client BaseClient) GetApplicationUserAssociationsResponder(resp *http.Response) (result ListUserApplicationModel, err error) {
        err = autorest.Respond(
            resp,
            client.ByInspecting(),
            azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusForbidden),
            autorest.ByUnmarshallingJSON(&result.Value),
            autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
        return
    }

    // GetAttachmentByID sends the get attachment by id request.
    //
    // drawer is the drawer identifier. ID is the attachment identifier.
    func (client BaseClient) GetAttachmentByID(ctx context.Context, drawer int32, ID int32) (result AttachmentModel, err error) {
        req, err := client.GetAttachmentByIDPreparer(ctx, drawer, ID)
        if err != nil {
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "GetAttachmentByID", nil , "Failure preparing request")
            return
        }

        resp, err := client.GetAttachmentByIDSender(req)
        if err != nil {
            result.Response = autorest.Response{Response: resp}
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "GetAttachmentByID", resp, "Failure sending request")
            return
        }

        result, err = client.GetAttachmentByIDResponder(resp)
        if err != nil {
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "GetAttachmentByID", resp, "Failure responding to request")
        }

        return
    }

    // GetAttachmentByIDPreparer prepares the GetAttachmentByID request.
    func (client BaseClient) GetAttachmentByIDPreparer(ctx context.Context, drawer int32, ID int32) (*http.Request, error) {
        pathParameters := map[string]interface{} {
        "drawer": autorest.Encode("path",drawer),
        "id": autorest.Encode("path",ID),
        }

        preparer := autorest.CreatePreparer(
            autorest.AsGet(),
            autorest.WithBaseURL(client.BaseURI),
            autorest.WithPathParameters("/v1/content/attachments/{drawer}/{id}",pathParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
    }

    // GetAttachmentByIDSender sends the GetAttachmentByID request. The method will close the
    // http.Response Body if it receives an error.
    func (client BaseClient) GetAttachmentByIDSender(req *http.Request) (*http.Response, error) {
        return autorest.SendWithSender(client, req,
            autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
    }

    // GetAttachmentByIDResponder handles the response to the GetAttachmentByID request. The method always
    // closes the http.Response Body.
    func (client BaseClient) GetAttachmentByIDResponder(resp *http.Response) (result AttachmentModel, err error) {
        err = autorest.Respond(
            resp,
            client.ByInspecting(),
            azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusNotFound),
            autorest.ByUnmarshallingJSON(&result),
            autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
        return
    }

    // GetAttachmentFileContent sends the get attachment file content request.
    //
    // drawer is the drawer identifier. ID is the attachment identifier.
    func (client BaseClient) GetAttachmentFileContent(ctx context.Context, drawer int32, ID int32) (result SetObject, err error) {
        req, err := client.GetAttachmentFileContentPreparer(ctx, drawer, ID)
        if err != nil {
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "GetAttachmentFileContent", nil , "Failure preparing request")
            return
        }

        resp, err := client.GetAttachmentFileContentSender(req)
        if err != nil {
            result.Response = autorest.Response{Response: resp}
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "GetAttachmentFileContent", resp, "Failure sending request")
            return
        }

        result, err = client.GetAttachmentFileContentResponder(resp)
        if err != nil {
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "GetAttachmentFileContent", resp, "Failure responding to request")
        }

        return
    }

    // GetAttachmentFileContentPreparer prepares the GetAttachmentFileContent request.
    func (client BaseClient) GetAttachmentFileContentPreparer(ctx context.Context, drawer int32, ID int32) (*http.Request, error) {
        pathParameters := map[string]interface{} {
        "drawer": autorest.Encode("path",drawer),
        "id": autorest.Encode("path",ID),
        }

        preparer := autorest.CreatePreparer(
            autorest.AsGet(),
            autorest.WithBaseURL(client.BaseURI),
            autorest.WithPathParameters("/v1/content/attachments/{drawer}/{id}/file",pathParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
    }

    // GetAttachmentFileContentSender sends the GetAttachmentFileContent request. The method will close the
    // http.Response Body if it receives an error.
    func (client BaseClient) GetAttachmentFileContentSender(req *http.Request) (*http.Response, error) {
        return autorest.SendWithSender(client, req,
            autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
    }

    // GetAttachmentFileContentResponder handles the response to the GetAttachmentFileContent request. The method always
    // closes the http.Response Body.
    func (client BaseClient) GetAttachmentFileContentResponder(resp *http.Response) (result SetObject, err error) {
        err = autorest.Respond(
            resp,
            client.ByInspecting(),
            azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusForbidden,http.StatusNotFound),
            autorest.ByUnmarshallingJSON(&result.Value),
            autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
        return
    }

    // GetAttachmentsByFilter sends the get attachments by filter request.
    //
    // typeParameter is gets or sets the type. extension is gets or sets the extension. minSize is gets or sets the minimum
    // size. maxSize is gets or sets the maximum size. ACL is gets or sets the access control list. entityID is gets or
    // sets the entity identifier. drawerID is gets or sets the drawer identifier. name is gets or sets the name.
    // creatorUserID is gets or sets the creator user identifier. modifierUserID is gets or sets the modifier user
    // identifier. minInsertionTime is gets or sets the minimum insertion time. maxInsertionTime is gets or sets the
    // maximum insertion time. minModificationTime is gets or sets the minimum modification time. maxModificationTime is
    // gets or sets the maximum modification time. page is gets or sets the page number. pageSize is gets or sets the size
    // of the page. sortOrder is gets or sets the order. sortBy is gets or sets the column to order by.
    func (client BaseClient) GetAttachmentsByFilter(ctx context.Context, typeParameter string, extension string, minSize *int64, maxSize *int64, ACL *int32, entityID *int32, drawerID *int32, name string, creatorUserID *int32, modifierUserID *int32, minInsertionTime *date.Time, maxInsertionTime *date.Time, minModificationTime *date.Time, maxModificationTime *date.Time, page *int32, pageSize *int32, sortOrder string, sortBy string) (result ListAttachmentModel, err error) {
        if err := validation.Validate([]validation.Validation{
        { TargetValue: extension,
         Constraints: []validation.Constraint{	{Target: "extension", Name: validation.MaxLength, Rule: 255, Chain: nil },
        	{Target: "extension", Name: validation.MinLength, Rule: 0, Chain: nil }}},
        { TargetValue: minSize,
         Constraints: []validation.Constraint{	{Target: "minSize", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "minSize", Name: validation.InclusiveMinimum, Rule: 0, Chain: nil },
        }}}},
        { TargetValue: maxSize,
         Constraints: []validation.Constraint{	{Target: "maxSize", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "maxSize", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil },
        }}}},
        { TargetValue: entityID,
         Constraints: []validation.Constraint{	{Target: "entityID", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "entityID", Name: validation.InclusiveMaximum, Rule: 2147483647, Chain: nil },
        	{Target: "entityID", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil },
        }}}},
        { TargetValue: drawerID,
         Constraints: []validation.Constraint{	{Target: "drawerID", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "drawerID", Name: validation.InclusiveMaximum, Rule: 2147483647, Chain: nil },
        	{Target: "drawerID", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil },
        }}}},
        { TargetValue: name,
         Constraints: []validation.Constraint{	{Target: "name", Name: validation.MaxLength, Rule: 255, Chain: nil },
        	{Target: "name", Name: validation.MinLength, Rule: 0, Chain: nil }}},
        { TargetValue: creatorUserID,
         Constraints: []validation.Constraint{	{Target: "creatorUserID", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "creatorUserID", Name: validation.InclusiveMaximum, Rule: 2147483647, Chain: nil },
        	{Target: "creatorUserID", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil },
        }}}},
        { TargetValue: modifierUserID,
         Constraints: []validation.Constraint{	{Target: "modifierUserID", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "modifierUserID", Name: validation.InclusiveMaximum, Rule: 2147483647, Chain: nil },
        	{Target: "modifierUserID", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil },
        }}}},
        { TargetValue: page,
         Constraints: []validation.Constraint{	{Target: "page", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "page", Name: validation.InclusiveMaximum, Rule: 2147483647, Chain: nil },
        	{Target: "page", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil },
        }}}},
        { TargetValue: pageSize,
         Constraints: []validation.Constraint{	{Target: "pageSize", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "pageSize", Name: validation.InclusiveMaximum, Rule: 1000, Chain: nil },
        	{Target: "pageSize", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil },
        }}}}}); err != nil {
            return result, validation.NewErrorWithValidationError(err, "softheonenterpriseapiclient.BaseClient","GetAttachmentsByFilter")
        }

        req, err := client.GetAttachmentsByFilterPreparer(ctx, typeParameter, extension, minSize, maxSize, ACL, entityID, drawerID, name, creatorUserID, modifierUserID, minInsertionTime, maxInsertionTime, minModificationTime, maxModificationTime, page, pageSize, sortOrder, sortBy)
        if err != nil {
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "GetAttachmentsByFilter", nil , "Failure preparing request")
            return
        }

        resp, err := client.GetAttachmentsByFilterSender(req)
        if err != nil {
            result.Response = autorest.Response{Response: resp}
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "GetAttachmentsByFilter", resp, "Failure sending request")
            return
        }

        result, err = client.GetAttachmentsByFilterResponder(resp)
        if err != nil {
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "GetAttachmentsByFilter", resp, "Failure responding to request")
        }

        return
    }

    // GetAttachmentsByFilterPreparer prepares the GetAttachmentsByFilter request.
    func (client BaseClient) GetAttachmentsByFilterPreparer(ctx context.Context, typeParameter string, extension string, minSize *int64, maxSize *int64, ACL *int32, entityID *int32, drawerID *int32, name string, creatorUserID *int32, modifierUserID *int32, minInsertionTime *date.Time, maxInsertionTime *date.Time, minModificationTime *date.Time, maxModificationTime *date.Time, page *int32, pageSize *int32, sortOrder string, sortBy string) (*http.Request, error) {
        queryParameters := map[string]interface{} {
        }
        if len(string(typeParameter)) > 0 {
            queryParameters["type"] = autorest.Encode("query",typeParameter)
        }
        if len(extension) > 0 {
            queryParameters["extension"] = autorest.Encode("query",extension)
        }
        if minSize != nil {
            queryParameters["minSize"] = autorest.Encode("query",*minSize)
        }
        if maxSize != nil {
            queryParameters["maxSize"] = autorest.Encode("query",*maxSize)
        }
        if ACL != nil {
            queryParameters["acl"] = autorest.Encode("query",*ACL)
        }
        if entityID != nil {
            queryParameters["entityID"] = autorest.Encode("query",*entityID)
        }
        if drawerID != nil {
            queryParameters["drawerID"] = autorest.Encode("query",*drawerID)
        }
        if len(name) > 0 {
            queryParameters["name"] = autorest.Encode("query",name)
        }
        if creatorUserID != nil {
            queryParameters["creatorUserID"] = autorest.Encode("query",*creatorUserID)
        }
        if modifierUserID != nil {
            queryParameters["modifierUserID"] = autorest.Encode("query",*modifierUserID)
        }
        if minInsertionTime != nil {
            queryParameters["minInsertionTime"] = autorest.Encode("query",*minInsertionTime)
        }
        if maxInsertionTime != nil {
            queryParameters["maxInsertionTime"] = autorest.Encode("query",*maxInsertionTime)
        }
        if minModificationTime != nil {
            queryParameters["minModificationTime"] = autorest.Encode("query",*minModificationTime)
        }
        if maxModificationTime != nil {
            queryParameters["maxModificationTime"] = autorest.Encode("query",*maxModificationTime)
        }
        if page != nil {
            queryParameters["page"] = autorest.Encode("query",*page)
        }
        if pageSize != nil {
            queryParameters["pageSize"] = autorest.Encode("query",*pageSize)
        }
        if len(string(sortOrder)) > 0 {
            queryParameters["sortOrder"] = autorest.Encode("query",sortOrder)
        }
        if len(string(sortBy)) > 0 {
            queryParameters["sortBy"] = autorest.Encode("query",sortBy)
        }

        preparer := autorest.CreatePreparer(
            autorest.AsGet(),
            autorest.WithBaseURL(client.BaseURI),
            autorest.WithPath("/v1/content/attachments"),
            autorest.WithQueryParameters(queryParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
    }

    // GetAttachmentsByFilterSender sends the GetAttachmentsByFilter request. The method will close the
    // http.Response Body if it receives an error.
    func (client BaseClient) GetAttachmentsByFilterSender(req *http.Request) (*http.Response, error) {
        return autorest.SendWithSender(client, req,
            autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
    }

    // GetAttachmentsByFilterResponder handles the response to the GetAttachmentsByFilter request. The method always
    // closes the http.Response Body.
    func (client BaseClient) GetAttachmentsByFilterResponder(resp *http.Response) (result ListAttachmentModel, err error) {
        err = autorest.Respond(
            resp,
            client.ByInspecting(),
            azure.WithErrorUnlessStatusCode(http.StatusOK),
            autorest.ByUnmarshallingJSON(&result.Value),
            autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
        return
    }

    // GetAttachmentVersionFileContent sends the get attachment version file content request.
    //
    // drawer is the drawer identifier. ID is the attachment identifier. versionID is the version identifier.
    func (client BaseClient) GetAttachmentVersionFileContent(ctx context.Context, drawer int32, ID int32, versionID int32) (result SetObject, err error) {
        req, err := client.GetAttachmentVersionFileContentPreparer(ctx, drawer, ID, versionID)
        if err != nil {
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "GetAttachmentVersionFileContent", nil , "Failure preparing request")
            return
        }

        resp, err := client.GetAttachmentVersionFileContentSender(req)
        if err != nil {
            result.Response = autorest.Response{Response: resp}
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "GetAttachmentVersionFileContent", resp, "Failure sending request")
            return
        }

        result, err = client.GetAttachmentVersionFileContentResponder(resp)
        if err != nil {
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "GetAttachmentVersionFileContent", resp, "Failure responding to request")
        }

        return
    }

    // GetAttachmentVersionFileContentPreparer prepares the GetAttachmentVersionFileContent request.
    func (client BaseClient) GetAttachmentVersionFileContentPreparer(ctx context.Context, drawer int32, ID int32, versionID int32) (*http.Request, error) {
        pathParameters := map[string]interface{} {
        "drawer": autorest.Encode("path",drawer),
        "id": autorest.Encode("path",ID),
        "versionID": autorest.Encode("path",versionID),
        }

        preparer := autorest.CreatePreparer(
            autorest.AsGet(),
            autorest.WithBaseURL(client.BaseURI),
            autorest.WithPathParameters("/v1/content/attachments/{drawer}/{id}/versions/{versionID}",pathParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
    }

    // GetAttachmentVersionFileContentSender sends the GetAttachmentVersionFileContent request. The method will close the
    // http.Response Body if it receives an error.
    func (client BaseClient) GetAttachmentVersionFileContentSender(req *http.Request) (*http.Response, error) {
        return autorest.SendWithSender(client, req,
            autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
    }

    // GetAttachmentVersionFileContentResponder handles the response to the GetAttachmentVersionFileContent request. The method always
    // closes the http.Response Body.
    func (client BaseClient) GetAttachmentVersionFileContentResponder(resp *http.Response) (result SetObject, err error) {
        err = autorest.Respond(
            resp,
            client.ByInspecting(),
            azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusForbidden,http.StatusNotFound),
            autorest.ByUnmarshallingJSON(&result.Value),
            autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
        return
    }

    // GetAttachmentVersionsByFilter sends the get attachment versions by filter request.
    //
    // drawer is the drawer identifier. ID is the attachment identifier. version is gets or sets the indexed version value.
    // creatorUserID is gets or sets the creator identifier. accessorUserID is gets or sets the identifier of the user who
    // accessed the attachment version. minAccessTime is gets or sets the min time the version was last accessed.
    // maxAccessTime is gets or sets the max time the version was last accessed. minCreationTime is gets or sets the min
    // creation time of the attachment version. maxCreationTime is gets or sets the max creation time of the attachment
    // version. minModificationTime is gets or sets the min modification time of the attachment version.
    // maxModificationTime is gets or sets the max modification time of the attachment version. page is gets or sets the
    // page number. pageSize is gets or sets the size of the page. sortOrder is gets or sets the order. sortBy is gets or
    // sets the column to order by.
    func (client BaseClient) GetAttachmentVersionsByFilter(ctx context.Context, drawer int32, ID int32, version *int32, creatorUserID *int32, accessorUserID *int32, minAccessTime *date.Time, maxAccessTime *date.Time, minCreationTime *date.Time, maxCreationTime *date.Time, minModificationTime *date.Time, maxModificationTime *date.Time, page *int32, pageSize *int32, sortOrder string, sortBy string) (result ListAttachmentVersionModel, err error) {
        if err := validation.Validate([]validation.Validation{
        { TargetValue: version,
         Constraints: []validation.Constraint{	{Target: "version", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "version", Name: validation.InclusiveMaximum, Rule: 2147483647, Chain: nil },
        	{Target: "version", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil },
        }}}},
        { TargetValue: creatorUserID,
         Constraints: []validation.Constraint{	{Target: "creatorUserID", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "creatorUserID", Name: validation.InclusiveMaximum, Rule: 2147483647, Chain: nil },
        	{Target: "creatorUserID", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil },
        }}}},
        { TargetValue: accessorUserID,
         Constraints: []validation.Constraint{	{Target: "accessorUserID", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "accessorUserID", Name: validation.InclusiveMaximum, Rule: 2147483647, Chain: nil },
        	{Target: "accessorUserID", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil },
        }}}},
        { TargetValue: page,
         Constraints: []validation.Constraint{	{Target: "page", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "page", Name: validation.InclusiveMaximum, Rule: 2147483647, Chain: nil },
        	{Target: "page", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil },
        }}}},
        { TargetValue: pageSize,
         Constraints: []validation.Constraint{	{Target: "pageSize", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "pageSize", Name: validation.InclusiveMaximum, Rule: 1000, Chain: nil },
        	{Target: "pageSize", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil },
        }}}}}); err != nil {
            return result, validation.NewErrorWithValidationError(err, "softheonenterpriseapiclient.BaseClient","GetAttachmentVersionsByFilter")
        }

        req, err := client.GetAttachmentVersionsByFilterPreparer(ctx, drawer, ID, version, creatorUserID, accessorUserID, minAccessTime, maxAccessTime, minCreationTime, maxCreationTime, minModificationTime, maxModificationTime, page, pageSize, sortOrder, sortBy)
        if err != nil {
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "GetAttachmentVersionsByFilter", nil , "Failure preparing request")
            return
        }

        resp, err := client.GetAttachmentVersionsByFilterSender(req)
        if err != nil {
            result.Response = autorest.Response{Response: resp}
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "GetAttachmentVersionsByFilter", resp, "Failure sending request")
            return
        }

        result, err = client.GetAttachmentVersionsByFilterResponder(resp)
        if err != nil {
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "GetAttachmentVersionsByFilter", resp, "Failure responding to request")
        }

        return
    }

    // GetAttachmentVersionsByFilterPreparer prepares the GetAttachmentVersionsByFilter request.
    func (client BaseClient) GetAttachmentVersionsByFilterPreparer(ctx context.Context, drawer int32, ID int32, version *int32, creatorUserID *int32, accessorUserID *int32, minAccessTime *date.Time, maxAccessTime *date.Time, minCreationTime *date.Time, maxCreationTime *date.Time, minModificationTime *date.Time, maxModificationTime *date.Time, page *int32, pageSize *int32, sortOrder string, sortBy string) (*http.Request, error) {
        pathParameters := map[string]interface{} {
        "drawer": autorest.Encode("path",drawer),
        "id": autorest.Encode("path",ID),
        }

        queryParameters := map[string]interface{} {
        }
        if version != nil {
            queryParameters["version"] = autorest.Encode("query",*version)
        }
        if creatorUserID != nil {
            queryParameters["creatorUserID"] = autorest.Encode("query",*creatorUserID)
        }
        if accessorUserID != nil {
            queryParameters["accessorUserID"] = autorest.Encode("query",*accessorUserID)
        }
        if minAccessTime != nil {
            queryParameters["minAccessTime"] = autorest.Encode("query",*minAccessTime)
        }
        if maxAccessTime != nil {
            queryParameters["maxAccessTime"] = autorest.Encode("query",*maxAccessTime)
        }
        if minCreationTime != nil {
            queryParameters["minCreationTime"] = autorest.Encode("query",*minCreationTime)
        }
        if maxCreationTime != nil {
            queryParameters["maxCreationTime"] = autorest.Encode("query",*maxCreationTime)
        }
        if minModificationTime != nil {
            queryParameters["minModificationTime"] = autorest.Encode("query",*minModificationTime)
        }
        if maxModificationTime != nil {
            queryParameters["maxModificationTime"] = autorest.Encode("query",*maxModificationTime)
        }
        if page != nil {
            queryParameters["page"] = autorest.Encode("query",*page)
        }
        if pageSize != nil {
            queryParameters["pageSize"] = autorest.Encode("query",*pageSize)
        }
        if len(string(sortOrder)) > 0 {
            queryParameters["sortOrder"] = autorest.Encode("query",sortOrder)
        }
        if len(string(sortBy)) > 0 {
            queryParameters["sortBy"] = autorest.Encode("query",sortBy)
        }

        preparer := autorest.CreatePreparer(
            autorest.AsGet(),
            autorest.WithBaseURL(client.BaseURI),
            autorest.WithPathParameters("/v1/content/attachments/{drawer}/{id}/versions",pathParameters),
            autorest.WithQueryParameters(queryParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
    }

    // GetAttachmentVersionsByFilterSender sends the GetAttachmentVersionsByFilter request. The method will close the
    // http.Response Body if it receives an error.
    func (client BaseClient) GetAttachmentVersionsByFilterSender(req *http.Request) (*http.Response, error) {
        return autorest.SendWithSender(client, req,
            autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
    }

    // GetAttachmentVersionsByFilterResponder handles the response to the GetAttachmentVersionsByFilter request. The method always
    // closes the http.Response Body.
    func (client BaseClient) GetAttachmentVersionsByFilterResponder(resp *http.Response) (result ListAttachmentVersionModel, err error) {
        err = autorest.Respond(
            resp,
            client.ByInspecting(),
            azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusNotFound),
            autorest.ByUnmarshallingJSON(&result.Value),
            autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
        return
    }

    // GetDrawerByID sends the get drawer by id request.
    //
    // ID is the drawer identifier.
    func (client BaseClient) GetDrawerByID(ctx context.Context, ID int32) (result DrawerModel, err error) {
        req, err := client.GetDrawerByIDPreparer(ctx, ID)
        if err != nil {
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "GetDrawerByID", nil , "Failure preparing request")
            return
        }

        resp, err := client.GetDrawerByIDSender(req)
        if err != nil {
            result.Response = autorest.Response{Response: resp}
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "GetDrawerByID", resp, "Failure sending request")
            return
        }

        result, err = client.GetDrawerByIDResponder(resp)
        if err != nil {
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "GetDrawerByID", resp, "Failure responding to request")
        }

        return
    }

    // GetDrawerByIDPreparer prepares the GetDrawerByID request.
    func (client BaseClient) GetDrawerByIDPreparer(ctx context.Context, ID int32) (*http.Request, error) {
        pathParameters := map[string]interface{} {
        "id": autorest.Encode("path",ID),
        }

        preparer := autorest.CreatePreparer(
            autorest.AsGet(),
            autorest.WithBaseURL(client.BaseURI),
            autorest.WithPathParameters("/v1/directory/drawers/{id}",pathParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
    }

    // GetDrawerByIDSender sends the GetDrawerByID request. The method will close the
    // http.Response Body if it receives an error.
    func (client BaseClient) GetDrawerByIDSender(req *http.Request) (*http.Response, error) {
        return autorest.SendWithSender(client, req,
            autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
    }

    // GetDrawerByIDResponder handles the response to the GetDrawerByID request. The method always
    // closes the http.Response Body.
    func (client BaseClient) GetDrawerByIDResponder(resp *http.Response) (result DrawerModel, err error) {
        err = autorest.Respond(
            resp,
            client.ByInspecting(),
            azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusNotFound),
            autorest.ByUnmarshallingJSON(&result),
            autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
        return
    }

    // GetDrawerByName sends the get drawer by name request.
    //
    // name is the drawer name.
    func (client BaseClient) GetDrawerByName(ctx context.Context, name string) (result DrawerModel, err error) {
        req, err := client.GetDrawerByNamePreparer(ctx, name)
        if err != nil {
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "GetDrawerByName", nil , "Failure preparing request")
            return
        }

        resp, err := client.GetDrawerByNameSender(req)
        if err != nil {
            result.Response = autorest.Response{Response: resp}
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "GetDrawerByName", resp, "Failure sending request")
            return
        }

        result, err = client.GetDrawerByNameResponder(resp)
        if err != nil {
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "GetDrawerByName", resp, "Failure responding to request")
        }

        return
    }

    // GetDrawerByNamePreparer prepares the GetDrawerByName request.
    func (client BaseClient) GetDrawerByNamePreparer(ctx context.Context, name string) (*http.Request, error) {
        pathParameters := map[string]interface{} {
        "name": autorest.Encode("path",name),
        }

        preparer := autorest.CreatePreparer(
            autorest.AsGet(),
            autorest.WithBaseURL(client.BaseURI),
            autorest.WithPathParameters("/v1/directory/drawers/{name}",pathParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
    }

    // GetDrawerByNameSender sends the GetDrawerByName request. The method will close the
    // http.Response Body if it receives an error.
    func (client BaseClient) GetDrawerByNameSender(req *http.Request) (*http.Response, error) {
        return autorest.SendWithSender(client, req,
            autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
    }

    // GetDrawerByNameResponder handles the response to the GetDrawerByName request. The method always
    // closes the http.Response Body.
    func (client BaseClient) GetDrawerByNameResponder(resp *http.Response) (result DrawerModel, err error) {
        err = autorest.Respond(
            resp,
            client.ByInspecting(),
            azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusNotFound),
            autorest.ByUnmarshallingJSON(&result),
            autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
        return
    }

    // GetDrawerGroupAssociations sends the get drawer group associations request.
    //
    // drawerID is the drawer identifier. groupID is the group identifier. ACL is gets or sets the access control level
    // permissions. page is gets or sets the page number. pageSize is gets or sets the size of the page. sortOrder is gets
    // or sets the order. sortBy is gets or sets the column to order by.
    func (client BaseClient) GetDrawerGroupAssociations(ctx context.Context, drawerID int32, groupID *int32, ACL *int32, page *int32, pageSize *int32, sortOrder string, sortBy string) (result ListGroupDrawerModel, err error) {
        if err := validation.Validate([]validation.Validation{
        { TargetValue: page,
         Constraints: []validation.Constraint{	{Target: "page", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "page", Name: validation.InclusiveMaximum, Rule: 2147483647, Chain: nil },
        	{Target: "page", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil },
        }}}},
        { TargetValue: pageSize,
         Constraints: []validation.Constraint{	{Target: "pageSize", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "pageSize", Name: validation.InclusiveMaximum, Rule: 1000, Chain: nil },
        	{Target: "pageSize", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil },
        }}}}}); err != nil {
            return result, validation.NewErrorWithValidationError(err, "softheonenterpriseapiclient.BaseClient","GetDrawerGroupAssociations")
        }

        req, err := client.GetDrawerGroupAssociationsPreparer(ctx, drawerID, groupID, ACL, page, pageSize, sortOrder, sortBy)
        if err != nil {
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "GetDrawerGroupAssociations", nil , "Failure preparing request")
            return
        }

        resp, err := client.GetDrawerGroupAssociationsSender(req)
        if err != nil {
            result.Response = autorest.Response{Response: resp}
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "GetDrawerGroupAssociations", resp, "Failure sending request")
            return
        }

        result, err = client.GetDrawerGroupAssociationsResponder(resp)
        if err != nil {
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "GetDrawerGroupAssociations", resp, "Failure responding to request")
        }

        return
    }

    // GetDrawerGroupAssociationsPreparer prepares the GetDrawerGroupAssociations request.
    func (client BaseClient) GetDrawerGroupAssociationsPreparer(ctx context.Context, drawerID int32, groupID *int32, ACL *int32, page *int32, pageSize *int32, sortOrder string, sortBy string) (*http.Request, error) {
        pathParameters := map[string]interface{} {
        "drawerID": autorest.Encode("path",drawerID),
        }

        queryParameters := map[string]interface{} {
        }
        if groupID != nil {
            queryParameters["groupID"] = autorest.Encode("query",*groupID)
        }
        if ACL != nil {
            queryParameters["acl"] = autorest.Encode("query",*ACL)
        }
        if page != nil {
            queryParameters["page"] = autorest.Encode("query",*page)
        }
        if pageSize != nil {
            queryParameters["pageSize"] = autorest.Encode("query",*pageSize)
        }
        if len(string(sortOrder)) > 0 {
            queryParameters["sortOrder"] = autorest.Encode("query",sortOrder)
        }
        if len(string(sortBy)) > 0 {
            queryParameters["sortBy"] = autorest.Encode("query",sortBy)
        }

        preparer := autorest.CreatePreparer(
            autorest.AsGet(),
            autorest.WithBaseURL(client.BaseURI),
            autorest.WithPathParameters("/v1/directory/drawers/{drawerID}/groups",pathParameters),
            autorest.WithQueryParameters(queryParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
    }

    // GetDrawerGroupAssociationsSender sends the GetDrawerGroupAssociations request. The method will close the
    // http.Response Body if it receives an error.
    func (client BaseClient) GetDrawerGroupAssociationsSender(req *http.Request) (*http.Response, error) {
        return autorest.SendWithSender(client, req,
            autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
    }

    // GetDrawerGroupAssociationsResponder handles the response to the GetDrawerGroupAssociations request. The method always
    // closes the http.Response Body.
    func (client BaseClient) GetDrawerGroupAssociationsResponder(resp *http.Response) (result ListGroupDrawerModel, err error) {
        err = autorest.Respond(
            resp,
            client.ByInspecting(),
            azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusForbidden),
            autorest.ByUnmarshallingJSON(&result.Value),
            autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
        return
    }

    // GetDrawerUserAssociations sends the get drawer user associations request.
    //
    // drawerID is the drawer identifier. userID is the user identifier. ACL is gets or sets the access control level
    // permissions. page is gets or sets the page number. pageSize is gets or sets the size of the page. sortOrder is gets
    // or sets the order. sortBy is gets or sets the column to order by.
    func (client BaseClient) GetDrawerUserAssociations(ctx context.Context, drawerID int32, userID *int32, ACL *int32, page *int32, pageSize *int32, sortOrder string, sortBy string) (result ListUserDrawerModel, err error) {
        if err := validation.Validate([]validation.Validation{
        { TargetValue: page,
         Constraints: []validation.Constraint{	{Target: "page", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "page", Name: validation.InclusiveMaximum, Rule: 2147483647, Chain: nil },
        	{Target: "page", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil },
        }}}},
        { TargetValue: pageSize,
         Constraints: []validation.Constraint{	{Target: "pageSize", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "pageSize", Name: validation.InclusiveMaximum, Rule: 1000, Chain: nil },
        	{Target: "pageSize", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil },
        }}}}}); err != nil {
            return result, validation.NewErrorWithValidationError(err, "softheonenterpriseapiclient.BaseClient","GetDrawerUserAssociations")
        }

        req, err := client.GetDrawerUserAssociationsPreparer(ctx, drawerID, userID, ACL, page, pageSize, sortOrder, sortBy)
        if err != nil {
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "GetDrawerUserAssociations", nil , "Failure preparing request")
            return
        }

        resp, err := client.GetDrawerUserAssociationsSender(req)
        if err != nil {
            result.Response = autorest.Response{Response: resp}
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "GetDrawerUserAssociations", resp, "Failure sending request")
            return
        }

        result, err = client.GetDrawerUserAssociationsResponder(resp)
        if err != nil {
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "GetDrawerUserAssociations", resp, "Failure responding to request")
        }

        return
    }

    // GetDrawerUserAssociationsPreparer prepares the GetDrawerUserAssociations request.
    func (client BaseClient) GetDrawerUserAssociationsPreparer(ctx context.Context, drawerID int32, userID *int32, ACL *int32, page *int32, pageSize *int32, sortOrder string, sortBy string) (*http.Request, error) {
        pathParameters := map[string]interface{} {
        "drawerID": autorest.Encode("path",drawerID),
        }

        queryParameters := map[string]interface{} {
        }
        if userID != nil {
            queryParameters["userID"] = autorest.Encode("query",*userID)
        }
        if ACL != nil {
            queryParameters["acl"] = autorest.Encode("query",*ACL)
        }
        if page != nil {
            queryParameters["page"] = autorest.Encode("query",*page)
        }
        if pageSize != nil {
            queryParameters["pageSize"] = autorest.Encode("query",*pageSize)
        }
        if len(string(sortOrder)) > 0 {
            queryParameters["sortOrder"] = autorest.Encode("query",sortOrder)
        }
        if len(string(sortBy)) > 0 {
            queryParameters["sortBy"] = autorest.Encode("query",sortBy)
        }

        preparer := autorest.CreatePreparer(
            autorest.AsGet(),
            autorest.WithBaseURL(client.BaseURI),
            autorest.WithPathParameters("/v1/directory/drawers/{drawerID}/users",pathParameters),
            autorest.WithQueryParameters(queryParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
    }

    // GetDrawerUserAssociationsSender sends the GetDrawerUserAssociations request. The method will close the
    // http.Response Body if it receives an error.
    func (client BaseClient) GetDrawerUserAssociationsSender(req *http.Request) (*http.Response, error) {
        return autorest.SendWithSender(client, req,
            autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
    }

    // GetDrawerUserAssociationsResponder handles the response to the GetDrawerUserAssociations request. The method always
    // closes the http.Response Body.
    func (client BaseClient) GetDrawerUserAssociationsResponder(resp *http.Response) (result ListUserDrawerModel, err error) {
        err = autorest.Respond(
            resp,
            client.ByInspecting(),
            azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusForbidden),
            autorest.ByUnmarshallingJSON(&result.Value),
            autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
        return
    }

    // GetEntitiesByFilter sends the get entities by filter request.
    //
    // drawerID is gets or sets the drawer identifier. ACL is gets or sets the access control list. typeParameter is gets
    // or sets the type of the entity. name is gets or sets the name. state is gets or sets the state. referenceCount is
    // gets or sets the reference count. attachCount is gets or sets the attach count. noteCount is gets or sets the note
    // count. ownerUserID is gets or sets the owner user identifier. ownerGroupID is gets or sets the owner group
    // identifier. creatorUserID is gets or sets the creator user identifier. creatorGroupID is gets or sets the creator
    // group identifier. modifierUserID is gets or sets the modifier user identifier. modifierGroupID is gets or sets the
    // modifier group identifier. minCreationTime is gets or sets the minimum creation time. maxCreationTime is gets or
    // sets the maximum creation time. minModificationTime is gets or sets the minimum modification time.
    // maxModificationTime is gets or sets the maximum modification time. page is gets or sets the page number. pageSize is
    // gets or sets the size of the page. sortOrder is gets or sets the order. sortBy is gets or sets the column to order
    // by.
    func (client BaseClient) GetEntitiesByFilter(ctx context.Context, drawerID int32, ACL *int32, typeParameter *int32, name string, state string, referenceCount *int32, attachCount *int32, noteCount *int32, ownerUserID *int32, ownerGroupID *int32, creatorUserID *int32, creatorGroupID *int32, modifierUserID *int32, modifierGroupID *int32, minCreationTime *date.Time, maxCreationTime *date.Time, minModificationTime *date.Time, maxModificationTime *date.Time, page *int32, pageSize *int32, sortOrder string, sortBy string) (result ListGetEntityBaseResponse, err error) {
        if err := validation.Validate([]validation.Validation{
        { TargetValue: drawerID,
         Constraints: []validation.Constraint{	{Target: "drawerID", Name: validation.InclusiveMaximum, Rule: 2147483647, Chain: nil },
        	{Target: "drawerID", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil }}},
        { TargetValue: typeParameter,
         Constraints: []validation.Constraint{	{Target: "typeParameter", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "typeParameter", Name: validation.InclusiveMaximum, Rule: 2147483647, Chain: nil },
        	{Target: "typeParameter", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil },
        }}}},
        { TargetValue: name,
         Constraints: []validation.Constraint{	{Target: "name", Name: validation.MaxLength, Rule: 255, Chain: nil },
        	{Target: "name", Name: validation.MinLength, Rule: 0, Chain: nil }}},
        { TargetValue: referenceCount,
         Constraints: []validation.Constraint{	{Target: "referenceCount", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "referenceCount", Name: validation.InclusiveMaximum, Rule: 2147483647, Chain: nil },
        	{Target: "referenceCount", Name: validation.InclusiveMinimum, Rule: 0, Chain: nil },
        }}}},
        { TargetValue: attachCount,
         Constraints: []validation.Constraint{	{Target: "attachCount", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "attachCount", Name: validation.InclusiveMaximum, Rule: 2147483647, Chain: nil },
        	{Target: "attachCount", Name: validation.InclusiveMinimum, Rule: 0, Chain: nil },
        }}}},
        { TargetValue: noteCount,
         Constraints: []validation.Constraint{	{Target: "noteCount", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "noteCount", Name: validation.InclusiveMaximum, Rule: 2147483647, Chain: nil },
        	{Target: "noteCount", Name: validation.InclusiveMinimum, Rule: 0, Chain: nil },
        }}}},
        { TargetValue: ownerUserID,
         Constraints: []validation.Constraint{	{Target: "ownerUserID", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "ownerUserID", Name: validation.InclusiveMaximum, Rule: 2147483647, Chain: nil },
        	{Target: "ownerUserID", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil },
        }}}},
        { TargetValue: ownerGroupID,
         Constraints: []validation.Constraint{	{Target: "ownerGroupID", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "ownerGroupID", Name: validation.InclusiveMaximum, Rule: 2147483647, Chain: nil },
        	{Target: "ownerGroupID", Name: validation.InclusiveMinimum, Rule: 0, Chain: nil },
        }}}},
        { TargetValue: creatorUserID,
         Constraints: []validation.Constraint{	{Target: "creatorUserID", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "creatorUserID", Name: validation.InclusiveMaximum, Rule: 2147483647, Chain: nil },
        	{Target: "creatorUserID", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil },
        }}}},
        { TargetValue: creatorGroupID,
         Constraints: []validation.Constraint{	{Target: "creatorGroupID", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "creatorGroupID", Name: validation.InclusiveMaximum, Rule: 2147483647, Chain: nil },
        	{Target: "creatorGroupID", Name: validation.InclusiveMinimum, Rule: 0, Chain: nil },
        }}}},
        { TargetValue: modifierUserID,
         Constraints: []validation.Constraint{	{Target: "modifierUserID", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "modifierUserID", Name: validation.InclusiveMaximum, Rule: 2147483647, Chain: nil },
        	{Target: "modifierUserID", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil },
        }}}},
        { TargetValue: modifierGroupID,
         Constraints: []validation.Constraint{	{Target: "modifierGroupID", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "modifierGroupID", Name: validation.InclusiveMaximum, Rule: 2147483647, Chain: nil },
        	{Target: "modifierGroupID", Name: validation.InclusiveMinimum, Rule: 0, Chain: nil },
        }}}},
        { TargetValue: page,
         Constraints: []validation.Constraint{	{Target: "page", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "page", Name: validation.InclusiveMaximum, Rule: 2147483647, Chain: nil },
        	{Target: "page", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil },
        }}}},
        { TargetValue: pageSize,
         Constraints: []validation.Constraint{	{Target: "pageSize", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "pageSize", Name: validation.InclusiveMaximum, Rule: 1000, Chain: nil },
        	{Target: "pageSize", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil },
        }}}}}); err != nil {
            return result, validation.NewErrorWithValidationError(err, "softheonenterpriseapiclient.BaseClient","GetEntitiesByFilter")
        }

        req, err := client.GetEntitiesByFilterPreparer(ctx, drawerID, ACL, typeParameter, name, state, referenceCount, attachCount, noteCount, ownerUserID, ownerGroupID, creatorUserID, creatorGroupID, modifierUserID, modifierGroupID, minCreationTime, maxCreationTime, minModificationTime, maxModificationTime, page, pageSize, sortOrder, sortBy)
        if err != nil {
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "GetEntitiesByFilter", nil , "Failure preparing request")
            return
        }

        resp, err := client.GetEntitiesByFilterSender(req)
        if err != nil {
            result.Response = autorest.Response{Response: resp}
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "GetEntitiesByFilter", resp, "Failure sending request")
            return
        }

        result, err = client.GetEntitiesByFilterResponder(resp)
        if err != nil {
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "GetEntitiesByFilter", resp, "Failure responding to request")
        }

        return
    }

    // GetEntitiesByFilterPreparer prepares the GetEntitiesByFilter request.
    func (client BaseClient) GetEntitiesByFilterPreparer(ctx context.Context, drawerID int32, ACL *int32, typeParameter *int32, name string, state string, referenceCount *int32, attachCount *int32, noteCount *int32, ownerUserID *int32, ownerGroupID *int32, creatorUserID *int32, creatorGroupID *int32, modifierUserID *int32, modifierGroupID *int32, minCreationTime *date.Time, maxCreationTime *date.Time, minModificationTime *date.Time, maxModificationTime *date.Time, page *int32, pageSize *int32, sortOrder string, sortBy string) (*http.Request, error) {
        queryParameters := map[string]interface{} {
        "drawerID": autorest.Encode("query",drawerID),
        }
        if ACL != nil {
            queryParameters["acl"] = autorest.Encode("query",*ACL)
        }
        if typeParameter != nil {
            queryParameters["type"] = autorest.Encode("query",*typeParameter)
        }
        if len(name) > 0 {
            queryParameters["name"] = autorest.Encode("query",name)
        }
        if len(string(state)) > 0 {
            queryParameters["state"] = autorest.Encode("query",state)
        }
        if referenceCount != nil {
            queryParameters["referenceCount"] = autorest.Encode("query",*referenceCount)
        }
        if attachCount != nil {
            queryParameters["attachCount"] = autorest.Encode("query",*attachCount)
        }
        if noteCount != nil {
            queryParameters["noteCount"] = autorest.Encode("query",*noteCount)
        }
        if ownerUserID != nil {
            queryParameters["ownerUserID"] = autorest.Encode("query",*ownerUserID)
        }
        if ownerGroupID != nil {
            queryParameters["ownerGroupID"] = autorest.Encode("query",*ownerGroupID)
        }
        if creatorUserID != nil {
            queryParameters["creatorUserID"] = autorest.Encode("query",*creatorUserID)
        }
        if creatorGroupID != nil {
            queryParameters["creatorGroupID"] = autorest.Encode("query",*creatorGroupID)
        }
        if modifierUserID != nil {
            queryParameters["modifierUserID"] = autorest.Encode("query",*modifierUserID)
        }
        if modifierGroupID != nil {
            queryParameters["modifierGroupID"] = autorest.Encode("query",*modifierGroupID)
        }
        if minCreationTime != nil {
            queryParameters["minCreationTime"] = autorest.Encode("query",*minCreationTime)
        }
        if maxCreationTime != nil {
            queryParameters["maxCreationTime"] = autorest.Encode("query",*maxCreationTime)
        }
        if minModificationTime != nil {
            queryParameters["minModificationTime"] = autorest.Encode("query",*minModificationTime)
        }
        if maxModificationTime != nil {
            queryParameters["maxModificationTime"] = autorest.Encode("query",*maxModificationTime)
        }
        if page != nil {
            queryParameters["page"] = autorest.Encode("query",*page)
        }
        if pageSize != nil {
            queryParameters["pageSize"] = autorest.Encode("query",*pageSize)
        }
        if len(string(sortOrder)) > 0 {
            queryParameters["sortOrder"] = autorest.Encode("query",sortOrder)
        }
        if len(string(sortBy)) > 0 {
            queryParameters["sortBy"] = autorest.Encode("query",sortBy)
        }

        preparer := autorest.CreatePreparer(
            autorest.AsGet(),
            autorest.WithBaseURL(client.BaseURI),
            autorest.WithPath("/v1/content/entities"),
            autorest.WithQueryParameters(queryParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
    }

    // GetEntitiesByFilterSender sends the GetEntitiesByFilter request. The method will close the
    // http.Response Body if it receives an error.
    func (client BaseClient) GetEntitiesByFilterSender(req *http.Request) (*http.Response, error) {
        return autorest.SendWithSender(client, req,
            autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
    }

    // GetEntitiesByFilterResponder handles the response to the GetEntitiesByFilter request. The method always
    // closes the http.Response Body.
    func (client BaseClient) GetEntitiesByFilterResponder(resp *http.Response) (result ListGetEntityBaseResponse, err error) {
        err = autorest.Respond(
            resp,
            client.ByInspecting(),
            azure.WithErrorUnlessStatusCode(http.StatusOK),
            autorest.ByUnmarshallingJSON(&result.Value),
            autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
        return
    }

    // GetEntityByID sends the get entity by id request.
    //
    // drawer is the drawer identifier. ID is the entity identifier.
    func (client BaseClient) GetEntityByID(ctx context.Context, drawer int32, ID int32) (result EntityModel, err error) {
        req, err := client.GetEntityByIDPreparer(ctx, drawer, ID)
        if err != nil {
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "GetEntityByID", nil , "Failure preparing request")
            return
        }

        resp, err := client.GetEntityByIDSender(req)
        if err != nil {
            result.Response = autorest.Response{Response: resp}
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "GetEntityByID", resp, "Failure sending request")
            return
        }

        result, err = client.GetEntityByIDResponder(resp)
        if err != nil {
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "GetEntityByID", resp, "Failure responding to request")
        }

        return
    }

    // GetEntityByIDPreparer prepares the GetEntityByID request.
    func (client BaseClient) GetEntityByIDPreparer(ctx context.Context, drawer int32, ID int32) (*http.Request, error) {
        pathParameters := map[string]interface{} {
        "drawer": autorest.Encode("path",drawer),
        "id": autorest.Encode("path",ID),
        }

        preparer := autorest.CreatePreparer(
            autorest.AsGet(),
            autorest.WithBaseURL(client.BaseURI),
            autorest.WithPathParameters("/v1/content/entities/{drawer}/{id}",pathParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
    }

    // GetEntityByIDSender sends the GetEntityByID request. The method will close the
    // http.Response Body if it receives an error.
    func (client BaseClient) GetEntityByIDSender(req *http.Request) (*http.Response, error) {
        return autorest.SendWithSender(client, req,
            autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
    }

    // GetEntityByIDResponder handles the response to the GetEntityByID request. The method always
    // closes the http.Response Body.
    func (client BaseClient) GetEntityByIDResponder(resp *http.Response) (result EntityModel, err error) {
        err = autorest.Respond(
            resp,
            client.ByInspecting(),
            azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusForbidden,http.StatusNotFound),
            autorest.ByUnmarshallingJSON(&result),
            autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
        return
    }

    // GetEventByID sends the get event by id request.
    //
    // drawer is the drawer identifier. ID is the event identifier.
    func (client BaseClient) GetEventByID(ctx context.Context, drawer int32, ID int32) (result EventModel, err error) {
        req, err := client.GetEventByIDPreparer(ctx, drawer, ID)
        if err != nil {
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "GetEventByID", nil , "Failure preparing request")
            return
        }

        resp, err := client.GetEventByIDSender(req)
        if err != nil {
            result.Response = autorest.Response{Response: resp}
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "GetEventByID", resp, "Failure sending request")
            return
        }

        result, err = client.GetEventByIDResponder(resp)
        if err != nil {
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "GetEventByID", resp, "Failure responding to request")
        }

        return
    }

    // GetEventByIDPreparer prepares the GetEventByID request.
    func (client BaseClient) GetEventByIDPreparer(ctx context.Context, drawer int32, ID int32) (*http.Request, error) {
        pathParameters := map[string]interface{} {
        "drawer": autorest.Encode("path",drawer),
        "id": autorest.Encode("path",ID),
        }

        preparer := autorest.CreatePreparer(
            autorest.AsGet(),
            autorest.WithBaseURL(client.BaseURI),
            autorest.WithPathParameters("/v1/content/events/{drawer}/{id}",pathParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
    }

    // GetEventByIDSender sends the GetEventByID request. The method will close the
    // http.Response Body if it receives an error.
    func (client BaseClient) GetEventByIDSender(req *http.Request) (*http.Response, error) {
        return autorest.SendWithSender(client, req,
            autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
    }

    // GetEventByIDResponder handles the response to the GetEventByID request. The method always
    // closes the http.Response Body.
    func (client BaseClient) GetEventByIDResponder(resp *http.Response) (result EventModel, err error) {
        err = autorest.Respond(
            resp,
            client.ByInspecting(),
            azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusNotFound),
            autorest.ByUnmarshallingJSON(&result),
            autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
        return
    }

    // GetEventsByFilter sends the get events by filter request.
    //
    // drawerID is gets or sets the drawer identifier. entityID is gets or sets the entity identifier. typeParameter is
    // gets or sets the type. minEventTime is gets or sets the minimum event time. maxEventTime is gets or sets the maximum
    // event time. eventUserID is gets or sets the event user identifier. eventGroupID is gets or sets the event group
    // identifier. category is gets or sets the category. class is gets or sets the class. operation is gets or sets the
    // operation. minProcessingTime is gets or sets the minimum processing time. maxProcessingTime is gets or sets the
    // maximum processing time. page is gets or sets the page number. pageSize is gets or sets the size of the page.
    // sortOrder is gets or sets the order. sortBy is gets or sets the column to order by.
    func (client BaseClient) GetEventsByFilter(ctx context.Context, drawerID int32, entityID int32, typeParameter string, minEventTime *date.Time, maxEventTime *date.Time, eventUserID *int32, eventGroupID *int32, category string, class string, operation string, minProcessingTime *int32, maxProcessingTime *int32, page *int32, pageSize *int32, sortOrder string, sortBy string) (result ListEventModel, err error) {
        if err := validation.Validate([]validation.Validation{
        { TargetValue: drawerID,
         Constraints: []validation.Constraint{	{Target: "drawerID", Name: validation.InclusiveMaximum, Rule: 2147483647, Chain: nil },
        	{Target: "drawerID", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil }}},
        { TargetValue: entityID,
         Constraints: []validation.Constraint{	{Target: "entityID", Name: validation.InclusiveMaximum, Rule: 2147483647, Chain: nil },
        	{Target: "entityID", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil }}},
        { TargetValue: eventUserID,
         Constraints: []validation.Constraint{	{Target: "eventUserID", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "eventUserID", Name: validation.InclusiveMaximum, Rule: 2147483647, Chain: nil },
        	{Target: "eventUserID", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil },
        }}}},
        { TargetValue: eventGroupID,
         Constraints: []validation.Constraint{	{Target: "eventGroupID", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "eventGroupID", Name: validation.InclusiveMaximum, Rule: 2147483647, Chain: nil },
        	{Target: "eventGroupID", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil },
        }}}},
        { TargetValue: page,
         Constraints: []validation.Constraint{	{Target: "page", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "page", Name: validation.InclusiveMaximum, Rule: 2147483647, Chain: nil },
        	{Target: "page", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil },
        }}}},
        { TargetValue: pageSize,
         Constraints: []validation.Constraint{	{Target: "pageSize", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "pageSize", Name: validation.InclusiveMaximum, Rule: 1000, Chain: nil },
        	{Target: "pageSize", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil },
        }}}}}); err != nil {
            return result, validation.NewErrorWithValidationError(err, "softheonenterpriseapiclient.BaseClient","GetEventsByFilter")
        }

        req, err := client.GetEventsByFilterPreparer(ctx, drawerID, entityID, typeParameter, minEventTime, maxEventTime, eventUserID, eventGroupID, category, class, operation, minProcessingTime, maxProcessingTime, page, pageSize, sortOrder, sortBy)
        if err != nil {
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "GetEventsByFilter", nil , "Failure preparing request")
            return
        }

        resp, err := client.GetEventsByFilterSender(req)
        if err != nil {
            result.Response = autorest.Response{Response: resp}
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "GetEventsByFilter", resp, "Failure sending request")
            return
        }

        result, err = client.GetEventsByFilterResponder(resp)
        if err != nil {
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "GetEventsByFilter", resp, "Failure responding to request")
        }

        return
    }

    // GetEventsByFilterPreparer prepares the GetEventsByFilter request.
    func (client BaseClient) GetEventsByFilterPreparer(ctx context.Context, drawerID int32, entityID int32, typeParameter string, minEventTime *date.Time, maxEventTime *date.Time, eventUserID *int32, eventGroupID *int32, category string, class string, operation string, minProcessingTime *int32, maxProcessingTime *int32, page *int32, pageSize *int32, sortOrder string, sortBy string) (*http.Request, error) {
        queryParameters := map[string]interface{} {
        "drawerID": autorest.Encode("query",drawerID),
        "entityID": autorest.Encode("query",entityID),
        }
        if len(string(typeParameter)) > 0 {
            queryParameters["type"] = autorest.Encode("query",typeParameter)
        }
        if minEventTime != nil {
            queryParameters["minEventTime"] = autorest.Encode("query",*minEventTime)
        }
        if maxEventTime != nil {
            queryParameters["maxEventTime"] = autorest.Encode("query",*maxEventTime)
        }
        if eventUserID != nil {
            queryParameters["eventUserID"] = autorest.Encode("query",*eventUserID)
        }
        if eventGroupID != nil {
            queryParameters["eventGroupID"] = autorest.Encode("query",*eventGroupID)
        }
        if len(string(category)) > 0 {
            queryParameters["category"] = autorest.Encode("query",category)
        }
        if len(string(class)) > 0 {
            queryParameters["class"] = autorest.Encode("query",class)
        }
        if len(string(operation)) > 0 {
            queryParameters["operation"] = autorest.Encode("query",operation)
        }
        if minProcessingTime != nil {
            queryParameters["minProcessingTime"] = autorest.Encode("query",*minProcessingTime)
        }
        if maxProcessingTime != nil {
            queryParameters["maxProcessingTime"] = autorest.Encode("query",*maxProcessingTime)
        }
        if page != nil {
            queryParameters["page"] = autorest.Encode("query",*page)
        }
        if pageSize != nil {
            queryParameters["pageSize"] = autorest.Encode("query",*pageSize)
        }
        if len(string(sortOrder)) > 0 {
            queryParameters["sortOrder"] = autorest.Encode("query",sortOrder)
        }
        if len(string(sortBy)) > 0 {
            queryParameters["sortBy"] = autorest.Encode("query",sortBy)
        }

        preparer := autorest.CreatePreparer(
            autorest.AsGet(),
            autorest.WithBaseURL(client.BaseURI),
            autorest.WithPath("/v1/content/events"),
            autorest.WithQueryParameters(queryParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
    }

    // GetEventsByFilterSender sends the GetEventsByFilter request. The method will close the
    // http.Response Body if it receives an error.
    func (client BaseClient) GetEventsByFilterSender(req *http.Request) (*http.Response, error) {
        return autorest.SendWithSender(client, req,
            autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
    }

    // GetEventsByFilterResponder handles the response to the GetEventsByFilter request. The method always
    // closes the http.Response Body.
    func (client BaseClient) GetEventsByFilterResponder(resp *http.Response) (result ListEventModel, err error) {
        err = autorest.Respond(
            resp,
            client.ByInspecting(),
            azure.WithErrorUnlessStatusCode(http.StatusOK),
            autorest.ByUnmarshallingJSON(&result.Value),
            autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
        return
    }

    // GetExtensionsByFilter sends the get extensions by filter request.
    //
    // drawerID is gets or sets the drawer identifier. entityID is gets or sets the entity identifier. profileID is gets or
    // sets the profile identifier. ID is gets or sets the extension identifier. typeParameter is gets or sets the type of
    // the extension. page is gets or sets the page number. pageSize is gets or sets the size of the page. sortOrder is
    // gets or sets the order. sortBy is gets or sets the column to order by.
    func (client BaseClient) GetExtensionsByFilter(ctx context.Context, drawerID int32, entityID int32, profileID int32, ID *int32, typeParameter *int32, page *int32, pageSize *int32, sortOrder string, sortBy string) (result ListExtensionModel, err error) {
        if err := validation.Validate([]validation.Validation{
        { TargetValue: drawerID,
         Constraints: []validation.Constraint{	{Target: "drawerID", Name: validation.InclusiveMaximum, Rule: 2147483647, Chain: nil },
        	{Target: "drawerID", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil }}},
        { TargetValue: entityID,
         Constraints: []validation.Constraint{	{Target: "entityID", Name: validation.InclusiveMaximum, Rule: 2147483647, Chain: nil },
        	{Target: "entityID", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil }}},
        { TargetValue: profileID,
         Constraints: []validation.Constraint{	{Target: "profileID", Name: validation.InclusiveMaximum, Rule: 2147483647, Chain: nil },
        	{Target: "profileID", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil }}},
        { TargetValue: ID,
         Constraints: []validation.Constraint{	{Target: "ID", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "ID", Name: validation.InclusiveMaximum, Rule: 2147483647, Chain: nil },
        	{Target: "ID", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil },
        }}}},
        { TargetValue: typeParameter,
         Constraints: []validation.Constraint{	{Target: "typeParameter", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "typeParameter", Name: validation.InclusiveMaximum, Rule: 2147483647, Chain: nil },
        	{Target: "typeParameter", Name: validation.InclusiveMinimum, Rule: 0, Chain: nil },
        }}}},
        { TargetValue: page,
         Constraints: []validation.Constraint{	{Target: "page", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "page", Name: validation.InclusiveMaximum, Rule: 2147483647, Chain: nil },
        	{Target: "page", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil },
        }}}},
        { TargetValue: pageSize,
         Constraints: []validation.Constraint{	{Target: "pageSize", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "pageSize", Name: validation.InclusiveMaximum, Rule: 1000, Chain: nil },
        	{Target: "pageSize", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil },
        }}}}}); err != nil {
            return result, validation.NewErrorWithValidationError(err, "softheonenterpriseapiclient.BaseClient","GetExtensionsByFilter")
        }

        req, err := client.GetExtensionsByFilterPreparer(ctx, drawerID, entityID, profileID, ID, typeParameter, page, pageSize, sortOrder, sortBy)
        if err != nil {
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "GetExtensionsByFilter", nil , "Failure preparing request")
            return
        }

        resp, err := client.GetExtensionsByFilterSender(req)
        if err != nil {
            result.Response = autorest.Response{Response: resp}
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "GetExtensionsByFilter", resp, "Failure sending request")
            return
        }

        result, err = client.GetExtensionsByFilterResponder(resp)
        if err != nil {
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "GetExtensionsByFilter", resp, "Failure responding to request")
        }

        return
    }

    // GetExtensionsByFilterPreparer prepares the GetExtensionsByFilter request.
    func (client BaseClient) GetExtensionsByFilterPreparer(ctx context.Context, drawerID int32, entityID int32, profileID int32, ID *int32, typeParameter *int32, page *int32, pageSize *int32, sortOrder string, sortBy string) (*http.Request, error) {
        queryParameters := map[string]interface{} {
        "drawerID": autorest.Encode("query",drawerID),
        "entityID": autorest.Encode("query",entityID),
        "profileID": autorest.Encode("query",profileID),
        }
        if ID != nil {
            queryParameters["iD"] = autorest.Encode("query",*ID)
        }
        if typeParameter != nil {
            queryParameters["type"] = autorest.Encode("query",*typeParameter)
        }
        if page != nil {
            queryParameters["page"] = autorest.Encode("query",*page)
        }
        if pageSize != nil {
            queryParameters["pageSize"] = autorest.Encode("query",*pageSize)
        }
        if len(string(sortOrder)) > 0 {
            queryParameters["sortOrder"] = autorest.Encode("query",sortOrder)
        }
        if len(string(sortBy)) > 0 {
            queryParameters["sortBy"] = autorest.Encode("query",sortBy)
        }

        preparer := autorest.CreatePreparer(
            autorest.AsGet(),
            autorest.WithBaseURL(client.BaseURI),
            autorest.WithPath("/v1/content/extensions"),
            autorest.WithQueryParameters(queryParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
    }

    // GetExtensionsByFilterSender sends the GetExtensionsByFilter request. The method will close the
    // http.Response Body if it receives an error.
    func (client BaseClient) GetExtensionsByFilterSender(req *http.Request) (*http.Response, error) {
        return autorest.SendWithSender(client, req,
            autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
    }

    // GetExtensionsByFilterResponder handles the response to the GetExtensionsByFilter request. The method always
    // closes the http.Response Body.
    func (client BaseClient) GetExtensionsByFilterResponder(resp *http.Response) (result ListExtensionModel, err error) {
        err = autorest.Respond(
            resp,
            client.ByInspecting(),
            azure.WithErrorUnlessStatusCode(http.StatusOK),
            autorest.ByUnmarshallingJSON(&result.Value),
            autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
        return
    }

    // GetFlowByID sends the get flow by id request.
    //
    // drawer is the drawer identifier. ID is the flow identifier.
    func (client BaseClient) GetFlowByID(ctx context.Context, drawer int32, ID int32) (result FlowModel, err error) {
        req, err := client.GetFlowByIDPreparer(ctx, drawer, ID)
        if err != nil {
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "GetFlowByID", nil , "Failure preparing request")
            return
        }

        resp, err := client.GetFlowByIDSender(req)
        if err != nil {
            result.Response = autorest.Response{Response: resp}
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "GetFlowByID", resp, "Failure sending request")
            return
        }

        result, err = client.GetFlowByIDResponder(resp)
        if err != nil {
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "GetFlowByID", resp, "Failure responding to request")
        }

        return
    }

    // GetFlowByIDPreparer prepares the GetFlowByID request.
    func (client BaseClient) GetFlowByIDPreparer(ctx context.Context, drawer int32, ID int32) (*http.Request, error) {
        pathParameters := map[string]interface{} {
        "drawer": autorest.Encode("path",drawer),
        "id": autorest.Encode("path",ID),
        }

        preparer := autorest.CreatePreparer(
            autorest.AsGet(),
            autorest.WithBaseURL(client.BaseURI),
            autorest.WithPathParameters("/v1/content/flows/{drawer}/{id}",pathParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
    }

    // GetFlowByIDSender sends the GetFlowByID request. The method will close the
    // http.Response Body if it receives an error.
    func (client BaseClient) GetFlowByIDSender(req *http.Request) (*http.Response, error) {
        return autorest.SendWithSender(client, req,
            autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
    }

    // GetFlowByIDResponder handles the response to the GetFlowByID request. The method always
    // closes the http.Response Body.
    func (client BaseClient) GetFlowByIDResponder(resp *http.Response) (result FlowModel, err error) {
        err = autorest.Respond(
            resp,
            client.ByInspecting(),
            azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusNotFound),
            autorest.ByUnmarshallingJSON(&result),
            autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
        return
    }

    // GetFlowsByFilter sends the get flows by filter request.
    //
    // drawerID is gets or sets the drawer identifier. entityID is gets or sets the entity identifier. typeParameter is
    // gets or sets the type. queueID is gets or sets the queue identifier. minWorkflowTime is gets or sets the minimum
    // workflow time. maxWorkflowTime is gets or sets the maximum workflow time. minInsertionTime is gets or sets the
    // minimum insertion time. maxInsertionTime is gets or sets the maximum insertion time. workflowUserID is gets or sets
    // the workflow user identifier. workflowGroupID is gets or sets the workflow group identifier. operation is gets or
    // sets the operation. category is gets or sets the category. status is gets or sets the status. state is gets or sets
    // the state. minIndex1 is gets or sets the minimum index 1. maxIndex1 is gets or sets the maximum index 1. minIndex2
    // is gets or sets the minimum index 2. maxIndex2 is gets or sets the maximum index 2. page is gets or sets the page
    // number. pageSize is gets or sets the size of the page. sortOrder is gets or sets the order. sortBy is gets or sets
    // the column to order by.
    func (client BaseClient) GetFlowsByFilter(ctx context.Context, drawerID int32, entityID int32, typeParameter string, queueID *int32, minWorkflowTime *date.Time, maxWorkflowTime *date.Time, minInsertionTime *date.Time, maxInsertionTime *date.Time, workflowUserID *int32, workflowGroupID *int32, operation string, category string, status string, state string, minIndex1 *int32, maxIndex1 *int32, minIndex2 *int32, maxIndex2 *int32, page *int32, pageSize *int32, sortOrder string, sortBy string) (result ListFlowModel, err error) {
        if err := validation.Validate([]validation.Validation{
        { TargetValue: drawerID,
         Constraints: []validation.Constraint{	{Target: "drawerID", Name: validation.InclusiveMaximum, Rule: 2147483647, Chain: nil },
        	{Target: "drawerID", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil }}},
        { TargetValue: entityID,
         Constraints: []validation.Constraint{	{Target: "entityID", Name: validation.InclusiveMaximum, Rule: 2147483647, Chain: nil },
        	{Target: "entityID", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil }}},
        { TargetValue: queueID,
         Constraints: []validation.Constraint{	{Target: "queueID", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "queueID", Name: validation.InclusiveMaximum, Rule: 2147483647, Chain: nil },
        	{Target: "queueID", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil },
        }}}},
        { TargetValue: workflowUserID,
         Constraints: []validation.Constraint{	{Target: "workflowUserID", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "workflowUserID", Name: validation.InclusiveMaximum, Rule: 2147483647, Chain: nil },
        	{Target: "workflowUserID", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil },
        }}}},
        { TargetValue: workflowGroupID,
         Constraints: []validation.Constraint{	{Target: "workflowGroupID", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "workflowGroupID", Name: validation.InclusiveMaximum, Rule: 2147483647, Chain: nil },
        	{Target: "workflowGroupID", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil },
        }}}},
        { TargetValue: page,
         Constraints: []validation.Constraint{	{Target: "page", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "page", Name: validation.InclusiveMaximum, Rule: 2147483647, Chain: nil },
        	{Target: "page", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil },
        }}}},
        { TargetValue: pageSize,
         Constraints: []validation.Constraint{	{Target: "pageSize", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "pageSize", Name: validation.InclusiveMaximum, Rule: 1000, Chain: nil },
        	{Target: "pageSize", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil },
        }}}}}); err != nil {
            return result, validation.NewErrorWithValidationError(err, "softheonenterpriseapiclient.BaseClient","GetFlowsByFilter")
        }

        req, err := client.GetFlowsByFilterPreparer(ctx, drawerID, entityID, typeParameter, queueID, minWorkflowTime, maxWorkflowTime, minInsertionTime, maxInsertionTime, workflowUserID, workflowGroupID, operation, category, status, state, minIndex1, maxIndex1, minIndex2, maxIndex2, page, pageSize, sortOrder, sortBy)
        if err != nil {
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "GetFlowsByFilter", nil , "Failure preparing request")
            return
        }

        resp, err := client.GetFlowsByFilterSender(req)
        if err != nil {
            result.Response = autorest.Response{Response: resp}
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "GetFlowsByFilter", resp, "Failure sending request")
            return
        }

        result, err = client.GetFlowsByFilterResponder(resp)
        if err != nil {
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "GetFlowsByFilter", resp, "Failure responding to request")
        }

        return
    }

    // GetFlowsByFilterPreparer prepares the GetFlowsByFilter request.
    func (client BaseClient) GetFlowsByFilterPreparer(ctx context.Context, drawerID int32, entityID int32, typeParameter string, queueID *int32, minWorkflowTime *date.Time, maxWorkflowTime *date.Time, minInsertionTime *date.Time, maxInsertionTime *date.Time, workflowUserID *int32, workflowGroupID *int32, operation string, category string, status string, state string, minIndex1 *int32, maxIndex1 *int32, minIndex2 *int32, maxIndex2 *int32, page *int32, pageSize *int32, sortOrder string, sortBy string) (*http.Request, error) {
        queryParameters := map[string]interface{} {
        "drawerID": autorest.Encode("query",drawerID),
        "entityID": autorest.Encode("query",entityID),
        }
        if len(string(typeParameter)) > 0 {
            queryParameters["type"] = autorest.Encode("query",typeParameter)
        }
        if queueID != nil {
            queryParameters["queueID"] = autorest.Encode("query",*queueID)
        }
        if minWorkflowTime != nil {
            queryParameters["minWorkflowTime"] = autorest.Encode("query",*minWorkflowTime)
        }
        if maxWorkflowTime != nil {
            queryParameters["maxWorkflowTime"] = autorest.Encode("query",*maxWorkflowTime)
        }
        if minInsertionTime != nil {
            queryParameters["minInsertionTime"] = autorest.Encode("query",*minInsertionTime)
        }
        if maxInsertionTime != nil {
            queryParameters["maxInsertionTime"] = autorest.Encode("query",*maxInsertionTime)
        }
        if workflowUserID != nil {
            queryParameters["workflowUserID"] = autorest.Encode("query",*workflowUserID)
        }
        if workflowGroupID != nil {
            queryParameters["workflowGroupID"] = autorest.Encode("query",*workflowGroupID)
        }
        if len(string(operation)) > 0 {
            queryParameters["operation"] = autorest.Encode("query",operation)
        }
        if len(string(category)) > 0 {
            queryParameters["category"] = autorest.Encode("query",category)
        }
        if len(string(status)) > 0 {
            queryParameters["status"] = autorest.Encode("query",status)
        }
        if len(string(state)) > 0 {
            queryParameters["state"] = autorest.Encode("query",state)
        }
        if minIndex1 != nil {
            queryParameters["minIndex1"] = autorest.Encode("query",*minIndex1)
        }
        if maxIndex1 != nil {
            queryParameters["maxIndex1"] = autorest.Encode("query",*maxIndex1)
        }
        if minIndex2 != nil {
            queryParameters["minIndex2"] = autorest.Encode("query",*minIndex2)
        }
        if maxIndex2 != nil {
            queryParameters["maxIndex2"] = autorest.Encode("query",*maxIndex2)
        }
        if page != nil {
            queryParameters["page"] = autorest.Encode("query",*page)
        }
        if pageSize != nil {
            queryParameters["pageSize"] = autorest.Encode("query",*pageSize)
        }
        if len(string(sortOrder)) > 0 {
            queryParameters["sortOrder"] = autorest.Encode("query",sortOrder)
        }
        if len(string(sortBy)) > 0 {
            queryParameters["sortBy"] = autorest.Encode("query",sortBy)
        }

        preparer := autorest.CreatePreparer(
            autorest.AsGet(),
            autorest.WithBaseURL(client.BaseURI),
            autorest.WithPath("/v1/content/flows"),
            autorest.WithQueryParameters(queryParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
    }

    // GetFlowsByFilterSender sends the GetFlowsByFilter request. The method will close the
    // http.Response Body if it receives an error.
    func (client BaseClient) GetFlowsByFilterSender(req *http.Request) (*http.Response, error) {
        return autorest.SendWithSender(client, req,
            autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
    }

    // GetFlowsByFilterResponder handles the response to the GetFlowsByFilter request. The method always
    // closes the http.Response Body.
    func (client BaseClient) GetFlowsByFilterResponder(resp *http.Response) (result ListFlowModel, err error) {
        err = autorest.Respond(
            resp,
            client.ByInspecting(),
            azure.WithErrorUnlessStatusCode(http.StatusOK),
            autorest.ByUnmarshallingJSON(&result.Value),
            autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
        return
    }

    // GetGroupApplicationAssociations sends the get group application associations request.
    //
    // groupID is the group identifier. applicationID is the application identifier. ACL is gets or sets the access control
    // level permissions. page is gets or sets the page number. pageSize is gets or sets the size of the page. sortOrder is
    // gets or sets the order. sortBy is gets or sets the column to order by.
    func (client BaseClient) GetGroupApplicationAssociations(ctx context.Context, groupID int32, applicationID *int32, ACL *int32, page *int32, pageSize *int32, sortOrder string, sortBy string) (result ListGroupApplicationModel, err error) {
        if err := validation.Validate([]validation.Validation{
        { TargetValue: page,
         Constraints: []validation.Constraint{	{Target: "page", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "page", Name: validation.InclusiveMaximum, Rule: 2147483647, Chain: nil },
        	{Target: "page", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil },
        }}}},
        { TargetValue: pageSize,
         Constraints: []validation.Constraint{	{Target: "pageSize", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "pageSize", Name: validation.InclusiveMaximum, Rule: 1000, Chain: nil },
        	{Target: "pageSize", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil },
        }}}}}); err != nil {
            return result, validation.NewErrorWithValidationError(err, "softheonenterpriseapiclient.BaseClient","GetGroupApplicationAssociations")
        }

        req, err := client.GetGroupApplicationAssociationsPreparer(ctx, groupID, applicationID, ACL, page, pageSize, sortOrder, sortBy)
        if err != nil {
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "GetGroupApplicationAssociations", nil , "Failure preparing request")
            return
        }

        resp, err := client.GetGroupApplicationAssociationsSender(req)
        if err != nil {
            result.Response = autorest.Response{Response: resp}
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "GetGroupApplicationAssociations", resp, "Failure sending request")
            return
        }

        result, err = client.GetGroupApplicationAssociationsResponder(resp)
        if err != nil {
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "GetGroupApplicationAssociations", resp, "Failure responding to request")
        }

        return
    }

    // GetGroupApplicationAssociationsPreparer prepares the GetGroupApplicationAssociations request.
    func (client BaseClient) GetGroupApplicationAssociationsPreparer(ctx context.Context, groupID int32, applicationID *int32, ACL *int32, page *int32, pageSize *int32, sortOrder string, sortBy string) (*http.Request, error) {
        pathParameters := map[string]interface{} {
        "groupID": autorest.Encode("path",groupID),
        }

        queryParameters := map[string]interface{} {
        }
        if applicationID != nil {
            queryParameters["applicationID"] = autorest.Encode("query",*applicationID)
        }
        if ACL != nil {
            queryParameters["acl"] = autorest.Encode("query",*ACL)
        }
        if page != nil {
            queryParameters["page"] = autorest.Encode("query",*page)
        }
        if pageSize != nil {
            queryParameters["pageSize"] = autorest.Encode("query",*pageSize)
        }
        if len(string(sortOrder)) > 0 {
            queryParameters["sortOrder"] = autorest.Encode("query",sortOrder)
        }
        if len(string(sortBy)) > 0 {
            queryParameters["sortBy"] = autorest.Encode("query",sortBy)
        }

        preparer := autorest.CreatePreparer(
            autorest.AsGet(),
            autorest.WithBaseURL(client.BaseURI),
            autorest.WithPathParameters("/v1/directory/groups/{groupID}/applications",pathParameters),
            autorest.WithQueryParameters(queryParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
    }

    // GetGroupApplicationAssociationsSender sends the GetGroupApplicationAssociations request. The method will close the
    // http.Response Body if it receives an error.
    func (client BaseClient) GetGroupApplicationAssociationsSender(req *http.Request) (*http.Response, error) {
        return autorest.SendWithSender(client, req,
            autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
    }

    // GetGroupApplicationAssociationsResponder handles the response to the GetGroupApplicationAssociations request. The method always
    // closes the http.Response Body.
    func (client BaseClient) GetGroupApplicationAssociationsResponder(resp *http.Response) (result ListGroupApplicationModel, err error) {
        err = autorest.Respond(
            resp,
            client.ByInspecting(),
            azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusForbidden),
            autorest.ByUnmarshallingJSON(&result.Value),
            autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
        return
    }

    // GetGroupByID sends the get group by id request.
    //
    // ID is the group identifier.
    func (client BaseClient) GetGroupByID(ctx context.Context, ID int32) (result GroupModel, err error) {
        req, err := client.GetGroupByIDPreparer(ctx, ID)
        if err != nil {
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "GetGroupByID", nil , "Failure preparing request")
            return
        }

        resp, err := client.GetGroupByIDSender(req)
        if err != nil {
            result.Response = autorest.Response{Response: resp}
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "GetGroupByID", resp, "Failure sending request")
            return
        }

        result, err = client.GetGroupByIDResponder(resp)
        if err != nil {
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "GetGroupByID", resp, "Failure responding to request")
        }

        return
    }

    // GetGroupByIDPreparer prepares the GetGroupByID request.
    func (client BaseClient) GetGroupByIDPreparer(ctx context.Context, ID int32) (*http.Request, error) {
        pathParameters := map[string]interface{} {
        "id": autorest.Encode("path",ID),
        }

        preparer := autorest.CreatePreparer(
            autorest.AsGet(),
            autorest.WithBaseURL(client.BaseURI),
            autorest.WithPathParameters("/v1/directory/groups/{id}",pathParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
    }

    // GetGroupByIDSender sends the GetGroupByID request. The method will close the
    // http.Response Body if it receives an error.
    func (client BaseClient) GetGroupByIDSender(req *http.Request) (*http.Response, error) {
        return autorest.SendWithSender(client, req,
            autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
    }

    // GetGroupByIDResponder handles the response to the GetGroupByID request. The method always
    // closes the http.Response Body.
    func (client BaseClient) GetGroupByIDResponder(resp *http.Response) (result GroupModel, err error) {
        err = autorest.Respond(
            resp,
            client.ByInspecting(),
            azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusForbidden,http.StatusNotFound),
            autorest.ByUnmarshallingJSON(&result),
            autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
        return
    }

    // GetGroupDrawerAssociations sends the get group drawer associations request.
    //
    // groupID is the group identifier. drawerID is the drawer identifier. ACL is gets or sets the access control level
    // permissions. page is gets or sets the page number. pageSize is gets or sets the size of the page. sortOrder is gets
    // or sets the order. sortBy is gets or sets the column to order by.
    func (client BaseClient) GetGroupDrawerAssociations(ctx context.Context, groupID int32, drawerID *int32, ACL *int32, page *int32, pageSize *int32, sortOrder string, sortBy string) (result ListGroupDrawerModel, err error) {
        if err := validation.Validate([]validation.Validation{
        { TargetValue: page,
         Constraints: []validation.Constraint{	{Target: "page", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "page", Name: validation.InclusiveMaximum, Rule: 2147483647, Chain: nil },
        	{Target: "page", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil },
        }}}},
        { TargetValue: pageSize,
         Constraints: []validation.Constraint{	{Target: "pageSize", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "pageSize", Name: validation.InclusiveMaximum, Rule: 1000, Chain: nil },
        	{Target: "pageSize", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil },
        }}}}}); err != nil {
            return result, validation.NewErrorWithValidationError(err, "softheonenterpriseapiclient.BaseClient","GetGroupDrawerAssociations")
        }

        req, err := client.GetGroupDrawerAssociationsPreparer(ctx, groupID, drawerID, ACL, page, pageSize, sortOrder, sortBy)
        if err != nil {
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "GetGroupDrawerAssociations", nil , "Failure preparing request")
            return
        }

        resp, err := client.GetGroupDrawerAssociationsSender(req)
        if err != nil {
            result.Response = autorest.Response{Response: resp}
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "GetGroupDrawerAssociations", resp, "Failure sending request")
            return
        }

        result, err = client.GetGroupDrawerAssociationsResponder(resp)
        if err != nil {
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "GetGroupDrawerAssociations", resp, "Failure responding to request")
        }

        return
    }

    // GetGroupDrawerAssociationsPreparer prepares the GetGroupDrawerAssociations request.
    func (client BaseClient) GetGroupDrawerAssociationsPreparer(ctx context.Context, groupID int32, drawerID *int32, ACL *int32, page *int32, pageSize *int32, sortOrder string, sortBy string) (*http.Request, error) {
        pathParameters := map[string]interface{} {
        "groupID": autorest.Encode("path",groupID),
        }

        queryParameters := map[string]interface{} {
        }
        if drawerID != nil {
            queryParameters["drawerID"] = autorest.Encode("query",*drawerID)
        }
        if ACL != nil {
            queryParameters["acl"] = autorest.Encode("query",*ACL)
        }
        if page != nil {
            queryParameters["page"] = autorest.Encode("query",*page)
        }
        if pageSize != nil {
            queryParameters["pageSize"] = autorest.Encode("query",*pageSize)
        }
        if len(string(sortOrder)) > 0 {
            queryParameters["sortOrder"] = autorest.Encode("query",sortOrder)
        }
        if len(string(sortBy)) > 0 {
            queryParameters["sortBy"] = autorest.Encode("query",sortBy)
        }

        preparer := autorest.CreatePreparer(
            autorest.AsGet(),
            autorest.WithBaseURL(client.BaseURI),
            autorest.WithPathParameters("/v1/directory/groups/{groupID}/drawers",pathParameters),
            autorest.WithQueryParameters(queryParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
    }

    // GetGroupDrawerAssociationsSender sends the GetGroupDrawerAssociations request. The method will close the
    // http.Response Body if it receives an error.
    func (client BaseClient) GetGroupDrawerAssociationsSender(req *http.Request) (*http.Response, error) {
        return autorest.SendWithSender(client, req,
            autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
    }

    // GetGroupDrawerAssociationsResponder handles the response to the GetGroupDrawerAssociations request. The method always
    // closes the http.Response Body.
    func (client BaseClient) GetGroupDrawerAssociationsResponder(resp *http.Response) (result ListGroupDrawerModel, err error) {
        err = autorest.Respond(
            resp,
            client.ByInspecting(),
            azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusForbidden),
            autorest.ByUnmarshallingJSON(&result.Value),
            autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
        return
    }

    // GetGroupQueueAssociations sends the get group queue associations request.
    //
    // groupID is the group identifier. queueID is the queue identifier. ACL is gets or sets the access control level
    // permissions. page is gets or sets the page number. pageSize is gets or sets the size of the page. sortOrder is gets
    // or sets the order. sortBy is gets or sets the column to order by.
    func (client BaseClient) GetGroupQueueAssociations(ctx context.Context, groupID int32, queueID *int32, ACL *int32, page *int32, pageSize *int32, sortOrder string, sortBy string) (result ListGroupQueueModel, err error) {
        if err := validation.Validate([]validation.Validation{
        { TargetValue: page,
         Constraints: []validation.Constraint{	{Target: "page", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "page", Name: validation.InclusiveMaximum, Rule: 2147483647, Chain: nil },
        	{Target: "page", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil },
        }}}},
        { TargetValue: pageSize,
         Constraints: []validation.Constraint{	{Target: "pageSize", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "pageSize", Name: validation.InclusiveMaximum, Rule: 1000, Chain: nil },
        	{Target: "pageSize", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil },
        }}}}}); err != nil {
            return result, validation.NewErrorWithValidationError(err, "softheonenterpriseapiclient.BaseClient","GetGroupQueueAssociations")
        }

        req, err := client.GetGroupQueueAssociationsPreparer(ctx, groupID, queueID, ACL, page, pageSize, sortOrder, sortBy)
        if err != nil {
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "GetGroupQueueAssociations", nil , "Failure preparing request")
            return
        }

        resp, err := client.GetGroupQueueAssociationsSender(req)
        if err != nil {
            result.Response = autorest.Response{Response: resp}
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "GetGroupQueueAssociations", resp, "Failure sending request")
            return
        }

        result, err = client.GetGroupQueueAssociationsResponder(resp)
        if err != nil {
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "GetGroupQueueAssociations", resp, "Failure responding to request")
        }

        return
    }

    // GetGroupQueueAssociationsPreparer prepares the GetGroupQueueAssociations request.
    func (client BaseClient) GetGroupQueueAssociationsPreparer(ctx context.Context, groupID int32, queueID *int32, ACL *int32, page *int32, pageSize *int32, sortOrder string, sortBy string) (*http.Request, error) {
        pathParameters := map[string]interface{} {
        "groupID": autorest.Encode("path",groupID),
        }

        queryParameters := map[string]interface{} {
        }
        if queueID != nil {
            queryParameters["queueID"] = autorest.Encode("query",*queueID)
        }
        if ACL != nil {
            queryParameters["acl"] = autorest.Encode("query",*ACL)
        }
        if page != nil {
            queryParameters["page"] = autorest.Encode("query",*page)
        }
        if pageSize != nil {
            queryParameters["pageSize"] = autorest.Encode("query",*pageSize)
        }
        if len(string(sortOrder)) > 0 {
            queryParameters["sortOrder"] = autorest.Encode("query",sortOrder)
        }
        if len(string(sortBy)) > 0 {
            queryParameters["sortBy"] = autorest.Encode("query",sortBy)
        }

        preparer := autorest.CreatePreparer(
            autorest.AsGet(),
            autorest.WithBaseURL(client.BaseURI),
            autorest.WithPathParameters("/v1/directory/groups/{groupID}/queues",pathParameters),
            autorest.WithQueryParameters(queryParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
    }

    // GetGroupQueueAssociationsSender sends the GetGroupQueueAssociations request. The method will close the
    // http.Response Body if it receives an error.
    func (client BaseClient) GetGroupQueueAssociationsSender(req *http.Request) (*http.Response, error) {
        return autorest.SendWithSender(client, req,
            autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
    }

    // GetGroupQueueAssociationsResponder handles the response to the GetGroupQueueAssociations request. The method always
    // closes the http.Response Body.
    func (client BaseClient) GetGroupQueueAssociationsResponder(resp *http.Response) (result ListGroupQueueModel, err error) {
        err = autorest.Respond(
            resp,
            client.ByInspecting(),
            azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusForbidden),
            autorest.ByUnmarshallingJSON(&result.Value),
            autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
        return
    }

    // GetGroupsByFilter sends the get groups by filter request.
    //
    // ID is gets or sets the group identifier. userID is gets or sets the user identifier. name is gets or sets the name.
    // typeParameter is gets or sets the type. state is gets or sets the state. page is gets or sets the page number.
    // pageSize is gets or sets the size of the page. sortOrder is gets or sets the order. sortBy is gets or sets the
    // column to order by.
    func (client BaseClient) GetGroupsByFilter(ctx context.Context, ID *int32, userID *int32, name string, typeParameter string, state string, page *int32, pageSize *int32, sortOrder string, sortBy string) (result ListGroupModel, err error) {
        if err := validation.Validate([]validation.Validation{
        { TargetValue: ID,
         Constraints: []validation.Constraint{	{Target: "ID", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "ID", Name: validation.InclusiveMaximum, Rule: 2147483647, Chain: nil },
        	{Target: "ID", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil },
        }}}},
        { TargetValue: userID,
         Constraints: []validation.Constraint{	{Target: "userID", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "userID", Name: validation.InclusiveMaximum, Rule: 2147483647, Chain: nil },
        	{Target: "userID", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil },
        }}}},
        { TargetValue: name,
         Constraints: []validation.Constraint{	{Target: "name", Name: validation.MaxLength, Rule: 255, Chain: nil },
        	{Target: "name", Name: validation.MinLength, Rule: 0, Chain: nil }}},
        { TargetValue: page,
         Constraints: []validation.Constraint{	{Target: "page", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "page", Name: validation.InclusiveMaximum, Rule: 2147483647, Chain: nil },
        	{Target: "page", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil },
        }}}},
        { TargetValue: pageSize,
         Constraints: []validation.Constraint{	{Target: "pageSize", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "pageSize", Name: validation.InclusiveMaximum, Rule: 1000, Chain: nil },
        	{Target: "pageSize", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil },
        }}}}}); err != nil {
            return result, validation.NewErrorWithValidationError(err, "softheonenterpriseapiclient.BaseClient","GetGroupsByFilter")
        }

        req, err := client.GetGroupsByFilterPreparer(ctx, ID, userID, name, typeParameter, state, page, pageSize, sortOrder, sortBy)
        if err != nil {
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "GetGroupsByFilter", nil , "Failure preparing request")
            return
        }

        resp, err := client.GetGroupsByFilterSender(req)
        if err != nil {
            result.Response = autorest.Response{Response: resp}
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "GetGroupsByFilter", resp, "Failure sending request")
            return
        }

        result, err = client.GetGroupsByFilterResponder(resp)
        if err != nil {
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "GetGroupsByFilter", resp, "Failure responding to request")
        }

        return
    }

    // GetGroupsByFilterPreparer prepares the GetGroupsByFilter request.
    func (client BaseClient) GetGroupsByFilterPreparer(ctx context.Context, ID *int32, userID *int32, name string, typeParameter string, state string, page *int32, pageSize *int32, sortOrder string, sortBy string) (*http.Request, error) {
        queryParameters := map[string]interface{} {
        }
        if ID != nil {
            queryParameters["iD"] = autorest.Encode("query",*ID)
        }
        if userID != nil {
            queryParameters["userID"] = autorest.Encode("query",*userID)
        }
        if len(name) > 0 {
            queryParameters["name"] = autorest.Encode("query",name)
        }
        if len(string(typeParameter)) > 0 {
            queryParameters["type"] = autorest.Encode("query",typeParameter)
        }
        if len(string(state)) > 0 {
            queryParameters["state"] = autorest.Encode("query",state)
        }
        if page != nil {
            queryParameters["page"] = autorest.Encode("query",*page)
        }
        if pageSize != nil {
            queryParameters["pageSize"] = autorest.Encode("query",*pageSize)
        }
        if len(string(sortOrder)) > 0 {
            queryParameters["sortOrder"] = autorest.Encode("query",sortOrder)
        }
        if len(string(sortBy)) > 0 {
            queryParameters["sortBy"] = autorest.Encode("query",sortBy)
        }

        preparer := autorest.CreatePreparer(
            autorest.AsGet(),
            autorest.WithBaseURL(client.BaseURI),
            autorest.WithPath("/v1/directory/groups"),
            autorest.WithQueryParameters(queryParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
    }

    // GetGroupsByFilterSender sends the GetGroupsByFilter request. The method will close the
    // http.Response Body if it receives an error.
    func (client BaseClient) GetGroupsByFilterSender(req *http.Request) (*http.Response, error) {
        return autorest.SendWithSender(client, req,
            autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
    }

    // GetGroupsByFilterResponder handles the response to the GetGroupsByFilter request. The method always
    // closes the http.Response Body.
    func (client BaseClient) GetGroupsByFilterResponder(resp *http.Response) (result ListGroupModel, err error) {
        err = autorest.Respond(
            resp,
            client.ByInspecting(),
            azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusForbidden),
            autorest.ByUnmarshallingJSON(&result.Value),
            autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
        return
    }

    // GetGroupUserAssociations sends the get group user associations request.
    //
    // groupID is the group identifier. userID is the user identifier. ACL is gets or sets the access control level
    // permissions. page is gets or sets the page number. pageSize is gets or sets the size of the page. sortOrder is gets
    // or sets the order. sortBy is gets or sets the column to order by.
    func (client BaseClient) GetGroupUserAssociations(ctx context.Context, groupID int32, userID *int32, ACL *int32, page *int32, pageSize *int32, sortOrder string, sortBy string) (result ListGroupUserModel, err error) {
        if err := validation.Validate([]validation.Validation{
        { TargetValue: page,
         Constraints: []validation.Constraint{	{Target: "page", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "page", Name: validation.InclusiveMaximum, Rule: 2147483647, Chain: nil },
        	{Target: "page", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil },
        }}}},
        { TargetValue: pageSize,
         Constraints: []validation.Constraint{	{Target: "pageSize", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "pageSize", Name: validation.InclusiveMaximum, Rule: 1000, Chain: nil },
        	{Target: "pageSize", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil },
        }}}}}); err != nil {
            return result, validation.NewErrorWithValidationError(err, "softheonenterpriseapiclient.BaseClient","GetGroupUserAssociations")
        }

        req, err := client.GetGroupUserAssociationsPreparer(ctx, groupID, userID, ACL, page, pageSize, sortOrder, sortBy)
        if err != nil {
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "GetGroupUserAssociations", nil , "Failure preparing request")
            return
        }

        resp, err := client.GetGroupUserAssociationsSender(req)
        if err != nil {
            result.Response = autorest.Response{Response: resp}
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "GetGroupUserAssociations", resp, "Failure sending request")
            return
        }

        result, err = client.GetGroupUserAssociationsResponder(resp)
        if err != nil {
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "GetGroupUserAssociations", resp, "Failure responding to request")
        }

        return
    }

    // GetGroupUserAssociationsPreparer prepares the GetGroupUserAssociations request.
    func (client BaseClient) GetGroupUserAssociationsPreparer(ctx context.Context, groupID int32, userID *int32, ACL *int32, page *int32, pageSize *int32, sortOrder string, sortBy string) (*http.Request, error) {
        pathParameters := map[string]interface{} {
        "groupID": autorest.Encode("path",groupID),
        }

        queryParameters := map[string]interface{} {
        }
        if userID != nil {
            queryParameters["userID"] = autorest.Encode("query",*userID)
        }
        if ACL != nil {
            queryParameters["acl"] = autorest.Encode("query",*ACL)
        }
        if page != nil {
            queryParameters["page"] = autorest.Encode("query",*page)
        }
        if pageSize != nil {
            queryParameters["pageSize"] = autorest.Encode("query",*pageSize)
        }
        if len(string(sortOrder)) > 0 {
            queryParameters["sortOrder"] = autorest.Encode("query",sortOrder)
        }
        if len(string(sortBy)) > 0 {
            queryParameters["sortBy"] = autorest.Encode("query",sortBy)
        }

        preparer := autorest.CreatePreparer(
            autorest.AsGet(),
            autorest.WithBaseURL(client.BaseURI),
            autorest.WithPathParameters("/v1/directory/groups/{groupID}/users",pathParameters),
            autorest.WithQueryParameters(queryParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
    }

    // GetGroupUserAssociationsSender sends the GetGroupUserAssociations request. The method will close the
    // http.Response Body if it receives an error.
    func (client BaseClient) GetGroupUserAssociationsSender(req *http.Request) (*http.Response, error) {
        return autorest.SendWithSender(client, req,
            autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
    }

    // GetGroupUserAssociationsResponder handles the response to the GetGroupUserAssociations request. The method always
    // closes the http.Response Body.
    func (client BaseClient) GetGroupUserAssociationsResponder(resp *http.Response) (result ListGroupUserModel, err error) {
        err = autorest.Respond(
            resp,
            client.ByInspecting(),
            azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusForbidden),
            autorest.ByUnmarshallingJSON(&result.Value),
            autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
        return
    }

    // GetLinkByID sends the get link by id request.
    //
    // drawer is the drawer identifier. ID is the link identifier.
    func (client BaseClient) GetLinkByID(ctx context.Context, drawer int32, ID int32) (result EntityLinkModel, err error) {
        req, err := client.GetLinkByIDPreparer(ctx, drawer, ID)
        if err != nil {
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "GetLinkByID", nil , "Failure preparing request")
            return
        }

        resp, err := client.GetLinkByIDSender(req)
        if err != nil {
            result.Response = autorest.Response{Response: resp}
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "GetLinkByID", resp, "Failure sending request")
            return
        }

        result, err = client.GetLinkByIDResponder(resp)
        if err != nil {
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "GetLinkByID", resp, "Failure responding to request")
        }

        return
    }

    // GetLinkByIDPreparer prepares the GetLinkByID request.
    func (client BaseClient) GetLinkByIDPreparer(ctx context.Context, drawer int32, ID int32) (*http.Request, error) {
        pathParameters := map[string]interface{} {
        "drawer": autorest.Encode("path",drawer),
        "id": autorest.Encode("path",ID),
        }

        preparer := autorest.CreatePreparer(
            autorest.AsGet(),
            autorest.WithBaseURL(client.BaseURI),
            autorest.WithPathParameters("/v1/content/links/{drawer}/{id}",pathParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
    }

    // GetLinkByIDSender sends the GetLinkByID request. The method will close the
    // http.Response Body if it receives an error.
    func (client BaseClient) GetLinkByIDSender(req *http.Request) (*http.Response, error) {
        return autorest.SendWithSender(client, req,
            autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
    }

    // GetLinkByIDResponder handles the response to the GetLinkByID request. The method always
    // closes the http.Response Body.
    func (client BaseClient) GetLinkByIDResponder(resp *http.Response) (result EntityLinkModel, err error) {
        err = autorest.Respond(
            resp,
            client.ByInspecting(),
            azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusForbidden,http.StatusNotFound),
            autorest.ByUnmarshallingJSON(&result),
            autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
        return
    }

    // GetLinksByFilter sends the get links by filter request.
    //
    // childEntityID is gets or sets the child entity identifier. childDrawerID is gets or sets the child drawer
    // identifier. childType is gets or sets the type of the child. ACL is gets or sets the access control list. entityID
    // is gets or sets the entity identifier. drawerID is gets or sets the drawer identifier. name is gets or sets the
    // name. creatorUserID is gets or sets the creator user identifier. modifierUserID is gets or sets the modifier user
    // identifier. minInsertionTime is gets or sets the minimum insertion time. maxInsertionTime is gets or sets the
    // maximum insertion time. minModificationTime is gets or sets the minimum modification time. maxModificationTime is
    // gets or sets the maximum modification time. page is gets or sets the page number. pageSize is gets or sets the size
    // of the page. sortOrder is gets or sets the order. sortBy is gets or sets the column to order by.
    func (client BaseClient) GetLinksByFilter(ctx context.Context, childEntityID *int32, childDrawerID *int32, childType *int32, ACL *int32, entityID *int32, drawerID *int32, name string, creatorUserID *int32, modifierUserID *int32, minInsertionTime *date.Time, maxInsertionTime *date.Time, minModificationTime *date.Time, maxModificationTime *date.Time, page *int32, pageSize *int32, sortOrder string, sortBy string) (result ListEntityLinkModel, err error) {
        if err := validation.Validate([]validation.Validation{
        { TargetValue: childEntityID,
         Constraints: []validation.Constraint{	{Target: "childEntityID", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "childEntityID", Name: validation.InclusiveMaximum, Rule: 2147483647, Chain: nil },
        	{Target: "childEntityID", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil },
        }}}},
        { TargetValue: childDrawerID,
         Constraints: []validation.Constraint{	{Target: "childDrawerID", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "childDrawerID", Name: validation.InclusiveMaximum, Rule: 2147483647, Chain: nil },
        	{Target: "childDrawerID", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil },
        }}}},
        { TargetValue: childType,
         Constraints: []validation.Constraint{	{Target: "childType", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "childType", Name: validation.InclusiveMaximum, Rule: 2147483647, Chain: nil },
        	{Target: "childType", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil },
        }}}},
        { TargetValue: entityID,
         Constraints: []validation.Constraint{	{Target: "entityID", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "entityID", Name: validation.InclusiveMaximum, Rule: 2147483647, Chain: nil },
        	{Target: "entityID", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil },
        }}}},
        { TargetValue: drawerID,
         Constraints: []validation.Constraint{	{Target: "drawerID", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "drawerID", Name: validation.InclusiveMaximum, Rule: 2147483647, Chain: nil },
        	{Target: "drawerID", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil },
        }}}},
        { TargetValue: name,
         Constraints: []validation.Constraint{	{Target: "name", Name: validation.MaxLength, Rule: 255, Chain: nil },
        	{Target: "name", Name: validation.MinLength, Rule: 0, Chain: nil }}},
        { TargetValue: creatorUserID,
         Constraints: []validation.Constraint{	{Target: "creatorUserID", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "creatorUserID", Name: validation.InclusiveMaximum, Rule: 2147483647, Chain: nil },
        	{Target: "creatorUserID", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil },
        }}}},
        { TargetValue: modifierUserID,
         Constraints: []validation.Constraint{	{Target: "modifierUserID", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "modifierUserID", Name: validation.InclusiveMaximum, Rule: 2147483647, Chain: nil },
        	{Target: "modifierUserID", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil },
        }}}},
        { TargetValue: page,
         Constraints: []validation.Constraint{	{Target: "page", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "page", Name: validation.InclusiveMaximum, Rule: 2147483647, Chain: nil },
        	{Target: "page", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil },
        }}}},
        { TargetValue: pageSize,
         Constraints: []validation.Constraint{	{Target: "pageSize", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "pageSize", Name: validation.InclusiveMaximum, Rule: 1000, Chain: nil },
        	{Target: "pageSize", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil },
        }}}}}); err != nil {
            return result, validation.NewErrorWithValidationError(err, "softheonenterpriseapiclient.BaseClient","GetLinksByFilter")
        }

        req, err := client.GetLinksByFilterPreparer(ctx, childEntityID, childDrawerID, childType, ACL, entityID, drawerID, name, creatorUserID, modifierUserID, minInsertionTime, maxInsertionTime, minModificationTime, maxModificationTime, page, pageSize, sortOrder, sortBy)
        if err != nil {
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "GetLinksByFilter", nil , "Failure preparing request")
            return
        }

        resp, err := client.GetLinksByFilterSender(req)
        if err != nil {
            result.Response = autorest.Response{Response: resp}
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "GetLinksByFilter", resp, "Failure sending request")
            return
        }

        result, err = client.GetLinksByFilterResponder(resp)
        if err != nil {
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "GetLinksByFilter", resp, "Failure responding to request")
        }

        return
    }

    // GetLinksByFilterPreparer prepares the GetLinksByFilter request.
    func (client BaseClient) GetLinksByFilterPreparer(ctx context.Context, childEntityID *int32, childDrawerID *int32, childType *int32, ACL *int32, entityID *int32, drawerID *int32, name string, creatorUserID *int32, modifierUserID *int32, minInsertionTime *date.Time, maxInsertionTime *date.Time, minModificationTime *date.Time, maxModificationTime *date.Time, page *int32, pageSize *int32, sortOrder string, sortBy string) (*http.Request, error) {
        queryParameters := map[string]interface{} {
        }
        if childEntityID != nil {
            queryParameters["childEntityID"] = autorest.Encode("query",*childEntityID)
        }
        if childDrawerID != nil {
            queryParameters["childDrawerID"] = autorest.Encode("query",*childDrawerID)
        }
        if childType != nil {
            queryParameters["childType"] = autorest.Encode("query",*childType)
        }
        if ACL != nil {
            queryParameters["acl"] = autorest.Encode("query",*ACL)
        }
        if entityID != nil {
            queryParameters["entityID"] = autorest.Encode("query",*entityID)
        }
        if drawerID != nil {
            queryParameters["drawerID"] = autorest.Encode("query",*drawerID)
        }
        if len(name) > 0 {
            queryParameters["name"] = autorest.Encode("query",name)
        }
        if creatorUserID != nil {
            queryParameters["creatorUserID"] = autorest.Encode("query",*creatorUserID)
        }
        if modifierUserID != nil {
            queryParameters["modifierUserID"] = autorest.Encode("query",*modifierUserID)
        }
        if minInsertionTime != nil {
            queryParameters["minInsertionTime"] = autorest.Encode("query",*minInsertionTime)
        }
        if maxInsertionTime != nil {
            queryParameters["maxInsertionTime"] = autorest.Encode("query",*maxInsertionTime)
        }
        if minModificationTime != nil {
            queryParameters["minModificationTime"] = autorest.Encode("query",*minModificationTime)
        }
        if maxModificationTime != nil {
            queryParameters["maxModificationTime"] = autorest.Encode("query",*maxModificationTime)
        }
        if page != nil {
            queryParameters["page"] = autorest.Encode("query",*page)
        }
        if pageSize != nil {
            queryParameters["pageSize"] = autorest.Encode("query",*pageSize)
        }
        if len(string(sortOrder)) > 0 {
            queryParameters["sortOrder"] = autorest.Encode("query",sortOrder)
        }
        if len(string(sortBy)) > 0 {
            queryParameters["sortBy"] = autorest.Encode("query",sortBy)
        }

        preparer := autorest.CreatePreparer(
            autorest.AsGet(),
            autorest.WithBaseURL(client.BaseURI),
            autorest.WithPath("/v1/content/links"),
            autorest.WithQueryParameters(queryParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
    }

    // GetLinksByFilterSender sends the GetLinksByFilter request. The method will close the
    // http.Response Body if it receives an error.
    func (client BaseClient) GetLinksByFilterSender(req *http.Request) (*http.Response, error) {
        return autorest.SendWithSender(client, req,
            autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
    }

    // GetLinksByFilterResponder handles the response to the GetLinksByFilter request. The method always
    // closes the http.Response Body.
    func (client BaseClient) GetLinksByFilterResponder(resp *http.Response) (result ListEntityLinkModel, err error) {
        err = autorest.Respond(
            resp,
            client.ByInspecting(),
            azure.WithErrorUnlessStatusCode(http.StatusOK),
            autorest.ByUnmarshallingJSON(&result.Value),
            autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
        return
    }

    // GetLocksByFilter sends the get locks by filter request.
    //
    // drawer is the drawer identifier. ID is the entity identifier.
    func (client BaseClient) GetLocksByFilter(ctx context.Context, drawer int32, ID int32) (result LockModel, err error) {
        req, err := client.GetLocksByFilterPreparer(ctx, drawer, ID)
        if err != nil {
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "GetLocksByFilter", nil , "Failure preparing request")
            return
        }

        resp, err := client.GetLocksByFilterSender(req)
        if err != nil {
            result.Response = autorest.Response{Response: resp}
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "GetLocksByFilter", resp, "Failure sending request")
            return
        }

        result, err = client.GetLocksByFilterResponder(resp)
        if err != nil {
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "GetLocksByFilter", resp, "Failure responding to request")
        }

        return
    }

    // GetLocksByFilterPreparer prepares the GetLocksByFilter request.
    func (client BaseClient) GetLocksByFilterPreparer(ctx context.Context, drawer int32, ID int32) (*http.Request, error) {
        pathParameters := map[string]interface{} {
        "drawer": autorest.Encode("path",drawer),
        "id": autorest.Encode("path",ID),
        }

        preparer := autorest.CreatePreparer(
            autorest.AsGet(),
            autorest.WithBaseURL(client.BaseURI),
            autorest.WithPathParameters("/v1/content/entities/{drawer}/{id}/locks",pathParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
    }

    // GetLocksByFilterSender sends the GetLocksByFilter request. The method will close the
    // http.Response Body if it receives an error.
    func (client BaseClient) GetLocksByFilterSender(req *http.Request) (*http.Response, error) {
        return autorest.SendWithSender(client, req,
            autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
    }

    // GetLocksByFilterResponder handles the response to the GetLocksByFilter request. The method always
    // closes the http.Response Body.
    func (client BaseClient) GetLocksByFilterResponder(resp *http.Response) (result LockModel, err error) {
        err = autorest.Respond(
            resp,
            client.ByInspecting(),
            azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusNotFound),
            autorest.ByUnmarshallingJSON(&result),
            autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
        return
    }

    // GetNoteByID sends the get note by id request.
    //
    // drawer is the drawer identifier. ID is the note identifier.
    func (client BaseClient) GetNoteByID(ctx context.Context, drawer int32, ID int32) (result NoteModel, err error) {
        req, err := client.GetNoteByIDPreparer(ctx, drawer, ID)
        if err != nil {
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "GetNoteByID", nil , "Failure preparing request")
            return
        }

        resp, err := client.GetNoteByIDSender(req)
        if err != nil {
            result.Response = autorest.Response{Response: resp}
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "GetNoteByID", resp, "Failure sending request")
            return
        }

        result, err = client.GetNoteByIDResponder(resp)
        if err != nil {
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "GetNoteByID", resp, "Failure responding to request")
        }

        return
    }

    // GetNoteByIDPreparer prepares the GetNoteByID request.
    func (client BaseClient) GetNoteByIDPreparer(ctx context.Context, drawer int32, ID int32) (*http.Request, error) {
        pathParameters := map[string]interface{} {
        "drawer": autorest.Encode("path",drawer),
        "id": autorest.Encode("path",ID),
        }

        preparer := autorest.CreatePreparer(
            autorest.AsGet(),
            autorest.WithBaseURL(client.BaseURI),
            autorest.WithPathParameters("/v1/content/notes/{drawer}/{id}",pathParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
    }

    // GetNoteByIDSender sends the GetNoteByID request. The method will close the
    // http.Response Body if it receives an error.
    func (client BaseClient) GetNoteByIDSender(req *http.Request) (*http.Response, error) {
        return autorest.SendWithSender(client, req,
            autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
    }

    // GetNoteByIDResponder handles the response to the GetNoteByID request. The method always
    // closes the http.Response Body.
    func (client BaseClient) GetNoteByIDResponder(resp *http.Response) (result NoteModel, err error) {
        err = autorest.Respond(
            resp,
            client.ByInspecting(),
            azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusForbidden,http.StatusNotFound),
            autorest.ByUnmarshallingJSON(&result),
            autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
        return
    }

    // GetNotesByFilter sends the get notes by filter request.
    //
    // drawerID is gets or sets the drawer identifier. entityID is gets or sets the entity identifier. name is gets or sets
    // the name. creatorUserID is gets or sets the creator user identifier. modifierUserID is gets or sets the modifier
    // user identifier. minCreationTime is gets or sets the minimum creation time. maxCreationTime is gets or sets the
    // maximum creation time. minModificationTime is gets or sets the minimum modification time. maxModificationTime is
    // gets or sets the maximum modification time. parentID is gets or sets the parent note identifier. page is gets or
    // sets the page number. pageSize is gets or sets the size of the page. sortOrder is gets or sets the order. sortBy is
    // gets or sets the column to order by.
    func (client BaseClient) GetNotesByFilter(ctx context.Context, drawerID int32, entityID *int32, name string, creatorUserID *int32, modifierUserID *int32, minCreationTime *date.Time, maxCreationTime *date.Time, minModificationTime *date.Time, maxModificationTime *date.Time, parentID *int32, page *int32, pageSize *int32, sortOrder string, sortBy string) (result ListNoteModel, err error) {
        if err := validation.Validate([]validation.Validation{
        { TargetValue: drawerID,
         Constraints: []validation.Constraint{	{Target: "drawerID", Name: validation.InclusiveMaximum, Rule: 2147483647, Chain: nil },
        	{Target: "drawerID", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil }}},
        { TargetValue: entityID,
         Constraints: []validation.Constraint{	{Target: "entityID", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "entityID", Name: validation.InclusiveMaximum, Rule: 2147483647, Chain: nil },
        	{Target: "entityID", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil },
        }}}},
        { TargetValue: name,
         Constraints: []validation.Constraint{	{Target: "name", Name: validation.MaxLength, Rule: 255, Chain: nil },
        	{Target: "name", Name: validation.MinLength, Rule: 0, Chain: nil }}},
        { TargetValue: creatorUserID,
         Constraints: []validation.Constraint{	{Target: "creatorUserID", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "creatorUserID", Name: validation.InclusiveMaximum, Rule: 2147483647, Chain: nil },
        	{Target: "creatorUserID", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil },
        }}}},
        { TargetValue: modifierUserID,
         Constraints: []validation.Constraint{	{Target: "modifierUserID", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "modifierUserID", Name: validation.InclusiveMaximum, Rule: 2147483647, Chain: nil },
        	{Target: "modifierUserID", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil },
        }}}},
        { TargetValue: parentID,
         Constraints: []validation.Constraint{	{Target: "parentID", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "parentID", Name: validation.InclusiveMaximum, Rule: 2147483647, Chain: nil },
        	{Target: "parentID", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil },
        }}}},
        { TargetValue: page,
         Constraints: []validation.Constraint{	{Target: "page", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "page", Name: validation.InclusiveMaximum, Rule: 2147483647, Chain: nil },
        	{Target: "page", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil },
        }}}},
        { TargetValue: pageSize,
         Constraints: []validation.Constraint{	{Target: "pageSize", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "pageSize", Name: validation.InclusiveMaximum, Rule: 1000, Chain: nil },
        	{Target: "pageSize", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil },
        }}}}}); err != nil {
            return result, validation.NewErrorWithValidationError(err, "softheonenterpriseapiclient.BaseClient","GetNotesByFilter")
        }

        req, err := client.GetNotesByFilterPreparer(ctx, drawerID, entityID, name, creatorUserID, modifierUserID, minCreationTime, maxCreationTime, minModificationTime, maxModificationTime, parentID, page, pageSize, sortOrder, sortBy)
        if err != nil {
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "GetNotesByFilter", nil , "Failure preparing request")
            return
        }

        resp, err := client.GetNotesByFilterSender(req)
        if err != nil {
            result.Response = autorest.Response{Response: resp}
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "GetNotesByFilter", resp, "Failure sending request")
            return
        }

        result, err = client.GetNotesByFilterResponder(resp)
        if err != nil {
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "GetNotesByFilter", resp, "Failure responding to request")
        }

        return
    }

    // GetNotesByFilterPreparer prepares the GetNotesByFilter request.
    func (client BaseClient) GetNotesByFilterPreparer(ctx context.Context, drawerID int32, entityID *int32, name string, creatorUserID *int32, modifierUserID *int32, minCreationTime *date.Time, maxCreationTime *date.Time, minModificationTime *date.Time, maxModificationTime *date.Time, parentID *int32, page *int32, pageSize *int32, sortOrder string, sortBy string) (*http.Request, error) {
        queryParameters := map[string]interface{} {
        "drawerID": autorest.Encode("query",drawerID),
        }
        if entityID != nil {
            queryParameters["entityID"] = autorest.Encode("query",*entityID)
        }
        if len(name) > 0 {
            queryParameters["name"] = autorest.Encode("query",name)
        }
        if creatorUserID != nil {
            queryParameters["creatorUserID"] = autorest.Encode("query",*creatorUserID)
        }
        if modifierUserID != nil {
            queryParameters["modifierUserID"] = autorest.Encode("query",*modifierUserID)
        }
        if minCreationTime != nil {
            queryParameters["minCreationTime"] = autorest.Encode("query",*minCreationTime)
        }
        if maxCreationTime != nil {
            queryParameters["maxCreationTime"] = autorest.Encode("query",*maxCreationTime)
        }
        if minModificationTime != nil {
            queryParameters["minModificationTime"] = autorest.Encode("query",*minModificationTime)
        }
        if maxModificationTime != nil {
            queryParameters["maxModificationTime"] = autorest.Encode("query",*maxModificationTime)
        }
        if parentID != nil {
            queryParameters["parentID"] = autorest.Encode("query",*parentID)
        }
        if page != nil {
            queryParameters["page"] = autorest.Encode("query",*page)
        }
        if pageSize != nil {
            queryParameters["pageSize"] = autorest.Encode("query",*pageSize)
        }
        if len(string(sortOrder)) > 0 {
            queryParameters["sortOrder"] = autorest.Encode("query",sortOrder)
        }
        if len(string(sortBy)) > 0 {
            queryParameters["sortBy"] = autorest.Encode("query",sortBy)
        }

        preparer := autorest.CreatePreparer(
            autorest.AsGet(),
            autorest.WithBaseURL(client.BaseURI),
            autorest.WithPath("/v1/content/notes"),
            autorest.WithQueryParameters(queryParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
    }

    // GetNotesByFilterSender sends the GetNotesByFilter request. The method will close the
    // http.Response Body if it receives an error.
    func (client BaseClient) GetNotesByFilterSender(req *http.Request) (*http.Response, error) {
        return autorest.SendWithSender(client, req,
            autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
    }

    // GetNotesByFilterResponder handles the response to the GetNotesByFilter request. The method always
    // closes the http.Response Body.
    func (client BaseClient) GetNotesByFilterResponder(resp *http.Response) (result ListNoteModel, err error) {
        err = autorest.Respond(
            resp,
            client.ByInspecting(),
            azure.WithErrorUnlessStatusCode(http.StatusOK),
            autorest.ByUnmarshallingJSON(&result.Value),
            autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
        return
    }

    // GetQueueAssignmentsByFilter sends the get queue assignments by filter request.
    //
    // queueID is gets or sets the unique queue identifier. userID is gets or sets the user identifier. groupID is gets or
    // sets the group identifier. typeParameter is gets or sets the queue assignment type. order is gets or sets the sort
    // order. taskSortColumn is gets or sets the task sort column. state is gets or sets the state. fetchType is gets or
    // sets the type of the fetch. page is gets or sets the page number. pageSize is gets or sets the size of the page.
    // sortOrder is gets or sets the order. sortBy is gets or sets the column to order by.
    func (client BaseClient) GetQueueAssignmentsByFilter(ctx context.Context, queueID *int32, userID *int32, groupID *int32, typeParameter string, order *int32, taskSortColumn string, state string, fetchType string, page *int32, pageSize *int32, sortOrder string, sortBy string) (result ListQueueAssignmentModel, err error) {
        if err := validation.Validate([]validation.Validation{
        { TargetValue: queueID,
         Constraints: []validation.Constraint{	{Target: "queueID", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "queueID", Name: validation.InclusiveMaximum, Rule: 2147483647, Chain: nil },
        	{Target: "queueID", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil },
        }}}},
        { TargetValue: userID,
         Constraints: []validation.Constraint{	{Target: "userID", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "userID", Name: validation.InclusiveMaximum, Rule: 2147483647, Chain: nil },
        	{Target: "userID", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil },
        }}}},
        { TargetValue: groupID,
         Constraints: []validation.Constraint{	{Target: "groupID", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "groupID", Name: validation.InclusiveMaximum, Rule: 2147483647, Chain: nil },
        	{Target: "groupID", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil },
        }}}},
        { TargetValue: order,
         Constraints: []validation.Constraint{	{Target: "order", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "order", Name: validation.InclusiveMaximum, Rule: 2147483647, Chain: nil },
        	{Target: "order", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil },
        }}}},
        { TargetValue: page,
         Constraints: []validation.Constraint{	{Target: "page", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "page", Name: validation.InclusiveMaximum, Rule: 2147483647, Chain: nil },
        	{Target: "page", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil },
        }}}},
        { TargetValue: pageSize,
         Constraints: []validation.Constraint{	{Target: "pageSize", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "pageSize", Name: validation.InclusiveMaximum, Rule: 1000, Chain: nil },
        	{Target: "pageSize", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil },
        }}}}}); err != nil {
            return result, validation.NewErrorWithValidationError(err, "softheonenterpriseapiclient.BaseClient","GetQueueAssignmentsByFilter")
        }

        req, err := client.GetQueueAssignmentsByFilterPreparer(ctx, queueID, userID, groupID, typeParameter, order, taskSortColumn, state, fetchType, page, pageSize, sortOrder, sortBy)
        if err != nil {
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "GetQueueAssignmentsByFilter", nil , "Failure preparing request")
            return
        }

        resp, err := client.GetQueueAssignmentsByFilterSender(req)
        if err != nil {
            result.Response = autorest.Response{Response: resp}
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "GetQueueAssignmentsByFilter", resp, "Failure sending request")
            return
        }

        result, err = client.GetQueueAssignmentsByFilterResponder(resp)
        if err != nil {
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "GetQueueAssignmentsByFilter", resp, "Failure responding to request")
        }

        return
    }

    // GetQueueAssignmentsByFilterPreparer prepares the GetQueueAssignmentsByFilter request.
    func (client BaseClient) GetQueueAssignmentsByFilterPreparer(ctx context.Context, queueID *int32, userID *int32, groupID *int32, typeParameter string, order *int32, taskSortColumn string, state string, fetchType string, page *int32, pageSize *int32, sortOrder string, sortBy string) (*http.Request, error) {
        queryParameters := map[string]interface{} {
        }
        if queueID != nil {
            queryParameters["queueID"] = autorest.Encode("query",*queueID)
        }
        if userID != nil {
            queryParameters["userID"] = autorest.Encode("query",*userID)
        }
        if groupID != nil {
            queryParameters["groupID"] = autorest.Encode("query",*groupID)
        }
        if len(string(typeParameter)) > 0 {
            queryParameters["type"] = autorest.Encode("query",typeParameter)
        }
        if order != nil {
            queryParameters["order"] = autorest.Encode("query",*order)
        }
        if len(string(taskSortColumn)) > 0 {
            queryParameters["taskSortColumn"] = autorest.Encode("query",taskSortColumn)
        }
        if len(string(state)) > 0 {
            queryParameters["state"] = autorest.Encode("query",state)
        }
        if len(string(fetchType)) > 0 {
            queryParameters["fetchType"] = autorest.Encode("query",fetchType)
        }
        if page != nil {
            queryParameters["page"] = autorest.Encode("query",*page)
        }
        if pageSize != nil {
            queryParameters["pageSize"] = autorest.Encode("query",*pageSize)
        }
        if len(string(sortOrder)) > 0 {
            queryParameters["sortOrder"] = autorest.Encode("query",sortOrder)
        }
        if len(string(sortBy)) > 0 {
            queryParameters["sortBy"] = autorest.Encode("query",sortBy)
        }

        preparer := autorest.CreatePreparer(
            autorest.AsGet(),
            autorest.WithBaseURL(client.BaseURI),
            autorest.WithPath("/v1/workflow/assignments"),
            autorest.WithQueryParameters(queryParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
    }

    // GetQueueAssignmentsByFilterSender sends the GetQueueAssignmentsByFilter request. The method will close the
    // http.Response Body if it receives an error.
    func (client BaseClient) GetQueueAssignmentsByFilterSender(req *http.Request) (*http.Response, error) {
        return autorest.SendWithSender(client, req,
            autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
    }

    // GetQueueAssignmentsByFilterResponder handles the response to the GetQueueAssignmentsByFilter request. The method always
    // closes the http.Response Body.
    func (client BaseClient) GetQueueAssignmentsByFilterResponder(resp *http.Response) (result ListQueueAssignmentModel, err error) {
        err = autorest.Respond(
            resp,
            client.ByInspecting(),
            azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusForbidden),
            autorest.ByUnmarshallingJSON(&result.Value),
            autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
        return
    }

    // GetQueueAssignmentsByID sends the get queue assignments by id request.
    //
    // userID is the user identifier. queueID is the queue identifier.
    func (client BaseClient) GetQueueAssignmentsByID(ctx context.Context, userID int32, queueID int32) (result QueueAssignmentModel, err error) {
        req, err := client.GetQueueAssignmentsByIDPreparer(ctx, userID, queueID)
        if err != nil {
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "GetQueueAssignmentsByID", nil , "Failure preparing request")
            return
        }

        resp, err := client.GetQueueAssignmentsByIDSender(req)
        if err != nil {
            result.Response = autorest.Response{Response: resp}
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "GetQueueAssignmentsByID", resp, "Failure sending request")
            return
        }

        result, err = client.GetQueueAssignmentsByIDResponder(resp)
        if err != nil {
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "GetQueueAssignmentsByID", resp, "Failure responding to request")
        }

        return
    }

    // GetQueueAssignmentsByIDPreparer prepares the GetQueueAssignmentsByID request.
    func (client BaseClient) GetQueueAssignmentsByIDPreparer(ctx context.Context, userID int32, queueID int32) (*http.Request, error) {
        pathParameters := map[string]interface{} {
        "queueId": autorest.Encode("path",queueID),
        "userId": autorest.Encode("path",userID),
        }

        preparer := autorest.CreatePreparer(
            autorest.AsGet(),
            autorest.WithBaseURL(client.BaseURI),
            autorest.WithPathParameters("/v1/workflow/assignments/users/{userId}/queues/{queueId}",pathParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
    }

    // GetQueueAssignmentsByIDSender sends the GetQueueAssignmentsByID request. The method will close the
    // http.Response Body if it receives an error.
    func (client BaseClient) GetQueueAssignmentsByIDSender(req *http.Request) (*http.Response, error) {
        return autorest.SendWithSender(client, req,
            autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
    }

    // GetQueueAssignmentsByIDResponder handles the response to the GetQueueAssignmentsByID request. The method always
    // closes the http.Response Body.
    func (client BaseClient) GetQueueAssignmentsByIDResponder(resp *http.Response) (result QueueAssignmentModel, err error) {
        err = autorest.Respond(
            resp,
            client.ByInspecting(),
            azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusForbidden,http.StatusNotFound),
            autorest.ByUnmarshallingJSON(&result),
            autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
        return
    }

    // GetQueueByID sends the get queue by id request.
    //
    // ID is the queue identifier.
    func (client BaseClient) GetQueueByID(ctx context.Context, ID int32) (result QueueModel, err error) {
        req, err := client.GetQueueByIDPreparer(ctx, ID)
        if err != nil {
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "GetQueueByID", nil , "Failure preparing request")
            return
        }

        resp, err := client.GetQueueByIDSender(req)
        if err != nil {
            result.Response = autorest.Response{Response: resp}
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "GetQueueByID", resp, "Failure sending request")
            return
        }

        result, err = client.GetQueueByIDResponder(resp)
        if err != nil {
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "GetQueueByID", resp, "Failure responding to request")
        }

        return
    }

    // GetQueueByIDPreparer prepares the GetQueueByID request.
    func (client BaseClient) GetQueueByIDPreparer(ctx context.Context, ID int32) (*http.Request, error) {
        pathParameters := map[string]interface{} {
        "id": autorest.Encode("path",ID),
        }

        preparer := autorest.CreatePreparer(
            autorest.AsGet(),
            autorest.WithBaseURL(client.BaseURI),
            autorest.WithPathParameters("/v1/workflow/queues/{id}",pathParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
    }

    // GetQueueByIDSender sends the GetQueueByID request. The method will close the
    // http.Response Body if it receives an error.
    func (client BaseClient) GetQueueByIDSender(req *http.Request) (*http.Response, error) {
        return autorest.SendWithSender(client, req,
            autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
    }

    // GetQueueByIDResponder handles the response to the GetQueueByID request. The method always
    // closes the http.Response Body.
    func (client BaseClient) GetQueueByIDResponder(resp *http.Response) (result QueueModel, err error) {
        err = autorest.Respond(
            resp,
            client.ByInspecting(),
            azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusNotFound),
            autorest.ByUnmarshallingJSON(&result),
            autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
        return
    }

    // GetQueueByName sends the get queue by name request.
    //
    // name is the queue name.
    func (client BaseClient) GetQueueByName(ctx context.Context, name string) (result QueueModel, err error) {
        req, err := client.GetQueueByNamePreparer(ctx, name)
        if err != nil {
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "GetQueueByName", nil , "Failure preparing request")
            return
        }

        resp, err := client.GetQueueByNameSender(req)
        if err != nil {
            result.Response = autorest.Response{Response: resp}
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "GetQueueByName", resp, "Failure sending request")
            return
        }

        result, err = client.GetQueueByNameResponder(resp)
        if err != nil {
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "GetQueueByName", resp, "Failure responding to request")
        }

        return
    }

    // GetQueueByNamePreparer prepares the GetQueueByName request.
    func (client BaseClient) GetQueueByNamePreparer(ctx context.Context, name string) (*http.Request, error) {
        pathParameters := map[string]interface{} {
        "name": autorest.Encode("path",name),
        }

        preparer := autorest.CreatePreparer(
            autorest.AsGet(),
            autorest.WithBaseURL(client.BaseURI),
            autorest.WithPathParameters("/v1/workflow/queues/{name}",pathParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
    }

    // GetQueueByNameSender sends the GetQueueByName request. The method will close the
    // http.Response Body if it receives an error.
    func (client BaseClient) GetQueueByNameSender(req *http.Request) (*http.Response, error) {
        return autorest.SendWithSender(client, req,
            autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
    }

    // GetQueueByNameResponder handles the response to the GetQueueByName request. The method always
    // closes the http.Response Body.
    func (client BaseClient) GetQueueByNameResponder(resp *http.Response) (result QueueModel, err error) {
        err = autorest.Respond(
            resp,
            client.ByInspecting(),
            azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusNotFound),
            autorest.ByUnmarshallingJSON(&result),
            autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
        return
    }

    // GetQueueGroupAssociations sends the get queue group associations request.
    //
    // queueID is the queue identifier. groupID is the group identifier. ACL is gets or sets the access control level
    // permissions. page is gets or sets the page number. pageSize is gets or sets the size of the page. sortOrder is gets
    // or sets the order. sortBy is gets or sets the column to order by.
    func (client BaseClient) GetQueueGroupAssociations(ctx context.Context, queueID int32, groupID *int32, ACL *int32, page *int32, pageSize *int32, sortOrder string, sortBy string) (result ListGroupQueueModel, err error) {
        if err := validation.Validate([]validation.Validation{
        { TargetValue: page,
         Constraints: []validation.Constraint{	{Target: "page", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "page", Name: validation.InclusiveMaximum, Rule: 2147483647, Chain: nil },
        	{Target: "page", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil },
        }}}},
        { TargetValue: pageSize,
         Constraints: []validation.Constraint{	{Target: "pageSize", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "pageSize", Name: validation.InclusiveMaximum, Rule: 1000, Chain: nil },
        	{Target: "pageSize", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil },
        }}}}}); err != nil {
            return result, validation.NewErrorWithValidationError(err, "softheonenterpriseapiclient.BaseClient","GetQueueGroupAssociations")
        }

        req, err := client.GetQueueGroupAssociationsPreparer(ctx, queueID, groupID, ACL, page, pageSize, sortOrder, sortBy)
        if err != nil {
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "GetQueueGroupAssociations", nil , "Failure preparing request")
            return
        }

        resp, err := client.GetQueueGroupAssociationsSender(req)
        if err != nil {
            result.Response = autorest.Response{Response: resp}
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "GetQueueGroupAssociations", resp, "Failure sending request")
            return
        }

        result, err = client.GetQueueGroupAssociationsResponder(resp)
        if err != nil {
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "GetQueueGroupAssociations", resp, "Failure responding to request")
        }

        return
    }

    // GetQueueGroupAssociationsPreparer prepares the GetQueueGroupAssociations request.
    func (client BaseClient) GetQueueGroupAssociationsPreparer(ctx context.Context, queueID int32, groupID *int32, ACL *int32, page *int32, pageSize *int32, sortOrder string, sortBy string) (*http.Request, error) {
        pathParameters := map[string]interface{} {
        "queueID": autorest.Encode("path",queueID),
        }

        queryParameters := map[string]interface{} {
        }
        if groupID != nil {
            queryParameters["groupID"] = autorest.Encode("query",*groupID)
        }
        if ACL != nil {
            queryParameters["acl"] = autorest.Encode("query",*ACL)
        }
        if page != nil {
            queryParameters["page"] = autorest.Encode("query",*page)
        }
        if pageSize != nil {
            queryParameters["pageSize"] = autorest.Encode("query",*pageSize)
        }
        if len(string(sortOrder)) > 0 {
            queryParameters["sortOrder"] = autorest.Encode("query",sortOrder)
        }
        if len(string(sortBy)) > 0 {
            queryParameters["sortBy"] = autorest.Encode("query",sortBy)
        }

        preparer := autorest.CreatePreparer(
            autorest.AsGet(),
            autorest.WithBaseURL(client.BaseURI),
            autorest.WithPathParameters("/v1/workflow/queues/{queueID}/groups",pathParameters),
            autorest.WithQueryParameters(queryParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
    }

    // GetQueueGroupAssociationsSender sends the GetQueueGroupAssociations request. The method will close the
    // http.Response Body if it receives an error.
    func (client BaseClient) GetQueueGroupAssociationsSender(req *http.Request) (*http.Response, error) {
        return autorest.SendWithSender(client, req,
            autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
    }

    // GetQueueGroupAssociationsResponder handles the response to the GetQueueGroupAssociations request. The method always
    // closes the http.Response Body.
    func (client BaseClient) GetQueueGroupAssociationsResponder(resp *http.Response) (result ListGroupQueueModel, err error) {
        err = autorest.Respond(
            resp,
            client.ByInspecting(),
            azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusForbidden),
            autorest.ByUnmarshallingJSON(&result.Value),
            autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
        return
    }

    // GetQueuesByFilter sends the get queues by filter request.
    //
    // ID is gets or sets the queue identifier. name is gets or sets the name. alias is gets or sets the alias.
    // typeParameter is gets or sets the type. access is gets or sets the access level. bypassSecurity is gets or sets a
    // value indicating whether to bypass security checks. page is gets or sets the page number. pageSize is gets or sets
    // the size of the page. sortOrder is gets or sets the order. sortBy is gets or sets the column to order by.
    func (client BaseClient) GetQueuesByFilter(ctx context.Context, ID *int32, name string, alias string, typeParameter string, access *int32, bypassSecurity *bool, page *int32, pageSize *int32, sortOrder string, sortBy string) (result ListQueueModel, err error) {
        if err := validation.Validate([]validation.Validation{
        { TargetValue: ID,
         Constraints: []validation.Constraint{	{Target: "ID", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "ID", Name: validation.InclusiveMaximum, Rule: 2147483647, Chain: nil },
        	{Target: "ID", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil },
        }}}},
        { TargetValue: name,
         Constraints: []validation.Constraint{	{Target: "name", Name: validation.MaxLength, Rule: 255, Chain: nil },
        	{Target: "name", Name: validation.MinLength, Rule: 0, Chain: nil }}},
        { TargetValue: alias,
         Constraints: []validation.Constraint{	{Target: "alias", Name: validation.MaxLength, Rule: 255, Chain: nil },
        	{Target: "alias", Name: validation.MinLength, Rule: 0, Chain: nil }}},
        { TargetValue: page,
         Constraints: []validation.Constraint{	{Target: "page", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "page", Name: validation.InclusiveMaximum, Rule: 2147483647, Chain: nil },
        	{Target: "page", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil },
        }}}},
        { TargetValue: pageSize,
         Constraints: []validation.Constraint{	{Target: "pageSize", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "pageSize", Name: validation.InclusiveMaximum, Rule: 1000, Chain: nil },
        	{Target: "pageSize", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil },
        }}}}}); err != nil {
            return result, validation.NewErrorWithValidationError(err, "softheonenterpriseapiclient.BaseClient","GetQueuesByFilter")
        }

        req, err := client.GetQueuesByFilterPreparer(ctx, ID, name, alias, typeParameter, access, bypassSecurity, page, pageSize, sortOrder, sortBy)
        if err != nil {
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "GetQueuesByFilter", nil , "Failure preparing request")
            return
        }

        resp, err := client.GetQueuesByFilterSender(req)
        if err != nil {
            result.Response = autorest.Response{Response: resp}
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "GetQueuesByFilter", resp, "Failure sending request")
            return
        }

        result, err = client.GetQueuesByFilterResponder(resp)
        if err != nil {
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "GetQueuesByFilter", resp, "Failure responding to request")
        }

        return
    }

    // GetQueuesByFilterPreparer prepares the GetQueuesByFilter request.
    func (client BaseClient) GetQueuesByFilterPreparer(ctx context.Context, ID *int32, name string, alias string, typeParameter string, access *int32, bypassSecurity *bool, page *int32, pageSize *int32, sortOrder string, sortBy string) (*http.Request, error) {
        queryParameters := map[string]interface{} {
        }
        if ID != nil {
            queryParameters["iD"] = autorest.Encode("query",*ID)
        }
        if len(name) > 0 {
            queryParameters["name"] = autorest.Encode("query",name)
        }
        if len(alias) > 0 {
            queryParameters["alias"] = autorest.Encode("query",alias)
        }
        if len(string(typeParameter)) > 0 {
            queryParameters["type"] = autorest.Encode("query",typeParameter)
        }
        if access != nil {
            queryParameters["access"] = autorest.Encode("query",*access)
        }
        if bypassSecurity != nil {
            queryParameters["bypassSecurity"] = autorest.Encode("query",*bypassSecurity)
        }
        if page != nil {
            queryParameters["page"] = autorest.Encode("query",*page)
        }
        if pageSize != nil {
            queryParameters["pageSize"] = autorest.Encode("query",*pageSize)
        }
        if len(string(sortOrder)) > 0 {
            queryParameters["sortOrder"] = autorest.Encode("query",sortOrder)
        }
        if len(string(sortBy)) > 0 {
            queryParameters["sortBy"] = autorest.Encode("query",sortBy)
        }

        preparer := autorest.CreatePreparer(
            autorest.AsGet(),
            autorest.WithBaseURL(client.BaseURI),
            autorest.WithPath("/v1/workflow/queues"),
            autorest.WithQueryParameters(queryParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
    }

    // GetQueuesByFilterSender sends the GetQueuesByFilter request. The method will close the
    // http.Response Body if it receives an error.
    func (client BaseClient) GetQueuesByFilterSender(req *http.Request) (*http.Response, error) {
        return autorest.SendWithSender(client, req,
            autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
    }

    // GetQueuesByFilterResponder handles the response to the GetQueuesByFilter request. The method always
    // closes the http.Response Body.
    func (client BaseClient) GetQueuesByFilterResponder(resp *http.Response) (result ListQueueModel, err error) {
        err = autorest.Respond(
            resp,
            client.ByInspecting(),
            azure.WithErrorUnlessStatusCode(http.StatusOK),
            autorest.ByUnmarshallingJSON(&result.Value),
            autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
        return
    }

    // GetQueueUserAssociations sends the get queue user associations request.
    //
    // queueID is the queue identifier. userID is the user identifier. ACL is gets or sets the access control level
    // permissions. page is gets or sets the page number. pageSize is gets or sets the size of the page. sortOrder is gets
    // or sets the order. sortBy is gets or sets the column to order by.
    func (client BaseClient) GetQueueUserAssociations(ctx context.Context, queueID int32, userID *int32, ACL *int32, page *int32, pageSize *int32, sortOrder string, sortBy string) (result ListUserQueueModel, err error) {
        if err := validation.Validate([]validation.Validation{
        { TargetValue: page,
         Constraints: []validation.Constraint{	{Target: "page", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "page", Name: validation.InclusiveMaximum, Rule: 2147483647, Chain: nil },
        	{Target: "page", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil },
        }}}},
        { TargetValue: pageSize,
         Constraints: []validation.Constraint{	{Target: "pageSize", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "pageSize", Name: validation.InclusiveMaximum, Rule: 1000, Chain: nil },
        	{Target: "pageSize", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil },
        }}}}}); err != nil {
            return result, validation.NewErrorWithValidationError(err, "softheonenterpriseapiclient.BaseClient","GetQueueUserAssociations")
        }

        req, err := client.GetQueueUserAssociationsPreparer(ctx, queueID, userID, ACL, page, pageSize, sortOrder, sortBy)
        if err != nil {
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "GetQueueUserAssociations", nil , "Failure preparing request")
            return
        }

        resp, err := client.GetQueueUserAssociationsSender(req)
        if err != nil {
            result.Response = autorest.Response{Response: resp}
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "GetQueueUserAssociations", resp, "Failure sending request")
            return
        }

        result, err = client.GetQueueUserAssociationsResponder(resp)
        if err != nil {
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "GetQueueUserAssociations", resp, "Failure responding to request")
        }

        return
    }

    // GetQueueUserAssociationsPreparer prepares the GetQueueUserAssociations request.
    func (client BaseClient) GetQueueUserAssociationsPreparer(ctx context.Context, queueID int32, userID *int32, ACL *int32, page *int32, pageSize *int32, sortOrder string, sortBy string) (*http.Request, error) {
        pathParameters := map[string]interface{} {
        "queueID": autorest.Encode("path",queueID),
        }

        queryParameters := map[string]interface{} {
        }
        if userID != nil {
            queryParameters["userID"] = autorest.Encode("query",*userID)
        }
        if ACL != nil {
            queryParameters["acl"] = autorest.Encode("query",*ACL)
        }
        if page != nil {
            queryParameters["page"] = autorest.Encode("query",*page)
        }
        if pageSize != nil {
            queryParameters["pageSize"] = autorest.Encode("query",*pageSize)
        }
        if len(string(sortOrder)) > 0 {
            queryParameters["sortOrder"] = autorest.Encode("query",sortOrder)
        }
        if len(string(sortBy)) > 0 {
            queryParameters["sortBy"] = autorest.Encode("query",sortBy)
        }

        preparer := autorest.CreatePreparer(
            autorest.AsGet(),
            autorest.WithBaseURL(client.BaseURI),
            autorest.WithPathParameters("/v1/workflow/queues/{queueID}/users",pathParameters),
            autorest.WithQueryParameters(queryParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
    }

    // GetQueueUserAssociationsSender sends the GetQueueUserAssociations request. The method will close the
    // http.Response Body if it receives an error.
    func (client BaseClient) GetQueueUserAssociationsSender(req *http.Request) (*http.Response, error) {
        return autorest.SendWithSender(client, req,
            autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
    }

    // GetQueueUserAssociationsResponder handles the response to the GetQueueUserAssociations request. The method always
    // closes the http.Response Body.
    func (client BaseClient) GetQueueUserAssociationsResponder(resp *http.Response) (result ListUserQueueModel, err error) {
        err = autorest.Respond(
            resp,
            client.ByInspecting(),
            azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusForbidden),
            autorest.ByUnmarshallingJSON(&result.Value),
            autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
        return
    }

    // GetTaskByID sends the get task by id request.
    //
    // ID is the identifier.
    func (client BaseClient) GetTaskByID(ctx context.Context, ID int32) (result TaskModel, err error) {
        req, err := client.GetTaskByIDPreparer(ctx, ID)
        if err != nil {
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "GetTaskByID", nil , "Failure preparing request")
            return
        }

        resp, err := client.GetTaskByIDSender(req)
        if err != nil {
            result.Response = autorest.Response{Response: resp}
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "GetTaskByID", resp, "Failure sending request")
            return
        }

        result, err = client.GetTaskByIDResponder(resp)
        if err != nil {
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "GetTaskByID", resp, "Failure responding to request")
        }

        return
    }

    // GetTaskByIDPreparer prepares the GetTaskByID request.
    func (client BaseClient) GetTaskByIDPreparer(ctx context.Context, ID int32) (*http.Request, error) {
        pathParameters := map[string]interface{} {
        "id": autorest.Encode("path",ID),
        }

        preparer := autorest.CreatePreparer(
            autorest.AsGet(),
            autorest.WithBaseURL(client.BaseURI),
            autorest.WithPathParameters("/v1/workflow/tasks/{id}",pathParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
    }

    // GetTaskByIDSender sends the GetTaskByID request. The method will close the
    // http.Response Body if it receives an error.
    func (client BaseClient) GetTaskByIDSender(req *http.Request) (*http.Response, error) {
        return autorest.SendWithSender(client, req,
            autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
    }

    // GetTaskByIDResponder handles the response to the GetTaskByID request. The method always
    // closes the http.Response Body.
    func (client BaseClient) GetTaskByIDResponder(resp *http.Response) (result TaskModel, err error) {
        err = autorest.Respond(
            resp,
            client.ByInspecting(),
            azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusNotFound),
            autorest.ByUnmarshallingJSON(&result),
            autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
        return
    }

    // GetTasksByFilter sends the get tasks by filter request.
    //
    // lastTaskID is gets or sets the last task identifier. ID is gets or sets the entity identifier. typeParameter is gets
    // or sets the type of the entity. queueID is gets or sets the queue identifier. queueType is gets or sets the type of
    // the queue. drawerID is gets or sets the drawer identifier. description is gets or sets the task description. taskID
    // is gets or sets the task identifier. page is gets or sets the page number. pageSize is gets or sets the size of the
    // page. sortOrder is gets or sets the order. sortBy is gets or sets the column to order by.
    func (client BaseClient) GetTasksByFilter(ctx context.Context, lastTaskID *int32, ID *int32, typeParameter *int32, queueID *int32, queueType *int32, drawerID *int32, description string, taskID *int32, page *int32, pageSize *int32, sortOrder string, sortBy string) (result ListTaskModel, err error) {
        if err := validation.Validate([]validation.Validation{
        { TargetValue: lastTaskID,
         Constraints: []validation.Constraint{	{Target: "lastTaskID", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "lastTaskID", Name: validation.InclusiveMaximum, Rule: 2147483647, Chain: nil },
        	{Target: "lastTaskID", Name: validation.InclusiveMinimum, Rule: 0, Chain: nil },
        }}}},
        { TargetValue: ID,
         Constraints: []validation.Constraint{	{Target: "ID", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "ID", Name: validation.InclusiveMaximum, Rule: 2147483647, Chain: nil },
        	{Target: "ID", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil },
        }}}},
        { TargetValue: queueType,
         Constraints: []validation.Constraint{	{Target: "queueType", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "queueType", Name: validation.InclusiveMaximum, Rule: 2147483647, Chain: nil },
        	{Target: "queueType", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil },
        }}}},
        { TargetValue: drawerID,
         Constraints: []validation.Constraint{	{Target: "drawerID", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "drawerID", Name: validation.InclusiveMaximum, Rule: 2147483647, Chain: nil },
        	{Target: "drawerID", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil },
        }}}},
        { TargetValue: description,
         Constraints: []validation.Constraint{	{Target: "description", Name: validation.MaxLength, Rule: 255, Chain: nil },
        	{Target: "description", Name: validation.MinLength, Rule: 0, Chain: nil }}},
        { TargetValue: page,
         Constraints: []validation.Constraint{	{Target: "page", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "page", Name: validation.InclusiveMaximum, Rule: 2147483647, Chain: nil },
        	{Target: "page", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil },
        }}}},
        { TargetValue: pageSize,
         Constraints: []validation.Constraint{	{Target: "pageSize", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "pageSize", Name: validation.InclusiveMaximum, Rule: 1000, Chain: nil },
        	{Target: "pageSize", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil },
        }}}}}); err != nil {
            return result, validation.NewErrorWithValidationError(err, "softheonenterpriseapiclient.BaseClient","GetTasksByFilter")
        }

        req, err := client.GetTasksByFilterPreparer(ctx, lastTaskID, ID, typeParameter, queueID, queueType, drawerID, description, taskID, page, pageSize, sortOrder, sortBy)
        if err != nil {
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "GetTasksByFilter", nil , "Failure preparing request")
            return
        }

        resp, err := client.GetTasksByFilterSender(req)
        if err != nil {
            result.Response = autorest.Response{Response: resp}
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "GetTasksByFilter", resp, "Failure sending request")
            return
        }

        result, err = client.GetTasksByFilterResponder(resp)
        if err != nil {
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "GetTasksByFilter", resp, "Failure responding to request")
        }

        return
    }

    // GetTasksByFilterPreparer prepares the GetTasksByFilter request.
    func (client BaseClient) GetTasksByFilterPreparer(ctx context.Context, lastTaskID *int32, ID *int32, typeParameter *int32, queueID *int32, queueType *int32, drawerID *int32, description string, taskID *int32, page *int32, pageSize *int32, sortOrder string, sortBy string) (*http.Request, error) {
        queryParameters := map[string]interface{} {
        }
        if lastTaskID != nil {
            queryParameters["lastTaskID"] = autorest.Encode("query",*lastTaskID)
        }
        if ID != nil {
            queryParameters["iD"] = autorest.Encode("query",*ID)
        }
        if typeParameter != nil {
            queryParameters["type"] = autorest.Encode("query",*typeParameter)
        }
        if queueID != nil {
            queryParameters["queueID"] = autorest.Encode("query",*queueID)
        }
        if queueType != nil {
            queryParameters["queueType"] = autorest.Encode("query",*queueType)
        }
        if drawerID != nil {
            queryParameters["drawerID"] = autorest.Encode("query",*drawerID)
        }
        if len(description) > 0 {
            queryParameters["description"] = autorest.Encode("query",description)
        }
        if taskID != nil {
            queryParameters["taskID"] = autorest.Encode("query",*taskID)
        }
        if page != nil {
            queryParameters["page"] = autorest.Encode("query",*page)
        }
        if pageSize != nil {
            queryParameters["pageSize"] = autorest.Encode("query",*pageSize)
        }
        if len(string(sortOrder)) > 0 {
            queryParameters["sortOrder"] = autorest.Encode("query",sortOrder)
        }
        if len(string(sortBy)) > 0 {
            queryParameters["sortBy"] = autorest.Encode("query",sortBy)
        }

        preparer := autorest.CreatePreparer(
            autorest.AsGet(),
            autorest.WithBaseURL(client.BaseURI),
            autorest.WithPath("/v1/workflow/tasks"),
            autorest.WithQueryParameters(queryParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
    }

    // GetTasksByFilterSender sends the GetTasksByFilter request. The method will close the
    // http.Response Body if it receives an error.
    func (client BaseClient) GetTasksByFilterSender(req *http.Request) (*http.Response, error) {
        return autorest.SendWithSender(client, req,
            autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
    }

    // GetTasksByFilterResponder handles the response to the GetTasksByFilter request. The method always
    // closes the http.Response Body.
    func (client BaseClient) GetTasksByFilterResponder(resp *http.Response) (result ListTaskModel, err error) {
        err = autorest.Respond(
            resp,
            client.ByInspecting(),
            azure.WithErrorUnlessStatusCode(http.StatusOK),
            autorest.ByUnmarshallingJSON(&result.Value),
            autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
        return
    }

    // GetTemplateByID sends the get template by id request.
    //
    // ID is the template identifier.
    func (client BaseClient) GetTemplateByID(ctx context.Context, ID string) (result EntityDefinitionModel, err error) {
        req, err := client.GetTemplateByIDPreparer(ctx, ID)
        if err != nil {
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "GetTemplateByID", nil , "Failure preparing request")
            return
        }

        resp, err := client.GetTemplateByIDSender(req)
        if err != nil {
            result.Response = autorest.Response{Response: resp}
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "GetTemplateByID", resp, "Failure sending request")
            return
        }

        result, err = client.GetTemplateByIDResponder(resp)
        if err != nil {
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "GetTemplateByID", resp, "Failure responding to request")
        }

        return
    }

    // GetTemplateByIDPreparer prepares the GetTemplateByID request.
    func (client BaseClient) GetTemplateByIDPreparer(ctx context.Context, ID string) (*http.Request, error) {
        pathParameters := map[string]interface{} {
        "id": autorest.Encode("path",ID),
        }

        preparer := autorest.CreatePreparer(
            autorest.AsGet(),
            autorest.WithBaseURL(client.BaseURI),
            autorest.WithPathParameters("/v1/template/ftl/{id}",pathParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
    }

    // GetTemplateByIDSender sends the GetTemplateByID request. The method will close the
    // http.Response Body if it receives an error.
    func (client BaseClient) GetTemplateByIDSender(req *http.Request) (*http.Response, error) {
        return autorest.SendWithSender(client, req,
            autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
    }

    // GetTemplateByIDResponder handles the response to the GetTemplateByID request. The method always
    // closes the http.Response Body.
    func (client BaseClient) GetTemplateByIDResponder(resp *http.Response) (result EntityDefinitionModel, err error) {
        err = autorest.Respond(
            resp,
            client.ByInspecting(),
            azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusNotFound),
            autorest.ByUnmarshallingJSON(&result),
            autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
        return
    }

    // GetTemplateByType sends the get template by type request.
    //
    // typeParameter is the unique template type.
    func (client BaseClient) GetTemplateByType(ctx context.Context, typeParameter int32) (result EntityDefinitionModel, err error) {
        req, err := client.GetTemplateByTypePreparer(ctx, typeParameter)
        if err != nil {
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "GetTemplateByType", nil , "Failure preparing request")
            return
        }

        resp, err := client.GetTemplateByTypeSender(req)
        if err != nil {
            result.Response = autorest.Response{Response: resp}
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "GetTemplateByType", resp, "Failure sending request")
            return
        }

        result, err = client.GetTemplateByTypeResponder(resp)
        if err != nil {
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "GetTemplateByType", resp, "Failure responding to request")
        }

        return
    }

    // GetTemplateByTypePreparer prepares the GetTemplateByType request.
    func (client BaseClient) GetTemplateByTypePreparer(ctx context.Context, typeParameter int32) (*http.Request, error) {
        pathParameters := map[string]interface{} {
        "type": autorest.Encode("path",typeParameter),
        }

        preparer := autorest.CreatePreparer(
            autorest.AsGet(),
            autorest.WithBaseURL(client.BaseURI),
            autorest.WithPathParameters("/v1/template/ftl/{type}",pathParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
    }

    // GetTemplateByTypeSender sends the GetTemplateByType request. The method will close the
    // http.Response Body if it receives an error.
    func (client BaseClient) GetTemplateByTypeSender(req *http.Request) (*http.Response, error) {
        return autorest.SendWithSender(client, req,
            autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
    }

    // GetTemplateByTypeResponder handles the response to the GetTemplateByType request. The method always
    // closes the http.Response Body.
    func (client BaseClient) GetTemplateByTypeResponder(resp *http.Response) (result EntityDefinitionModel, err error) {
        err = autorest.Respond(
            resp,
            client.ByInspecting(),
            azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusNotFound),
            autorest.ByUnmarshallingJSON(&result),
            autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
        return
    }

    // GetTemplatesByFilter sends the get templates by filter request.
    //
    // drawerID is gets or sets the drawer identifier. name is gets or sets the name. category is gets or sets the
    // category. page is gets or sets the page number. pageSize is gets or sets the size of the page. sortOrder is gets or
    // sets the order. sortBy is gets or sets the column to order by.
    func (client BaseClient) GetTemplatesByFilter(ctx context.Context, drawerID *int32, name string, category string, page *int32, pageSize *int32, sortOrder string, sortBy *int32) (result ListEntityDefinitionModel, err error) {
        if err := validation.Validate([]validation.Validation{
        { TargetValue: drawerID,
         Constraints: []validation.Constraint{	{Target: "drawerID", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "drawerID", Name: validation.InclusiveMaximum, Rule: 2147483647, Chain: nil },
        	{Target: "drawerID", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil },
        }}}},
        { TargetValue: name,
         Constraints: []validation.Constraint{	{Target: "name", Name: validation.MaxLength, Rule: 255, Chain: nil },
        	{Target: "name", Name: validation.MinLength, Rule: 0, Chain: nil }}},
        { TargetValue: category,
         Constraints: []validation.Constraint{	{Target: "category", Name: validation.MaxLength, Rule: 255, Chain: nil },
        	{Target: "category", Name: validation.MinLength, Rule: 0, Chain: nil }}},
        { TargetValue: page,
         Constraints: []validation.Constraint{	{Target: "page", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "page", Name: validation.InclusiveMaximum, Rule: 2147483647, Chain: nil },
        	{Target: "page", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil },
        }}}},
        { TargetValue: pageSize,
         Constraints: []validation.Constraint{	{Target: "pageSize", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "pageSize", Name: validation.InclusiveMaximum, Rule: 1000, Chain: nil },
        	{Target: "pageSize", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil },
        }}}}}); err != nil {
            return result, validation.NewErrorWithValidationError(err, "softheonenterpriseapiclient.BaseClient","GetTemplatesByFilter")
        }

        req, err := client.GetTemplatesByFilterPreparer(ctx, drawerID, name, category, page, pageSize, sortOrder, sortBy)
        if err != nil {
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "GetTemplatesByFilter", nil , "Failure preparing request")
            return
        }

        resp, err := client.GetTemplatesByFilterSender(req)
        if err != nil {
            result.Response = autorest.Response{Response: resp}
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "GetTemplatesByFilter", resp, "Failure sending request")
            return
        }

        result, err = client.GetTemplatesByFilterResponder(resp)
        if err != nil {
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "GetTemplatesByFilter", resp, "Failure responding to request")
        }

        return
    }

    // GetTemplatesByFilterPreparer prepares the GetTemplatesByFilter request.
    func (client BaseClient) GetTemplatesByFilterPreparer(ctx context.Context, drawerID *int32, name string, category string, page *int32, pageSize *int32, sortOrder string, sortBy *int32) (*http.Request, error) {
        queryParameters := map[string]interface{} {
        }
        if drawerID != nil {
            queryParameters["drawerID"] = autorest.Encode("query",*drawerID)
        }
        if len(name) > 0 {
            queryParameters["name"] = autorest.Encode("query",name)
        }
        if len(category) > 0 {
            queryParameters["category"] = autorest.Encode("query",category)
        }
        if page != nil {
            queryParameters["page"] = autorest.Encode("query",*page)
        }
        if pageSize != nil {
            queryParameters["pageSize"] = autorest.Encode("query",*pageSize)
        }
        if len(string(sortOrder)) > 0 {
            queryParameters["sortOrder"] = autorest.Encode("query",sortOrder)
        }
        if sortBy != nil {
            queryParameters["sortBy"] = autorest.Encode("query",*sortBy)
        }

        preparer := autorest.CreatePreparer(
            autorest.AsGet(),
            autorest.WithBaseURL(client.BaseURI),
            autorest.WithPath("/v1/template/ftl"),
            autorest.WithQueryParameters(queryParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
    }

    // GetTemplatesByFilterSender sends the GetTemplatesByFilter request. The method will close the
    // http.Response Body if it receives an error.
    func (client BaseClient) GetTemplatesByFilterSender(req *http.Request) (*http.Response, error) {
        return autorest.SendWithSender(client, req,
            autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
    }

    // GetTemplatesByFilterResponder handles the response to the GetTemplatesByFilter request. The method always
    // closes the http.Response Body.
    func (client BaseClient) GetTemplatesByFilterResponder(resp *http.Response) (result ListEntityDefinitionModel, err error) {
        err = autorest.Respond(
            resp,
            client.ByInspecting(),
            azure.WithErrorUnlessStatusCode(http.StatusOK),
            autorest.ByUnmarshallingJSON(&result.Value),
            autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
        return
    }

    // GetUserApplicationAssociations sends the get user application associations request.
    //
    // userID is the user identifier. applicationID is the application identifier. ACL is gets or sets the access control
    // level permissions. page is gets or sets the page number. pageSize is gets or sets the size of the page. sortOrder is
    // gets or sets the order. sortBy is gets or sets the column to order by.
    func (client BaseClient) GetUserApplicationAssociations(ctx context.Context, userID int32, applicationID *int32, ACL *int32, page *int32, pageSize *int32, sortOrder string, sortBy string) (result ListUserApplicationModel, err error) {
        if err := validation.Validate([]validation.Validation{
        { TargetValue: page,
         Constraints: []validation.Constraint{	{Target: "page", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "page", Name: validation.InclusiveMaximum, Rule: 2147483647, Chain: nil },
        	{Target: "page", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil },
        }}}},
        { TargetValue: pageSize,
         Constraints: []validation.Constraint{	{Target: "pageSize", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "pageSize", Name: validation.InclusiveMaximum, Rule: 1000, Chain: nil },
        	{Target: "pageSize", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil },
        }}}}}); err != nil {
            return result, validation.NewErrorWithValidationError(err, "softheonenterpriseapiclient.BaseClient","GetUserApplicationAssociations")
        }

        req, err := client.GetUserApplicationAssociationsPreparer(ctx, userID, applicationID, ACL, page, pageSize, sortOrder, sortBy)
        if err != nil {
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "GetUserApplicationAssociations", nil , "Failure preparing request")
            return
        }

        resp, err := client.GetUserApplicationAssociationsSender(req)
        if err != nil {
            result.Response = autorest.Response{Response: resp}
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "GetUserApplicationAssociations", resp, "Failure sending request")
            return
        }

        result, err = client.GetUserApplicationAssociationsResponder(resp)
        if err != nil {
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "GetUserApplicationAssociations", resp, "Failure responding to request")
        }

        return
    }

    // GetUserApplicationAssociationsPreparer prepares the GetUserApplicationAssociations request.
    func (client BaseClient) GetUserApplicationAssociationsPreparer(ctx context.Context, userID int32, applicationID *int32, ACL *int32, page *int32, pageSize *int32, sortOrder string, sortBy string) (*http.Request, error) {
        pathParameters := map[string]interface{} {
        "userID": autorest.Encode("path",userID),
        }

        queryParameters := map[string]interface{} {
        }
        if applicationID != nil {
            queryParameters["applicationID"] = autorest.Encode("query",*applicationID)
        }
        if ACL != nil {
            queryParameters["acl"] = autorest.Encode("query",*ACL)
        }
        if page != nil {
            queryParameters["page"] = autorest.Encode("query",*page)
        }
        if pageSize != nil {
            queryParameters["pageSize"] = autorest.Encode("query",*pageSize)
        }
        if len(string(sortOrder)) > 0 {
            queryParameters["sortOrder"] = autorest.Encode("query",sortOrder)
        }
        if len(string(sortBy)) > 0 {
            queryParameters["sortBy"] = autorest.Encode("query",sortBy)
        }

        preparer := autorest.CreatePreparer(
            autorest.AsGet(),
            autorest.WithBaseURL(client.BaseURI),
            autorest.WithPathParameters("/v1/directory/users/{userID}/applications",pathParameters),
            autorest.WithQueryParameters(queryParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
    }

    // GetUserApplicationAssociationsSender sends the GetUserApplicationAssociations request. The method will close the
    // http.Response Body if it receives an error.
    func (client BaseClient) GetUserApplicationAssociationsSender(req *http.Request) (*http.Response, error) {
        return autorest.SendWithSender(client, req,
            autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
    }

    // GetUserApplicationAssociationsResponder handles the response to the GetUserApplicationAssociations request. The method always
    // closes the http.Response Body.
    func (client BaseClient) GetUserApplicationAssociationsResponder(resp *http.Response) (result ListUserApplicationModel, err error) {
        err = autorest.Respond(
            resp,
            client.ByInspecting(),
            azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusForbidden),
            autorest.ByUnmarshallingJSON(&result.Value),
            autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
        return
    }

    // GetUserByID sends the get user by id request.
    //
    // ID is the user identifier.
    func (client BaseClient) GetUserByID(ctx context.Context, ID int32) (result UserModel, err error) {
        req, err := client.GetUserByIDPreparer(ctx, ID)
        if err != nil {
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "GetUserByID", nil , "Failure preparing request")
            return
        }

        resp, err := client.GetUserByIDSender(req)
        if err != nil {
            result.Response = autorest.Response{Response: resp}
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "GetUserByID", resp, "Failure sending request")
            return
        }

        result, err = client.GetUserByIDResponder(resp)
        if err != nil {
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "GetUserByID", resp, "Failure responding to request")
        }

        return
    }

    // GetUserByIDPreparer prepares the GetUserByID request.
    func (client BaseClient) GetUserByIDPreparer(ctx context.Context, ID int32) (*http.Request, error) {
        pathParameters := map[string]interface{} {
        "id": autorest.Encode("path",ID),
        }

        preparer := autorest.CreatePreparer(
            autorest.AsGet(),
            autorest.WithBaseURL(client.BaseURI),
            autorest.WithPathParameters("/v1/directory/users/{id}",pathParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
    }

    // GetUserByIDSender sends the GetUserByID request. The method will close the
    // http.Response Body if it receives an error.
    func (client BaseClient) GetUserByIDSender(req *http.Request) (*http.Response, error) {
        return autorest.SendWithSender(client, req,
            autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
    }

    // GetUserByIDResponder handles the response to the GetUserByID request. The method always
    // closes the http.Response Body.
    func (client BaseClient) GetUserByIDResponder(resp *http.Response) (result UserModel, err error) {
        err = autorest.Respond(
            resp,
            client.ByInspecting(),
            azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusForbidden,http.StatusNotFound),
            autorest.ByUnmarshallingJSON(&result),
            autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
        return
    }

    // GetUserDrawerAssociations sends the get user drawer associations request.
    //
    // userID is the user identifier. drawerID is the drawer identifier. ACL is gets or sets the access control level
    // permissions. page is gets or sets the page number. pageSize is gets or sets the size of the page. sortOrder is gets
    // or sets the order. sortBy is gets or sets the column to order by.
    func (client BaseClient) GetUserDrawerAssociations(ctx context.Context, userID int32, drawerID *int32, ACL *int32, page *int32, pageSize *int32, sortOrder string, sortBy string) (result ListUserDrawerModel, err error) {
        if err := validation.Validate([]validation.Validation{
        { TargetValue: page,
         Constraints: []validation.Constraint{	{Target: "page", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "page", Name: validation.InclusiveMaximum, Rule: 2147483647, Chain: nil },
        	{Target: "page", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil },
        }}}},
        { TargetValue: pageSize,
         Constraints: []validation.Constraint{	{Target: "pageSize", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "pageSize", Name: validation.InclusiveMaximum, Rule: 1000, Chain: nil },
        	{Target: "pageSize", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil },
        }}}}}); err != nil {
            return result, validation.NewErrorWithValidationError(err, "softheonenterpriseapiclient.BaseClient","GetUserDrawerAssociations")
        }

        req, err := client.GetUserDrawerAssociationsPreparer(ctx, userID, drawerID, ACL, page, pageSize, sortOrder, sortBy)
        if err != nil {
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "GetUserDrawerAssociations", nil , "Failure preparing request")
            return
        }

        resp, err := client.GetUserDrawerAssociationsSender(req)
        if err != nil {
            result.Response = autorest.Response{Response: resp}
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "GetUserDrawerAssociations", resp, "Failure sending request")
            return
        }

        result, err = client.GetUserDrawerAssociationsResponder(resp)
        if err != nil {
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "GetUserDrawerAssociations", resp, "Failure responding to request")
        }

        return
    }

    // GetUserDrawerAssociationsPreparer prepares the GetUserDrawerAssociations request.
    func (client BaseClient) GetUserDrawerAssociationsPreparer(ctx context.Context, userID int32, drawerID *int32, ACL *int32, page *int32, pageSize *int32, sortOrder string, sortBy string) (*http.Request, error) {
        pathParameters := map[string]interface{} {
        "userID": autorest.Encode("path",userID),
        }

        queryParameters := map[string]interface{} {
        }
        if drawerID != nil {
            queryParameters["drawerID"] = autorest.Encode("query",*drawerID)
        }
        if ACL != nil {
            queryParameters["acl"] = autorest.Encode("query",*ACL)
        }
        if page != nil {
            queryParameters["page"] = autorest.Encode("query",*page)
        }
        if pageSize != nil {
            queryParameters["pageSize"] = autorest.Encode("query",*pageSize)
        }
        if len(string(sortOrder)) > 0 {
            queryParameters["sortOrder"] = autorest.Encode("query",sortOrder)
        }
        if len(string(sortBy)) > 0 {
            queryParameters["sortBy"] = autorest.Encode("query",sortBy)
        }

        preparer := autorest.CreatePreparer(
            autorest.AsGet(),
            autorest.WithBaseURL(client.BaseURI),
            autorest.WithPathParameters("/v1/directory/users/{userID}/drawers",pathParameters),
            autorest.WithQueryParameters(queryParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
    }

    // GetUserDrawerAssociationsSender sends the GetUserDrawerAssociations request. The method will close the
    // http.Response Body if it receives an error.
    func (client BaseClient) GetUserDrawerAssociationsSender(req *http.Request) (*http.Response, error) {
        return autorest.SendWithSender(client, req,
            autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
    }

    // GetUserDrawerAssociationsResponder handles the response to the GetUserDrawerAssociations request. The method always
    // closes the http.Response Body.
    func (client BaseClient) GetUserDrawerAssociationsResponder(resp *http.Response) (result ListUserDrawerModel, err error) {
        err = autorest.Respond(
            resp,
            client.ByInspecting(),
            azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusForbidden),
            autorest.ByUnmarshallingJSON(&result.Value),
            autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
        return
    }

    // GetUserGroupAssociations sends the get user group associations request.
    //
    // userID is the user identifier. groupID is the group identifier. ACL is gets or sets the access control level
    // permissions. page is gets or sets the page number. pageSize is gets or sets the size of the page. sortOrder is gets
    // or sets the order. sortBy is gets or sets the column to order by.
    func (client BaseClient) GetUserGroupAssociations(ctx context.Context, userID int32, groupID *int32, ACL *int32, page *int32, pageSize *int32, sortOrder string, sortBy string) (result ListGroupUserModel, err error) {
        if err := validation.Validate([]validation.Validation{
        { TargetValue: page,
         Constraints: []validation.Constraint{	{Target: "page", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "page", Name: validation.InclusiveMaximum, Rule: 2147483647, Chain: nil },
        	{Target: "page", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil },
        }}}},
        { TargetValue: pageSize,
         Constraints: []validation.Constraint{	{Target: "pageSize", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "pageSize", Name: validation.InclusiveMaximum, Rule: 1000, Chain: nil },
        	{Target: "pageSize", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil },
        }}}}}); err != nil {
            return result, validation.NewErrorWithValidationError(err, "softheonenterpriseapiclient.BaseClient","GetUserGroupAssociations")
        }

        req, err := client.GetUserGroupAssociationsPreparer(ctx, userID, groupID, ACL, page, pageSize, sortOrder, sortBy)
        if err != nil {
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "GetUserGroupAssociations", nil , "Failure preparing request")
            return
        }

        resp, err := client.GetUserGroupAssociationsSender(req)
        if err != nil {
            result.Response = autorest.Response{Response: resp}
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "GetUserGroupAssociations", resp, "Failure sending request")
            return
        }

        result, err = client.GetUserGroupAssociationsResponder(resp)
        if err != nil {
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "GetUserGroupAssociations", resp, "Failure responding to request")
        }

        return
    }

    // GetUserGroupAssociationsPreparer prepares the GetUserGroupAssociations request.
    func (client BaseClient) GetUserGroupAssociationsPreparer(ctx context.Context, userID int32, groupID *int32, ACL *int32, page *int32, pageSize *int32, sortOrder string, sortBy string) (*http.Request, error) {
        pathParameters := map[string]interface{} {
        "userID": autorest.Encode("path",userID),
        }

        queryParameters := map[string]interface{} {
        }
        if groupID != nil {
            queryParameters["groupID"] = autorest.Encode("query",*groupID)
        }
        if ACL != nil {
            queryParameters["acl"] = autorest.Encode("query",*ACL)
        }
        if page != nil {
            queryParameters["page"] = autorest.Encode("query",*page)
        }
        if pageSize != nil {
            queryParameters["pageSize"] = autorest.Encode("query",*pageSize)
        }
        if len(string(sortOrder)) > 0 {
            queryParameters["sortOrder"] = autorest.Encode("query",sortOrder)
        }
        if len(string(sortBy)) > 0 {
            queryParameters["sortBy"] = autorest.Encode("query",sortBy)
        }

        preparer := autorest.CreatePreparer(
            autorest.AsGet(),
            autorest.WithBaseURL(client.BaseURI),
            autorest.WithPathParameters("/v1/directory/users/{userID}/groups",pathParameters),
            autorest.WithQueryParameters(queryParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
    }

    // GetUserGroupAssociationsSender sends the GetUserGroupAssociations request. The method will close the
    // http.Response Body if it receives an error.
    func (client BaseClient) GetUserGroupAssociationsSender(req *http.Request) (*http.Response, error) {
        return autorest.SendWithSender(client, req,
            autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
    }

    // GetUserGroupAssociationsResponder handles the response to the GetUserGroupAssociations request. The method always
    // closes the http.Response Body.
    func (client BaseClient) GetUserGroupAssociationsResponder(resp *http.Response) (result ListGroupUserModel, err error) {
        err = autorest.Respond(
            resp,
            client.ByInspecting(),
            azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusForbidden),
            autorest.ByUnmarshallingJSON(&result.Value),
            autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
        return
    }

    // GetUserQueueAssociations sends the get user queue associations request.
    //
    // userID is the user identifier. queueID is the queue identifier. ACL is gets or sets the access control level
    // permissions. page is gets or sets the page number. pageSize is gets or sets the size of the page. sortOrder is gets
    // or sets the order. sortBy is gets or sets the column to order by.
    func (client BaseClient) GetUserQueueAssociations(ctx context.Context, userID int32, queueID *int32, ACL *int32, page *int32, pageSize *int32, sortOrder string, sortBy string) (result ListUserQueueModel, err error) {
        if err := validation.Validate([]validation.Validation{
        { TargetValue: page,
         Constraints: []validation.Constraint{	{Target: "page", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "page", Name: validation.InclusiveMaximum, Rule: 2147483647, Chain: nil },
        	{Target: "page", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil },
        }}}},
        { TargetValue: pageSize,
         Constraints: []validation.Constraint{	{Target: "pageSize", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "pageSize", Name: validation.InclusiveMaximum, Rule: 1000, Chain: nil },
        	{Target: "pageSize", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil },
        }}}}}); err != nil {
            return result, validation.NewErrorWithValidationError(err, "softheonenterpriseapiclient.BaseClient","GetUserQueueAssociations")
        }

        req, err := client.GetUserQueueAssociationsPreparer(ctx, userID, queueID, ACL, page, pageSize, sortOrder, sortBy)
        if err != nil {
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "GetUserQueueAssociations", nil , "Failure preparing request")
            return
        }

        resp, err := client.GetUserQueueAssociationsSender(req)
        if err != nil {
            result.Response = autorest.Response{Response: resp}
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "GetUserQueueAssociations", resp, "Failure sending request")
            return
        }

        result, err = client.GetUserQueueAssociationsResponder(resp)
        if err != nil {
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "GetUserQueueAssociations", resp, "Failure responding to request")
        }

        return
    }

    // GetUserQueueAssociationsPreparer prepares the GetUserQueueAssociations request.
    func (client BaseClient) GetUserQueueAssociationsPreparer(ctx context.Context, userID int32, queueID *int32, ACL *int32, page *int32, pageSize *int32, sortOrder string, sortBy string) (*http.Request, error) {
        pathParameters := map[string]interface{} {
        "userID": autorest.Encode("path",userID),
        }

        queryParameters := map[string]interface{} {
        }
        if queueID != nil {
            queryParameters["queueID"] = autorest.Encode("query",*queueID)
        }
        if ACL != nil {
            queryParameters["acl"] = autorest.Encode("query",*ACL)
        }
        if page != nil {
            queryParameters["page"] = autorest.Encode("query",*page)
        }
        if pageSize != nil {
            queryParameters["pageSize"] = autorest.Encode("query",*pageSize)
        }
        if len(string(sortOrder)) > 0 {
            queryParameters["sortOrder"] = autorest.Encode("query",sortOrder)
        }
        if len(string(sortBy)) > 0 {
            queryParameters["sortBy"] = autorest.Encode("query",sortBy)
        }

        preparer := autorest.CreatePreparer(
            autorest.AsGet(),
            autorest.WithBaseURL(client.BaseURI),
            autorest.WithPathParameters("/v1/directory/users/{userID}/queues",pathParameters),
            autorest.WithQueryParameters(queryParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
    }

    // GetUserQueueAssociationsSender sends the GetUserQueueAssociations request. The method will close the
    // http.Response Body if it receives an error.
    func (client BaseClient) GetUserQueueAssociationsSender(req *http.Request) (*http.Response, error) {
        return autorest.SendWithSender(client, req,
            autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
    }

    // GetUserQueueAssociationsResponder handles the response to the GetUserQueueAssociations request. The method always
    // closes the http.Response Body.
    func (client BaseClient) GetUserQueueAssociationsResponder(resp *http.Response) (result ListUserQueueModel, err error) {
        err = autorest.Respond(
            resp,
            client.ByInspecting(),
            azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusForbidden),
            autorest.ByUnmarshallingJSON(&result.Value),
            autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
        return
    }

    // GetUsersByFilter sends the get users by filter request.
    //
    // ID is gets or sets the identifier. primaryGroupID is gets or sets the primary group identifier. groupID is gets or
    // sets the group identifier. groupName is gets or sets the name of the group. username is gets or sets the username.
    // typeParameter is gets or sets the type. state is gets or sets the state. fullName is gets or sets the full name.
    // page is gets or sets the page number. pageSize is gets or sets the size of the page. sortOrder is gets or sets the
    // order. sortBy is gets or sets the column to order by.
    func (client BaseClient) GetUsersByFilter(ctx context.Context, ID *int32, primaryGroupID *int32, groupID *int32, groupName string, username string, typeParameter string, state string, fullName string, page *int32, pageSize *int32, sortOrder string, sortBy string) (result ListUserModel, err error) {
        if err := validation.Validate([]validation.Validation{
        { TargetValue: page,
         Constraints: []validation.Constraint{	{Target: "page", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "page", Name: validation.InclusiveMaximum, Rule: 2147483647, Chain: nil },
        	{Target: "page", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil },
        }}}},
        { TargetValue: pageSize,
         Constraints: []validation.Constraint{	{Target: "pageSize", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "pageSize", Name: validation.InclusiveMaximum, Rule: 1000, Chain: nil },
        	{Target: "pageSize", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil },
        }}}}}); err != nil {
            return result, validation.NewErrorWithValidationError(err, "softheonenterpriseapiclient.BaseClient","GetUsersByFilter")
        }

        req, err := client.GetUsersByFilterPreparer(ctx, ID, primaryGroupID, groupID, groupName, username, typeParameter, state, fullName, page, pageSize, sortOrder, sortBy)
        if err != nil {
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "GetUsersByFilter", nil , "Failure preparing request")
            return
        }

        resp, err := client.GetUsersByFilterSender(req)
        if err != nil {
            result.Response = autorest.Response{Response: resp}
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "GetUsersByFilter", resp, "Failure sending request")
            return
        }

        result, err = client.GetUsersByFilterResponder(resp)
        if err != nil {
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "GetUsersByFilter", resp, "Failure responding to request")
        }

        return
    }

    // GetUsersByFilterPreparer prepares the GetUsersByFilter request.
    func (client BaseClient) GetUsersByFilterPreparer(ctx context.Context, ID *int32, primaryGroupID *int32, groupID *int32, groupName string, username string, typeParameter string, state string, fullName string, page *int32, pageSize *int32, sortOrder string, sortBy string) (*http.Request, error) {
        queryParameters := map[string]interface{} {
        }
        if ID != nil {
            queryParameters["iD"] = autorest.Encode("query",*ID)
        }
        if primaryGroupID != nil {
            queryParameters["primaryGroupID"] = autorest.Encode("query",*primaryGroupID)
        }
        if groupID != nil {
            queryParameters["groupID"] = autorest.Encode("query",*groupID)
        }
        if len(groupName) > 0 {
            queryParameters["groupName"] = autorest.Encode("query",groupName)
        }
        if len(username) > 0 {
            queryParameters["username"] = autorest.Encode("query",username)
        }
        if len(string(typeParameter)) > 0 {
            queryParameters["type"] = autorest.Encode("query",typeParameter)
        }
        if len(string(state)) > 0 {
            queryParameters["state"] = autorest.Encode("query",state)
        }
        if len(fullName) > 0 {
            queryParameters["fullName"] = autorest.Encode("query",fullName)
        }
        if page != nil {
            queryParameters["page"] = autorest.Encode("query",*page)
        }
        if pageSize != nil {
            queryParameters["pageSize"] = autorest.Encode("query",*pageSize)
        }
        if len(string(sortOrder)) > 0 {
            queryParameters["sortOrder"] = autorest.Encode("query",sortOrder)
        }
        if len(string(sortBy)) > 0 {
            queryParameters["sortBy"] = autorest.Encode("query",sortBy)
        }

        preparer := autorest.CreatePreparer(
            autorest.AsGet(),
            autorest.WithBaseURL(client.BaseURI),
            autorest.WithPath("/v1/directory/users"),
            autorest.WithQueryParameters(queryParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
    }

    // GetUsersByFilterSender sends the GetUsersByFilter request. The method will close the
    // http.Response Body if it receives an error.
    func (client BaseClient) GetUsersByFilterSender(req *http.Request) (*http.Response, error) {
        return autorest.SendWithSender(client, req,
            autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
    }

    // GetUsersByFilterResponder handles the response to the GetUsersByFilter request. The method always
    // closes the http.Response Body.
    func (client BaseClient) GetUsersByFilterResponder(resp *http.Response) (result ListUserModel, err error) {
        err = autorest.Respond(
            resp,
            client.ByInspecting(),
            azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusForbidden),
            autorest.ByUnmarshallingJSON(&result.Value),
            autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
        return
    }

    // GetWorkflowByID sends the get workflow by id request.
    //
    // ID is the workflow identifier.
    func (client BaseClient) GetWorkflowByID(ctx context.Context, ID int32) (result WorkflowModel, err error) {
        req, err := client.GetWorkflowByIDPreparer(ctx, ID)
        if err != nil {
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "GetWorkflowByID", nil , "Failure preparing request")
            return
        }

        resp, err := client.GetWorkflowByIDSender(req)
        if err != nil {
            result.Response = autorest.Response{Response: resp}
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "GetWorkflowByID", resp, "Failure sending request")
            return
        }

        result, err = client.GetWorkflowByIDResponder(resp)
        if err != nil {
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "GetWorkflowByID", resp, "Failure responding to request")
        }

        return
    }

    // GetWorkflowByIDPreparer prepares the GetWorkflowByID request.
    func (client BaseClient) GetWorkflowByIDPreparer(ctx context.Context, ID int32) (*http.Request, error) {
        pathParameters := map[string]interface{} {
        "id": autorest.Encode("path",ID),
        }

        preparer := autorest.CreatePreparer(
            autorest.AsGet(),
            autorest.WithBaseURL(client.BaseURI),
            autorest.WithPathParameters("/v1/workflow/workflows/{id}",pathParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
    }

    // GetWorkflowByIDSender sends the GetWorkflowByID request. The method will close the
    // http.Response Body if it receives an error.
    func (client BaseClient) GetWorkflowByIDSender(req *http.Request) (*http.Response, error) {
        return autorest.SendWithSender(client, req,
            autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
    }

    // GetWorkflowByIDResponder handles the response to the GetWorkflowByID request. The method always
    // closes the http.Response Body.
    func (client BaseClient) GetWorkflowByIDResponder(resp *http.Response) (result WorkflowModel, err error) {
        err = autorest.Respond(
            resp,
            client.ByInspecting(),
            azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusNotFound),
            autorest.ByUnmarshallingJSON(&result),
            autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
        return
    }

    // GetWorkflowQueuesByID sends the get workflow queues by id request.
    //
    // ID is the workflow identifier.
    func (client BaseClient) GetWorkflowQueuesByID(ctx context.Context, ID int32) (result ListWorkflowQueueModel, err error) {
        req, err := client.GetWorkflowQueuesByIDPreparer(ctx, ID)
        if err != nil {
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "GetWorkflowQueuesByID", nil , "Failure preparing request")
            return
        }

        resp, err := client.GetWorkflowQueuesByIDSender(req)
        if err != nil {
            result.Response = autorest.Response{Response: resp}
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "GetWorkflowQueuesByID", resp, "Failure sending request")
            return
        }

        result, err = client.GetWorkflowQueuesByIDResponder(resp)
        if err != nil {
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "GetWorkflowQueuesByID", resp, "Failure responding to request")
        }

        return
    }

    // GetWorkflowQueuesByIDPreparer prepares the GetWorkflowQueuesByID request.
    func (client BaseClient) GetWorkflowQueuesByIDPreparer(ctx context.Context, ID int32) (*http.Request, error) {
        pathParameters := map[string]interface{} {
        "id": autorest.Encode("path",ID),
        }

        preparer := autorest.CreatePreparer(
            autorest.AsGet(),
            autorest.WithBaseURL(client.BaseURI),
            autorest.WithPathParameters("/v1/workflow/workflows/{id}/queue",pathParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
    }

    // GetWorkflowQueuesByIDSender sends the GetWorkflowQueuesByID request. The method will close the
    // http.Response Body if it receives an error.
    func (client BaseClient) GetWorkflowQueuesByIDSender(req *http.Request) (*http.Response, error) {
        return autorest.SendWithSender(client, req,
            autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
    }

    // GetWorkflowQueuesByIDResponder handles the response to the GetWorkflowQueuesByID request. The method always
    // closes the http.Response Body.
    func (client BaseClient) GetWorkflowQueuesByIDResponder(resp *http.Response) (result ListWorkflowQueueModel, err error) {
        err = autorest.Respond(
            resp,
            client.ByInspecting(),
            azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusNotFound),
            autorest.ByUnmarshallingJSON(&result.Value),
            autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
        return
    }

    // GetWorkflowsByFilter sends the get workflows by filter request.
    //
    // applicationID is gets or sets the application identifier. entityType is gets or sets the type of the entity. name is
    // gets or sets the name. page is gets or sets the page number. pageSize is gets or sets the size of the page.
    // sortOrder is gets or sets the order. sortBy is gets or sets the column to order by.
    func (client BaseClient) GetWorkflowsByFilter(ctx context.Context, applicationID *int32, entityType *int32, name string, page *int32, pageSize *int32, sortOrder string, sortBy *int32) (result ListWorkflowModel, err error) {
        if err := validation.Validate([]validation.Validation{
        { TargetValue: applicationID,
         Constraints: []validation.Constraint{	{Target: "applicationID", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "applicationID", Name: validation.InclusiveMaximum, Rule: 2147483647, Chain: nil },
        	{Target: "applicationID", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil },
        }}}},
        { TargetValue: entityType,
         Constraints: []validation.Constraint{	{Target: "entityType", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "entityType", Name: validation.InclusiveMaximum, Rule: 2147483647, Chain: nil },
        	{Target: "entityType", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil },
        }}}},
        { TargetValue: name,
         Constraints: []validation.Constraint{	{Target: "name", Name: validation.MaxLength, Rule: 255, Chain: nil },
        	{Target: "name", Name: validation.MinLength, Rule: 0, Chain: nil }}},
        { TargetValue: page,
         Constraints: []validation.Constraint{	{Target: "page", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "page", Name: validation.InclusiveMaximum, Rule: 2147483647, Chain: nil },
        	{Target: "page", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil },
        }}}},
        { TargetValue: pageSize,
         Constraints: []validation.Constraint{	{Target: "pageSize", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "pageSize", Name: validation.InclusiveMaximum, Rule: 1000, Chain: nil },
        	{Target: "pageSize", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil },
        }}}}}); err != nil {
            return result, validation.NewErrorWithValidationError(err, "softheonenterpriseapiclient.BaseClient","GetWorkflowsByFilter")
        }

        req, err := client.GetWorkflowsByFilterPreparer(ctx, applicationID, entityType, name, page, pageSize, sortOrder, sortBy)
        if err != nil {
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "GetWorkflowsByFilter", nil , "Failure preparing request")
            return
        }

        resp, err := client.GetWorkflowsByFilterSender(req)
        if err != nil {
            result.Response = autorest.Response{Response: resp}
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "GetWorkflowsByFilter", resp, "Failure sending request")
            return
        }

        result, err = client.GetWorkflowsByFilterResponder(resp)
        if err != nil {
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "GetWorkflowsByFilter", resp, "Failure responding to request")
        }

        return
    }

    // GetWorkflowsByFilterPreparer prepares the GetWorkflowsByFilter request.
    func (client BaseClient) GetWorkflowsByFilterPreparer(ctx context.Context, applicationID *int32, entityType *int32, name string, page *int32, pageSize *int32, sortOrder string, sortBy *int32) (*http.Request, error) {
        queryParameters := map[string]interface{} {
        }
        if applicationID != nil {
            queryParameters["applicationID"] = autorest.Encode("query",*applicationID)
        }
        if entityType != nil {
            queryParameters["entityType"] = autorest.Encode("query",*entityType)
        }
        if len(name) > 0 {
            queryParameters["name"] = autorest.Encode("query",name)
        }
        if page != nil {
            queryParameters["page"] = autorest.Encode("query",*page)
        }
        if pageSize != nil {
            queryParameters["pageSize"] = autorest.Encode("query",*pageSize)
        }
        if len(string(sortOrder)) > 0 {
            queryParameters["sortOrder"] = autorest.Encode("query",sortOrder)
        }
        if sortBy != nil {
            queryParameters["sortBy"] = autorest.Encode("query",*sortBy)
        }

        preparer := autorest.CreatePreparer(
            autorest.AsGet(),
            autorest.WithBaseURL(client.BaseURI),
            autorest.WithPath("/v1/workflow/workflows"),
            autorest.WithQueryParameters(queryParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
    }

    // GetWorkflowsByFilterSender sends the GetWorkflowsByFilter request. The method will close the
    // http.Response Body if it receives an error.
    func (client BaseClient) GetWorkflowsByFilterSender(req *http.Request) (*http.Response, error) {
        return autorest.SendWithSender(client, req,
            autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
    }

    // GetWorkflowsByFilterResponder handles the response to the GetWorkflowsByFilter request. The method always
    // closes the http.Response Body.
    func (client BaseClient) GetWorkflowsByFilterResponder(resp *http.Response) (result ListWorkflowModel, err error) {
        err = autorest.Respond(
            resp,
            client.ByInspecting(),
            azure.WithErrorUnlessStatusCode(http.StatusOK),
            autorest.ByUnmarshallingJSON(&result.Value),
            autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
        return
    }

    // GetXMLTemplateByType sends the get xml template by type request.
    //
    // typeParameter is the unique template type.
    func (client BaseClient) GetXMLTemplateByType(ctx context.Context, typeParameter int32) (result String, err error) {
        req, err := client.GetXMLTemplateByTypePreparer(ctx, typeParameter)
        if err != nil {
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "GetXMLTemplateByType", nil , "Failure preparing request")
            return
        }

        resp, err := client.GetXMLTemplateByTypeSender(req)
        if err != nil {
            result.Response = autorest.Response{Response: resp}
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "GetXMLTemplateByType", resp, "Failure sending request")
            return
        }

        result, err = client.GetXMLTemplateByTypeResponder(resp)
        if err != nil {
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "GetXMLTemplateByType", resp, "Failure responding to request")
        }

        return
    }

    // GetXMLTemplateByTypePreparer prepares the GetXMLTemplateByType request.
    func (client BaseClient) GetXMLTemplateByTypePreparer(ctx context.Context, typeParameter int32) (*http.Request, error) {
        pathParameters := map[string]interface{} {
        "type": autorest.Encode("path",typeParameter),
        }

        preparer := autorest.CreatePreparer(
            autorest.AsGet(),
            autorest.WithBaseURL(client.BaseURI),
            autorest.WithPathParameters("/v1/template/xml/{type}",pathParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
    }

    // GetXMLTemplateByTypeSender sends the GetXMLTemplateByType request. The method will close the
    // http.Response Body if it receives an error.
    func (client BaseClient) GetXMLTemplateByTypeSender(req *http.Request) (*http.Response, error) {
        return autorest.SendWithSender(client, req,
            autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
    }

    // GetXMLTemplateByTypeResponder handles the response to the GetXMLTemplateByType request. The method always
    // closes the http.Response Body.
    func (client BaseClient) GetXMLTemplateByTypeResponder(resp *http.Response) (result String, err error) {
        err = autorest.Respond(
            resp,
            client.ByInspecting(),
            azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusNotFound),
            autorest.ByUnmarshallingJSON(&result.Value),
            autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
        return
    }

    // InitializeEntityWorkflow sends the initialize entity workflow request.
    //
    // model is the model.
    func (client BaseClient) InitializeEntityWorkflow(ctx context.Context, model WorkflowActionInitializeModel) (result SetObject, err error) {
        if err := validation.Validate([]validation.Validation{
        { TargetValue: model,
         Constraints: []validation.Constraint{	{Target: "model.DrawerID", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "model.DrawerID", Name: validation.InclusiveMaximum, Rule: 2147483647, Chain: nil },
        	{Target: "model.DrawerID", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil },
        }},
        	{Target: "model.EntityID", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "model.EntityID", Name: validation.InclusiveMaximum, Rule: 2147483647, Chain: nil },
        	{Target: "model.EntityID", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil },
        }},
        	{Target: "model.Source", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "model.Source", Name: validation.MaxLength, Rule: 255, Chain: nil },
        	{Target: "model.Source", Name: validation.MinLength, Rule: 0, Chain: nil },
        }},
        	{Target: "model.Computer", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "model.Computer", Name: validation.MaxLength, Rule: 255, Chain: nil },
        	{Target: "model.Computer", Name: validation.MinLength, Rule: 0, Chain: nil },
        }},
        	{Target: "model.IPAddress", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "model.IPAddress", Name: validation.MaxLength, Rule: 255, Chain: nil },
        	{Target: "model.IPAddress", Name: validation.MinLength, Rule: 0, Chain: nil },
        }}}}}); err != nil {
            return result, validation.NewErrorWithValidationError(err, "softheonenterpriseapiclient.BaseClient","InitializeEntityWorkflow")
        }

        req, err := client.InitializeEntityWorkflowPreparer(ctx, model)
        if err != nil {
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "InitializeEntityWorkflow", nil , "Failure preparing request")
            return
        }

        resp, err := client.InitializeEntityWorkflowSender(req)
        if err != nil {
            result.Response = autorest.Response{Response: resp}
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "InitializeEntityWorkflow", resp, "Failure sending request")
            return
        }

        result, err = client.InitializeEntityWorkflowResponder(resp)
        if err != nil {
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "InitializeEntityWorkflow", resp, "Failure responding to request")
        }

        return
    }

    // InitializeEntityWorkflowPreparer prepares the InitializeEntityWorkflow request.
    func (client BaseClient) InitializeEntityWorkflowPreparer(ctx context.Context, model WorkflowActionInitializeModel) (*http.Request, error) {
        preparer := autorest.CreatePreparer(
            autorest.AsJSON(),
            autorest.AsPost(),
            autorest.WithBaseURL(client.BaseURI),
            autorest.WithPath("/v1/workflow/actions/initialize"),
            autorest.WithJSON(model))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
    }

    // InitializeEntityWorkflowSender sends the InitializeEntityWorkflow request. The method will close the
    // http.Response Body if it receives an error.
    func (client BaseClient) InitializeEntityWorkflowSender(req *http.Request) (*http.Response, error) {
        return autorest.SendWithSender(client, req,
            autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
    }

    // InitializeEntityWorkflowResponder handles the response to the InitializeEntityWorkflow request. The method always
    // closes the http.Response Body.
    func (client BaseClient) InitializeEntityWorkflowResponder(resp *http.Response) (result SetObject, err error) {
        err = autorest.Respond(
            resp,
            client.ByInspecting(),
            azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusNoContent,http.StatusForbidden,http.StatusNotFound),
            autorest.ByUnmarshallingJSON(&result.Value),
            autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
        return
    }

    // OverrideTask sends the override task request.
    //
    // model is the model.
    func (client BaseClient) OverrideTask(ctx context.Context, model WorkflowActionModel) (result SetObject, err error) {
        if err := validation.Validate([]validation.Validation{
        { TargetValue: model,
         Constraints: []validation.Constraint{	{Target: "model.TaskID", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "model.TaskID", Name: validation.InclusiveMaximum, Rule: 2147483647, Chain: nil },
        	{Target: "model.TaskID", Name: validation.InclusiveMinimum, Rule: 0, Chain: nil },
        }},
        	{Target: "model.TargetID", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "model.TargetID", Name: validation.InclusiveMaximum, Rule: 2147483647, Chain: nil },
        	{Target: "model.TargetID", Name: validation.InclusiveMinimum, Rule: 0, Chain: nil },
        }},
        	{Target: "model.QueueName", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "model.QueueName", Name: validation.MaxLength, Rule: 255, Chain: nil },
        	{Target: "model.QueueName", Name: validation.MinLength, Rule: 0, Chain: nil },
        }},
        	{Target: "model.Source", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "model.Source", Name: validation.MaxLength, Rule: 255, Chain: nil },
        	{Target: "model.Source", Name: validation.MinLength, Rule: 0, Chain: nil },
        }},
        	{Target: "model.Computer", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "model.Computer", Name: validation.MaxLength, Rule: 255, Chain: nil },
        	{Target: "model.Computer", Name: validation.MinLength, Rule: 0, Chain: nil },
        }},
        	{Target: "model.IPAddress", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "model.IPAddress", Name: validation.MaxLength, Rule: 255, Chain: nil },
        	{Target: "model.IPAddress", Name: validation.MinLength, Rule: 0, Chain: nil },
        }}}}}); err != nil {
            return result, validation.NewErrorWithValidationError(err, "softheonenterpriseapiclient.BaseClient","OverrideTask")
        }

        req, err := client.OverrideTaskPreparer(ctx, model)
        if err != nil {
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "OverrideTask", nil , "Failure preparing request")
            return
        }

        resp, err := client.OverrideTaskSender(req)
        if err != nil {
            result.Response = autorest.Response{Response: resp}
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "OverrideTask", resp, "Failure sending request")
            return
        }

        result, err = client.OverrideTaskResponder(resp)
        if err != nil {
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "OverrideTask", resp, "Failure responding to request")
        }

        return
    }

    // OverrideTaskPreparer prepares the OverrideTask request.
    func (client BaseClient) OverrideTaskPreparer(ctx context.Context, model WorkflowActionModel) (*http.Request, error) {
        preparer := autorest.CreatePreparer(
            autorest.AsJSON(),
            autorest.AsPost(),
            autorest.WithBaseURL(client.BaseURI),
            autorest.WithPath("/v1/workflow/actions/override"),
            autorest.WithJSON(model))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
    }

    // OverrideTaskSender sends the OverrideTask request. The method will close the
    // http.Response Body if it receives an error.
    func (client BaseClient) OverrideTaskSender(req *http.Request) (*http.Response, error) {
        return autorest.SendWithSender(client, req,
            autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
    }

    // OverrideTaskResponder handles the response to the OverrideTask request. The method always
    // closes the http.Response Body.
    func (client BaseClient) OverrideTaskResponder(resp *http.Response) (result SetObject, err error) {
        err = autorest.Respond(
            resp,
            client.ByInspecting(),
            azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusNoContent,http.StatusForbidden,http.StatusNotFound),
            autorest.ByUnmarshallingJSON(&result.Value),
            autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
        return
    }

    // RejectTask sends the reject task request.
    //
    // model is the model.
    func (client BaseClient) RejectTask(ctx context.Context, model WorkflowActionModel) (result SetObject, err error) {
        if err := validation.Validate([]validation.Validation{
        { TargetValue: model,
         Constraints: []validation.Constraint{	{Target: "model.TaskID", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "model.TaskID", Name: validation.InclusiveMaximum, Rule: 2147483647, Chain: nil },
        	{Target: "model.TaskID", Name: validation.InclusiveMinimum, Rule: 0, Chain: nil },
        }},
        	{Target: "model.TargetID", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "model.TargetID", Name: validation.InclusiveMaximum, Rule: 2147483647, Chain: nil },
        	{Target: "model.TargetID", Name: validation.InclusiveMinimum, Rule: 0, Chain: nil },
        }},
        	{Target: "model.QueueName", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "model.QueueName", Name: validation.MaxLength, Rule: 255, Chain: nil },
        	{Target: "model.QueueName", Name: validation.MinLength, Rule: 0, Chain: nil },
        }},
        	{Target: "model.Source", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "model.Source", Name: validation.MaxLength, Rule: 255, Chain: nil },
        	{Target: "model.Source", Name: validation.MinLength, Rule: 0, Chain: nil },
        }},
        	{Target: "model.Computer", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "model.Computer", Name: validation.MaxLength, Rule: 255, Chain: nil },
        	{Target: "model.Computer", Name: validation.MinLength, Rule: 0, Chain: nil },
        }},
        	{Target: "model.IPAddress", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "model.IPAddress", Name: validation.MaxLength, Rule: 255, Chain: nil },
        	{Target: "model.IPAddress", Name: validation.MinLength, Rule: 0, Chain: nil },
        }}}}}); err != nil {
            return result, validation.NewErrorWithValidationError(err, "softheonenterpriseapiclient.BaseClient","RejectTask")
        }

        req, err := client.RejectTaskPreparer(ctx, model)
        if err != nil {
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "RejectTask", nil , "Failure preparing request")
            return
        }

        resp, err := client.RejectTaskSender(req)
        if err != nil {
            result.Response = autorest.Response{Response: resp}
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "RejectTask", resp, "Failure sending request")
            return
        }

        result, err = client.RejectTaskResponder(resp)
        if err != nil {
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "RejectTask", resp, "Failure responding to request")
        }

        return
    }

    // RejectTaskPreparer prepares the RejectTask request.
    func (client BaseClient) RejectTaskPreparer(ctx context.Context, model WorkflowActionModel) (*http.Request, error) {
        preparer := autorest.CreatePreparer(
            autorest.AsJSON(),
            autorest.AsPost(),
            autorest.WithBaseURL(client.BaseURI),
            autorest.WithPath("/v1/workflow/actions/reject"),
            autorest.WithJSON(model))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
    }

    // RejectTaskSender sends the RejectTask request. The method will close the
    // http.Response Body if it receives an error.
    func (client BaseClient) RejectTaskSender(req *http.Request) (*http.Response, error) {
        return autorest.SendWithSender(client, req,
            autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
    }

    // RejectTaskResponder handles the response to the RejectTask request. The method always
    // closes the http.Response Body.
    func (client BaseClient) RejectTaskResponder(resp *http.Response) (result SetObject, err error) {
        err = autorest.Respond(
            resp,
            client.ByInspecting(),
            azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusNoContent,http.StatusForbidden,http.StatusNotFound),
            autorest.ByUnmarshallingJSON(&result.Value),
            autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
        return
    }

    // ResetTask sends the reset task request.
    //
    // model is the model.
    func (client BaseClient) ResetTask(ctx context.Context, model WorkflowActionModel) (result SetObject, err error) {
        if err := validation.Validate([]validation.Validation{
        { TargetValue: model,
         Constraints: []validation.Constraint{	{Target: "model.TaskID", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "model.TaskID", Name: validation.InclusiveMaximum, Rule: 2147483647, Chain: nil },
        	{Target: "model.TaskID", Name: validation.InclusiveMinimum, Rule: 0, Chain: nil },
        }},
        	{Target: "model.TargetID", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "model.TargetID", Name: validation.InclusiveMaximum, Rule: 2147483647, Chain: nil },
        	{Target: "model.TargetID", Name: validation.InclusiveMinimum, Rule: 0, Chain: nil },
        }},
        	{Target: "model.QueueName", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "model.QueueName", Name: validation.MaxLength, Rule: 255, Chain: nil },
        	{Target: "model.QueueName", Name: validation.MinLength, Rule: 0, Chain: nil },
        }},
        	{Target: "model.Source", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "model.Source", Name: validation.MaxLength, Rule: 255, Chain: nil },
        	{Target: "model.Source", Name: validation.MinLength, Rule: 0, Chain: nil },
        }},
        	{Target: "model.Computer", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "model.Computer", Name: validation.MaxLength, Rule: 255, Chain: nil },
        	{Target: "model.Computer", Name: validation.MinLength, Rule: 0, Chain: nil },
        }},
        	{Target: "model.IPAddress", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "model.IPAddress", Name: validation.MaxLength, Rule: 255, Chain: nil },
        	{Target: "model.IPAddress", Name: validation.MinLength, Rule: 0, Chain: nil },
        }}}}}); err != nil {
            return result, validation.NewErrorWithValidationError(err, "softheonenterpriseapiclient.BaseClient","ResetTask")
        }

        req, err := client.ResetTaskPreparer(ctx, model)
        if err != nil {
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "ResetTask", nil , "Failure preparing request")
            return
        }

        resp, err := client.ResetTaskSender(req)
        if err != nil {
            result.Response = autorest.Response{Response: resp}
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "ResetTask", resp, "Failure sending request")
            return
        }

        result, err = client.ResetTaskResponder(resp)
        if err != nil {
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "ResetTask", resp, "Failure responding to request")
        }

        return
    }

    // ResetTaskPreparer prepares the ResetTask request.
    func (client BaseClient) ResetTaskPreparer(ctx context.Context, model WorkflowActionModel) (*http.Request, error) {
        preparer := autorest.CreatePreparer(
            autorest.AsJSON(),
            autorest.AsPost(),
            autorest.WithBaseURL(client.BaseURI),
            autorest.WithPath("/v1/workflow/actions/reset"),
            autorest.WithJSON(model))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
    }

    // ResetTaskSender sends the ResetTask request. The method will close the
    // http.Response Body if it receives an error.
    func (client BaseClient) ResetTaskSender(req *http.Request) (*http.Response, error) {
        return autorest.SendWithSender(client, req,
            autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
    }

    // ResetTaskResponder handles the response to the ResetTask request. The method always
    // closes the http.Response Body.
    func (client BaseClient) ResetTaskResponder(resp *http.Response) (result SetObject, err error) {
        err = autorest.Respond(
            resp,
            client.ByInspecting(),
            azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusNoContent,http.StatusForbidden,http.StatusNotFound),
            autorest.ByUnmarshallingJSON(&result.Value),
            autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
        return
    }

    // RollbackAttachmentVersion sends the rollback attachment version request.
    //
    // drawer is the drawer identifier. ID is the attachment identifier. versionID is the version identifier.
    func (client BaseClient) RollbackAttachmentVersion(ctx context.Context, drawer int32, ID int32, versionID int32) (result SetObject, err error) {
        req, err := client.RollbackAttachmentVersionPreparer(ctx, drawer, ID, versionID)
        if err != nil {
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "RollbackAttachmentVersion", nil , "Failure preparing request")
            return
        }

        resp, err := client.RollbackAttachmentVersionSender(req)
        if err != nil {
            result.Response = autorest.Response{Response: resp}
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "RollbackAttachmentVersion", resp, "Failure sending request")
            return
        }

        result, err = client.RollbackAttachmentVersionResponder(resp)
        if err != nil {
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "RollbackAttachmentVersion", resp, "Failure responding to request")
        }

        return
    }

    // RollbackAttachmentVersionPreparer prepares the RollbackAttachmentVersion request.
    func (client BaseClient) RollbackAttachmentVersionPreparer(ctx context.Context, drawer int32, ID int32, versionID int32) (*http.Request, error) {
        pathParameters := map[string]interface{} {
        "drawer": autorest.Encode("path",drawer),
        "id": autorest.Encode("path",ID),
        "versionID": autorest.Encode("path",versionID),
        }

        preparer := autorest.CreatePreparer(
            autorest.AsPut(),
            autorest.WithBaseURL(client.BaseURI),
            autorest.WithPathParameters("/v1/content/attachments/{drawer}/{id}/rollback/{versionID}",pathParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
    }

    // RollbackAttachmentVersionSender sends the RollbackAttachmentVersion request. The method will close the
    // http.Response Body if it receives an error.
    func (client BaseClient) RollbackAttachmentVersionSender(req *http.Request) (*http.Response, error) {
        return autorest.SendWithSender(client, req,
            autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
    }

    // RollbackAttachmentVersionResponder handles the response to the RollbackAttachmentVersion request. The method always
    // closes the http.Response Body.
    func (client BaseClient) RollbackAttachmentVersionResponder(resp *http.Response) (result SetObject, err error) {
        err = autorest.Respond(
            resp,
            client.ByInspecting(),
            azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusNoContent,http.StatusBadRequest,http.StatusForbidden,http.StatusNotFound),
            autorest.ByUnmarshallingJSON(&result.Value),
            autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
        return
    }

    // RouteTask sends the route task request.
    //
    // model is the model.
    func (client BaseClient) RouteTask(ctx context.Context, model WorkflowActionRouteModel) (result SetObject, err error) {
        if err := validation.Validate([]validation.Validation{
        { TargetValue: model,
         Constraints: []validation.Constraint{	{Target: "model.TaskID", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "model.TaskID", Name: validation.InclusiveMaximum, Rule: 2147483647, Chain: nil },
        	{Target: "model.TaskID", Name: validation.InclusiveMinimum, Rule: 0, Chain: nil },
        }},
        	{Target: "model.TargetID", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "model.TargetID", Name: validation.InclusiveMaximum, Rule: 2147483647, Chain: nil },
        	{Target: "model.TargetID", Name: validation.InclusiveMinimum, Rule: 0, Chain: nil },
        }},
        	{Target: "model.QueueName", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "model.QueueName", Name: validation.MaxLength, Rule: 255, Chain: nil },
        	{Target: "model.QueueName", Name: validation.MinLength, Rule: 0, Chain: nil },
        }},
        	{Target: "model.Source", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "model.Source", Name: validation.MaxLength, Rule: 255, Chain: nil },
        	{Target: "model.Source", Name: validation.MinLength, Rule: 0, Chain: nil },
        }},
        	{Target: "model.Computer", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "model.Computer", Name: validation.MaxLength, Rule: 255, Chain: nil },
        	{Target: "model.Computer", Name: validation.MinLength, Rule: 0, Chain: nil },
        }},
        	{Target: "model.IPAddress", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "model.IPAddress", Name: validation.MaxLength, Rule: 255, Chain: nil },
        	{Target: "model.IPAddress", Name: validation.MinLength, Rule: 0, Chain: nil },
        }}}}}); err != nil {
            return result, validation.NewErrorWithValidationError(err, "softheonenterpriseapiclient.BaseClient","RouteTask")
        }

        req, err := client.RouteTaskPreparer(ctx, model)
        if err != nil {
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "RouteTask", nil , "Failure preparing request")
            return
        }

        resp, err := client.RouteTaskSender(req)
        if err != nil {
            result.Response = autorest.Response{Response: resp}
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "RouteTask", resp, "Failure sending request")
            return
        }

        result, err = client.RouteTaskResponder(resp)
        if err != nil {
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "RouteTask", resp, "Failure responding to request")
        }

        return
    }

    // RouteTaskPreparer prepares the RouteTask request.
    func (client BaseClient) RouteTaskPreparer(ctx context.Context, model WorkflowActionRouteModel) (*http.Request, error) {
        preparer := autorest.CreatePreparer(
            autorest.AsJSON(),
            autorest.AsPost(),
            autorest.WithBaseURL(client.BaseURI),
            autorest.WithPath("/v1/workflow/actions/route"),
            autorest.WithJSON(model))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
    }

    // RouteTaskSender sends the RouteTask request. The method will close the
    // http.Response Body if it receives an error.
    func (client BaseClient) RouteTaskSender(req *http.Request) (*http.Response, error) {
        return autorest.SendWithSender(client, req,
            autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
    }

    // RouteTaskResponder handles the response to the RouteTask request. The method always
    // closes the http.Response Body.
    func (client BaseClient) RouteTaskResponder(resp *http.Response) (result SetObject, err error) {
        err = autorest.Respond(
            resp,
            client.ByInspecting(),
            azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusNoContent,http.StatusForbidden,http.StatusNotFound),
            autorest.ByUnmarshallingJSON(&result.Value),
            autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
        return
    }

    // SuspendTask sends the suspend task request.
    //
    // model is the model.
    func (client BaseClient) SuspendTask(ctx context.Context, model WorkflowActionModel) (result SetObject, err error) {
        if err := validation.Validate([]validation.Validation{
        { TargetValue: model,
         Constraints: []validation.Constraint{	{Target: "model.TaskID", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "model.TaskID", Name: validation.InclusiveMaximum, Rule: 2147483647, Chain: nil },
        	{Target: "model.TaskID", Name: validation.InclusiveMinimum, Rule: 0, Chain: nil },
        }},
        	{Target: "model.TargetID", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "model.TargetID", Name: validation.InclusiveMaximum, Rule: 2147483647, Chain: nil },
        	{Target: "model.TargetID", Name: validation.InclusiveMinimum, Rule: 0, Chain: nil },
        }},
        	{Target: "model.QueueName", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "model.QueueName", Name: validation.MaxLength, Rule: 255, Chain: nil },
        	{Target: "model.QueueName", Name: validation.MinLength, Rule: 0, Chain: nil },
        }},
        	{Target: "model.Source", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "model.Source", Name: validation.MaxLength, Rule: 255, Chain: nil },
        	{Target: "model.Source", Name: validation.MinLength, Rule: 0, Chain: nil },
        }},
        	{Target: "model.Computer", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "model.Computer", Name: validation.MaxLength, Rule: 255, Chain: nil },
        	{Target: "model.Computer", Name: validation.MinLength, Rule: 0, Chain: nil },
        }},
        	{Target: "model.IPAddress", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "model.IPAddress", Name: validation.MaxLength, Rule: 255, Chain: nil },
        	{Target: "model.IPAddress", Name: validation.MinLength, Rule: 0, Chain: nil },
        }}}}}); err != nil {
            return result, validation.NewErrorWithValidationError(err, "softheonenterpriseapiclient.BaseClient","SuspendTask")
        }

        req, err := client.SuspendTaskPreparer(ctx, model)
        if err != nil {
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "SuspendTask", nil , "Failure preparing request")
            return
        }

        resp, err := client.SuspendTaskSender(req)
        if err != nil {
            result.Response = autorest.Response{Response: resp}
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "SuspendTask", resp, "Failure sending request")
            return
        }

        result, err = client.SuspendTaskResponder(resp)
        if err != nil {
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "SuspendTask", resp, "Failure responding to request")
        }

        return
    }

    // SuspendTaskPreparer prepares the SuspendTask request.
    func (client BaseClient) SuspendTaskPreparer(ctx context.Context, model WorkflowActionModel) (*http.Request, error) {
        preparer := autorest.CreatePreparer(
            autorest.AsJSON(),
            autorest.AsPost(),
            autorest.WithBaseURL(client.BaseURI),
            autorest.WithPath("/v1/workflow/actions/suspend"),
            autorest.WithJSON(model))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
    }

    // SuspendTaskSender sends the SuspendTask request. The method will close the
    // http.Response Body if it receives an error.
    func (client BaseClient) SuspendTaskSender(req *http.Request) (*http.Response, error) {
        return autorest.SendWithSender(client, req,
            autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
    }

    // SuspendTaskResponder handles the response to the SuspendTask request. The method always
    // closes the http.Response Body.
    func (client BaseClient) SuspendTaskResponder(resp *http.Response) (result SetObject, err error) {
        err = autorest.Respond(
            resp,
            client.ByInspecting(),
            azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusNoContent,http.StatusForbidden,http.StatusNotFound),
            autorest.ByUnmarshallingJSON(&result.Value),
            autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
        return
    }

    // UndoCheckOutAttachment sends the undo check out attachment request.
    //
    // drawer is the drawer identifier. ID is the attachment identifier.
    func (client BaseClient) UndoCheckOutAttachment(ctx context.Context, drawer int32, ID int32) (result SetObject, err error) {
        req, err := client.UndoCheckOutAttachmentPreparer(ctx, drawer, ID)
        if err != nil {
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "UndoCheckOutAttachment", nil , "Failure preparing request")
            return
        }

        resp, err := client.UndoCheckOutAttachmentSender(req)
        if err != nil {
            result.Response = autorest.Response{Response: resp}
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "UndoCheckOutAttachment", resp, "Failure sending request")
            return
        }

        result, err = client.UndoCheckOutAttachmentResponder(resp)
        if err != nil {
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "UndoCheckOutAttachment", resp, "Failure responding to request")
        }

        return
    }

    // UndoCheckOutAttachmentPreparer prepares the UndoCheckOutAttachment request.
    func (client BaseClient) UndoCheckOutAttachmentPreparer(ctx context.Context, drawer int32, ID int32) (*http.Request, error) {
        pathParameters := map[string]interface{} {
        "drawer": autorest.Encode("path",drawer),
        "id": autorest.Encode("path",ID),
        }

        preparer := autorest.CreatePreparer(
            autorest.AsDelete(),
            autorest.WithBaseURL(client.BaseURI),
            autorest.WithPathParameters("/v1/content/attachments/{drawer}/{id}/checkout",pathParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
    }

    // UndoCheckOutAttachmentSender sends the UndoCheckOutAttachment request. The method will close the
    // http.Response Body if it receives an error.
    func (client BaseClient) UndoCheckOutAttachmentSender(req *http.Request) (*http.Response, error) {
        return autorest.SendWithSender(client, req,
            autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
    }

    // UndoCheckOutAttachmentResponder handles the response to the UndoCheckOutAttachment request. The method always
    // closes the http.Response Body.
    func (client BaseClient) UndoCheckOutAttachmentResponder(resp *http.Response) (result SetObject, err error) {
        err = autorest.Respond(
            resp,
            client.ByInspecting(),
            azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusNoContent,http.StatusBadRequest,http.StatusForbidden,http.StatusNotFound),
            autorest.ByUnmarshallingJSON(&result.Value),
            autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
        return
    }

    // UpdateAttachment sends the update attachment request.
    //
    // drawer is the drawer identifier. ID is the attachment identifier. model is the model.
    func (client BaseClient) UpdateAttachment(ctx context.Context, drawer int32, ID int32, model UpdateAttachmentRequestModel) (result SetObject, err error) {
        if err := validation.Validate([]validation.Validation{
        { TargetValue: model,
         Constraints: []validation.Constraint{	{Target: "model.Name", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "model.Name", Name: validation.MaxLength, Rule: 255, Chain: nil },
        	{Target: "model.Name", Name: validation.MinLength, Rule: 0, Chain: nil },
        }},
        	{Target: "model.PageNumber", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "model.PageNumber", Name: validation.InclusiveMaximum, Rule: 2147483647, Chain: nil },
        	{Target: "model.PageNumber", Name: validation.InclusiveMinimum, Rule: 0, Chain: nil },
        }},
        	{Target: "model.Note", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "model.Note", Name: validation.MaxLength, Rule: 255, Chain: nil },
        	{Target: "model.Note", Name: validation.MinLength, Rule: 0, Chain: nil },
        }}}}}); err != nil {
            return result, validation.NewErrorWithValidationError(err, "softheonenterpriseapiclient.BaseClient","UpdateAttachment")
        }

        req, err := client.UpdateAttachmentPreparer(ctx, drawer, ID, model)
        if err != nil {
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "UpdateAttachment", nil , "Failure preparing request")
            return
        }

        resp, err := client.UpdateAttachmentSender(req)
        if err != nil {
            result.Response = autorest.Response{Response: resp}
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "UpdateAttachment", resp, "Failure sending request")
            return
        }

        result, err = client.UpdateAttachmentResponder(resp)
        if err != nil {
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "UpdateAttachment", resp, "Failure responding to request")
        }

        return
    }

    // UpdateAttachmentPreparer prepares the UpdateAttachment request.
    func (client BaseClient) UpdateAttachmentPreparer(ctx context.Context, drawer int32, ID int32, model UpdateAttachmentRequestModel) (*http.Request, error) {
        pathParameters := map[string]interface{} {
        "drawer": autorest.Encode("path",drawer),
        "id": autorest.Encode("path",ID),
        }

        preparer := autorest.CreatePreparer(
            autorest.AsJSON(),
            autorest.AsPut(),
            autorest.WithBaseURL(client.BaseURI),
            autorest.WithPathParameters("/v1/content/attachments/{drawer}/{id}",pathParameters),
            autorest.WithJSON(model))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
    }

    // UpdateAttachmentSender sends the UpdateAttachment request. The method will close the
    // http.Response Body if it receives an error.
    func (client BaseClient) UpdateAttachmentSender(req *http.Request) (*http.Response, error) {
        return autorest.SendWithSender(client, req,
            autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
    }

    // UpdateAttachmentResponder handles the response to the UpdateAttachment request. The method always
    // closes the http.Response Body.
    func (client BaseClient) UpdateAttachmentResponder(resp *http.Response) (result SetObject, err error) {
        err = autorest.Respond(
            resp,
            client.ByInspecting(),
            azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusNoContent,http.StatusForbidden,http.StatusNotFound),
            autorest.ByUnmarshallingJSON(&result.Value),
            autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
        return
    }

    // UpdateDrawer sends the update drawer request.
    //
    // ID is the drawer identifier. model is the model.
    func (client BaseClient) UpdateDrawer(ctx context.Context, ID int32, model DrawerBase) (result SetObject, err error) {
        if err := validation.Validate([]validation.Validation{
        { TargetValue: model,
         Constraints: []validation.Constraint{	{Target: "model.Name", Name: validation.Null, Rule: true ,
        Chain: []validation.Constraint{	{Target: "model.Name", Name: validation.MaxLength, Rule: 255, Chain: nil },
        	{Target: "model.Name", Name: validation.MinLength, Rule: 0, Chain: nil },
        }},
        	{Target: "model.Edition", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "model.Edition", Name: validation.InclusiveMaximum, Rule: 2147483647, Chain: nil },
        	{Target: "model.Edition", Name: validation.InclusiveMinimum, Rule: 0, Chain: nil },
        }},
        	{Target: "model.ReservedString1", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "model.ReservedString1", Name: validation.MaxLength, Rule: 255, Chain: nil },
        	{Target: "model.ReservedString1", Name: validation.MinLength, Rule: 0, Chain: nil },
        }},
        	{Target: "model.ReservedString2", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "model.ReservedString2", Name: validation.MaxLength, Rule: 255, Chain: nil },
        	{Target: "model.ReservedString2", Name: validation.MinLength, Rule: 0, Chain: nil },
        }}}}}); err != nil {
            return result, validation.NewErrorWithValidationError(err, "softheonenterpriseapiclient.BaseClient","UpdateDrawer")
        }

        req, err := client.UpdateDrawerPreparer(ctx, ID, model)
        if err != nil {
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "UpdateDrawer", nil , "Failure preparing request")
            return
        }

        resp, err := client.UpdateDrawerSender(req)
        if err != nil {
            result.Response = autorest.Response{Response: resp}
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "UpdateDrawer", resp, "Failure sending request")
            return
        }

        result, err = client.UpdateDrawerResponder(resp)
        if err != nil {
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "UpdateDrawer", resp, "Failure responding to request")
        }

        return
    }

    // UpdateDrawerPreparer prepares the UpdateDrawer request.
    func (client BaseClient) UpdateDrawerPreparer(ctx context.Context, ID int32, model DrawerBase) (*http.Request, error) {
        pathParameters := map[string]interface{} {
        "id": autorest.Encode("path",ID),
        }

        preparer := autorest.CreatePreparer(
            autorest.AsJSON(),
            autorest.AsPut(),
            autorest.WithBaseURL(client.BaseURI),
            autorest.WithPathParameters("/v1/directory/drawers/{id}",pathParameters),
            autorest.WithJSON(model))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
    }

    // UpdateDrawerSender sends the UpdateDrawer request. The method will close the
    // http.Response Body if it receives an error.
    func (client BaseClient) UpdateDrawerSender(req *http.Request) (*http.Response, error) {
        return autorest.SendWithSender(client, req,
            autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
    }

    // UpdateDrawerResponder handles the response to the UpdateDrawer request. The method always
    // closes the http.Response Body.
    func (client BaseClient) UpdateDrawerResponder(resp *http.Response) (result SetObject, err error) {
        err = autorest.Respond(
            resp,
            client.ByInspecting(),
            azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusNoContent,http.StatusForbidden,http.StatusNotFound),
            autorest.ByUnmarshallingJSON(&result.Value),
            autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
        return
    }

    // UpdateEntity sends the update entity request.
    //
    // drawer is the drawer identifier. ID is the entity identifier. model is the entity model.
    func (client BaseClient) UpdateEntity(ctx context.Context, drawer int32, ID int32, model UpdateEntityRequestModel) (result SetObject, err error) {
        if err := validation.Validate([]validation.Validation{
        { TargetValue: model,
         Constraints: []validation.Constraint{	{Target: "model.Name", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "model.Name", Name: validation.MaxLength, Rule: 255, Chain: nil },
        	{Target: "model.Name", Name: validation.MinLength, Rule: 0, Chain: nil },
        }}}}}); err != nil {
            return result, validation.NewErrorWithValidationError(err, "softheonenterpriseapiclient.BaseClient","UpdateEntity")
        }

        req, err := client.UpdateEntityPreparer(ctx, drawer, ID, model)
        if err != nil {
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "UpdateEntity", nil , "Failure preparing request")
            return
        }

        resp, err := client.UpdateEntitySender(req)
        if err != nil {
            result.Response = autorest.Response{Response: resp}
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "UpdateEntity", resp, "Failure sending request")
            return
        }

        result, err = client.UpdateEntityResponder(resp)
        if err != nil {
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "UpdateEntity", resp, "Failure responding to request")
        }

        return
    }

    // UpdateEntityPreparer prepares the UpdateEntity request.
    func (client BaseClient) UpdateEntityPreparer(ctx context.Context, drawer int32, ID int32, model UpdateEntityRequestModel) (*http.Request, error) {
        pathParameters := map[string]interface{} {
        "drawer": autorest.Encode("path",drawer),
        "id": autorest.Encode("path",ID),
        }

        preparer := autorest.CreatePreparer(
            autorest.AsJSON(),
            autorest.AsPut(),
            autorest.WithBaseURL(client.BaseURI),
            autorest.WithPathParameters("/v1/content/entities/{drawer}/{id}",pathParameters),
            autorest.WithJSON(model))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
    }

    // UpdateEntitySender sends the UpdateEntity request. The method will close the
    // http.Response Body if it receives an error.
    func (client BaseClient) UpdateEntitySender(req *http.Request) (*http.Response, error) {
        return autorest.SendWithSender(client, req,
            autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
    }

    // UpdateEntityResponder handles the response to the UpdateEntity request. The method always
    // closes the http.Response Body.
    func (client BaseClient) UpdateEntityResponder(resp *http.Response) (result SetObject, err error) {
        err = autorest.Respond(
            resp,
            client.ByInspecting(),
            azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusNoContent,http.StatusForbidden,http.StatusNotFound),
            autorest.ByUnmarshallingJSON(&result.Value),
            autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
        return
    }

    // UpdateGroup sends the update group request.
    //
    // ID is the group identifier. model is the group model.
    func (client BaseClient) UpdateGroup(ctx context.Context, ID int32, model GroupBase) (result SetObject, err error) {
        if err := validation.Validate([]validation.Validation{
        { TargetValue: model,
         Constraints: []validation.Constraint{	{Target: "model.Name", Name: validation.Null, Rule: true ,
        Chain: []validation.Constraint{	{Target: "model.Name", Name: validation.MaxLength, Rule: 255, Chain: nil },
        	{Target: "model.Name", Name: validation.MinLength, Rule: 0, Chain: nil },
        }},
        	{Target: "model.ReservedString1", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "model.ReservedString1", Name: validation.MaxLength, Rule: 255, Chain: nil },
        	{Target: "model.ReservedString1", Name: validation.MinLength, Rule: 0, Chain: nil },
        }},
        	{Target: "model.ReservedString2", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "model.ReservedString2", Name: validation.MaxLength, Rule: 255, Chain: nil },
        	{Target: "model.ReservedString2", Name: validation.MinLength, Rule: 0, Chain: nil },
        }}}}}); err != nil {
            return result, validation.NewErrorWithValidationError(err, "softheonenterpriseapiclient.BaseClient","UpdateGroup")
        }

        req, err := client.UpdateGroupPreparer(ctx, ID, model)
        if err != nil {
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "UpdateGroup", nil , "Failure preparing request")
            return
        }

        resp, err := client.UpdateGroupSender(req)
        if err != nil {
            result.Response = autorest.Response{Response: resp}
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "UpdateGroup", resp, "Failure sending request")
            return
        }

        result, err = client.UpdateGroupResponder(resp)
        if err != nil {
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "UpdateGroup", resp, "Failure responding to request")
        }

        return
    }

    // UpdateGroupPreparer prepares the UpdateGroup request.
    func (client BaseClient) UpdateGroupPreparer(ctx context.Context, ID int32, model GroupBase) (*http.Request, error) {
        pathParameters := map[string]interface{} {
        "id": autorest.Encode("path",ID),
        }

        preparer := autorest.CreatePreparer(
            autorest.AsJSON(),
            autorest.AsPut(),
            autorest.WithBaseURL(client.BaseURI),
            autorest.WithPathParameters("/v1/directory/groups/{id}",pathParameters),
            autorest.WithJSON(model))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
    }

    // UpdateGroupSender sends the UpdateGroup request. The method will close the
    // http.Response Body if it receives an error.
    func (client BaseClient) UpdateGroupSender(req *http.Request) (*http.Response, error) {
        return autorest.SendWithSender(client, req,
            autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
    }

    // UpdateGroupResponder handles the response to the UpdateGroup request. The method always
    // closes the http.Response Body.
    func (client BaseClient) UpdateGroupResponder(resp *http.Response) (result SetObject, err error) {
        err = autorest.Respond(
            resp,
            client.ByInspecting(),
            azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusNoContent,http.StatusForbidden,http.StatusNotFound,http.StatusInternalServerError),
            autorest.ByUnmarshallingJSON(&result.Value),
            autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
        return
    }

    // UpdateLink sends the update link request.
    //
    // drawer is the drawer identifier. ID is the link identifier. model is the model.
    func (client BaseClient) UpdateLink(ctx context.Context, drawer int32, ID int32, model UpdateEntityLinkRequestModel) (result SetObject, err error) {
        if err := validation.Validate([]validation.Validation{
        { TargetValue: model,
         Constraints: []validation.Constraint{	{Target: "model.VirtualName", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "model.VirtualName", Name: validation.MaxLength, Rule: 255, Chain: nil },
        	{Target: "model.VirtualName", Name: validation.MinLength, Rule: 0, Chain: nil },
        }},
        	{Target: "model.Name", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "model.Name", Name: validation.MaxLength, Rule: 255, Chain: nil },
        	{Target: "model.Name", Name: validation.MinLength, Rule: 0, Chain: nil },
        }},
        	{Target: "model.PageNumber", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "model.PageNumber", Name: validation.InclusiveMaximum, Rule: 2147483647, Chain: nil },
        	{Target: "model.PageNumber", Name: validation.InclusiveMinimum, Rule: 0, Chain: nil },
        }},
        	{Target: "model.Note", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "model.Note", Name: validation.MaxLength, Rule: 255, Chain: nil },
        	{Target: "model.Note", Name: validation.MinLength, Rule: 0, Chain: nil },
        }}}}}); err != nil {
            return result, validation.NewErrorWithValidationError(err, "softheonenterpriseapiclient.BaseClient","UpdateLink")
        }

        req, err := client.UpdateLinkPreparer(ctx, drawer, ID, model)
        if err != nil {
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "UpdateLink", nil , "Failure preparing request")
            return
        }

        resp, err := client.UpdateLinkSender(req)
        if err != nil {
            result.Response = autorest.Response{Response: resp}
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "UpdateLink", resp, "Failure sending request")
            return
        }

        result, err = client.UpdateLinkResponder(resp)
        if err != nil {
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "UpdateLink", resp, "Failure responding to request")
        }

        return
    }

    // UpdateLinkPreparer prepares the UpdateLink request.
    func (client BaseClient) UpdateLinkPreparer(ctx context.Context, drawer int32, ID int32, model UpdateEntityLinkRequestModel) (*http.Request, error) {
        pathParameters := map[string]interface{} {
        "drawer": autorest.Encode("path",drawer),
        "id": autorest.Encode("path",ID),
        }

        preparer := autorest.CreatePreparer(
            autorest.AsJSON(),
            autorest.AsPut(),
            autorest.WithBaseURL(client.BaseURI),
            autorest.WithPathParameters("/v1/content/links/{drawer}/{id}",pathParameters),
            autorest.WithJSON(model))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
    }

    // UpdateLinkSender sends the UpdateLink request. The method will close the
    // http.Response Body if it receives an error.
    func (client BaseClient) UpdateLinkSender(req *http.Request) (*http.Response, error) {
        return autorest.SendWithSender(client, req,
            autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
    }

    // UpdateLinkResponder handles the response to the UpdateLink request. The method always
    // closes the http.Response Body.
    func (client BaseClient) UpdateLinkResponder(resp *http.Response) (result SetObject, err error) {
        err = autorest.Respond(
            resp,
            client.ByInspecting(),
            azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusNoContent,http.StatusForbidden,http.StatusNotFound),
            autorest.ByUnmarshallingJSON(&result.Value),
            autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
        return
    }

    // UpdateNote sends the update note request.
    //
    // drawer is the drawer identifier. ID is the note identifier. model is the note model.
    func (client BaseClient) UpdateNote(ctx context.Context, drawer int32, ID int32, model NoteBase) (result SetObject, err error) {
        if err := validation.Validate([]validation.Validation{
        { TargetValue: model,
         Constraints: []validation.Constraint{	{Target: "model.Name", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "model.Name", Name: validation.MaxLength, Rule: 255, Chain: nil },
        	{Target: "model.Name", Name: validation.MinLength, Rule: 0, Chain: nil },
        }},
        	{Target: "model.Note", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "model.Note", Name: validation.MaxLength, Rule: 8000, Chain: nil },
        	{Target: "model.Note", Name: validation.MinLength, Rule: 0, Chain: nil },
        }}}}}); err != nil {
            return result, validation.NewErrorWithValidationError(err, "softheonenterpriseapiclient.BaseClient","UpdateNote")
        }

        req, err := client.UpdateNotePreparer(ctx, drawer, ID, model)
        if err != nil {
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "UpdateNote", nil , "Failure preparing request")
            return
        }

        resp, err := client.UpdateNoteSender(req)
        if err != nil {
            result.Response = autorest.Response{Response: resp}
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "UpdateNote", resp, "Failure sending request")
            return
        }

        result, err = client.UpdateNoteResponder(resp)
        if err != nil {
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "UpdateNote", resp, "Failure responding to request")
        }

        return
    }

    // UpdateNotePreparer prepares the UpdateNote request.
    func (client BaseClient) UpdateNotePreparer(ctx context.Context, drawer int32, ID int32, model NoteBase) (*http.Request, error) {
        pathParameters := map[string]interface{} {
        "drawer": autorest.Encode("path",drawer),
        "id": autorest.Encode("path",ID),
        }

        preparer := autorest.CreatePreparer(
            autorest.AsJSON(),
            autorest.AsPut(),
            autorest.WithBaseURL(client.BaseURI),
            autorest.WithPathParameters("/v1/content/notes/{drawer}/{id}",pathParameters),
            autorest.WithJSON(model))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
    }

    // UpdateNoteSender sends the UpdateNote request. The method will close the
    // http.Response Body if it receives an error.
    func (client BaseClient) UpdateNoteSender(req *http.Request) (*http.Response, error) {
        return autorest.SendWithSender(client, req,
            autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
    }

    // UpdateNoteResponder handles the response to the UpdateNote request. The method always
    // closes the http.Response Body.
    func (client BaseClient) UpdateNoteResponder(resp *http.Response) (result SetObject, err error) {
        err = autorest.Respond(
            resp,
            client.ByInspecting(),
            azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusNoContent,http.StatusForbidden,http.StatusNotFound),
            autorest.ByUnmarshallingJSON(&result.Value),
            autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
        return
    }

    // UpdateQueue sends the update queue request.
    //
    // ID is the unique queue identifier. model is the queue model.
    func (client BaseClient) UpdateQueue(ctx context.Context, ID int32, model QueueBase) (result SetObject, err error) {
        if err := validation.Validate([]validation.Validation{
        { TargetValue: model,
         Constraints: []validation.Constraint{	{Target: "model.Name", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "model.Name", Name: validation.MaxLength, Rule: 255, Chain: nil },
        	{Target: "model.Name", Name: validation.MinLength, Rule: 0, Chain: nil },
        }},
        	{Target: "model.Alias", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "model.Alias", Name: validation.MaxLength, Rule: 255, Chain: nil },
        	{Target: "model.Alias", Name: validation.MinLength, Rule: 0, Chain: nil },
        }},
        	{Target: "model.Category", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "model.Category", Name: validation.MaxLength, Rule: 255, Chain: nil },
        	{Target: "model.Category", Name: validation.MinLength, Rule: 0, Chain: nil },
        }},
        	{Target: "model.Description", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "model.Description", Name: validation.MaxLength, Rule: 255, Chain: nil },
        	{Target: "model.Description", Name: validation.MinLength, Rule: 0, Chain: nil },
        }},
        	{Target: "model.ReservedString1", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "model.ReservedString1", Name: validation.MaxLength, Rule: 255, Chain: nil },
        	{Target: "model.ReservedString1", Name: validation.MinLength, Rule: 0, Chain: nil },
        }},
        	{Target: "model.ReservedString2", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "model.ReservedString2", Name: validation.MaxLength, Rule: 255, Chain: nil },
        	{Target: "model.ReservedString2", Name: validation.MinLength, Rule: 0, Chain: nil },
        }}}}}); err != nil {
            return result, validation.NewErrorWithValidationError(err, "softheonenterpriseapiclient.BaseClient","UpdateQueue")
        }

        req, err := client.UpdateQueuePreparer(ctx, ID, model)
        if err != nil {
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "UpdateQueue", nil , "Failure preparing request")
            return
        }

        resp, err := client.UpdateQueueSender(req)
        if err != nil {
            result.Response = autorest.Response{Response: resp}
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "UpdateQueue", resp, "Failure sending request")
            return
        }

        result, err = client.UpdateQueueResponder(resp)
        if err != nil {
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "UpdateQueue", resp, "Failure responding to request")
        }

        return
    }

    // UpdateQueuePreparer prepares the UpdateQueue request.
    func (client BaseClient) UpdateQueuePreparer(ctx context.Context, ID int32, model QueueBase) (*http.Request, error) {
        pathParameters := map[string]interface{} {
        "id": autorest.Encode("path",ID),
        }

        preparer := autorest.CreatePreparer(
            autorest.AsJSON(),
            autorest.AsPut(),
            autorest.WithBaseURL(client.BaseURI),
            autorest.WithPathParameters("/v1/workflow/queues/{id}",pathParameters),
            autorest.WithJSON(model))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
    }

    // UpdateQueueSender sends the UpdateQueue request. The method will close the
    // http.Response Body if it receives an error.
    func (client BaseClient) UpdateQueueSender(req *http.Request) (*http.Response, error) {
        return autorest.SendWithSender(client, req,
            autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
    }

    // UpdateQueueResponder handles the response to the UpdateQueue request. The method always
    // closes the http.Response Body.
    func (client BaseClient) UpdateQueueResponder(resp *http.Response) (result SetObject, err error) {
        err = autorest.Respond(
            resp,
            client.ByInspecting(),
            azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusForbidden,http.StatusNotFound),
            autorest.ByUnmarshallingJSON(&result.Value),
            autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
        return
    }

    // UpdateQueueAssignemnt sends the update queue assignemnt request.
    //
    // model is the model.
    func (client BaseClient) UpdateQueueAssignemnt(ctx context.Context, model QueueAssignmentModel) (result SetObject, err error) {
        if err := validation.Validate([]validation.Validation{
        { TargetValue: model,
         Constraints: []validation.Constraint{	{Target: "model.QueueID", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "model.QueueID", Name: validation.InclusiveMaximum, Rule: 2147483647, Chain: nil },
        	{Target: "model.QueueID", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil },
        }},
        	{Target: "model.UserID", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "model.UserID", Name: validation.InclusiveMaximum, Rule: 2147483647, Chain: nil },
        	{Target: "model.UserID", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil },
        }},
        	{Target: "model.GroupID", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "model.GroupID", Name: validation.InclusiveMaximum, Rule: 2147483647, Chain: nil },
        	{Target: "model.GroupID", Name: validation.InclusiveMinimum, Rule: 0, Chain: nil },
        }}}}}); err != nil {
            return result, validation.NewErrorWithValidationError(err, "softheonenterpriseapiclient.BaseClient","UpdateQueueAssignemnt")
        }

        req, err := client.UpdateQueueAssignemntPreparer(ctx, model)
        if err != nil {
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "UpdateQueueAssignemnt", nil , "Failure preparing request")
            return
        }

        resp, err := client.UpdateQueueAssignemntSender(req)
        if err != nil {
            result.Response = autorest.Response{Response: resp}
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "UpdateQueueAssignemnt", resp, "Failure sending request")
            return
        }

        result, err = client.UpdateQueueAssignemntResponder(resp)
        if err != nil {
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "UpdateQueueAssignemnt", resp, "Failure responding to request")
        }

        return
    }

    // UpdateQueueAssignemntPreparer prepares the UpdateQueueAssignemnt request.
    func (client BaseClient) UpdateQueueAssignemntPreparer(ctx context.Context, model QueueAssignmentModel) (*http.Request, error) {
        preparer := autorest.CreatePreparer(
            autorest.AsJSON(),
            autorest.AsPut(),
            autorest.WithBaseURL(client.BaseURI),
            autorest.WithPath("/v1/workflow/assignments"),
            autorest.WithJSON(model))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
    }

    // UpdateQueueAssignemntSender sends the UpdateQueueAssignemnt request. The method will close the
    // http.Response Body if it receives an error.
    func (client BaseClient) UpdateQueueAssignemntSender(req *http.Request) (*http.Response, error) {
        return autorest.SendWithSender(client, req,
            autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
    }

    // UpdateQueueAssignemntResponder handles the response to the UpdateQueueAssignemnt request. The method always
    // closes the http.Response Body.
    func (client BaseClient) UpdateQueueAssignemntResponder(resp *http.Response) (result SetObject, err error) {
        err = autorest.Respond(
            resp,
            client.ByInspecting(),
            azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusNoContent,http.StatusForbidden,http.StatusNotFound),
            autorest.ByUnmarshallingJSON(&result.Value),
            autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
        return
    }

    // UpdateTask sends the update task request.
    //
    // ID is the identifier. model is the task model.
    func (client BaseClient) UpdateTask(ctx context.Context, ID int32, model TaskBase) (result SetObject, err error) {
        if err := validation.Validate([]validation.Validation{
        { TargetValue: model,
         Constraints: []validation.Constraint{	{Target: "model.AddressID", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "model.AddressID", Name: validation.InclusiveMaximum, Rule: 2147483647, Chain: nil },
        	{Target: "model.AddressID", Name: validation.InclusiveMinimum, Rule: 0, Chain: nil },
        }},
        	{Target: "model.Description", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "model.Description", Name: validation.MaxLength, Rule: 255, Chain: nil },
        	{Target: "model.Description", Name: validation.MinLength, Rule: 0, Chain: nil },
        }},
        	{Target: "model.Message1", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "model.Message1", Name: validation.MaxLength, Rule: 255, Chain: nil },
        	{Target: "model.Message1", Name: validation.MinLength, Rule: 0, Chain: nil },
        }},
        	{Target: "model.Message2", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "model.Message2", Name: validation.MaxLength, Rule: 255, Chain: nil },
        	{Target: "model.Message2", Name: validation.MinLength, Rule: 0, Chain: nil },
        }},
        	{Target: "model.Message3", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "model.Message3", Name: validation.MaxLength, Rule: 255, Chain: nil },
        	{Target: "model.Message3", Name: validation.MinLength, Rule: 0, Chain: nil },
        }},
        	{Target: "model.Message4", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "model.Message4", Name: validation.MaxLength, Rule: 255, Chain: nil },
        	{Target: "model.Message4", Name: validation.MinLength, Rule: 0, Chain: nil },
        }},
        	{Target: "model.Message5", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "model.Message5", Name: validation.MaxLength, Rule: 255, Chain: nil },
        	{Target: "model.Message5", Name: validation.MinLength, Rule: 0, Chain: nil },
        }},
        	{Target: "model.Message6", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "model.Message6", Name: validation.MaxLength, Rule: 255, Chain: nil },
        	{Target: "model.Message6", Name: validation.MinLength, Rule: 0, Chain: nil },
        }},
        	{Target: "model.Message7", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "model.Message7", Name: validation.MaxLength, Rule: 255, Chain: nil },
        	{Target: "model.Message7", Name: validation.MinLength, Rule: 0, Chain: nil },
        }},
        	{Target: "model.Message8", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "model.Message8", Name: validation.MaxLength, Rule: 255, Chain: nil },
        	{Target: "model.Message8", Name: validation.MinLength, Rule: 0, Chain: nil },
        }},
        	{Target: "model.Message9", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "model.Message9", Name: validation.MaxLength, Rule: 255, Chain: nil },
        	{Target: "model.Message9", Name: validation.MinLength, Rule: 0, Chain: nil },
        }},
        	{Target: "model.Message10", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "model.Message10", Name: validation.MaxLength, Rule: 255, Chain: nil },
        	{Target: "model.Message10", Name: validation.MinLength, Rule: 0, Chain: nil },
        }},
        	{Target: "model.Message11", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "model.Message11", Name: validation.MaxLength, Rule: 255, Chain: nil },
        	{Target: "model.Message11", Name: validation.MinLength, Rule: 0, Chain: nil },
        }},
        	{Target: "model.Message12", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "model.Message12", Name: validation.MaxLength, Rule: 255, Chain: nil },
        	{Target: "model.Message12", Name: validation.MinLength, Rule: 0, Chain: nil },
        }},
        	{Target: "model.Message13", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "model.Message13", Name: validation.MaxLength, Rule: 255, Chain: nil },
        	{Target: "model.Message13", Name: validation.MinLength, Rule: 0, Chain: nil },
        }},
        	{Target: "model.Message14", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "model.Message14", Name: validation.MaxLength, Rule: 255, Chain: nil },
        	{Target: "model.Message14", Name: validation.MinLength, Rule: 0, Chain: nil },
        }},
        	{Target: "model.Message15", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "model.Message15", Name: validation.MaxLength, Rule: 255, Chain: nil },
        	{Target: "model.Message15", Name: validation.MinLength, Rule: 0, Chain: nil },
        }},
        	{Target: "model.Message16", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "model.Message16", Name: validation.MaxLength, Rule: 255, Chain: nil },
        	{Target: "model.Message16", Name: validation.MinLength, Rule: 0, Chain: nil },
        }},
        	{Target: "model.TaskFileAttachment", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "model.TaskFileAttachment", Name: validation.MaxLength, Rule: 255, Chain: nil },
        	{Target: "model.TaskFileAttachment", Name: validation.MinLength, Rule: 0, Chain: nil },
        }},
        	{Target: "model.ReservedString1", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "model.ReservedString1", Name: validation.MaxLength, Rule: 255, Chain: nil },
        	{Target: "model.ReservedString1", Name: validation.MinLength, Rule: 0, Chain: nil },
        }}}}}); err != nil {
            return result, validation.NewErrorWithValidationError(err, "softheonenterpriseapiclient.BaseClient","UpdateTask")
        }

        req, err := client.UpdateTaskPreparer(ctx, ID, model)
        if err != nil {
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "UpdateTask", nil , "Failure preparing request")
            return
        }

        resp, err := client.UpdateTaskSender(req)
        if err != nil {
            result.Response = autorest.Response{Response: resp}
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "UpdateTask", resp, "Failure sending request")
            return
        }

        result, err = client.UpdateTaskResponder(resp)
        if err != nil {
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "UpdateTask", resp, "Failure responding to request")
        }

        return
    }

    // UpdateTaskPreparer prepares the UpdateTask request.
    func (client BaseClient) UpdateTaskPreparer(ctx context.Context, ID int32, model TaskBase) (*http.Request, error) {
        pathParameters := map[string]interface{} {
        "id": autorest.Encode("path",ID),
        }

        preparer := autorest.CreatePreparer(
            autorest.AsJSON(),
            autorest.AsPut(),
            autorest.WithBaseURL(client.BaseURI),
            autorest.WithPathParameters("/v1/workflow/tasks/{id}",pathParameters),
            autorest.WithJSON(model))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
    }

    // UpdateTaskSender sends the UpdateTask request. The method will close the
    // http.Response Body if it receives an error.
    func (client BaseClient) UpdateTaskSender(req *http.Request) (*http.Response, error) {
        return autorest.SendWithSender(client, req,
            autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
    }

    // UpdateTaskResponder handles the response to the UpdateTask request. The method always
    // closes the http.Response Body.
    func (client BaseClient) UpdateTaskResponder(resp *http.Response) (result SetObject, err error) {
        err = autorest.Respond(
            resp,
            client.ByInspecting(),
            azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusNoContent,http.StatusForbidden,http.StatusNotFound),
            autorest.ByUnmarshallingJSON(&result.Value),
            autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
        return
    }

    // UpdateTemplateByID sends the update template by id request.
    //
    // ID is the unique template identifier. model is the entity template model.
    func (client BaseClient) UpdateTemplateByID(ctx context.Context, ID string, model UpdateEntityDefinitionRequestModel) (result SetObject, err error) {
        if err := validation.Validate([]validation.Validation{
        { TargetValue: model,
         Constraints: []validation.Constraint{	{Target: "model.Category", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "model.Category", Name: validation.MaxLength, Rule: 255, Chain: nil },
        	{Target: "model.Category", Name: validation.MinLength, Rule: 0, Chain: nil },
        }},
        	{Target: "model.Name", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "model.Name", Name: validation.MaxLength, Rule: 255, Chain: nil },
        	{Target: "model.Name", Name: validation.MinLength, Rule: 0, Chain: nil },
        }},
        	{Target: "model.SmallImage", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "model.SmallImage", Name: validation.MaxLength, Rule: 255, Chain: nil },
        	{Target: "model.SmallImage", Name: validation.MinLength, Rule: 0, Chain: nil },
        }},
        	{Target: "model.LargeImage", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "model.LargeImage", Name: validation.MaxLength, Rule: 255, Chain: nil },
        	{Target: "model.LargeImage", Name: validation.MinLength, Rule: 0, Chain: nil },
        }}}}}); err != nil {
            return result, validation.NewErrorWithValidationError(err, "softheonenterpriseapiclient.BaseClient","UpdateTemplateByID")
        }

        req, err := client.UpdateTemplateByIDPreparer(ctx, ID, model)
        if err != nil {
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "UpdateTemplateByID", nil , "Failure preparing request")
            return
        }

        resp, err := client.UpdateTemplateByIDSender(req)
        if err != nil {
            result.Response = autorest.Response{Response: resp}
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "UpdateTemplateByID", resp, "Failure sending request")
            return
        }

        result, err = client.UpdateTemplateByIDResponder(resp)
        if err != nil {
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "UpdateTemplateByID", resp, "Failure responding to request")
        }

        return
    }

    // UpdateTemplateByIDPreparer prepares the UpdateTemplateByID request.
    func (client BaseClient) UpdateTemplateByIDPreparer(ctx context.Context, ID string, model UpdateEntityDefinitionRequestModel) (*http.Request, error) {
        pathParameters := map[string]interface{} {
        "id": autorest.Encode("path",ID),
        }

        preparer := autorest.CreatePreparer(
            autorest.AsJSON(),
            autorest.AsPut(),
            autorest.WithBaseURL(client.BaseURI),
            autorest.WithPathParameters("/v1/template/ftl/{id}",pathParameters),
            autorest.WithJSON(model))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
    }

    // UpdateTemplateByIDSender sends the UpdateTemplateByID request. The method will close the
    // http.Response Body if it receives an error.
    func (client BaseClient) UpdateTemplateByIDSender(req *http.Request) (*http.Response, error) {
        return autorest.SendWithSender(client, req,
            autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
    }

    // UpdateTemplateByIDResponder handles the response to the UpdateTemplateByID request. The method always
    // closes the http.Response Body.
    func (client BaseClient) UpdateTemplateByIDResponder(resp *http.Response) (result SetObject, err error) {
        err = autorest.Respond(
            resp,
            client.ByInspecting(),
            azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusNoContent,http.StatusForbidden,http.StatusNotFound),
            autorest.ByUnmarshallingJSON(&result.Value),
            autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
        return
    }

    // UpdateTemplateByType sends the update template by type request.
    //
    // typeParameter is the unique template type. model is the entity template model.
    func (client BaseClient) UpdateTemplateByType(ctx context.Context, typeParameter int32, model UpdateEntityDefinitionRequestModel) (result SetObject, err error) {
        if err := validation.Validate([]validation.Validation{
        { TargetValue: model,
         Constraints: []validation.Constraint{	{Target: "model.Category", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "model.Category", Name: validation.MaxLength, Rule: 255, Chain: nil },
        	{Target: "model.Category", Name: validation.MinLength, Rule: 0, Chain: nil },
        }},
        	{Target: "model.Name", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "model.Name", Name: validation.MaxLength, Rule: 255, Chain: nil },
        	{Target: "model.Name", Name: validation.MinLength, Rule: 0, Chain: nil },
        }},
        	{Target: "model.SmallImage", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "model.SmallImage", Name: validation.MaxLength, Rule: 255, Chain: nil },
        	{Target: "model.SmallImage", Name: validation.MinLength, Rule: 0, Chain: nil },
        }},
        	{Target: "model.LargeImage", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "model.LargeImage", Name: validation.MaxLength, Rule: 255, Chain: nil },
        	{Target: "model.LargeImage", Name: validation.MinLength, Rule: 0, Chain: nil },
        }}}}}); err != nil {
            return result, validation.NewErrorWithValidationError(err, "softheonenterpriseapiclient.BaseClient","UpdateTemplateByType")
        }

        req, err := client.UpdateTemplateByTypePreparer(ctx, typeParameter, model)
        if err != nil {
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "UpdateTemplateByType", nil , "Failure preparing request")
            return
        }

        resp, err := client.UpdateTemplateByTypeSender(req)
        if err != nil {
            result.Response = autorest.Response{Response: resp}
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "UpdateTemplateByType", resp, "Failure sending request")
            return
        }

        result, err = client.UpdateTemplateByTypeResponder(resp)
        if err != nil {
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "UpdateTemplateByType", resp, "Failure responding to request")
        }

        return
    }

    // UpdateTemplateByTypePreparer prepares the UpdateTemplateByType request.
    func (client BaseClient) UpdateTemplateByTypePreparer(ctx context.Context, typeParameter int32, model UpdateEntityDefinitionRequestModel) (*http.Request, error) {
        pathParameters := map[string]interface{} {
        "type": autorest.Encode("path",typeParameter),
        }

        preparer := autorest.CreatePreparer(
            autorest.AsJSON(),
            autorest.AsPut(),
            autorest.WithBaseURL(client.BaseURI),
            autorest.WithPathParameters("/v1/template/ftl/{type}",pathParameters),
            autorest.WithJSON(model))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
    }

    // UpdateTemplateByTypeSender sends the UpdateTemplateByType request. The method will close the
    // http.Response Body if it receives an error.
    func (client BaseClient) UpdateTemplateByTypeSender(req *http.Request) (*http.Response, error) {
        return autorest.SendWithSender(client, req,
            autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
    }

    // UpdateTemplateByTypeResponder handles the response to the UpdateTemplateByType request. The method always
    // closes the http.Response Body.
    func (client BaseClient) UpdateTemplateByTypeResponder(resp *http.Response) (result SetObject, err error) {
        err = autorest.Respond(
            resp,
            client.ByInspecting(),
            azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusNoContent,http.StatusForbidden,http.StatusNotFound),
            autorest.ByUnmarshallingJSON(&result.Value),
            autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
        return
    }

    // UpdateUser sends the update user request.
    //
    // ID is the user identifier. model is the user model.
    func (client BaseClient) UpdateUser(ctx context.Context, ID int32, model UserBase) (result SetObject, err error) {
        if err := validation.Validate([]validation.Validation{
        { TargetValue: model,
         Constraints: []validation.Constraint{	{Target: "model.PrimaryGroupID", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "model.PrimaryGroupID", Name: validation.InclusiveMaximum, Rule: 2147483647, Chain: nil },
        	{Target: "model.PrimaryGroupID", Name: validation.InclusiveMinimum, Rule: 0, Chain: nil },
        }},
        	{Target: "model.FullName", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "model.FullName", Name: validation.MaxLength, Rule: 255, Chain: nil },
        	{Target: "model.FullName", Name: validation.MinLength, Rule: 0, Chain: nil },
        }},
        	{Target: "model.ObjectCount", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "model.ObjectCount", Name: validation.InclusiveMaximum, Rule: 2147483647, Chain: nil },
        	{Target: "model.ObjectCount", Name: validation.InclusiveMinimum, Rule: 0, Chain: nil },
        }},
        	{Target: "model.IPAddress", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "model.IPAddress", Name: validation.MaxLength, Rule: 255, Chain: nil },
        	{Target: "model.IPAddress", Name: validation.MinLength, Rule: 0, Chain: nil },
        }},
        	{Target: "model.Address", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "model.Address", Name: validation.MaxLength, Rule: 255, Chain: nil },
        	{Target: "model.Address", Name: validation.MinLength, Rule: 0, Chain: nil },
        }},
        	{Target: "model.ReservedString1", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "model.ReservedString1", Name: validation.MaxLength, Rule: 128, Chain: nil },
        	{Target: "model.ReservedString1", Name: validation.MinLength, Rule: 0, Chain: nil },
        }},
        	{Target: "model.ReservedString2", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "model.ReservedString2", Name: validation.MaxLength, Rule: 128, Chain: nil },
        	{Target: "model.ReservedString2", Name: validation.MinLength, Rule: 0, Chain: nil },
        }}}}}); err != nil {
            return result, validation.NewErrorWithValidationError(err, "softheonenterpriseapiclient.BaseClient","UpdateUser")
        }

        req, err := client.UpdateUserPreparer(ctx, ID, model)
        if err != nil {
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "UpdateUser", nil , "Failure preparing request")
            return
        }

        resp, err := client.UpdateUserSender(req)
        if err != nil {
            result.Response = autorest.Response{Response: resp}
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "UpdateUser", resp, "Failure sending request")
            return
        }

        result, err = client.UpdateUserResponder(resp)
        if err != nil {
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "UpdateUser", resp, "Failure responding to request")
        }

        return
    }

    // UpdateUserPreparer prepares the UpdateUser request.
    func (client BaseClient) UpdateUserPreparer(ctx context.Context, ID int32, model UserBase) (*http.Request, error) {
        pathParameters := map[string]interface{} {
        "id": autorest.Encode("path",ID),
        }

        preparer := autorest.CreatePreparer(
            autorest.AsJSON(),
            autorest.AsPut(),
            autorest.WithBaseURL(client.BaseURI),
            autorest.WithPathParameters("/v1/directory/users/{id}",pathParameters),
            autorest.WithJSON(model))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
    }

    // UpdateUserSender sends the UpdateUser request. The method will close the
    // http.Response Body if it receives an error.
    func (client BaseClient) UpdateUserSender(req *http.Request) (*http.Response, error) {
        return autorest.SendWithSender(client, req,
            autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
    }

    // UpdateUserResponder handles the response to the UpdateUser request. The method always
    // closes the http.Response Body.
    func (client BaseClient) UpdateUserResponder(resp *http.Response) (result SetObject, err error) {
        err = autorest.Respond(
            resp,
            client.ByInspecting(),
            azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusNoContent,http.StatusForbidden,http.StatusNotFound),
            autorest.ByUnmarshallingJSON(&result.Value),
            autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
        return
    }

    // ValidateTemplateField sends the validate template field request.
    //
    // typeParameter is the template type. fieldID is the field name. sortColumn is gets or sets the sort column. page is
    // gets or sets the page number. pageSize is gets or sets the size of the page. sortOrder is gets or sets the order.
    // sortBy is gets or sets the column to order by.
    func (client BaseClient) ValidateTemplateField(ctx context.Context, typeParameter int32, fieldID string, sortColumn string, page *int32, pageSize *int32, sortOrder string, sortBy *int32) (result FieldValidationModel, err error) {
        if err := validation.Validate([]validation.Validation{
        { TargetValue: page,
         Constraints: []validation.Constraint{	{Target: "page", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "page", Name: validation.InclusiveMaximum, Rule: 2147483647, Chain: nil },
        	{Target: "page", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil },
        }}}},
        { TargetValue: pageSize,
         Constraints: []validation.Constraint{	{Target: "pageSize", Name: validation.Null, Rule: false ,
        Chain: []validation.Constraint{	{Target: "pageSize", Name: validation.InclusiveMaximum, Rule: 1000, Chain: nil },
        	{Target: "pageSize", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil },
        }}}}}); err != nil {
            return result, validation.NewErrorWithValidationError(err, "softheonenterpriseapiclient.BaseClient","ValidateTemplateField")
        }

        req, err := client.ValidateTemplateFieldPreparer(ctx, typeParameter, fieldID, sortColumn, page, pageSize, sortOrder, sortBy)
        if err != nil {
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "ValidateTemplateField", nil , "Failure preparing request")
            return
        }

        resp, err := client.ValidateTemplateFieldSender(req)
        if err != nil {
            result.Response = autorest.Response{Response: resp}
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "ValidateTemplateField", resp, "Failure sending request")
            return
        }

        result, err = client.ValidateTemplateFieldResponder(resp)
        if err != nil {
            err = autorest.NewErrorWithError(err, "softheonenterpriseapiclient.BaseClient", "ValidateTemplateField", resp, "Failure responding to request")
        }

        return
    }

    // ValidateTemplateFieldPreparer prepares the ValidateTemplateField request.
    func (client BaseClient) ValidateTemplateFieldPreparer(ctx context.Context, typeParameter int32, fieldID string, sortColumn string, page *int32, pageSize *int32, sortOrder string, sortBy *int32) (*http.Request, error) {
        pathParameters := map[string]interface{} {
        "fieldID": autorest.Encode("path",fieldID),
        "type": autorest.Encode("path",typeParameter),
        }

        queryParameters := map[string]interface{} {
        }
        if len(sortColumn) > 0 {
            queryParameters["sortColumn"] = autorest.Encode("query",sortColumn)
        }
        if page != nil {
            queryParameters["page"] = autorest.Encode("query",*page)
        }
        if pageSize != nil {
            queryParameters["pageSize"] = autorest.Encode("query",*pageSize)
        }
        if len(string(sortOrder)) > 0 {
            queryParameters["sortOrder"] = autorest.Encode("query",sortOrder)
        }
        if sortBy != nil {
            queryParameters["sortBy"] = autorest.Encode("query",*sortBy)
        }

        preparer := autorest.CreatePreparer(
            autorest.AsGet(),
            autorest.WithBaseURL(client.BaseURI),
            autorest.WithPathParameters("/v1/template/ftl/{type}/validate/{fieldID}",pathParameters),
            autorest.WithQueryParameters(queryParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
    }

    // ValidateTemplateFieldSender sends the ValidateTemplateField request. The method will close the
    // http.Response Body if it receives an error.
    func (client BaseClient) ValidateTemplateFieldSender(req *http.Request) (*http.Response, error) {
        return autorest.SendWithSender(client, req,
            autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
    }

    // ValidateTemplateFieldResponder handles the response to the ValidateTemplateField request. The method always
    // closes the http.Response Body.
    func (client BaseClient) ValidateTemplateFieldResponder(resp *http.Response) (result FieldValidationModel, err error) {
        err = autorest.Respond(
            resp,
            client.ByInspecting(),
            azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusNotFound),
            autorest.ByUnmarshallingJSON(&result),
            autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
        return
    }

