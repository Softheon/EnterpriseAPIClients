/**
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is
 * regenerated.
 */

package softheon.enterprise.api.client.implementation;

import softheon.enterprise.api.client.SoftheonEnterpriseAPI;
import com.microsoft.rest.ServiceClient;
import com.microsoft.rest.RestClient;
import okhttp3.OkHttpClient;
import retrofit2.Retrofit;
import com.google.common.reflect.TypeToken;
import com.microsoft.rest.CollectionFormat;
import com.microsoft.rest.RestException;
import com.microsoft.rest.ServiceCallback;
import com.microsoft.rest.ServiceFuture;
import com.microsoft.rest.ServiceResponse;
import com.microsoft.rest.Validator;
import java.io.IOException;
import java.util.List;
import okhttp3.ResponseBody;
import org.joda.time.DateTime;
import retrofit2.http.Body;
import retrofit2.http.GET;
import retrofit2.http.Headers;
import retrofit2.http.HTTP;
import retrofit2.http.Path;
import retrofit2.http.POST;
import retrofit2.http.PUT;
import retrofit2.http.Query;
import retrofit2.Response;
import rx.functions.Func1;
import rx.Observable;
import softheon.enterprise.api.client.models.ApplicationModel;
import softheon.enterprise.api.client.models.AttachmentModel;
import softheon.enterprise.api.client.models.AttachmentVersionModel;
import softheon.enterprise.api.client.models.DrawerBase;
import softheon.enterprise.api.client.models.DrawerModel;
import softheon.enterprise.api.client.models.EntityContentModel;
import softheon.enterprise.api.client.models.EntityDefinitionBase;
import softheon.enterprise.api.client.models.EntityDefinitionModel;
import softheon.enterprise.api.client.models.EntityLinkModel;
import softheon.enterprise.api.client.models.EntityModel;
import softheon.enterprise.api.client.models.EventModel;
import softheon.enterprise.api.client.models.ExtensionModel;
import softheon.enterprise.api.client.models.FieldValidationModel;
import softheon.enterprise.api.client.models.FlowModel;
import softheon.enterprise.api.client.models.GetEntityBaseResponse;
import softheon.enterprise.api.client.models.GroupApplicationModel;
import softheon.enterprise.api.client.models.GroupBase;
import softheon.enterprise.api.client.models.GroupDrawerModel;
import softheon.enterprise.api.client.models.GroupModel;
import softheon.enterprise.api.client.models.GroupQueueModel;
import softheon.enterprise.api.client.models.GroupUserModel;
import softheon.enterprise.api.client.models.InsertEntityLinkRequestModel;
import softheon.enterprise.api.client.models.InsertEntityRequestModel;
import softheon.enterprise.api.client.models.InsertGroupRequestModel;
import softheon.enterprise.api.client.models.InsertNoteRequestModel;
import softheon.enterprise.api.client.models.InsertQueueAssignmentRequestModel;
import softheon.enterprise.api.client.models.InsertQueueRequestModel;
import softheon.enterprise.api.client.models.InsertTaskRequestModel;
import softheon.enterprise.api.client.models.InsertUserRequestModel;
import softheon.enterprise.api.client.models.LockModel;
import softheon.enterprise.api.client.models.NoteBase;
import softheon.enterprise.api.client.models.NoteModel;
import softheon.enterprise.api.client.models.QueueAssignmentModel;
import softheon.enterprise.api.client.models.QueueBase;
import softheon.enterprise.api.client.models.QueueModel;
import softheon.enterprise.api.client.models.TaskBase;
import softheon.enterprise.api.client.models.TaskModel;
import softheon.enterprise.api.client.models.UpdateAttachmentRequestModel;
import softheon.enterprise.api.client.models.UpdateEntityDefinitionRequestModel;
import softheon.enterprise.api.client.models.UpdateEntityLinkRequestModel;
import softheon.enterprise.api.client.models.UpdateEntityRequestModel;
import softheon.enterprise.api.client.models.UpdateLockRequestModel;
import softheon.enterprise.api.client.models.UserApplicationModel;
import softheon.enterprise.api.client.models.UserBase;
import softheon.enterprise.api.client.models.UserDrawerModel;
import softheon.enterprise.api.client.models.UserModel;
import softheon.enterprise.api.client.models.UserQueueModel;
import softheon.enterprise.api.client.models.WorkflowActionInitializeModel;
import softheon.enterprise.api.client.models.WorkflowActionModel;
import softheon.enterprise.api.client.models.WorkflowActionRouteModel;
import softheon.enterprise.api.client.models.WorkflowModel;
import softheon.enterprise.api.client.models.WorkflowQueueModel;

/**
 * Initializes a new instance of the SoftheonEnterpriseAPI class.
 */
public class SoftheonEnterpriseAPIImpl extends ServiceClient implements SoftheonEnterpriseAPI {
    /**
     * The Retrofit service to perform REST calls.
     */
    private SoftheonEnterpriseAPIService service;

    /**
     * Initializes an instance of SoftheonEnterpriseAPI client.
     */
    public SoftheonEnterpriseAPIImpl() {
        this("http://localhost:54963");
    }

    /**
     * Initializes an instance of SoftheonEnterpriseAPI client.
     *
     * @param baseUrl the base URL of the host
     */
    public SoftheonEnterpriseAPIImpl(String baseUrl) {
        super(baseUrl);
        initialize();
    }

    /**
     * Initializes an instance of SoftheonEnterpriseAPI client.
     *
     * @param clientBuilder the builder for building an OkHttp client, bundled with user configurations
     * @param restBuilder the builder for building an Retrofit client, bundled with user configurations
     */
    public SoftheonEnterpriseAPIImpl(OkHttpClient.Builder clientBuilder, Retrofit.Builder restBuilder) {
        this("http://localhost:54963", clientBuilder, restBuilder);
        initialize();
    }

    /**
     * Initializes an instance of SoftheonEnterpriseAPI client.
     *
     * @param baseUrl the base URL of the host
     * @param clientBuilder the builder for building an OkHttp client, bundled with user configurations
     * @param restBuilder the builder for building an Retrofit client, bundled with user configurations
     */
    public SoftheonEnterpriseAPIImpl(String baseUrl, OkHttpClient.Builder clientBuilder, Retrofit.Builder restBuilder) {
        super(baseUrl, clientBuilder, restBuilder);
        initialize();
    }

    /**
     * Initializes an instance of SoftheonEnterpriseAPI client.
     *
     * @param restClient the REST client containing pre-configured settings
     */
    public SoftheonEnterpriseAPIImpl(RestClient restClient) {
        super(restClient);
        initialize();
    }

    private void initialize() {
        initializeService();
    }

    private void initializeService() {
        service = retrofit().create(SoftheonEnterpriseAPIService.class);
    }

    /**
     * The interface defining all the services for SoftheonEnterpriseAPI to be
     * used by Retrofit to perform actually REST calls.
     */
    interface SoftheonEnterpriseAPIService {
        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: softheon.enterprise.api.client.SoftheonEnterpriseAPI acceptTask" })
        @POST("v1/workflow/actions/accept")
        Observable<Response<ResponseBody>> acceptTask(@Body WorkflowActionModel model);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: softheon.enterprise.api.client.SoftheonEnterpriseAPI rejectTask" })
        @POST("v1/workflow/actions/reject")
        Observable<Response<ResponseBody>> rejectTask(@Body WorkflowActionModel model);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: softheon.enterprise.api.client.SoftheonEnterpriseAPI suspendTask" })
        @POST("v1/workflow/actions/suspend")
        Observable<Response<ResponseBody>> suspendTask(@Body WorkflowActionModel model);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: softheon.enterprise.api.client.SoftheonEnterpriseAPI routeTask" })
        @POST("v1/workflow/actions/route")
        Observable<Response<ResponseBody>> routeTask(@Body WorkflowActionRouteModel model);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: softheon.enterprise.api.client.SoftheonEnterpriseAPI overrideTask" })
        @POST("v1/workflow/actions/override")
        Observable<Response<ResponseBody>> overrideTask(@Body WorkflowActionModel model);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: softheon.enterprise.api.client.SoftheonEnterpriseAPI resetTask" })
        @POST("v1/workflow/actions/reset")
        Observable<Response<ResponseBody>> resetTask(@Body WorkflowActionModel model);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: softheon.enterprise.api.client.SoftheonEnterpriseAPI initializeEntityWorkflow" })
        @POST("v1/workflow/actions/initialize")
        Observable<Response<ResponseBody>> initializeEntityWorkflow(@Body WorkflowActionInitializeModel model);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: softheon.enterprise.api.client.SoftheonEnterpriseAPI getAllApplications" })
        @GET("v1/directory/applications")
        Observable<Response<ResponseBody>> getAllApplications();

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: softheon.enterprise.api.client.SoftheonEnterpriseAPI getApplicationById" })
        @GET("v1/directory/applications/{id}")
        Observable<Response<ResponseBody>> getApplicationById(@Path("id") int id);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: softheon.enterprise.api.client.SoftheonEnterpriseAPI getApplicationByName" })
        @GET("v1/directory/applications/{name}")
        Observable<Response<ResponseBody>> getApplicationByName(@Path("name") String name);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: softheon.enterprise.api.client.SoftheonEnterpriseAPI getDrawerGroupAssociations" })
        @GET("v1/directory/drawers/{drawerID}/groups")
        Observable<Response<ResponseBody>> getDrawerGroupAssociations(@Path("drawerID") int drawerID, @Query("groupID") Integer groupID, @Query("acl") Integer acl, @Query("page") Integer page, @Query("pageSize") Integer pageSize, @Query("sortOrder") String sortOrder, @Query("sortBy") String sortBy);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: softheon.enterprise.api.client.SoftheonEnterpriseAPI getGroupDrawerAssociations" })
        @GET("v1/directory/groups/{groupID}/drawers")
        Observable<Response<ResponseBody>> getGroupDrawerAssociations(@Path("groupID") int groupID, @Query("drawerID") Integer drawerID, @Query("acl") Integer acl, @Query("page") Integer page, @Query("pageSize") Integer pageSize, @Query("sortOrder") String sortOrder, @Query("sortBy") String sortBy);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: softheon.enterprise.api.client.SoftheonEnterpriseAPI createOrUpdateDrawerGroupAssociation" })
        @PUT("v1/directory/drawers/{drawerID}/groups/{groupID}")
        Observable<Response<ResponseBody>> createOrUpdateDrawerGroupAssociation(@Path("groupID") int groupID, @Path("drawerID") int drawerID, @Body GroupDrawerModel model);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: softheon.enterprise.api.client.SoftheonEnterpriseAPI deleteDrawerGroupAssociation" })
        @HTTP(path = "v1/directory/drawers/{drawerID}/groups/{groupID}", method = "DELETE", hasBody = true)
        Observable<Response<ResponseBody>> deleteDrawerGroupAssociation(@Path("groupID") int groupID, @Path("drawerID") int drawerID);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: softheon.enterprise.api.client.SoftheonEnterpriseAPI createOrUpdateGroupDrawerAssociation" })
        @PUT("v1/directory/groups/{groupID}/drawers/{drawerID}")
        Observable<Response<ResponseBody>> createOrUpdateGroupDrawerAssociation(@Path("groupID") int groupID, @Path("drawerID") int drawerID, @Body GroupDrawerModel model);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: softheon.enterprise.api.client.SoftheonEnterpriseAPI deleteGroupDrawerAssociation" })
        @HTTP(path = "v1/directory/groups/{groupID}/drawers/{drawerID}", method = "DELETE", hasBody = true)
        Observable<Response<ResponseBody>> deleteGroupDrawerAssociation(@Path("groupID") int groupID, @Path("drawerID") int drawerID);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: softheon.enterprise.api.client.SoftheonEnterpriseAPI getUserGroupAssociations" })
        @GET("v1/directory/users/{userID}/groups")
        Observable<Response<ResponseBody>> getUserGroupAssociations(@Path("userID") int userID, @Query("groupID") Integer groupID, @Query("acl") Integer acl, @Query("page") Integer page, @Query("pageSize") Integer pageSize, @Query("sortOrder") String sortOrder, @Query("sortBy") String sortBy);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: softheon.enterprise.api.client.SoftheonEnterpriseAPI getGroupUserAssociations" })
        @GET("v1/directory/groups/{groupID}/users")
        Observable<Response<ResponseBody>> getGroupUserAssociations(@Path("groupID") int groupID, @Query("userID") Integer userID, @Query("acl") Integer acl, @Query("page") Integer page, @Query("pageSize") Integer pageSize, @Query("sortOrder") String sortOrder, @Query("sortBy") String sortBy);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: softheon.enterprise.api.client.SoftheonEnterpriseAPI createUserGroupAssociation" })
        @POST("v1/directory/users/{userID}/groups/{groupID}")
        Observable<Response<ResponseBody>> createUserGroupAssociation(@Path("groupID") int groupID, @Path("userID") int userID, @Body GroupUserModel model);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: softheon.enterprise.api.client.SoftheonEnterpriseAPI deleteUserGroupAssociation" })
        @HTTP(path = "v1/directory/users/{userID}/groups/{groupID}", method = "DELETE", hasBody = true)
        Observable<Response<ResponseBody>> deleteUserGroupAssociation(@Path("groupID") int groupID, @Path("userID") int userID);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: softheon.enterprise.api.client.SoftheonEnterpriseAPI createGroupUserAssociation" })
        @POST("v1/directory/groups/{groupID}/users/{userID}")
        Observable<Response<ResponseBody>> createGroupUserAssociation(@Path("groupID") int groupID, @Path("userID") int userID, @Body GroupUserModel model);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: softheon.enterprise.api.client.SoftheonEnterpriseAPI deleteGroupUserAssociation" })
        @HTTP(path = "v1/directory/groups/{groupID}/users/{userID}", method = "DELETE", hasBody = true)
        Observable<Response<ResponseBody>> deleteGroupUserAssociation(@Path("groupID") int groupID, @Path("userID") int userID);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: softheon.enterprise.api.client.SoftheonEnterpriseAPI getQueueGroupAssociations" })
        @GET("v1/workflow/queues/{queueID}/groups")
        Observable<Response<ResponseBody>> getQueueGroupAssociations(@Path("queueID") int queueID, @Query("groupID") Integer groupID, @Query("acl") Integer acl, @Query("page") Integer page, @Query("pageSize") Integer pageSize, @Query("sortOrder") String sortOrder, @Query("sortBy") String sortBy);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: softheon.enterprise.api.client.SoftheonEnterpriseAPI getGroupQueueAssociations" })
        @GET("v1/directory/groups/{groupID}/queues")
        Observable<Response<ResponseBody>> getGroupQueueAssociations(@Path("groupID") int groupID, @Query("queueID") Integer queueID, @Query("acl") Integer acl, @Query("page") Integer page, @Query("pageSize") Integer pageSize, @Query("sortOrder") String sortOrder, @Query("sortBy") String sortBy);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: softheon.enterprise.api.client.SoftheonEnterpriseAPI createOrUpdateQueueGroupAssociation" })
        @PUT("v1/workflow/queues/{queueID}/groups/{groupID}")
        Observable<Response<ResponseBody>> createOrUpdateQueueGroupAssociation(@Path("groupID") int groupID, @Path("queueID") int queueID, @Body GroupQueueModel model);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: softheon.enterprise.api.client.SoftheonEnterpriseAPI deleteQueueGroupAssociation" })
        @HTTP(path = "v1/workflow/queues/{queueID}/groups/{groupID}", method = "DELETE", hasBody = true)
        Observable<Response<ResponseBody>> deleteQueueGroupAssociation(@Path("groupID") int groupID, @Path("queueID") int queueID);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: softheon.enterprise.api.client.SoftheonEnterpriseAPI createOrUpdateGroupQueueAssociation" })
        @PUT("v1/directory/groups/{groupID}/queues/{queueID}")
        Observable<Response<ResponseBody>> createOrUpdateGroupQueueAssociation(@Path("groupID") int groupID, @Path("queueID") int queueID, @Body GroupQueueModel model);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: softheon.enterprise.api.client.SoftheonEnterpriseAPI deleteGroupQueueAssociation" })
        @HTTP(path = "v1/directory/groups/{groupID}/queues/{queueID}", method = "DELETE", hasBody = true)
        Observable<Response<ResponseBody>> deleteGroupQueueAssociation(@Path("groupID") int groupID, @Path("queueID") int queueID);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: softheon.enterprise.api.client.SoftheonEnterpriseAPI getApplicationGroupAssociations" })
        @GET("v1/directory/applications/{applicationID}/groups")
        Observable<Response<ResponseBody>> getApplicationGroupAssociations(@Path("applicationID") int applicationID, @Query("groupID") Integer groupID, @Query("acl") Integer acl, @Query("page") Integer page, @Query("pageSize") Integer pageSize, @Query("sortOrder") String sortOrder, @Query("sortBy") String sortBy);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: softheon.enterprise.api.client.SoftheonEnterpriseAPI getGroupApplicationAssociations" })
        @GET("v1/directory/groups/{groupID}/applications")
        Observable<Response<ResponseBody>> getGroupApplicationAssociations(@Path("groupID") int groupID, @Query("applicationID") Integer applicationID, @Query("acl") Integer acl, @Query("page") Integer page, @Query("pageSize") Integer pageSize, @Query("sortOrder") String sortOrder, @Query("sortBy") String sortBy);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: softheon.enterprise.api.client.SoftheonEnterpriseAPI createOrUpdateApplicationGroupAssociation" })
        @PUT("v1/directory/applications/{applicationID}/groups/{groupID}")
        Observable<Response<ResponseBody>> createOrUpdateApplicationGroupAssociation(@Path("groupID") int groupID, @Path("applicationID") int applicationID, @Body GroupApplicationModel model);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: softheon.enterprise.api.client.SoftheonEnterpriseAPI deleteApplicationGroupAssociation" })
        @HTTP(path = "v1/directory/applications/{applicationID}/groups/{groupID}", method = "DELETE", hasBody = true)
        Observable<Response<ResponseBody>> deleteApplicationGroupAssociation(@Path("groupID") int groupID, @Path("applicationID") int applicationID);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: softheon.enterprise.api.client.SoftheonEnterpriseAPI createOrUpdateGroupApplicationAssociation" })
        @PUT("v1/directory/groups/{groupID}/applications/{applicationID}")
        Observable<Response<ResponseBody>> createOrUpdateGroupApplicationAssociation(@Path("groupID") int groupID, @Path("applicationID") int applicationID, @Body GroupApplicationModel model);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: softheon.enterprise.api.client.SoftheonEnterpriseAPI deleteGroupApplicationAssociation" })
        @HTTP(path = "v1/directory/groups/{groupID}/applications/{applicationID}", method = "DELETE", hasBody = true)
        Observable<Response<ResponseBody>> deleteGroupApplicationAssociation(@Path("groupID") int groupID, @Path("applicationID") int applicationID);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: softheon.enterprise.api.client.SoftheonEnterpriseAPI getDrawerUserAssociations" })
        @GET("v1/directory/drawers/{drawerID}/users")
        Observable<Response<ResponseBody>> getDrawerUserAssociations(@Path("drawerID") int drawerID, @Query("userID") Integer userID, @Query("acl") Integer acl, @Query("page") Integer page, @Query("pageSize") Integer pageSize, @Query("sortOrder") String sortOrder, @Query("sortBy") String sortBy);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: softheon.enterprise.api.client.SoftheonEnterpriseAPI getUserDrawerAssociations" })
        @GET("v1/directory/users/{userID}/drawers")
        Observable<Response<ResponseBody>> getUserDrawerAssociations(@Path("userID") int userID, @Query("drawerID") Integer drawerID, @Query("acl") Integer acl, @Query("page") Integer page, @Query("pageSize") Integer pageSize, @Query("sortOrder") String sortOrder, @Query("sortBy") String sortBy);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: softheon.enterprise.api.client.SoftheonEnterpriseAPI createOrUpdateDrawerUserAssociation" })
        @PUT("v1/directory/drawers/{drawerID}/users/{userID}")
        Observable<Response<ResponseBody>> createOrUpdateDrawerUserAssociation(@Path("userID") int userID, @Path("drawerID") int drawerID, @Body UserDrawerModel model);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: softheon.enterprise.api.client.SoftheonEnterpriseAPI deleteDrawerUserAssociation" })
        @HTTP(path = "v1/directory/drawers/{drawerID}/users/{userID}", method = "DELETE", hasBody = true)
        Observable<Response<ResponseBody>> deleteDrawerUserAssociation(@Path("userID") int userID, @Path("drawerID") int drawerID);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: softheon.enterprise.api.client.SoftheonEnterpriseAPI createOrUpdateUserDrawerAssociation" })
        @PUT("v1/directory/users/{userID}/drawers/{drawerID}")
        Observable<Response<ResponseBody>> createOrUpdateUserDrawerAssociation(@Path("userID") int userID, @Path("drawerID") int drawerID, @Body UserDrawerModel model);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: softheon.enterprise.api.client.SoftheonEnterpriseAPI deleteUserDrawerAssociation" })
        @HTTP(path = "v1/directory/users/{userID}/drawers/{drawerID}", method = "DELETE", hasBody = true)
        Observable<Response<ResponseBody>> deleteUserDrawerAssociation(@Path("userID") int userID, @Path("drawerID") int drawerID);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: softheon.enterprise.api.client.SoftheonEnterpriseAPI getQueueUserAssociations" })
        @GET("v1/workflow/queues/{queueID}/users")
        Observable<Response<ResponseBody>> getQueueUserAssociations(@Path("queueID") int queueID, @Query("userID") Integer userID, @Query("acl") Integer acl, @Query("page") Integer page, @Query("pageSize") Integer pageSize, @Query("sortOrder") String sortOrder, @Query("sortBy") String sortBy);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: softheon.enterprise.api.client.SoftheonEnterpriseAPI getUserQueueAssociations" })
        @GET("v1/directory/users/{userID}/queues")
        Observable<Response<ResponseBody>> getUserQueueAssociations(@Path("userID") int userID, @Query("queueID") Integer queueID, @Query("acl") Integer acl, @Query("page") Integer page, @Query("pageSize") Integer pageSize, @Query("sortOrder") String sortOrder, @Query("sortBy") String sortBy);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: softheon.enterprise.api.client.SoftheonEnterpriseAPI createOrUpdateQueueUserAssociation" })
        @PUT("v1/workflow/queues/{queueID}/users/{userID}")
        Observable<Response<ResponseBody>> createOrUpdateQueueUserAssociation(@Path("userID") int userID, @Path("queueID") int queueID, @Body UserQueueModel model);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: softheon.enterprise.api.client.SoftheonEnterpriseAPI deleteQueueUserAssociation" })
        @HTTP(path = "v1/workflow/queues/{queueID}/users/{userID}", method = "DELETE", hasBody = true)
        Observable<Response<ResponseBody>> deleteQueueUserAssociation(@Path("userID") int userID, @Path("queueID") int queueID);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: softheon.enterprise.api.client.SoftheonEnterpriseAPI createOrUpdateUserQueueAssociation" })
        @PUT("v1/directory/users/{userID}/queues/{queueID}")
        Observable<Response<ResponseBody>> createOrUpdateUserQueueAssociation(@Path("userID") int userID, @Path("queueID") int queueID, @Body UserQueueModel model);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: softheon.enterprise.api.client.SoftheonEnterpriseAPI deleteUserQueueAssociation" })
        @HTTP(path = "v1/directory/users/{userID}/queues/{queueID}", method = "DELETE", hasBody = true)
        Observable<Response<ResponseBody>> deleteUserQueueAssociation(@Path("userID") int userID, @Path("queueID") int queueID);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: softheon.enterprise.api.client.SoftheonEnterpriseAPI getApplicationUserAssociations" })
        @GET("v1/directory/applications/{applicationID}/users")
        Observable<Response<ResponseBody>> getApplicationUserAssociations(@Path("applicationID") int applicationID, @Query("userID") Integer userID, @Query("acl") Integer acl, @Query("page") Integer page, @Query("pageSize") Integer pageSize, @Query("sortOrder") String sortOrder, @Query("sortBy") String sortBy);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: softheon.enterprise.api.client.SoftheonEnterpriseAPI getUserApplicationAssociations" })
        @GET("v1/directory/users/{userID}/applications")
        Observable<Response<ResponseBody>> getUserApplicationAssociations(@Path("userID") int userID, @Query("applicationID") Integer applicationID, @Query("acl") Integer acl, @Query("page") Integer page, @Query("pageSize") Integer pageSize, @Query("sortOrder") String sortOrder, @Query("sortBy") String sortBy);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: softheon.enterprise.api.client.SoftheonEnterpriseAPI createOrUpdateApplicationUserAssociation" })
        @PUT("v1/directory/applications/{applicationID}/users/{userID}")
        Observable<Response<ResponseBody>> createOrUpdateApplicationUserAssociation(@Path("userID") int userID, @Path("applicationID") int applicationID, @Body UserApplicationModel model);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: softheon.enterprise.api.client.SoftheonEnterpriseAPI deleteApplicationUserAssociation" })
        @HTTP(path = "v1/directory/applications/{applicationID}/users/{userID}", method = "DELETE", hasBody = true)
        Observable<Response<ResponseBody>> deleteApplicationUserAssociation(@Path("userID") int userID, @Path("applicationID") int applicationID);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: softheon.enterprise.api.client.SoftheonEnterpriseAPI createOrUpdateUserApplicationAssociation" })
        @PUT("v1/directory/users/{userID}/applications/{applicationID}")
        Observable<Response<ResponseBody>> createOrUpdateUserApplicationAssociation(@Path("userID") int userID, @Path("applicationID") int applicationID, @Body UserApplicationModel model);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: softheon.enterprise.api.client.SoftheonEnterpriseAPI deleteUserApplicationAssociation" })
        @HTTP(path = "v1/directory/users/{userID}/applications/{applicationID}", method = "DELETE", hasBody = true)
        Observable<Response<ResponseBody>> deleteUserApplicationAssociation(@Path("userID") int userID, @Path("applicationID") int applicationID);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: softheon.enterprise.api.client.SoftheonEnterpriseAPI getAttachmentsByFilter" })
        @GET("v1/content/attachments")
        Observable<Response<ResponseBody>> getAttachmentsByFilter(@Query("type") String type, @Query("extension") String extension, @Query("minSize") Long minSize, @Query("maxSize") Long maxSize, @Query("acl") Integer acl, @Query("entityID") Integer entityID, @Query("drawerID") Integer drawerID, @Query("name") String name, @Query("creatorUserID") Integer creatorUserID, @Query("modifierUserID") Integer modifierUserID, @Query("minInsertionTime") DateTime minInsertionTime, @Query("maxInsertionTime") DateTime maxInsertionTime, @Query("minModificationTime") DateTime minModificationTime, @Query("maxModificationTime") DateTime maxModificationTime, @Query("page") Integer page, @Query("pageSize") Integer pageSize, @Query("sortOrder") String sortOrder, @Query("sortBy") String sortBy);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: softheon.enterprise.api.client.SoftheonEnterpriseAPI getAttachmentById" })
        @GET("v1/content/attachments/{drawer}/{id}")
        Observable<Response<ResponseBody>> getAttachmentById(@Path("drawer") int drawer, @Path("id") int id);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: softheon.enterprise.api.client.SoftheonEnterpriseAPI updateAttachment" })
        @PUT("v1/content/attachments/{drawer}/{id}")
        Observable<Response<ResponseBody>> updateAttachment(@Path("drawer") int drawer, @Path("id") int id, @Body UpdateAttachmentRequestModel model);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: softheon.enterprise.api.client.SoftheonEnterpriseAPI deleteAttachment" })
        @HTTP(path = "v1/content/attachments/{drawer}/{id}", method = "DELETE", hasBody = true)
        Observable<Response<ResponseBody>> deleteAttachment(@Path("drawer") int drawer, @Path("id") int id);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: softheon.enterprise.api.client.SoftheonEnterpriseAPI getAttachmentFileContent" })
        @GET("v1/content/attachments/{drawer}/{id}/file")
        Observable<Response<ResponseBody>> getAttachmentFileContent(@Path("drawer") int drawer, @Path("id") int id);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: softheon.enterprise.api.client.SoftheonEnterpriseAPI createAttachment" })
        @POST("v1/content/attachments/{drawer}")
        Observable<Response<ResponseBody>> createAttachment(@Path("drawer") int drawer);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: softheon.enterprise.api.client.SoftheonEnterpriseAPI archiveAttachment" })
        @PUT("v1/content/attachments/{drawer}/{id}/archive")
        Observable<Response<ResponseBody>> archiveAttachment(@Path("drawer") int drawer, @Path("id") int id);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: softheon.enterprise.api.client.SoftheonEnterpriseAPI getAttachmentVersionsByFilter" })
        @GET("v1/content/attachments/{drawer}/{id}/versions")
        Observable<Response<ResponseBody>> getAttachmentVersionsByFilter(@Path("drawer") int drawer, @Path("id") int id, @Query("version") Integer version, @Query("creatorUserID") Integer creatorUserID, @Query("accessorUserID") Integer accessorUserID, @Query("minAccessTime") DateTime minAccessTime, @Query("maxAccessTime") DateTime maxAccessTime, @Query("minCreationTime") DateTime minCreationTime, @Query("maxCreationTime") DateTime maxCreationTime, @Query("minModificationTime") DateTime minModificationTime, @Query("maxModificationTime") DateTime maxModificationTime, @Query("page") Integer page, @Query("pageSize") Integer pageSize, @Query("sortOrder") String sortOrder, @Query("sortBy") String sortBy);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: softheon.enterprise.api.client.SoftheonEnterpriseAPI getAttachmentVersionFileContent" })
        @GET("v1/content/attachments/{drawer}/{id}/versions/{versionID}")
        Observable<Response<ResponseBody>> getAttachmentVersionFileContent(@Path("drawer") int drawer, @Path("id") int id, @Path("versionID") int versionID);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: softheon.enterprise.api.client.SoftheonEnterpriseAPI checkOutAttachment" })
        @PUT("v1/content/attachments/{drawer}/{id}/checkout")
        Observable<Response<ResponseBody>> checkOutAttachment(@Path("drawer") int drawer, @Path("id") int id);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: softheon.enterprise.api.client.SoftheonEnterpriseAPI undoCheckOutAttachment" })
        @HTTP(path = "v1/content/attachments/{drawer}/{id}/checkout", method = "DELETE", hasBody = true)
        Observable<Response<ResponseBody>> undoCheckOutAttachment(@Path("drawer") int drawer, @Path("id") int id);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: softheon.enterprise.api.client.SoftheonEnterpriseAPI checkInAttachment" })
        @PUT("v1/content/attachments/{drawer}/{id}/checkin")
        Observable<Response<ResponseBody>> checkInAttachment(@Path("drawer") int drawer, @Path("id") int id);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: softheon.enterprise.api.client.SoftheonEnterpriseAPI rollbackAttachmentVersion" })
        @PUT("v1/content/attachments/{drawer}/{id}/rollback/{versionID}")
        Observable<Response<ResponseBody>> rollbackAttachmentVersion(@Path("drawer") int drawer, @Path("id") int id, @Path("versionID") int versionID);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: softheon.enterprise.api.client.SoftheonEnterpriseAPI getAllDrawers" })
        @GET("v1/directory/drawers")
        Observable<Response<ResponseBody>> getAllDrawers();

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: softheon.enterprise.api.client.SoftheonEnterpriseAPI getDrawerById" })
        @GET("v1/directory/drawers/{id}")
        Observable<Response<ResponseBody>> getDrawerById(@Path("id") int id);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: softheon.enterprise.api.client.SoftheonEnterpriseAPI updateDrawer" })
        @PUT("v1/directory/drawers/{id}")
        Observable<Response<ResponseBody>> updateDrawer(@Path("id") int id, @Body DrawerBase model);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: softheon.enterprise.api.client.SoftheonEnterpriseAPI getDrawerByName" })
        @GET("v1/directory/drawers/{name}")
        Observable<Response<ResponseBody>> getDrawerByName(@Path("name") String name);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: softheon.enterprise.api.client.SoftheonEnterpriseAPI getEntitiesByFilter" })
        @GET("v1/content/entities")
        Observable<Response<ResponseBody>> getEntitiesByFilter(@Query("drawerID") int drawerID, @Query("acl") Integer acl, @Query("type") Integer type, @Query("name") String name, @Query("state") String state, @Query("referenceCount") Integer referenceCount, @Query("attachCount") Integer attachCount, @Query("noteCount") Integer noteCount, @Query("ownerUserID") Integer ownerUserID, @Query("ownerGroupID") Integer ownerGroupID, @Query("creatorUserID") Integer creatorUserID, @Query("creatorGroupID") Integer creatorGroupID, @Query("modifierUserID") Integer modifierUserID, @Query("modifierGroupID") Integer modifierGroupID, @Query("minCreationTime") DateTime minCreationTime, @Query("maxCreationTime") DateTime maxCreationTime, @Query("minModificationTime") DateTime minModificationTime, @Query("maxModificationTime") DateTime maxModificationTime, @Query("metadata") String metadata, @Query("page") Integer page, @Query("pageSize") Integer pageSize, @Query("sortOrder") String sortOrder, @Query("sortBy") String sortBy);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: softheon.enterprise.api.client.SoftheonEnterpriseAPI getEntityById" })
        @GET("v1/content/entities/{drawer}/{id}")
        Observable<Response<ResponseBody>> getEntityById(@Path("drawer") int drawer, @Path("id") int id);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: softheon.enterprise.api.client.SoftheonEnterpriseAPI updateEntity" })
        @PUT("v1/content/entities/{drawer}/{id}")
        Observable<Response<ResponseBody>> updateEntity(@Path("drawer") int drawer, @Path("id") int id, @Body UpdateEntityRequestModel model);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: softheon.enterprise.api.client.SoftheonEnterpriseAPI deleteEntity" })
        @HTTP(path = "v1/content/entities/{drawer}/{id}", method = "DELETE", hasBody = true)
        Observable<Response<ResponseBody>> deleteEntity(@Path("drawer") int drawer, @Path("id") int id);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: softheon.enterprise.api.client.SoftheonEnterpriseAPI createEntity" })
        @POST("v1/content/entities/{drawer}")
        Observable<Response<ResponseBody>> createEntity(@Path("drawer") int drawer, @Body InsertEntityRequestModel model);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: softheon.enterprise.api.client.SoftheonEnterpriseAPI copyEntity" })
        @POST("v1/content/entities/{drawer}/{id}/copy")
        Observable<Response<ResponseBody>> copyEntity(@Path("drawer") int drawer, @Path("id") int id, @Body EntityContentModel model);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: softheon.enterprise.api.client.SoftheonEnterpriseAPI getEventsByFilter" })
        @GET("v1/content/events")
        Observable<Response<ResponseBody>> getEventsByFilter(@Query("drawerID") int drawerID, @Query("entityID") int entityID, @Query("type") String type, @Query("minEventTime") DateTime minEventTime, @Query("maxEventTime") DateTime maxEventTime, @Query("eventUserID") Integer eventUserID, @Query("eventGroupID") Integer eventGroupID, @Query("category") String category, @Query("class") String classParameter, @Query("operation") String operation, @Query("minProcessingTime") Integer minProcessingTime, @Query("maxProcessingTime") Integer maxProcessingTime, @Query("page") Integer page, @Query("pageSize") Integer pageSize, @Query("sortOrder") String sortOrder, @Query("sortBy") String sortBy);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: softheon.enterprise.api.client.SoftheonEnterpriseAPI getEventById" })
        @GET("v1/content/events/{drawer}/{id}")
        Observable<Response<ResponseBody>> getEventById(@Path("drawer") int drawer, @Path("id") int id);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: softheon.enterprise.api.client.SoftheonEnterpriseAPI createEvent" })
        @POST("v1/content/events/{drawer}")
        Observable<Response<ResponseBody>> createEvent(@Path("drawer") int drawer, @Body EventModel model);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: softheon.enterprise.api.client.SoftheonEnterpriseAPI getExtensionsByFilter" })
        @GET("v1/content/extensions")
        Observable<Response<ResponseBody>> getExtensionsByFilter(@Query("drawerID") int drawerID, @Query("entityID") int entityID, @Query("profileID") int profileID, @Query("iD") Integer iD, @Query("type") Integer type, @Query("page") Integer page, @Query("pageSize") Integer pageSize, @Query("sortOrder") String sortOrder, @Query("sortBy") String sortBy);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: softheon.enterprise.api.client.SoftheonEnterpriseAPI getFlowsByFilter" })
        @GET("v1/content/flows")
        Observable<Response<ResponseBody>> getFlowsByFilter(@Query("drawerID") int drawerID, @Query("entityID") int entityID, @Query("type") String type, @Query("queueID") Integer queueID, @Query("minWorkflowTime") DateTime minWorkflowTime, @Query("maxWorkflowTime") DateTime maxWorkflowTime, @Query("minInsertionTime") DateTime minInsertionTime, @Query("maxInsertionTime") DateTime maxInsertionTime, @Query("workflowUserID") Integer workflowUserID, @Query("workflowGroupID") Integer workflowGroupID, @Query("operation") String operation, @Query("category") String category, @Query("status") String status, @Query("state") String state, @Query("minIndex1") Integer minIndex1, @Query("maxIndex1") Integer maxIndex1, @Query("minIndex2") Integer minIndex2, @Query("maxIndex2") Integer maxIndex2, @Query("page") Integer page, @Query("pageSize") Integer pageSize, @Query("sortOrder") String sortOrder, @Query("sortBy") String sortBy);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: softheon.enterprise.api.client.SoftheonEnterpriseAPI getFlowById" })
        @GET("v1/content/flows/{drawer}/{id}")
        Observable<Response<ResponseBody>> getFlowById(@Path("drawer") int drawer, @Path("id") int id);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: softheon.enterprise.api.client.SoftheonEnterpriseAPI getTemplatesByFilter" })
        @GET("v1/template/ftl")
        Observable<Response<ResponseBody>> getTemplatesByFilter(@Query("drawerID") Integer drawerID, @Query("name") String name, @Query("category") String category, @Query("page") Integer page, @Query("pageSize") Integer pageSize, @Query("sortOrder") String sortOrder, @Query("sortBy") Integer sortBy);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: softheon.enterprise.api.client.SoftheonEnterpriseAPI createTemplate" })
        @POST("v1/template/ftl")
        Observable<Response<ResponseBody>> createTemplate(@Body EntityDefinitionBase model);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: softheon.enterprise.api.client.SoftheonEnterpriseAPI getTemplateByType" })
        @GET("v1/template/ftl/{type}")
        Observable<Response<ResponseBody>> getTemplateByType(@Path("type") int type);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: softheon.enterprise.api.client.SoftheonEnterpriseAPI updateTemplateByType" })
        @PUT("v1/template/ftl/{type}")
        Observable<Response<ResponseBody>> updateTemplateByType(@Path("type") int type, @Body UpdateEntityDefinitionRequestModel model);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: softheon.enterprise.api.client.SoftheonEnterpriseAPI deleteTemplateByType" })
        @HTTP(path = "v1/template/ftl/{type}", method = "DELETE", hasBody = true)
        Observable<Response<ResponseBody>> deleteTemplateByType(@Path("type") int type);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: softheon.enterprise.api.client.SoftheonEnterpriseAPI getTemplateById" })
        @GET("v1/template/ftl/{id}")
        Observable<Response<ResponseBody>> getTemplateById(@Path("id") String id);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: softheon.enterprise.api.client.SoftheonEnterpriseAPI updateTemplateById" })
        @PUT("v1/template/ftl/{id}")
        Observable<Response<ResponseBody>> updateTemplateById(@Path("id") String id, @Body UpdateEntityDefinitionRequestModel model);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: softheon.enterprise.api.client.SoftheonEnterpriseAPI deleteTemplateById" })
        @HTTP(path = "v1/template/ftl/{id}", method = "DELETE", hasBody = true)
        Observable<Response<ResponseBody>> deleteTemplateById(@Path("id") String id);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: softheon.enterprise.api.client.SoftheonEnterpriseAPI validateTemplateField" })
        @GET("v1/template/ftl/{type}/validate/{fieldID}")
        Observable<Response<ResponseBody>> validateTemplateField(@Path("type") int type, @Path("fieldID") String fieldID, @Query("sortColumn") String sortColumn, @Query("metadata") String metadata, @Query("page") Integer page, @Query("pageSize") Integer pageSize, @Query("sortOrder") String sortOrder, @Query("sortBy") Integer sortBy);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: softheon.enterprise.api.client.SoftheonEnterpriseAPI getGroupsByFilter" })
        @GET("v1/directory/groups")
        Observable<Response<ResponseBody>> getGroupsByFilter(@Query("iD") Integer iD, @Query("userID") Integer userID, @Query("name") String name, @Query("type") String type, @Query("state") String state, @Query("page") Integer page, @Query("pageSize") Integer pageSize, @Query("sortOrder") String sortOrder, @Query("sortBy") String sortBy);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: softheon.enterprise.api.client.SoftheonEnterpriseAPI createGroup" })
        @POST("v1/directory/groups")
        Observable<Response<ResponseBody>> createGroup(@Body InsertGroupRequestModel model);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: softheon.enterprise.api.client.SoftheonEnterpriseAPI getGroupById" })
        @GET("v1/directory/groups/{id}")
        Observable<Response<ResponseBody>> getGroupById(@Path("id") int id);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: softheon.enterprise.api.client.SoftheonEnterpriseAPI updateGroup" })
        @PUT("v1/directory/groups/{id}")
        Observable<Response<ResponseBody>> updateGroup(@Path("id") int id, @Body GroupBase model);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: softheon.enterprise.api.client.SoftheonEnterpriseAPI deleteGroup" })
        @HTTP(path = "v1/directory/groups/{id}", method = "DELETE", hasBody = true)
        Observable<Response<ResponseBody>> deleteGroup(@Path("id") int id);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: softheon.enterprise.api.client.SoftheonEnterpriseAPI getLinksByFilter" })
        @GET("v1/content/links")
        Observable<Response<ResponseBody>> getLinksByFilter(@Query("childEntityID") Integer childEntityID, @Query("childDrawerID") Integer childDrawerID, @Query("childType") Integer childType, @Query("acl") Integer acl, @Query("entityID") Integer entityID, @Query("drawerID") Integer drawerID, @Query("name") String name, @Query("creatorUserID") Integer creatorUserID, @Query("modifierUserID") Integer modifierUserID, @Query("minInsertionTime") DateTime minInsertionTime, @Query("maxInsertionTime") DateTime maxInsertionTime, @Query("minModificationTime") DateTime minModificationTime, @Query("maxModificationTime") DateTime maxModificationTime, @Query("page") Integer page, @Query("pageSize") Integer pageSize, @Query("sortOrder") String sortOrder, @Query("sortBy") String sortBy);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: softheon.enterprise.api.client.SoftheonEnterpriseAPI getLinkById" })
        @GET("v1/content/links/{drawer}/{id}")
        Observable<Response<ResponseBody>> getLinkById(@Path("drawer") int drawer, @Path("id") int id);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: softheon.enterprise.api.client.SoftheonEnterpriseAPI updateLink" })
        @PUT("v1/content/links/{drawer}/{id}")
        Observable<Response<ResponseBody>> updateLink(@Path("drawer") int drawer, @Path("id") int id, @Body UpdateEntityLinkRequestModel model);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: softheon.enterprise.api.client.SoftheonEnterpriseAPI deleteLink" })
        @HTTP(path = "v1/content/links/{drawer}/{id}", method = "DELETE", hasBody = true)
        Observable<Response<ResponseBody>> deleteLink(@Path("drawer") int drawer, @Path("id") int id);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: softheon.enterprise.api.client.SoftheonEnterpriseAPI createLink" })
        @POST("v1/content/links/{drawer}")
        Observable<Response<ResponseBody>> createLink(@Path("drawer") int drawer, @Body InsertEntityLinkRequestModel model);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: softheon.enterprise.api.client.SoftheonEnterpriseAPI getLocksByFilter" })
        @GET("v1/content/entities/{drawer}/{id}/locks")
        Observable<Response<ResponseBody>> getLocksByFilter(@Path("drawer") int drawer, @Path("id") int id);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: softheon.enterprise.api.client.SoftheonEnterpriseAPI createOrUpdateLock" })
        @PUT("v1/content/entities/{drawer}/{id}/locks")
        Observable<Response<ResponseBody>> createOrUpdateLock(@Path("drawer") int drawer, @Path("id") int id, @Body UpdateLockRequestModel model);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: softheon.enterprise.api.client.SoftheonEnterpriseAPI deleteLock" })
        @HTTP(path = "v1/content/entities/{drawer}/{id}/locks", method = "DELETE", hasBody = true)
        Observable<Response<ResponseBody>> deleteLock(@Path("drawer") int drawer, @Path("id") int id);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: softheon.enterprise.api.client.SoftheonEnterpriseAPI getNotesByFilter" })
        @GET("v1/content/notes")
        Observable<Response<ResponseBody>> getNotesByFilter(@Query("drawerID") int drawerID, @Query("entityID") Integer entityID, @Query("name") String name, @Query("creatorUserID") Integer creatorUserID, @Query("modifierUserID") Integer modifierUserID, @Query("minCreationTime") DateTime minCreationTime, @Query("maxCreationTime") DateTime maxCreationTime, @Query("minModificationTime") DateTime minModificationTime, @Query("maxModificationTime") DateTime maxModificationTime, @Query("parentID") Integer parentID, @Query("page") Integer page, @Query("pageSize") Integer pageSize, @Query("sortOrder") String sortOrder, @Query("sortBy") String sortBy);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: softheon.enterprise.api.client.SoftheonEnterpriseAPI getNoteById" })
        @GET("v1/content/notes/{drawer}/{id}")
        Observable<Response<ResponseBody>> getNoteById(@Path("drawer") int drawer, @Path("id") int id);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: softheon.enterprise.api.client.SoftheonEnterpriseAPI updateNote" })
        @PUT("v1/content/notes/{drawer}/{id}")
        Observable<Response<ResponseBody>> updateNote(@Path("drawer") int drawer, @Path("id") int id, @Body NoteBase model);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: softheon.enterprise.api.client.SoftheonEnterpriseAPI deleteNote" })
        @HTTP(path = "v1/content/notes/{drawer}/{id}", method = "DELETE", hasBody = true)
        Observable<Response<ResponseBody>> deleteNote(@Path("drawer") int drawer, @Path("id") int id);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: softheon.enterprise.api.client.SoftheonEnterpriseAPI createNote" })
        @POST("v1/content/notes/{drawer}")
        Observable<Response<ResponseBody>> createNote(@Path("drawer") int drawer, @Body InsertNoteRequestModel model);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: softheon.enterprise.api.client.SoftheonEnterpriseAPI getQueueAssignmentsByFilter" })
        @GET("v1/workflow/assignments")
        Observable<Response<ResponseBody>> getQueueAssignmentsByFilter(@Query("queueID") Integer queueID, @Query("userID") Integer userID, @Query("groupID") Integer groupID, @Query("type") String type, @Query("order") Integer order, @Query("taskSortColumn") String taskSortColumn, @Query("state") String state, @Query("fetchType") String fetchType, @Query("page") Integer page, @Query("pageSize") Integer pageSize, @Query("sortOrder") String sortOrder, @Query("sortBy") String sortBy);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: softheon.enterprise.api.client.SoftheonEnterpriseAPI updateQueueAssignemnt" })
        @PUT("v1/workflow/assignments")
        Observable<Response<ResponseBody>> updateQueueAssignemnt(@Body QueueAssignmentModel model);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: softheon.enterprise.api.client.SoftheonEnterpriseAPI createQueueAssignment" })
        @POST("v1/workflow/assignments")
        Observable<Response<ResponseBody>> createQueueAssignment(@Body InsertQueueAssignmentRequestModel model);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: softheon.enterprise.api.client.SoftheonEnterpriseAPI getQueueAssignmentsById" })
        @GET("v1/workflow/assignments/users/{userId}/queues/{queueId}")
        Observable<Response<ResponseBody>> getQueueAssignmentsById(@Path("userId") int userId, @Path("queueId") int queueId);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: softheon.enterprise.api.client.SoftheonEnterpriseAPI deleteQueueAssignment" })
        @HTTP(path = "v1/workflow/assignments/users/{userId}/queues/{queueId}", method = "DELETE", hasBody = true)
        Observable<Response<ResponseBody>> deleteQueueAssignment(@Path("userId") int userId, @Path("queueId") int queueId);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: softheon.enterprise.api.client.SoftheonEnterpriseAPI getQueuesByFilter" })
        @GET("v1/workflow/queues")
        Observable<Response<ResponseBody>> getQueuesByFilter(@Query("iD") Integer iD, @Query("name") String name, @Query("alias") String alias, @Query("type") String type, @Query("access") Integer access, @Query("bypassSecurity") Boolean bypassSecurity, @Query("page") Integer page, @Query("pageSize") Integer pageSize, @Query("sortOrder") String sortOrder, @Query("sortBy") String sortBy);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: softheon.enterprise.api.client.SoftheonEnterpriseAPI createQueue" })
        @POST("v1/workflow/queues")
        Observable<Response<ResponseBody>> createQueue(@Body InsertQueueRequestModel model);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: softheon.enterprise.api.client.SoftheonEnterpriseAPI getQueueById" })
        @GET("v1/workflow/queues/{id}")
        Observable<Response<ResponseBody>> getQueueById(@Path("id") int id);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: softheon.enterprise.api.client.SoftheonEnterpriseAPI updateQueue" })
        @PUT("v1/workflow/queues/{id}")
        Observable<Response<ResponseBody>> updateQueue(@Path("id") int id, @Body QueueBase model);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: softheon.enterprise.api.client.SoftheonEnterpriseAPI deleteQueue" })
        @HTTP(path = "v1/workflow/queues/{id}", method = "DELETE", hasBody = true)
        Observable<Response<ResponseBody>> deleteQueue(@Path("id") int id);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: softheon.enterprise.api.client.SoftheonEnterpriseAPI getQueueByName" })
        @GET("v1/workflow/queues/{name}")
        Observable<Response<ResponseBody>> getQueueByName(@Path("name") String name);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: softheon.enterprise.api.client.SoftheonEnterpriseAPI getTasksByFilter" })
        @GET("v1/workflow/tasks")
        Observable<Response<ResponseBody>> getTasksByFilter(@Query("lastTaskID") Integer lastTaskID, @Query("iD") Integer iD, @Query("type") Integer type, @Query("queueID") Integer queueID, @Query("queueType") Integer queueType, @Query("drawerID") Integer drawerID, @Query("description") String description, @Query("taskID") Integer taskID, @Query("page") Integer page, @Query("pageSize") Integer pageSize, @Query("sortOrder") String sortOrder, @Query("sortBy") String sortBy);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: softheon.enterprise.api.client.SoftheonEnterpriseAPI createTask" })
        @POST("v1/workflow/tasks")
        Observable<Response<ResponseBody>> createTask(@Body InsertTaskRequestModel model);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: softheon.enterprise.api.client.SoftheonEnterpriseAPI getTaskById" })
        @GET("v1/workflow/tasks/{id}")
        Observable<Response<ResponseBody>> getTaskById(@Path("id") int id);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: softheon.enterprise.api.client.SoftheonEnterpriseAPI updateTask" })
        @PUT("v1/workflow/tasks/{id}")
        Observable<Response<ResponseBody>> updateTask(@Path("id") int id, @Body TaskBase model);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: softheon.enterprise.api.client.SoftheonEnterpriseAPI deleteTask" })
        @HTTP(path = "v1/workflow/tasks/{id}", method = "DELETE", hasBody = true)
        Observable<Response<ResponseBody>> deleteTask(@Path("id") int id);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: softheon.enterprise.api.client.SoftheonEnterpriseAPI fetchTaskFromQueueAssignment" })
        @GET("v1/workflow/tasks/fetch")
        Observable<Response<ResponseBody>> fetchTaskFromQueueAssignment();

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: softheon.enterprise.api.client.SoftheonEnterpriseAPI getUsersByFilter" })
        @GET("v1/directory/users")
        Observable<Response<ResponseBody>> getUsersByFilter(@Query("iD") Integer iD, @Query("primaryGroupID") Integer primaryGroupID, @Query("groupID") Integer groupID, @Query("groupName") String groupName, @Query("username") String username, @Query("type") String type, @Query("state") String state, @Query("fullName") String fullName, @Query("page") Integer page, @Query("pageSize") Integer pageSize, @Query("sortOrder") String sortOrder, @Query("sortBy") String sortBy);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: softheon.enterprise.api.client.SoftheonEnterpriseAPI createUser" })
        @POST("v1/directory/users")
        Observable<Response<ResponseBody>> createUser(@Body InsertUserRequestModel model);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: softheon.enterprise.api.client.SoftheonEnterpriseAPI getUserById" })
        @GET("v1/directory/users/{id}")
        Observable<Response<ResponseBody>> getUserById(@Path("id") int id);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: softheon.enterprise.api.client.SoftheonEnterpriseAPI updateUser" })
        @PUT("v1/directory/users/{id}")
        Observable<Response<ResponseBody>> updateUser(@Path("id") int id, @Body UserBase model);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: softheon.enterprise.api.client.SoftheonEnterpriseAPI deleteUser" })
        @HTTP(path = "v1/directory/users/{id}", method = "DELETE", hasBody = true)
        Observable<Response<ResponseBody>> deleteUser(@Path("id") int id);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: softheon.enterprise.api.client.SoftheonEnterpriseAPI getWorkflowsByFilter" })
        @GET("v1/workflow/workflows")
        Observable<Response<ResponseBody>> getWorkflowsByFilter(@Query("applicationID") Integer applicationID, @Query("entityType") Integer entityType, @Query("name") String name, @Query("page") Integer page, @Query("pageSize") Integer pageSize, @Query("sortOrder") String sortOrder, @Query("sortBy") Integer sortBy);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: softheon.enterprise.api.client.SoftheonEnterpriseAPI getWorkflowById" })
        @GET("v1/workflow/workflows/{id}")
        Observable<Response<ResponseBody>> getWorkflowById(@Path("id") int id);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: softheon.enterprise.api.client.SoftheonEnterpriseAPI getWorkflowQueuesById" })
        @GET("v1/workflow/workflows/{id}/queue")
        Observable<Response<ResponseBody>> getWorkflowQueuesById(@Path("id") int id);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: softheon.enterprise.api.client.SoftheonEnterpriseAPI getXMLTemplateByType" })
        @GET("v1/template/xml/{type}")
        Observable<Response<ResponseBody>> getXMLTemplateByType(@Path("type") int type);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: softheon.enterprise.api.client.SoftheonEnterpriseAPI createXMLTemplate" })
        @POST("v1/template/xml")
        Observable<Response<ResponseBody>> createXMLTemplate();

    }

    /**
     * Accepts the task.
     *
     * @param model The model.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object acceptTask(WorkflowActionModel model) {
        return acceptTaskWithServiceResponseAsync(model).toBlocking().single().body();
    }

    /**
     * Accepts the task.
     *
     * @param model The model.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> acceptTaskAsync(WorkflowActionModel model, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromResponse(acceptTaskWithServiceResponseAsync(model), serviceCallback);
    }

    /**
     * Accepts the task.
     *
     * @param model The model.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> acceptTaskAsync(WorkflowActionModel model) {
        return acceptTaskWithServiceResponseAsync(model).map(new Func1<ServiceResponse<Object>, Object>() {
            @Override
            public Object call(ServiceResponse<Object> response) {
                return response.body();
            }
        });
    }

    /**
     * Accepts the task.
     *
     * @param model The model.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> acceptTaskWithServiceResponseAsync(WorkflowActionModel model) {
        if (model == null) {
            throw new IllegalArgumentException("Parameter model is required and cannot be null.");
        }
        Validator.validate(model);
        return service.acceptTask(model)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = acceptTaskDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Object> acceptTaskDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<Object, RestException>newInstance(this.serializerAdapter())
                .register(204, new TypeToken<Object>() { }.getType())
                .register(403, new TypeToken<Void>() { }.getType())
                .register(404, new TypeToken<Void>() { }.getType())
                .build(response);
    }

    /**
     * Rejects the task.
     *
     * @param model The model.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object rejectTask(WorkflowActionModel model) {
        return rejectTaskWithServiceResponseAsync(model).toBlocking().single().body();
    }

    /**
     * Rejects the task.
     *
     * @param model The model.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> rejectTaskAsync(WorkflowActionModel model, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromResponse(rejectTaskWithServiceResponseAsync(model), serviceCallback);
    }

    /**
     * Rejects the task.
     *
     * @param model The model.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> rejectTaskAsync(WorkflowActionModel model) {
        return rejectTaskWithServiceResponseAsync(model).map(new Func1<ServiceResponse<Object>, Object>() {
            @Override
            public Object call(ServiceResponse<Object> response) {
                return response.body();
            }
        });
    }

    /**
     * Rejects the task.
     *
     * @param model The model.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> rejectTaskWithServiceResponseAsync(WorkflowActionModel model) {
        if (model == null) {
            throw new IllegalArgumentException("Parameter model is required and cannot be null.");
        }
        Validator.validate(model);
        return service.rejectTask(model)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = rejectTaskDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Object> rejectTaskDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<Object, RestException>newInstance(this.serializerAdapter())
                .register(204, new TypeToken<Object>() { }.getType())
                .register(403, new TypeToken<Void>() { }.getType())
                .register(404, new TypeToken<Void>() { }.getType())
                .build(response);
    }

    /**
     * Suspends the task.
     *
     * @param model The model.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object suspendTask(WorkflowActionModel model) {
        return suspendTaskWithServiceResponseAsync(model).toBlocking().single().body();
    }

    /**
     * Suspends the task.
     *
     * @param model The model.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> suspendTaskAsync(WorkflowActionModel model, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromResponse(suspendTaskWithServiceResponseAsync(model), serviceCallback);
    }

    /**
     * Suspends the task.
     *
     * @param model The model.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> suspendTaskAsync(WorkflowActionModel model) {
        return suspendTaskWithServiceResponseAsync(model).map(new Func1<ServiceResponse<Object>, Object>() {
            @Override
            public Object call(ServiceResponse<Object> response) {
                return response.body();
            }
        });
    }

    /**
     * Suspends the task.
     *
     * @param model The model.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> suspendTaskWithServiceResponseAsync(WorkflowActionModel model) {
        if (model == null) {
            throw new IllegalArgumentException("Parameter model is required and cannot be null.");
        }
        Validator.validate(model);
        return service.suspendTask(model)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = suspendTaskDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Object> suspendTaskDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<Object, RestException>newInstance(this.serializerAdapter())
                .register(204, new TypeToken<Object>() { }.getType())
                .register(403, new TypeToken<Void>() { }.getType())
                .register(404, new TypeToken<Void>() { }.getType())
                .build(response);
    }

    /**
     * Routes the task.
     *
     * @param model The model.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object routeTask(WorkflowActionRouteModel model) {
        return routeTaskWithServiceResponseAsync(model).toBlocking().single().body();
    }

    /**
     * Routes the task.
     *
     * @param model The model.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> routeTaskAsync(WorkflowActionRouteModel model, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromResponse(routeTaskWithServiceResponseAsync(model), serviceCallback);
    }

    /**
     * Routes the task.
     *
     * @param model The model.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> routeTaskAsync(WorkflowActionRouteModel model) {
        return routeTaskWithServiceResponseAsync(model).map(new Func1<ServiceResponse<Object>, Object>() {
            @Override
            public Object call(ServiceResponse<Object> response) {
                return response.body();
            }
        });
    }

    /**
     * Routes the task.
     *
     * @param model The model.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> routeTaskWithServiceResponseAsync(WorkflowActionRouteModel model) {
        if (model == null) {
            throw new IllegalArgumentException("Parameter model is required and cannot be null.");
        }
        Validator.validate(model);
        return service.routeTask(model)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = routeTaskDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Object> routeTaskDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<Object, RestException>newInstance(this.serializerAdapter())
                .register(204, new TypeToken<Object>() { }.getType())
                .register(403, new TypeToken<Void>() { }.getType())
                .register(404, new TypeToken<Void>() { }.getType())
                .build(response);
    }

    /**
     * Overrides the task.
     *
     * @param model The model.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object overrideTask(WorkflowActionModel model) {
        return overrideTaskWithServiceResponseAsync(model).toBlocking().single().body();
    }

    /**
     * Overrides the task.
     *
     * @param model The model.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> overrideTaskAsync(WorkflowActionModel model, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromResponse(overrideTaskWithServiceResponseAsync(model), serviceCallback);
    }

    /**
     * Overrides the task.
     *
     * @param model The model.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> overrideTaskAsync(WorkflowActionModel model) {
        return overrideTaskWithServiceResponseAsync(model).map(new Func1<ServiceResponse<Object>, Object>() {
            @Override
            public Object call(ServiceResponse<Object> response) {
                return response.body();
            }
        });
    }

    /**
     * Overrides the task.
     *
     * @param model The model.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> overrideTaskWithServiceResponseAsync(WorkflowActionModel model) {
        if (model == null) {
            throw new IllegalArgumentException("Parameter model is required and cannot be null.");
        }
        Validator.validate(model);
        return service.overrideTask(model)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = overrideTaskDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Object> overrideTaskDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<Object, RestException>newInstance(this.serializerAdapter())
                .register(204, new TypeToken<Object>() { }.getType())
                .register(403, new TypeToken<Void>() { }.getType())
                .register(404, new TypeToken<Void>() { }.getType())
                .build(response);
    }

    /**
     * Resets the task.
     *
     * @param model The model.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object resetTask(WorkflowActionModel model) {
        return resetTaskWithServiceResponseAsync(model).toBlocking().single().body();
    }

    /**
     * Resets the task.
     *
     * @param model The model.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> resetTaskAsync(WorkflowActionModel model, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromResponse(resetTaskWithServiceResponseAsync(model), serviceCallback);
    }

    /**
     * Resets the task.
     *
     * @param model The model.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> resetTaskAsync(WorkflowActionModel model) {
        return resetTaskWithServiceResponseAsync(model).map(new Func1<ServiceResponse<Object>, Object>() {
            @Override
            public Object call(ServiceResponse<Object> response) {
                return response.body();
            }
        });
    }

    /**
     * Resets the task.
     *
     * @param model The model.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> resetTaskWithServiceResponseAsync(WorkflowActionModel model) {
        if (model == null) {
            throw new IllegalArgumentException("Parameter model is required and cannot be null.");
        }
        Validator.validate(model);
        return service.resetTask(model)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = resetTaskDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Object> resetTaskDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<Object, RestException>newInstance(this.serializerAdapter())
                .register(204, new TypeToken<Object>() { }.getType())
                .register(403, new TypeToken<Void>() { }.getType())
                .register(404, new TypeToken<Void>() { }.getType())
                .build(response);
    }

    /**
     * Initializes the Workflow.
     *
     * @param model The model.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object initializeEntityWorkflow(WorkflowActionInitializeModel model) {
        return initializeEntityWorkflowWithServiceResponseAsync(model).toBlocking().single().body();
    }

    /**
     * Initializes the Workflow.
     *
     * @param model The model.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> initializeEntityWorkflowAsync(WorkflowActionInitializeModel model, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromResponse(initializeEntityWorkflowWithServiceResponseAsync(model), serviceCallback);
    }

    /**
     * Initializes the Workflow.
     *
     * @param model The model.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> initializeEntityWorkflowAsync(WorkflowActionInitializeModel model) {
        return initializeEntityWorkflowWithServiceResponseAsync(model).map(new Func1<ServiceResponse<Object>, Object>() {
            @Override
            public Object call(ServiceResponse<Object> response) {
                return response.body();
            }
        });
    }

    /**
     * Initializes the Workflow.
     *
     * @param model The model.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> initializeEntityWorkflowWithServiceResponseAsync(WorkflowActionInitializeModel model) {
        if (model == null) {
            throw new IllegalArgumentException("Parameter model is required and cannot be null.");
        }
        Validator.validate(model);
        return service.initializeEntityWorkflow(model)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = initializeEntityWorkflowDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Object> initializeEntityWorkflowDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<Object, RestException>newInstance(this.serializerAdapter())
                .register(204, new TypeToken<Object>() { }.getType())
                .register(403, new TypeToken<Void>() { }.getType())
                .register(404, new TypeToken<Void>() { }.getType())
                .build(response);
    }

    /**
     * Gets a list of all available applications.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;ApplicationModel&gt; object if successful.
     */
    public List<ApplicationModel> getAllApplications() {
        return getAllApplicationsWithServiceResponseAsync().toBlocking().single().body();
    }

    /**
     * Gets a list of all available applications.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<ApplicationModel>> getAllApplicationsAsync(final ServiceCallback<List<ApplicationModel>> serviceCallback) {
        return ServiceFuture.fromResponse(getAllApplicationsWithServiceResponseAsync(), serviceCallback);
    }

    /**
     * Gets a list of all available applications.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;ApplicationModel&gt; object
     */
    public Observable<List<ApplicationModel>> getAllApplicationsAsync() {
        return getAllApplicationsWithServiceResponseAsync().map(new Func1<ServiceResponse<List<ApplicationModel>>, List<ApplicationModel>>() {
            @Override
            public List<ApplicationModel> call(ServiceResponse<List<ApplicationModel>> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets a list of all available applications.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;ApplicationModel&gt; object
     */
    public Observable<ServiceResponse<List<ApplicationModel>>> getAllApplicationsWithServiceResponseAsync() {
        return service.getAllApplications()
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<ApplicationModel>>>>() {
                @Override
                public Observable<ServiceResponse<List<ApplicationModel>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<ApplicationModel>> clientResponse = getAllApplicationsDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<List<ApplicationModel>> getAllApplicationsDelegate(Response<ResponseBody> response) throws RestException, IOException {
        return this.restClient().responseBuilderFactory().<List<ApplicationModel>, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<List<ApplicationModel>>() { }.getType())
                .build(response);
    }

    /**
     * Gets a single application by its unique identifier.
     *
     * @param id The unique application identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the ApplicationModel object if successful.
     */
    public ApplicationModel getApplicationById(int id) {
        return getApplicationByIdWithServiceResponseAsync(id).toBlocking().single().body();
    }

    /**
     * Gets a single application by its unique identifier.
     *
     * @param id The unique application identifier.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<ApplicationModel> getApplicationByIdAsync(int id, final ServiceCallback<ApplicationModel> serviceCallback) {
        return ServiceFuture.fromResponse(getApplicationByIdWithServiceResponseAsync(id), serviceCallback);
    }

    /**
     * Gets a single application by its unique identifier.
     *
     * @param id The unique application identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ApplicationModel object
     */
    public Observable<ApplicationModel> getApplicationByIdAsync(int id) {
        return getApplicationByIdWithServiceResponseAsync(id).map(new Func1<ServiceResponse<ApplicationModel>, ApplicationModel>() {
            @Override
            public ApplicationModel call(ServiceResponse<ApplicationModel> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets a single application by its unique identifier.
     *
     * @param id The unique application identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ApplicationModel object
     */
    public Observable<ServiceResponse<ApplicationModel>> getApplicationByIdWithServiceResponseAsync(int id) {
        return service.getApplicationById(id)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<ApplicationModel>>>() {
                @Override
                public Observable<ServiceResponse<ApplicationModel>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<ApplicationModel> clientResponse = getApplicationByIdDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<ApplicationModel> getApplicationByIdDelegate(Response<ResponseBody> response) throws RestException, IOException {
        return this.restClient().responseBuilderFactory().<ApplicationModel, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<ApplicationModel>() { }.getType())
                .register(404, new TypeToken<Void>() { }.getType())
                .build(response);
    }

    /**
     * Gets a single application by its name.
     *
     * @param name The unique application name.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the ApplicationModel object if successful.
     */
    public ApplicationModel getApplicationByName(String name) {
        return getApplicationByNameWithServiceResponseAsync(name).toBlocking().single().body();
    }

    /**
     * Gets a single application by its name.
     *
     * @param name The unique application name.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<ApplicationModel> getApplicationByNameAsync(String name, final ServiceCallback<ApplicationModel> serviceCallback) {
        return ServiceFuture.fromResponse(getApplicationByNameWithServiceResponseAsync(name), serviceCallback);
    }

    /**
     * Gets a single application by its name.
     *
     * @param name The unique application name.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ApplicationModel object
     */
    public Observable<ApplicationModel> getApplicationByNameAsync(String name) {
        return getApplicationByNameWithServiceResponseAsync(name).map(new Func1<ServiceResponse<ApplicationModel>, ApplicationModel>() {
            @Override
            public ApplicationModel call(ServiceResponse<ApplicationModel> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets a single application by its name.
     *
     * @param name The unique application name.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ApplicationModel object
     */
    public Observable<ServiceResponse<ApplicationModel>> getApplicationByNameWithServiceResponseAsync(String name) {
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        return service.getApplicationByName(name)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<ApplicationModel>>>() {
                @Override
                public Observable<ServiceResponse<ApplicationModel>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<ApplicationModel> clientResponse = getApplicationByNameDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<ApplicationModel> getApplicationByNameDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<ApplicationModel, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<ApplicationModel>() { }.getType())
                .register(404, new TypeToken<Void>() { }.getType())
                .build(response);
    }

    /**
     * Gets a list of drawer group associations.
     *
     * @param drawerID The drawer identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;GroupDrawerModel&gt; object if successful.
     */
    public List<GroupDrawerModel> getDrawerGroupAssociations(int drawerID) {
        return getDrawerGroupAssociationsWithServiceResponseAsync(drawerID).toBlocking().single().body();
    }

    /**
     * Gets a list of drawer group associations.
     *
     * @param drawerID The drawer identifier.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<GroupDrawerModel>> getDrawerGroupAssociationsAsync(int drawerID, final ServiceCallback<List<GroupDrawerModel>> serviceCallback) {
        return ServiceFuture.fromResponse(getDrawerGroupAssociationsWithServiceResponseAsync(drawerID), serviceCallback);
    }

    /**
     * Gets a list of drawer group associations.
     *
     * @param drawerID The drawer identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;GroupDrawerModel&gt; object
     */
    public Observable<List<GroupDrawerModel>> getDrawerGroupAssociationsAsync(int drawerID) {
        return getDrawerGroupAssociationsWithServiceResponseAsync(drawerID).map(new Func1<ServiceResponse<List<GroupDrawerModel>>, List<GroupDrawerModel>>() {
            @Override
            public List<GroupDrawerModel> call(ServiceResponse<List<GroupDrawerModel>> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets a list of drawer group associations.
     *
     * @param drawerID The drawer identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;GroupDrawerModel&gt; object
     */
    public Observable<ServiceResponse<List<GroupDrawerModel>>> getDrawerGroupAssociationsWithServiceResponseAsync(int drawerID) {
        final Integer groupID = null;
        final Integer acl = null;
        final Integer page = null;
        final Integer pageSize = null;
        final String sortOrder = null;
        final String sortBy = null;
        return service.getDrawerGroupAssociations(drawerID, groupID, acl, page, pageSize, sortOrder, sortBy)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<GroupDrawerModel>>>>() {
                @Override
                public Observable<ServiceResponse<List<GroupDrawerModel>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<GroupDrawerModel>> clientResponse = getDrawerGroupAssociationsDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Gets a list of drawer group associations.
     *
     * @param drawerID The drawer identifier.
     * @param groupID The group identifier.
     * @param acl Gets or sets the access control level permissions.
     * @param page Gets or sets the page number.
     * @param pageSize Gets or sets the size of the page.
     * @param sortOrder Gets or sets the order. Possible values include: 'Unspecified', 'Ascending', 'Descending'
     * @param sortBy Gets or sets the column to order by. Possible values include: 'Unspecified', 'DrawerID', 'ApplicationID', 'GroupID', 'UserID', 'QueueID', 'Acl'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;GroupDrawerModel&gt; object if successful.
     */
    public List<GroupDrawerModel> getDrawerGroupAssociations(int drawerID, Integer groupID, Integer acl, Integer page, Integer pageSize, String sortOrder, String sortBy) {
        return getDrawerGroupAssociationsWithServiceResponseAsync(drawerID, groupID, acl, page, pageSize, sortOrder, sortBy).toBlocking().single().body();
    }

    /**
     * Gets a list of drawer group associations.
     *
     * @param drawerID The drawer identifier.
     * @param groupID The group identifier.
     * @param acl Gets or sets the access control level permissions.
     * @param page Gets or sets the page number.
     * @param pageSize Gets or sets the size of the page.
     * @param sortOrder Gets or sets the order. Possible values include: 'Unspecified', 'Ascending', 'Descending'
     * @param sortBy Gets or sets the column to order by. Possible values include: 'Unspecified', 'DrawerID', 'ApplicationID', 'GroupID', 'UserID', 'QueueID', 'Acl'
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<GroupDrawerModel>> getDrawerGroupAssociationsAsync(int drawerID, Integer groupID, Integer acl, Integer page, Integer pageSize, String sortOrder, String sortBy, final ServiceCallback<List<GroupDrawerModel>> serviceCallback) {
        return ServiceFuture.fromResponse(getDrawerGroupAssociationsWithServiceResponseAsync(drawerID, groupID, acl, page, pageSize, sortOrder, sortBy), serviceCallback);
    }

    /**
     * Gets a list of drawer group associations.
     *
     * @param drawerID The drawer identifier.
     * @param groupID The group identifier.
     * @param acl Gets or sets the access control level permissions.
     * @param page Gets or sets the page number.
     * @param pageSize Gets or sets the size of the page.
     * @param sortOrder Gets or sets the order. Possible values include: 'Unspecified', 'Ascending', 'Descending'
     * @param sortBy Gets or sets the column to order by. Possible values include: 'Unspecified', 'DrawerID', 'ApplicationID', 'GroupID', 'UserID', 'QueueID', 'Acl'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;GroupDrawerModel&gt; object
     */
    public Observable<List<GroupDrawerModel>> getDrawerGroupAssociationsAsync(int drawerID, Integer groupID, Integer acl, Integer page, Integer pageSize, String sortOrder, String sortBy) {
        return getDrawerGroupAssociationsWithServiceResponseAsync(drawerID, groupID, acl, page, pageSize, sortOrder, sortBy).map(new Func1<ServiceResponse<List<GroupDrawerModel>>, List<GroupDrawerModel>>() {
            @Override
            public List<GroupDrawerModel> call(ServiceResponse<List<GroupDrawerModel>> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets a list of drawer group associations.
     *
     * @param drawerID The drawer identifier.
     * @param groupID The group identifier.
     * @param acl Gets or sets the access control level permissions.
     * @param page Gets or sets the page number.
     * @param pageSize Gets or sets the size of the page.
     * @param sortOrder Gets or sets the order. Possible values include: 'Unspecified', 'Ascending', 'Descending'
     * @param sortBy Gets or sets the column to order by. Possible values include: 'Unspecified', 'DrawerID', 'ApplicationID', 'GroupID', 'UserID', 'QueueID', 'Acl'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;GroupDrawerModel&gt; object
     */
    public Observable<ServiceResponse<List<GroupDrawerModel>>> getDrawerGroupAssociationsWithServiceResponseAsync(int drawerID, Integer groupID, Integer acl, Integer page, Integer pageSize, String sortOrder, String sortBy) {
        return service.getDrawerGroupAssociations(drawerID, groupID, acl, page, pageSize, sortOrder, sortBy)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<GroupDrawerModel>>>>() {
                @Override
                public Observable<ServiceResponse<List<GroupDrawerModel>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<GroupDrawerModel>> clientResponse = getDrawerGroupAssociationsDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<List<GroupDrawerModel>> getDrawerGroupAssociationsDelegate(Response<ResponseBody> response) throws RestException, IOException {
        return this.restClient().responseBuilderFactory().<List<GroupDrawerModel>, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<List<GroupDrawerModel>>() { }.getType())
                .register(403, new TypeToken<Void>() { }.getType())
                .build(response);
    }

    /**
     * Gets a list of group drawer associations.
     *
     * @param groupID The group identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;GroupDrawerModel&gt; object if successful.
     */
    public List<GroupDrawerModel> getGroupDrawerAssociations(int groupID) {
        return getGroupDrawerAssociationsWithServiceResponseAsync(groupID).toBlocking().single().body();
    }

    /**
     * Gets a list of group drawer associations.
     *
     * @param groupID The group identifier.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<GroupDrawerModel>> getGroupDrawerAssociationsAsync(int groupID, final ServiceCallback<List<GroupDrawerModel>> serviceCallback) {
        return ServiceFuture.fromResponse(getGroupDrawerAssociationsWithServiceResponseAsync(groupID), serviceCallback);
    }

    /**
     * Gets a list of group drawer associations.
     *
     * @param groupID The group identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;GroupDrawerModel&gt; object
     */
    public Observable<List<GroupDrawerModel>> getGroupDrawerAssociationsAsync(int groupID) {
        return getGroupDrawerAssociationsWithServiceResponseAsync(groupID).map(new Func1<ServiceResponse<List<GroupDrawerModel>>, List<GroupDrawerModel>>() {
            @Override
            public List<GroupDrawerModel> call(ServiceResponse<List<GroupDrawerModel>> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets a list of group drawer associations.
     *
     * @param groupID The group identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;GroupDrawerModel&gt; object
     */
    public Observable<ServiceResponse<List<GroupDrawerModel>>> getGroupDrawerAssociationsWithServiceResponseAsync(int groupID) {
        final Integer drawerID = null;
        final Integer acl = null;
        final Integer page = null;
        final Integer pageSize = null;
        final String sortOrder = null;
        final String sortBy = null;
        return service.getGroupDrawerAssociations(groupID, drawerID, acl, page, pageSize, sortOrder, sortBy)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<GroupDrawerModel>>>>() {
                @Override
                public Observable<ServiceResponse<List<GroupDrawerModel>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<GroupDrawerModel>> clientResponse = getGroupDrawerAssociationsDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Gets a list of group drawer associations.
     *
     * @param groupID The group identifier.
     * @param drawerID The drawer identifier.
     * @param acl Gets or sets the access control level permissions.
     * @param page Gets or sets the page number.
     * @param pageSize Gets or sets the size of the page.
     * @param sortOrder Gets or sets the order. Possible values include: 'Unspecified', 'Ascending', 'Descending'
     * @param sortBy Gets or sets the column to order by. Possible values include: 'Unspecified', 'DrawerID', 'ApplicationID', 'GroupID', 'UserID', 'QueueID', 'Acl'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;GroupDrawerModel&gt; object if successful.
     */
    public List<GroupDrawerModel> getGroupDrawerAssociations(int groupID, Integer drawerID, Integer acl, Integer page, Integer pageSize, String sortOrder, String sortBy) {
        return getGroupDrawerAssociationsWithServiceResponseAsync(groupID, drawerID, acl, page, pageSize, sortOrder, sortBy).toBlocking().single().body();
    }

    /**
     * Gets a list of group drawer associations.
     *
     * @param groupID The group identifier.
     * @param drawerID The drawer identifier.
     * @param acl Gets or sets the access control level permissions.
     * @param page Gets or sets the page number.
     * @param pageSize Gets or sets the size of the page.
     * @param sortOrder Gets or sets the order. Possible values include: 'Unspecified', 'Ascending', 'Descending'
     * @param sortBy Gets or sets the column to order by. Possible values include: 'Unspecified', 'DrawerID', 'ApplicationID', 'GroupID', 'UserID', 'QueueID', 'Acl'
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<GroupDrawerModel>> getGroupDrawerAssociationsAsync(int groupID, Integer drawerID, Integer acl, Integer page, Integer pageSize, String sortOrder, String sortBy, final ServiceCallback<List<GroupDrawerModel>> serviceCallback) {
        return ServiceFuture.fromResponse(getGroupDrawerAssociationsWithServiceResponseAsync(groupID, drawerID, acl, page, pageSize, sortOrder, sortBy), serviceCallback);
    }

    /**
     * Gets a list of group drawer associations.
     *
     * @param groupID The group identifier.
     * @param drawerID The drawer identifier.
     * @param acl Gets or sets the access control level permissions.
     * @param page Gets or sets the page number.
     * @param pageSize Gets or sets the size of the page.
     * @param sortOrder Gets or sets the order. Possible values include: 'Unspecified', 'Ascending', 'Descending'
     * @param sortBy Gets or sets the column to order by. Possible values include: 'Unspecified', 'DrawerID', 'ApplicationID', 'GroupID', 'UserID', 'QueueID', 'Acl'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;GroupDrawerModel&gt; object
     */
    public Observable<List<GroupDrawerModel>> getGroupDrawerAssociationsAsync(int groupID, Integer drawerID, Integer acl, Integer page, Integer pageSize, String sortOrder, String sortBy) {
        return getGroupDrawerAssociationsWithServiceResponseAsync(groupID, drawerID, acl, page, pageSize, sortOrder, sortBy).map(new Func1<ServiceResponse<List<GroupDrawerModel>>, List<GroupDrawerModel>>() {
            @Override
            public List<GroupDrawerModel> call(ServiceResponse<List<GroupDrawerModel>> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets a list of group drawer associations.
     *
     * @param groupID The group identifier.
     * @param drawerID The drawer identifier.
     * @param acl Gets or sets the access control level permissions.
     * @param page Gets or sets the page number.
     * @param pageSize Gets or sets the size of the page.
     * @param sortOrder Gets or sets the order. Possible values include: 'Unspecified', 'Ascending', 'Descending'
     * @param sortBy Gets or sets the column to order by. Possible values include: 'Unspecified', 'DrawerID', 'ApplicationID', 'GroupID', 'UserID', 'QueueID', 'Acl'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;GroupDrawerModel&gt; object
     */
    public Observable<ServiceResponse<List<GroupDrawerModel>>> getGroupDrawerAssociationsWithServiceResponseAsync(int groupID, Integer drawerID, Integer acl, Integer page, Integer pageSize, String sortOrder, String sortBy) {
        return service.getGroupDrawerAssociations(groupID, drawerID, acl, page, pageSize, sortOrder, sortBy)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<GroupDrawerModel>>>>() {
                @Override
                public Observable<ServiceResponse<List<GroupDrawerModel>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<GroupDrawerModel>> clientResponse = getGroupDrawerAssociationsDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<List<GroupDrawerModel>> getGroupDrawerAssociationsDelegate(Response<ResponseBody> response) throws RestException, IOException {
        return this.restClient().responseBuilderFactory().<List<GroupDrawerModel>, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<List<GroupDrawerModel>>() { }.getType())
                .register(403, new TypeToken<Void>() { }.getType())
                .build(response);
    }

    /**
     * Inserts/Updates the drawer group association.
     *
     * @param groupID The group identifier.
     * @param drawerID The drawer identifier.
     * @param model The model.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object createOrUpdateDrawerGroupAssociation(int groupID, int drawerID, GroupDrawerModel model) {
        return createOrUpdateDrawerGroupAssociationWithServiceResponseAsync(groupID, drawerID, model).toBlocking().single().body();
    }

    /**
     * Inserts/Updates the drawer group association.
     *
     * @param groupID The group identifier.
     * @param drawerID The drawer identifier.
     * @param model The model.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> createOrUpdateDrawerGroupAssociationAsync(int groupID, int drawerID, GroupDrawerModel model, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromResponse(createOrUpdateDrawerGroupAssociationWithServiceResponseAsync(groupID, drawerID, model), serviceCallback);
    }

    /**
     * Inserts/Updates the drawer group association.
     *
     * @param groupID The group identifier.
     * @param drawerID The drawer identifier.
     * @param model The model.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> createOrUpdateDrawerGroupAssociationAsync(int groupID, int drawerID, GroupDrawerModel model) {
        return createOrUpdateDrawerGroupAssociationWithServiceResponseAsync(groupID, drawerID, model).map(new Func1<ServiceResponse<Object>, Object>() {
            @Override
            public Object call(ServiceResponse<Object> response) {
                return response.body();
            }
        });
    }

    /**
     * Inserts/Updates the drawer group association.
     *
     * @param groupID The group identifier.
     * @param drawerID The drawer identifier.
     * @param model The model.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> createOrUpdateDrawerGroupAssociationWithServiceResponseAsync(int groupID, int drawerID, GroupDrawerModel model) {
        if (model == null) {
            throw new IllegalArgumentException("Parameter model is required and cannot be null.");
        }
        Validator.validate(model);
        return service.createOrUpdateDrawerGroupAssociation(groupID, drawerID, model)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = createOrUpdateDrawerGroupAssociationDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Object> createOrUpdateDrawerGroupAssociationDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<Object, RestException>newInstance(this.serializerAdapter())
                .register(204, new TypeToken<Object>() { }.getType())
                .register(403, new TypeToken<Void>() { }.getType())
                .build(response);
    }

    /**
     * Deletes a drawer group association;.
     *
     * @param groupID The group identifier.
     * @param drawerID The drawer identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object deleteDrawerGroupAssociation(int groupID, int drawerID) {
        return deleteDrawerGroupAssociationWithServiceResponseAsync(groupID, drawerID).toBlocking().single().body();
    }

    /**
     * Deletes a drawer group association;.
     *
     * @param groupID The group identifier.
     * @param drawerID The drawer identifier.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> deleteDrawerGroupAssociationAsync(int groupID, int drawerID, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromResponse(deleteDrawerGroupAssociationWithServiceResponseAsync(groupID, drawerID), serviceCallback);
    }

    /**
     * Deletes a drawer group association;.
     *
     * @param groupID The group identifier.
     * @param drawerID The drawer identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> deleteDrawerGroupAssociationAsync(int groupID, int drawerID) {
        return deleteDrawerGroupAssociationWithServiceResponseAsync(groupID, drawerID).map(new Func1<ServiceResponse<Object>, Object>() {
            @Override
            public Object call(ServiceResponse<Object> response) {
                return response.body();
            }
        });
    }

    /**
     * Deletes a drawer group association;.
     *
     * @param groupID The group identifier.
     * @param drawerID The drawer identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> deleteDrawerGroupAssociationWithServiceResponseAsync(int groupID, int drawerID) {
        return service.deleteDrawerGroupAssociation(groupID, drawerID)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = deleteDrawerGroupAssociationDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Object> deleteDrawerGroupAssociationDelegate(Response<ResponseBody> response) throws RestException, IOException {
        return this.restClient().responseBuilderFactory().<Object, RestException>newInstance(this.serializerAdapter())
                .register(204, new TypeToken<Object>() { }.getType())
                .register(403, new TypeToken<Void>() { }.getType())
                .register(404, new TypeToken<Void>() { }.getType())
                .build(response);
    }

    /**
     * Inserts/Updates the group drawer association.
     *
     * @param groupID The group identifier.
     * @param drawerID The drawer identifier.
     * @param model The model.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object createOrUpdateGroupDrawerAssociation(int groupID, int drawerID, GroupDrawerModel model) {
        return createOrUpdateGroupDrawerAssociationWithServiceResponseAsync(groupID, drawerID, model).toBlocking().single().body();
    }

    /**
     * Inserts/Updates the group drawer association.
     *
     * @param groupID The group identifier.
     * @param drawerID The drawer identifier.
     * @param model The model.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> createOrUpdateGroupDrawerAssociationAsync(int groupID, int drawerID, GroupDrawerModel model, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromResponse(createOrUpdateGroupDrawerAssociationWithServiceResponseAsync(groupID, drawerID, model), serviceCallback);
    }

    /**
     * Inserts/Updates the group drawer association.
     *
     * @param groupID The group identifier.
     * @param drawerID The drawer identifier.
     * @param model The model.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> createOrUpdateGroupDrawerAssociationAsync(int groupID, int drawerID, GroupDrawerModel model) {
        return createOrUpdateGroupDrawerAssociationWithServiceResponseAsync(groupID, drawerID, model).map(new Func1<ServiceResponse<Object>, Object>() {
            @Override
            public Object call(ServiceResponse<Object> response) {
                return response.body();
            }
        });
    }

    /**
     * Inserts/Updates the group drawer association.
     *
     * @param groupID The group identifier.
     * @param drawerID The drawer identifier.
     * @param model The model.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> createOrUpdateGroupDrawerAssociationWithServiceResponseAsync(int groupID, int drawerID, GroupDrawerModel model) {
        if (model == null) {
            throw new IllegalArgumentException("Parameter model is required and cannot be null.");
        }
        Validator.validate(model);
        return service.createOrUpdateGroupDrawerAssociation(groupID, drawerID, model)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = createOrUpdateGroupDrawerAssociationDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Object> createOrUpdateGroupDrawerAssociationDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<Object, RestException>newInstance(this.serializerAdapter())
                .register(204, new TypeToken<Object>() { }.getType())
                .register(403, new TypeToken<Void>() { }.getType())
                .build(response);
    }

    /**
     * Deletes a group drawer association;.
     *
     * @param groupID The group identifier.
     * @param drawerID The drawer identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object deleteGroupDrawerAssociation(int groupID, int drawerID) {
        return deleteGroupDrawerAssociationWithServiceResponseAsync(groupID, drawerID).toBlocking().single().body();
    }

    /**
     * Deletes a group drawer association;.
     *
     * @param groupID The group identifier.
     * @param drawerID The drawer identifier.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> deleteGroupDrawerAssociationAsync(int groupID, int drawerID, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromResponse(deleteGroupDrawerAssociationWithServiceResponseAsync(groupID, drawerID), serviceCallback);
    }

    /**
     * Deletes a group drawer association;.
     *
     * @param groupID The group identifier.
     * @param drawerID The drawer identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> deleteGroupDrawerAssociationAsync(int groupID, int drawerID) {
        return deleteGroupDrawerAssociationWithServiceResponseAsync(groupID, drawerID).map(new Func1<ServiceResponse<Object>, Object>() {
            @Override
            public Object call(ServiceResponse<Object> response) {
                return response.body();
            }
        });
    }

    /**
     * Deletes a group drawer association;.
     *
     * @param groupID The group identifier.
     * @param drawerID The drawer identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> deleteGroupDrawerAssociationWithServiceResponseAsync(int groupID, int drawerID) {
        return service.deleteGroupDrawerAssociation(groupID, drawerID)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = deleteGroupDrawerAssociationDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Object> deleteGroupDrawerAssociationDelegate(Response<ResponseBody> response) throws RestException, IOException {
        return this.restClient().responseBuilderFactory().<Object, RestException>newInstance(this.serializerAdapter())
                .register(204, new TypeToken<Object>() { }.getType())
                .register(403, new TypeToken<Void>() { }.getType())
                .register(404, new TypeToken<Void>() { }.getType())
                .build(response);
    }

    /**
     * Gets a list of user group associations.
     *
     * @param userID The user identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;GroupUserModel&gt; object if successful.
     */
    public List<GroupUserModel> getUserGroupAssociations(int userID) {
        return getUserGroupAssociationsWithServiceResponseAsync(userID).toBlocking().single().body();
    }

    /**
     * Gets a list of user group associations.
     *
     * @param userID The user identifier.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<GroupUserModel>> getUserGroupAssociationsAsync(int userID, final ServiceCallback<List<GroupUserModel>> serviceCallback) {
        return ServiceFuture.fromResponse(getUserGroupAssociationsWithServiceResponseAsync(userID), serviceCallback);
    }

    /**
     * Gets a list of user group associations.
     *
     * @param userID The user identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;GroupUserModel&gt; object
     */
    public Observable<List<GroupUserModel>> getUserGroupAssociationsAsync(int userID) {
        return getUserGroupAssociationsWithServiceResponseAsync(userID).map(new Func1<ServiceResponse<List<GroupUserModel>>, List<GroupUserModel>>() {
            @Override
            public List<GroupUserModel> call(ServiceResponse<List<GroupUserModel>> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets a list of user group associations.
     *
     * @param userID The user identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;GroupUserModel&gt; object
     */
    public Observable<ServiceResponse<List<GroupUserModel>>> getUserGroupAssociationsWithServiceResponseAsync(int userID) {
        final Integer groupID = null;
        final Integer acl = null;
        final Integer page = null;
        final Integer pageSize = null;
        final String sortOrder = null;
        final String sortBy = null;
        return service.getUserGroupAssociations(userID, groupID, acl, page, pageSize, sortOrder, sortBy)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<GroupUserModel>>>>() {
                @Override
                public Observable<ServiceResponse<List<GroupUserModel>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<GroupUserModel>> clientResponse = getUserGroupAssociationsDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Gets a list of user group associations.
     *
     * @param userID The user identifier.
     * @param groupID The group identifier.
     * @param acl Gets or sets the access control level permissions.
     * @param page Gets or sets the page number.
     * @param pageSize Gets or sets the size of the page.
     * @param sortOrder Gets or sets the order. Possible values include: 'Unspecified', 'Ascending', 'Descending'
     * @param sortBy Gets or sets the column to order by. Possible values include: 'Unspecified', 'DrawerID', 'ApplicationID', 'GroupID', 'UserID', 'QueueID', 'Acl'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;GroupUserModel&gt; object if successful.
     */
    public List<GroupUserModel> getUserGroupAssociations(int userID, Integer groupID, Integer acl, Integer page, Integer pageSize, String sortOrder, String sortBy) {
        return getUserGroupAssociationsWithServiceResponseAsync(userID, groupID, acl, page, pageSize, sortOrder, sortBy).toBlocking().single().body();
    }

    /**
     * Gets a list of user group associations.
     *
     * @param userID The user identifier.
     * @param groupID The group identifier.
     * @param acl Gets or sets the access control level permissions.
     * @param page Gets or sets the page number.
     * @param pageSize Gets or sets the size of the page.
     * @param sortOrder Gets or sets the order. Possible values include: 'Unspecified', 'Ascending', 'Descending'
     * @param sortBy Gets or sets the column to order by. Possible values include: 'Unspecified', 'DrawerID', 'ApplicationID', 'GroupID', 'UserID', 'QueueID', 'Acl'
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<GroupUserModel>> getUserGroupAssociationsAsync(int userID, Integer groupID, Integer acl, Integer page, Integer pageSize, String sortOrder, String sortBy, final ServiceCallback<List<GroupUserModel>> serviceCallback) {
        return ServiceFuture.fromResponse(getUserGroupAssociationsWithServiceResponseAsync(userID, groupID, acl, page, pageSize, sortOrder, sortBy), serviceCallback);
    }

    /**
     * Gets a list of user group associations.
     *
     * @param userID The user identifier.
     * @param groupID The group identifier.
     * @param acl Gets or sets the access control level permissions.
     * @param page Gets or sets the page number.
     * @param pageSize Gets or sets the size of the page.
     * @param sortOrder Gets or sets the order. Possible values include: 'Unspecified', 'Ascending', 'Descending'
     * @param sortBy Gets or sets the column to order by. Possible values include: 'Unspecified', 'DrawerID', 'ApplicationID', 'GroupID', 'UserID', 'QueueID', 'Acl'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;GroupUserModel&gt; object
     */
    public Observable<List<GroupUserModel>> getUserGroupAssociationsAsync(int userID, Integer groupID, Integer acl, Integer page, Integer pageSize, String sortOrder, String sortBy) {
        return getUserGroupAssociationsWithServiceResponseAsync(userID, groupID, acl, page, pageSize, sortOrder, sortBy).map(new Func1<ServiceResponse<List<GroupUserModel>>, List<GroupUserModel>>() {
            @Override
            public List<GroupUserModel> call(ServiceResponse<List<GroupUserModel>> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets a list of user group associations.
     *
     * @param userID The user identifier.
     * @param groupID The group identifier.
     * @param acl Gets or sets the access control level permissions.
     * @param page Gets or sets the page number.
     * @param pageSize Gets or sets the size of the page.
     * @param sortOrder Gets or sets the order. Possible values include: 'Unspecified', 'Ascending', 'Descending'
     * @param sortBy Gets or sets the column to order by. Possible values include: 'Unspecified', 'DrawerID', 'ApplicationID', 'GroupID', 'UserID', 'QueueID', 'Acl'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;GroupUserModel&gt; object
     */
    public Observable<ServiceResponse<List<GroupUserModel>>> getUserGroupAssociationsWithServiceResponseAsync(int userID, Integer groupID, Integer acl, Integer page, Integer pageSize, String sortOrder, String sortBy) {
        return service.getUserGroupAssociations(userID, groupID, acl, page, pageSize, sortOrder, sortBy)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<GroupUserModel>>>>() {
                @Override
                public Observable<ServiceResponse<List<GroupUserModel>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<GroupUserModel>> clientResponse = getUserGroupAssociationsDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<List<GroupUserModel>> getUserGroupAssociationsDelegate(Response<ResponseBody> response) throws RestException, IOException {
        return this.restClient().responseBuilderFactory().<List<GroupUserModel>, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<List<GroupUserModel>>() { }.getType())
                .register(403, new TypeToken<Void>() { }.getType())
                .build(response);
    }

    /**
     * Gets a list of group user associations.
     *
     * @param groupID The group identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;GroupUserModel&gt; object if successful.
     */
    public List<GroupUserModel> getGroupUserAssociations(int groupID) {
        return getGroupUserAssociationsWithServiceResponseAsync(groupID).toBlocking().single().body();
    }

    /**
     * Gets a list of group user associations.
     *
     * @param groupID The group identifier.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<GroupUserModel>> getGroupUserAssociationsAsync(int groupID, final ServiceCallback<List<GroupUserModel>> serviceCallback) {
        return ServiceFuture.fromResponse(getGroupUserAssociationsWithServiceResponseAsync(groupID), serviceCallback);
    }

    /**
     * Gets a list of group user associations.
     *
     * @param groupID The group identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;GroupUserModel&gt; object
     */
    public Observable<List<GroupUserModel>> getGroupUserAssociationsAsync(int groupID) {
        return getGroupUserAssociationsWithServiceResponseAsync(groupID).map(new Func1<ServiceResponse<List<GroupUserModel>>, List<GroupUserModel>>() {
            @Override
            public List<GroupUserModel> call(ServiceResponse<List<GroupUserModel>> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets a list of group user associations.
     *
     * @param groupID The group identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;GroupUserModel&gt; object
     */
    public Observable<ServiceResponse<List<GroupUserModel>>> getGroupUserAssociationsWithServiceResponseAsync(int groupID) {
        final Integer userID = null;
        final Integer acl = null;
        final Integer page = null;
        final Integer pageSize = null;
        final String sortOrder = null;
        final String sortBy = null;
        return service.getGroupUserAssociations(groupID, userID, acl, page, pageSize, sortOrder, sortBy)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<GroupUserModel>>>>() {
                @Override
                public Observable<ServiceResponse<List<GroupUserModel>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<GroupUserModel>> clientResponse = getGroupUserAssociationsDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Gets a list of group user associations.
     *
     * @param groupID The group identifier.
     * @param userID The user identifier.
     * @param acl Gets or sets the access control level permissions.
     * @param page Gets or sets the page number.
     * @param pageSize Gets or sets the size of the page.
     * @param sortOrder Gets or sets the order. Possible values include: 'Unspecified', 'Ascending', 'Descending'
     * @param sortBy Gets or sets the column to order by. Possible values include: 'Unspecified', 'DrawerID', 'ApplicationID', 'GroupID', 'UserID', 'QueueID', 'Acl'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;GroupUserModel&gt; object if successful.
     */
    public List<GroupUserModel> getGroupUserAssociations(int groupID, Integer userID, Integer acl, Integer page, Integer pageSize, String sortOrder, String sortBy) {
        return getGroupUserAssociationsWithServiceResponseAsync(groupID, userID, acl, page, pageSize, sortOrder, sortBy).toBlocking().single().body();
    }

    /**
     * Gets a list of group user associations.
     *
     * @param groupID The group identifier.
     * @param userID The user identifier.
     * @param acl Gets or sets the access control level permissions.
     * @param page Gets or sets the page number.
     * @param pageSize Gets or sets the size of the page.
     * @param sortOrder Gets or sets the order. Possible values include: 'Unspecified', 'Ascending', 'Descending'
     * @param sortBy Gets or sets the column to order by. Possible values include: 'Unspecified', 'DrawerID', 'ApplicationID', 'GroupID', 'UserID', 'QueueID', 'Acl'
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<GroupUserModel>> getGroupUserAssociationsAsync(int groupID, Integer userID, Integer acl, Integer page, Integer pageSize, String sortOrder, String sortBy, final ServiceCallback<List<GroupUserModel>> serviceCallback) {
        return ServiceFuture.fromResponse(getGroupUserAssociationsWithServiceResponseAsync(groupID, userID, acl, page, pageSize, sortOrder, sortBy), serviceCallback);
    }

    /**
     * Gets a list of group user associations.
     *
     * @param groupID The group identifier.
     * @param userID The user identifier.
     * @param acl Gets or sets the access control level permissions.
     * @param page Gets or sets the page number.
     * @param pageSize Gets or sets the size of the page.
     * @param sortOrder Gets or sets the order. Possible values include: 'Unspecified', 'Ascending', 'Descending'
     * @param sortBy Gets or sets the column to order by. Possible values include: 'Unspecified', 'DrawerID', 'ApplicationID', 'GroupID', 'UserID', 'QueueID', 'Acl'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;GroupUserModel&gt; object
     */
    public Observable<List<GroupUserModel>> getGroupUserAssociationsAsync(int groupID, Integer userID, Integer acl, Integer page, Integer pageSize, String sortOrder, String sortBy) {
        return getGroupUserAssociationsWithServiceResponseAsync(groupID, userID, acl, page, pageSize, sortOrder, sortBy).map(new Func1<ServiceResponse<List<GroupUserModel>>, List<GroupUserModel>>() {
            @Override
            public List<GroupUserModel> call(ServiceResponse<List<GroupUserModel>> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets a list of group user associations.
     *
     * @param groupID The group identifier.
     * @param userID The user identifier.
     * @param acl Gets or sets the access control level permissions.
     * @param page Gets or sets the page number.
     * @param pageSize Gets or sets the size of the page.
     * @param sortOrder Gets or sets the order. Possible values include: 'Unspecified', 'Ascending', 'Descending'
     * @param sortBy Gets or sets the column to order by. Possible values include: 'Unspecified', 'DrawerID', 'ApplicationID', 'GroupID', 'UserID', 'QueueID', 'Acl'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;GroupUserModel&gt; object
     */
    public Observable<ServiceResponse<List<GroupUserModel>>> getGroupUserAssociationsWithServiceResponseAsync(int groupID, Integer userID, Integer acl, Integer page, Integer pageSize, String sortOrder, String sortBy) {
        return service.getGroupUserAssociations(groupID, userID, acl, page, pageSize, sortOrder, sortBy)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<GroupUserModel>>>>() {
                @Override
                public Observable<ServiceResponse<List<GroupUserModel>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<GroupUserModel>> clientResponse = getGroupUserAssociationsDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<List<GroupUserModel>> getGroupUserAssociationsDelegate(Response<ResponseBody> response) throws RestException, IOException {
        return this.restClient().responseBuilderFactory().<List<GroupUserModel>, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<List<GroupUserModel>>() { }.getType())
                .register(403, new TypeToken<Void>() { }.getType())
                .build(response);
    }

    /**
     * Inserts the user group association.
     *
     * @param groupID The group identifier.
     * @param userID The user identifier.
     * @param model The model.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object createUserGroupAssociation(int groupID, int userID, GroupUserModel model) {
        return createUserGroupAssociationWithServiceResponseAsync(groupID, userID, model).toBlocking().single().body();
    }

    /**
     * Inserts the user group association.
     *
     * @param groupID The group identifier.
     * @param userID The user identifier.
     * @param model The model.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> createUserGroupAssociationAsync(int groupID, int userID, GroupUserModel model, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromResponse(createUserGroupAssociationWithServiceResponseAsync(groupID, userID, model), serviceCallback);
    }

    /**
     * Inserts the user group association.
     *
     * @param groupID The group identifier.
     * @param userID The user identifier.
     * @param model The model.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> createUserGroupAssociationAsync(int groupID, int userID, GroupUserModel model) {
        return createUserGroupAssociationWithServiceResponseAsync(groupID, userID, model).map(new Func1<ServiceResponse<Object>, Object>() {
            @Override
            public Object call(ServiceResponse<Object> response) {
                return response.body();
            }
        });
    }

    /**
     * Inserts the user group association.
     *
     * @param groupID The group identifier.
     * @param userID The user identifier.
     * @param model The model.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> createUserGroupAssociationWithServiceResponseAsync(int groupID, int userID, GroupUserModel model) {
        if (model == null) {
            throw new IllegalArgumentException("Parameter model is required and cannot be null.");
        }
        Validator.validate(model);
        return service.createUserGroupAssociation(groupID, userID, model)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = createUserGroupAssociationDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Object> createUserGroupAssociationDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<Object, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<Object>() { }.getType())
                .register(403, new TypeToken<Void>() { }.getType())
                .register(409, new TypeToken<Void>() { }.getType())
                .build(response);
    }

    /**
     * Deletes a user group association;.
     *
     * @param groupID The group identifier.
     * @param userID The user identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object deleteUserGroupAssociation(int groupID, int userID) {
        return deleteUserGroupAssociationWithServiceResponseAsync(groupID, userID).toBlocking().single().body();
    }

    /**
     * Deletes a user group association;.
     *
     * @param groupID The group identifier.
     * @param userID The user identifier.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> deleteUserGroupAssociationAsync(int groupID, int userID, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromResponse(deleteUserGroupAssociationWithServiceResponseAsync(groupID, userID), serviceCallback);
    }

    /**
     * Deletes a user group association;.
     *
     * @param groupID The group identifier.
     * @param userID The user identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> deleteUserGroupAssociationAsync(int groupID, int userID) {
        return deleteUserGroupAssociationWithServiceResponseAsync(groupID, userID).map(new Func1<ServiceResponse<Object>, Object>() {
            @Override
            public Object call(ServiceResponse<Object> response) {
                return response.body();
            }
        });
    }

    /**
     * Deletes a user group association;.
     *
     * @param groupID The group identifier.
     * @param userID The user identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> deleteUserGroupAssociationWithServiceResponseAsync(int groupID, int userID) {
        return service.deleteUserGroupAssociation(groupID, userID)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = deleteUserGroupAssociationDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Object> deleteUserGroupAssociationDelegate(Response<ResponseBody> response) throws RestException, IOException {
        return this.restClient().responseBuilderFactory().<Object, RestException>newInstance(this.serializerAdapter())
                .register(204, new TypeToken<Object>() { }.getType())
                .register(403, new TypeToken<Void>() { }.getType())
                .register(404, new TypeToken<Void>() { }.getType())
                .build(response);
    }

    /**
     * Inserts the group user association.
     *
     * @param groupID The group identifier.
     * @param userID The user identifier.
     * @param model The model.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object createGroupUserAssociation(int groupID, int userID, GroupUserModel model) {
        return createGroupUserAssociationWithServiceResponseAsync(groupID, userID, model).toBlocking().single().body();
    }

    /**
     * Inserts the group user association.
     *
     * @param groupID The group identifier.
     * @param userID The user identifier.
     * @param model The model.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> createGroupUserAssociationAsync(int groupID, int userID, GroupUserModel model, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromResponse(createGroupUserAssociationWithServiceResponseAsync(groupID, userID, model), serviceCallback);
    }

    /**
     * Inserts the group user association.
     *
     * @param groupID The group identifier.
     * @param userID The user identifier.
     * @param model The model.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> createGroupUserAssociationAsync(int groupID, int userID, GroupUserModel model) {
        return createGroupUserAssociationWithServiceResponseAsync(groupID, userID, model).map(new Func1<ServiceResponse<Object>, Object>() {
            @Override
            public Object call(ServiceResponse<Object> response) {
                return response.body();
            }
        });
    }

    /**
     * Inserts the group user association.
     *
     * @param groupID The group identifier.
     * @param userID The user identifier.
     * @param model The model.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> createGroupUserAssociationWithServiceResponseAsync(int groupID, int userID, GroupUserModel model) {
        if (model == null) {
            throw new IllegalArgumentException("Parameter model is required and cannot be null.");
        }
        Validator.validate(model);
        return service.createGroupUserAssociation(groupID, userID, model)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = createGroupUserAssociationDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Object> createGroupUserAssociationDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<Object, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<Object>() { }.getType())
                .register(403, new TypeToken<Void>() { }.getType())
                .register(409, new TypeToken<Void>() { }.getType())
                .build(response);
    }

    /**
     * Deletes a group user association;.
     *
     * @param groupID The group identifier.
     * @param userID The user identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object deleteGroupUserAssociation(int groupID, int userID) {
        return deleteGroupUserAssociationWithServiceResponseAsync(groupID, userID).toBlocking().single().body();
    }

    /**
     * Deletes a group user association;.
     *
     * @param groupID The group identifier.
     * @param userID The user identifier.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> deleteGroupUserAssociationAsync(int groupID, int userID, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromResponse(deleteGroupUserAssociationWithServiceResponseAsync(groupID, userID), serviceCallback);
    }

    /**
     * Deletes a group user association;.
     *
     * @param groupID The group identifier.
     * @param userID The user identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> deleteGroupUserAssociationAsync(int groupID, int userID) {
        return deleteGroupUserAssociationWithServiceResponseAsync(groupID, userID).map(new Func1<ServiceResponse<Object>, Object>() {
            @Override
            public Object call(ServiceResponse<Object> response) {
                return response.body();
            }
        });
    }

    /**
     * Deletes a group user association;.
     *
     * @param groupID The group identifier.
     * @param userID The user identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> deleteGroupUserAssociationWithServiceResponseAsync(int groupID, int userID) {
        return service.deleteGroupUserAssociation(groupID, userID)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = deleteGroupUserAssociationDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Object> deleteGroupUserAssociationDelegate(Response<ResponseBody> response) throws RestException, IOException {
        return this.restClient().responseBuilderFactory().<Object, RestException>newInstance(this.serializerAdapter())
                .register(204, new TypeToken<Object>() { }.getType())
                .register(403, new TypeToken<Void>() { }.getType())
                .register(404, new TypeToken<Void>() { }.getType())
                .build(response);
    }

    /**
     * Gets a list of queue group associations.
     *
     * @param queueID The queue identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;GroupQueueModel&gt; object if successful.
     */
    public List<GroupQueueModel> getQueueGroupAssociations(int queueID) {
        return getQueueGroupAssociationsWithServiceResponseAsync(queueID).toBlocking().single().body();
    }

    /**
     * Gets a list of queue group associations.
     *
     * @param queueID The queue identifier.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<GroupQueueModel>> getQueueGroupAssociationsAsync(int queueID, final ServiceCallback<List<GroupQueueModel>> serviceCallback) {
        return ServiceFuture.fromResponse(getQueueGroupAssociationsWithServiceResponseAsync(queueID), serviceCallback);
    }

    /**
     * Gets a list of queue group associations.
     *
     * @param queueID The queue identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;GroupQueueModel&gt; object
     */
    public Observable<List<GroupQueueModel>> getQueueGroupAssociationsAsync(int queueID) {
        return getQueueGroupAssociationsWithServiceResponseAsync(queueID).map(new Func1<ServiceResponse<List<GroupQueueModel>>, List<GroupQueueModel>>() {
            @Override
            public List<GroupQueueModel> call(ServiceResponse<List<GroupQueueModel>> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets a list of queue group associations.
     *
     * @param queueID The queue identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;GroupQueueModel&gt; object
     */
    public Observable<ServiceResponse<List<GroupQueueModel>>> getQueueGroupAssociationsWithServiceResponseAsync(int queueID) {
        final Integer groupID = null;
        final Integer acl = null;
        final Integer page = null;
        final Integer pageSize = null;
        final String sortOrder = null;
        final String sortBy = null;
        return service.getQueueGroupAssociations(queueID, groupID, acl, page, pageSize, sortOrder, sortBy)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<GroupQueueModel>>>>() {
                @Override
                public Observable<ServiceResponse<List<GroupQueueModel>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<GroupQueueModel>> clientResponse = getQueueGroupAssociationsDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Gets a list of queue group associations.
     *
     * @param queueID The queue identifier.
     * @param groupID The group identifier.
     * @param acl Gets or sets the access control level permissions.
     * @param page Gets or sets the page number.
     * @param pageSize Gets or sets the size of the page.
     * @param sortOrder Gets or sets the order. Possible values include: 'Unspecified', 'Ascending', 'Descending'
     * @param sortBy Gets or sets the column to order by. Possible values include: 'Unspecified', 'DrawerID', 'ApplicationID', 'GroupID', 'UserID', 'QueueID', 'Acl'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;GroupQueueModel&gt; object if successful.
     */
    public List<GroupQueueModel> getQueueGroupAssociations(int queueID, Integer groupID, Integer acl, Integer page, Integer pageSize, String sortOrder, String sortBy) {
        return getQueueGroupAssociationsWithServiceResponseAsync(queueID, groupID, acl, page, pageSize, sortOrder, sortBy).toBlocking().single().body();
    }

    /**
     * Gets a list of queue group associations.
     *
     * @param queueID The queue identifier.
     * @param groupID The group identifier.
     * @param acl Gets or sets the access control level permissions.
     * @param page Gets or sets the page number.
     * @param pageSize Gets or sets the size of the page.
     * @param sortOrder Gets or sets the order. Possible values include: 'Unspecified', 'Ascending', 'Descending'
     * @param sortBy Gets or sets the column to order by. Possible values include: 'Unspecified', 'DrawerID', 'ApplicationID', 'GroupID', 'UserID', 'QueueID', 'Acl'
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<GroupQueueModel>> getQueueGroupAssociationsAsync(int queueID, Integer groupID, Integer acl, Integer page, Integer pageSize, String sortOrder, String sortBy, final ServiceCallback<List<GroupQueueModel>> serviceCallback) {
        return ServiceFuture.fromResponse(getQueueGroupAssociationsWithServiceResponseAsync(queueID, groupID, acl, page, pageSize, sortOrder, sortBy), serviceCallback);
    }

    /**
     * Gets a list of queue group associations.
     *
     * @param queueID The queue identifier.
     * @param groupID The group identifier.
     * @param acl Gets or sets the access control level permissions.
     * @param page Gets or sets the page number.
     * @param pageSize Gets or sets the size of the page.
     * @param sortOrder Gets or sets the order. Possible values include: 'Unspecified', 'Ascending', 'Descending'
     * @param sortBy Gets or sets the column to order by. Possible values include: 'Unspecified', 'DrawerID', 'ApplicationID', 'GroupID', 'UserID', 'QueueID', 'Acl'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;GroupQueueModel&gt; object
     */
    public Observable<List<GroupQueueModel>> getQueueGroupAssociationsAsync(int queueID, Integer groupID, Integer acl, Integer page, Integer pageSize, String sortOrder, String sortBy) {
        return getQueueGroupAssociationsWithServiceResponseAsync(queueID, groupID, acl, page, pageSize, sortOrder, sortBy).map(new Func1<ServiceResponse<List<GroupQueueModel>>, List<GroupQueueModel>>() {
            @Override
            public List<GroupQueueModel> call(ServiceResponse<List<GroupQueueModel>> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets a list of queue group associations.
     *
     * @param queueID The queue identifier.
     * @param groupID The group identifier.
     * @param acl Gets or sets the access control level permissions.
     * @param page Gets or sets the page number.
     * @param pageSize Gets or sets the size of the page.
     * @param sortOrder Gets or sets the order. Possible values include: 'Unspecified', 'Ascending', 'Descending'
     * @param sortBy Gets or sets the column to order by. Possible values include: 'Unspecified', 'DrawerID', 'ApplicationID', 'GroupID', 'UserID', 'QueueID', 'Acl'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;GroupQueueModel&gt; object
     */
    public Observable<ServiceResponse<List<GroupQueueModel>>> getQueueGroupAssociationsWithServiceResponseAsync(int queueID, Integer groupID, Integer acl, Integer page, Integer pageSize, String sortOrder, String sortBy) {
        return service.getQueueGroupAssociations(queueID, groupID, acl, page, pageSize, sortOrder, sortBy)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<GroupQueueModel>>>>() {
                @Override
                public Observable<ServiceResponse<List<GroupQueueModel>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<GroupQueueModel>> clientResponse = getQueueGroupAssociationsDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<List<GroupQueueModel>> getQueueGroupAssociationsDelegate(Response<ResponseBody> response) throws RestException, IOException {
        return this.restClient().responseBuilderFactory().<List<GroupQueueModel>, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<List<GroupQueueModel>>() { }.getType())
                .register(403, new TypeToken<Void>() { }.getType())
                .build(response);
    }

    /**
     * Gets a list of group queue associations.
     *
     * @param groupID The group identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;GroupQueueModel&gt; object if successful.
     */
    public List<GroupQueueModel> getGroupQueueAssociations(int groupID) {
        return getGroupQueueAssociationsWithServiceResponseAsync(groupID).toBlocking().single().body();
    }

    /**
     * Gets a list of group queue associations.
     *
     * @param groupID The group identifier.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<GroupQueueModel>> getGroupQueueAssociationsAsync(int groupID, final ServiceCallback<List<GroupQueueModel>> serviceCallback) {
        return ServiceFuture.fromResponse(getGroupQueueAssociationsWithServiceResponseAsync(groupID), serviceCallback);
    }

    /**
     * Gets a list of group queue associations.
     *
     * @param groupID The group identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;GroupQueueModel&gt; object
     */
    public Observable<List<GroupQueueModel>> getGroupQueueAssociationsAsync(int groupID) {
        return getGroupQueueAssociationsWithServiceResponseAsync(groupID).map(new Func1<ServiceResponse<List<GroupQueueModel>>, List<GroupQueueModel>>() {
            @Override
            public List<GroupQueueModel> call(ServiceResponse<List<GroupQueueModel>> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets a list of group queue associations.
     *
     * @param groupID The group identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;GroupQueueModel&gt; object
     */
    public Observable<ServiceResponse<List<GroupQueueModel>>> getGroupQueueAssociationsWithServiceResponseAsync(int groupID) {
        final Integer queueID = null;
        final Integer acl = null;
        final Integer page = null;
        final Integer pageSize = null;
        final String sortOrder = null;
        final String sortBy = null;
        return service.getGroupQueueAssociations(groupID, queueID, acl, page, pageSize, sortOrder, sortBy)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<GroupQueueModel>>>>() {
                @Override
                public Observable<ServiceResponse<List<GroupQueueModel>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<GroupQueueModel>> clientResponse = getGroupQueueAssociationsDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Gets a list of group queue associations.
     *
     * @param groupID The group identifier.
     * @param queueID The queue identifier.
     * @param acl Gets or sets the access control level permissions.
     * @param page Gets or sets the page number.
     * @param pageSize Gets or sets the size of the page.
     * @param sortOrder Gets or sets the order. Possible values include: 'Unspecified', 'Ascending', 'Descending'
     * @param sortBy Gets or sets the column to order by. Possible values include: 'Unspecified', 'DrawerID', 'ApplicationID', 'GroupID', 'UserID', 'QueueID', 'Acl'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;GroupQueueModel&gt; object if successful.
     */
    public List<GroupQueueModel> getGroupQueueAssociations(int groupID, Integer queueID, Integer acl, Integer page, Integer pageSize, String sortOrder, String sortBy) {
        return getGroupQueueAssociationsWithServiceResponseAsync(groupID, queueID, acl, page, pageSize, sortOrder, sortBy).toBlocking().single().body();
    }

    /**
     * Gets a list of group queue associations.
     *
     * @param groupID The group identifier.
     * @param queueID The queue identifier.
     * @param acl Gets or sets the access control level permissions.
     * @param page Gets or sets the page number.
     * @param pageSize Gets or sets the size of the page.
     * @param sortOrder Gets or sets the order. Possible values include: 'Unspecified', 'Ascending', 'Descending'
     * @param sortBy Gets or sets the column to order by. Possible values include: 'Unspecified', 'DrawerID', 'ApplicationID', 'GroupID', 'UserID', 'QueueID', 'Acl'
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<GroupQueueModel>> getGroupQueueAssociationsAsync(int groupID, Integer queueID, Integer acl, Integer page, Integer pageSize, String sortOrder, String sortBy, final ServiceCallback<List<GroupQueueModel>> serviceCallback) {
        return ServiceFuture.fromResponse(getGroupQueueAssociationsWithServiceResponseAsync(groupID, queueID, acl, page, pageSize, sortOrder, sortBy), serviceCallback);
    }

    /**
     * Gets a list of group queue associations.
     *
     * @param groupID The group identifier.
     * @param queueID The queue identifier.
     * @param acl Gets or sets the access control level permissions.
     * @param page Gets or sets the page number.
     * @param pageSize Gets or sets the size of the page.
     * @param sortOrder Gets or sets the order. Possible values include: 'Unspecified', 'Ascending', 'Descending'
     * @param sortBy Gets or sets the column to order by. Possible values include: 'Unspecified', 'DrawerID', 'ApplicationID', 'GroupID', 'UserID', 'QueueID', 'Acl'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;GroupQueueModel&gt; object
     */
    public Observable<List<GroupQueueModel>> getGroupQueueAssociationsAsync(int groupID, Integer queueID, Integer acl, Integer page, Integer pageSize, String sortOrder, String sortBy) {
        return getGroupQueueAssociationsWithServiceResponseAsync(groupID, queueID, acl, page, pageSize, sortOrder, sortBy).map(new Func1<ServiceResponse<List<GroupQueueModel>>, List<GroupQueueModel>>() {
            @Override
            public List<GroupQueueModel> call(ServiceResponse<List<GroupQueueModel>> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets a list of group queue associations.
     *
     * @param groupID The group identifier.
     * @param queueID The queue identifier.
     * @param acl Gets or sets the access control level permissions.
     * @param page Gets or sets the page number.
     * @param pageSize Gets or sets the size of the page.
     * @param sortOrder Gets or sets the order. Possible values include: 'Unspecified', 'Ascending', 'Descending'
     * @param sortBy Gets or sets the column to order by. Possible values include: 'Unspecified', 'DrawerID', 'ApplicationID', 'GroupID', 'UserID', 'QueueID', 'Acl'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;GroupQueueModel&gt; object
     */
    public Observable<ServiceResponse<List<GroupQueueModel>>> getGroupQueueAssociationsWithServiceResponseAsync(int groupID, Integer queueID, Integer acl, Integer page, Integer pageSize, String sortOrder, String sortBy) {
        return service.getGroupQueueAssociations(groupID, queueID, acl, page, pageSize, sortOrder, sortBy)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<GroupQueueModel>>>>() {
                @Override
                public Observable<ServiceResponse<List<GroupQueueModel>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<GroupQueueModel>> clientResponse = getGroupQueueAssociationsDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<List<GroupQueueModel>> getGroupQueueAssociationsDelegate(Response<ResponseBody> response) throws RestException, IOException {
        return this.restClient().responseBuilderFactory().<List<GroupQueueModel>, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<List<GroupQueueModel>>() { }.getType())
                .register(403, new TypeToken<Void>() { }.getType())
                .build(response);
    }

    /**
     * Inserts/Updates the queue group association.
     *
     * @param groupID The group identifier.
     * @param queueID The queue identifier.
     * @param model The model.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object createOrUpdateQueueGroupAssociation(int groupID, int queueID, GroupQueueModel model) {
        return createOrUpdateQueueGroupAssociationWithServiceResponseAsync(groupID, queueID, model).toBlocking().single().body();
    }

    /**
     * Inserts/Updates the queue group association.
     *
     * @param groupID The group identifier.
     * @param queueID The queue identifier.
     * @param model The model.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> createOrUpdateQueueGroupAssociationAsync(int groupID, int queueID, GroupQueueModel model, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromResponse(createOrUpdateQueueGroupAssociationWithServiceResponseAsync(groupID, queueID, model), serviceCallback);
    }

    /**
     * Inserts/Updates the queue group association.
     *
     * @param groupID The group identifier.
     * @param queueID The queue identifier.
     * @param model The model.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> createOrUpdateQueueGroupAssociationAsync(int groupID, int queueID, GroupQueueModel model) {
        return createOrUpdateQueueGroupAssociationWithServiceResponseAsync(groupID, queueID, model).map(new Func1<ServiceResponse<Object>, Object>() {
            @Override
            public Object call(ServiceResponse<Object> response) {
                return response.body();
            }
        });
    }

    /**
     * Inserts/Updates the queue group association.
     *
     * @param groupID The group identifier.
     * @param queueID The queue identifier.
     * @param model The model.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> createOrUpdateQueueGroupAssociationWithServiceResponseAsync(int groupID, int queueID, GroupQueueModel model) {
        if (model == null) {
            throw new IllegalArgumentException("Parameter model is required and cannot be null.");
        }
        Validator.validate(model);
        return service.createOrUpdateQueueGroupAssociation(groupID, queueID, model)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = createOrUpdateQueueGroupAssociationDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Object> createOrUpdateQueueGroupAssociationDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<Object, RestException>newInstance(this.serializerAdapter())
                .register(204, new TypeToken<Object>() { }.getType())
                .register(403, new TypeToken<Void>() { }.getType())
                .build(response);
    }

    /**
     * Deletes a queue group association;.
     *
     * @param groupID The group identifier.
     * @param queueID The queue identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object deleteQueueGroupAssociation(int groupID, int queueID) {
        return deleteQueueGroupAssociationWithServiceResponseAsync(groupID, queueID).toBlocking().single().body();
    }

    /**
     * Deletes a queue group association;.
     *
     * @param groupID The group identifier.
     * @param queueID The queue identifier.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> deleteQueueGroupAssociationAsync(int groupID, int queueID, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromResponse(deleteQueueGroupAssociationWithServiceResponseAsync(groupID, queueID), serviceCallback);
    }

    /**
     * Deletes a queue group association;.
     *
     * @param groupID The group identifier.
     * @param queueID The queue identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> deleteQueueGroupAssociationAsync(int groupID, int queueID) {
        return deleteQueueGroupAssociationWithServiceResponseAsync(groupID, queueID).map(new Func1<ServiceResponse<Object>, Object>() {
            @Override
            public Object call(ServiceResponse<Object> response) {
                return response.body();
            }
        });
    }

    /**
     * Deletes a queue group association;.
     *
     * @param groupID The group identifier.
     * @param queueID The queue identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> deleteQueueGroupAssociationWithServiceResponseAsync(int groupID, int queueID) {
        return service.deleteQueueGroupAssociation(groupID, queueID)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = deleteQueueGroupAssociationDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Object> deleteQueueGroupAssociationDelegate(Response<ResponseBody> response) throws RestException, IOException {
        return this.restClient().responseBuilderFactory().<Object, RestException>newInstance(this.serializerAdapter())
                .register(204, new TypeToken<Object>() { }.getType())
                .register(403, new TypeToken<Void>() { }.getType())
                .register(404, new TypeToken<Void>() { }.getType())
                .build(response);
    }

    /**
     * Inserts/Updates the group queue association.
     *
     * @param groupID The group identifier.
     * @param queueID The queue identifier.
     * @param model The model.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object createOrUpdateGroupQueueAssociation(int groupID, int queueID, GroupQueueModel model) {
        return createOrUpdateGroupQueueAssociationWithServiceResponseAsync(groupID, queueID, model).toBlocking().single().body();
    }

    /**
     * Inserts/Updates the group queue association.
     *
     * @param groupID The group identifier.
     * @param queueID The queue identifier.
     * @param model The model.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> createOrUpdateGroupQueueAssociationAsync(int groupID, int queueID, GroupQueueModel model, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromResponse(createOrUpdateGroupQueueAssociationWithServiceResponseAsync(groupID, queueID, model), serviceCallback);
    }

    /**
     * Inserts/Updates the group queue association.
     *
     * @param groupID The group identifier.
     * @param queueID The queue identifier.
     * @param model The model.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> createOrUpdateGroupQueueAssociationAsync(int groupID, int queueID, GroupQueueModel model) {
        return createOrUpdateGroupQueueAssociationWithServiceResponseAsync(groupID, queueID, model).map(new Func1<ServiceResponse<Object>, Object>() {
            @Override
            public Object call(ServiceResponse<Object> response) {
                return response.body();
            }
        });
    }

    /**
     * Inserts/Updates the group queue association.
     *
     * @param groupID The group identifier.
     * @param queueID The queue identifier.
     * @param model The model.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> createOrUpdateGroupQueueAssociationWithServiceResponseAsync(int groupID, int queueID, GroupQueueModel model) {
        if (model == null) {
            throw new IllegalArgumentException("Parameter model is required and cannot be null.");
        }
        Validator.validate(model);
        return service.createOrUpdateGroupQueueAssociation(groupID, queueID, model)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = createOrUpdateGroupQueueAssociationDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Object> createOrUpdateGroupQueueAssociationDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<Object, RestException>newInstance(this.serializerAdapter())
                .register(204, new TypeToken<Object>() { }.getType())
                .register(403, new TypeToken<Void>() { }.getType())
                .build(response);
    }

    /**
     * Deletes a group queue association;.
     *
     * @param groupID The group identifier.
     * @param queueID The queue identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object deleteGroupQueueAssociation(int groupID, int queueID) {
        return deleteGroupQueueAssociationWithServiceResponseAsync(groupID, queueID).toBlocking().single().body();
    }

    /**
     * Deletes a group queue association;.
     *
     * @param groupID The group identifier.
     * @param queueID The queue identifier.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> deleteGroupQueueAssociationAsync(int groupID, int queueID, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromResponse(deleteGroupQueueAssociationWithServiceResponseAsync(groupID, queueID), serviceCallback);
    }

    /**
     * Deletes a group queue association;.
     *
     * @param groupID The group identifier.
     * @param queueID The queue identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> deleteGroupQueueAssociationAsync(int groupID, int queueID) {
        return deleteGroupQueueAssociationWithServiceResponseAsync(groupID, queueID).map(new Func1<ServiceResponse<Object>, Object>() {
            @Override
            public Object call(ServiceResponse<Object> response) {
                return response.body();
            }
        });
    }

    /**
     * Deletes a group queue association;.
     *
     * @param groupID The group identifier.
     * @param queueID The queue identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> deleteGroupQueueAssociationWithServiceResponseAsync(int groupID, int queueID) {
        return service.deleteGroupQueueAssociation(groupID, queueID)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = deleteGroupQueueAssociationDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Object> deleteGroupQueueAssociationDelegate(Response<ResponseBody> response) throws RestException, IOException {
        return this.restClient().responseBuilderFactory().<Object, RestException>newInstance(this.serializerAdapter())
                .register(204, new TypeToken<Object>() { }.getType())
                .register(403, new TypeToken<Void>() { }.getType())
                .register(404, new TypeToken<Void>() { }.getType())
                .build(response);
    }

    /**
     * Gets a list of application group associations.
     *
     * @param applicationID The application identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;GroupApplicationModel&gt; object if successful.
     */
    public List<GroupApplicationModel> getApplicationGroupAssociations(int applicationID) {
        return getApplicationGroupAssociationsWithServiceResponseAsync(applicationID).toBlocking().single().body();
    }

    /**
     * Gets a list of application group associations.
     *
     * @param applicationID The application identifier.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<GroupApplicationModel>> getApplicationGroupAssociationsAsync(int applicationID, final ServiceCallback<List<GroupApplicationModel>> serviceCallback) {
        return ServiceFuture.fromResponse(getApplicationGroupAssociationsWithServiceResponseAsync(applicationID), serviceCallback);
    }

    /**
     * Gets a list of application group associations.
     *
     * @param applicationID The application identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;GroupApplicationModel&gt; object
     */
    public Observable<List<GroupApplicationModel>> getApplicationGroupAssociationsAsync(int applicationID) {
        return getApplicationGroupAssociationsWithServiceResponseAsync(applicationID).map(new Func1<ServiceResponse<List<GroupApplicationModel>>, List<GroupApplicationModel>>() {
            @Override
            public List<GroupApplicationModel> call(ServiceResponse<List<GroupApplicationModel>> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets a list of application group associations.
     *
     * @param applicationID The application identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;GroupApplicationModel&gt; object
     */
    public Observable<ServiceResponse<List<GroupApplicationModel>>> getApplicationGroupAssociationsWithServiceResponseAsync(int applicationID) {
        final Integer groupID = null;
        final Integer acl = null;
        final Integer page = null;
        final Integer pageSize = null;
        final String sortOrder = null;
        final String sortBy = null;
        return service.getApplicationGroupAssociations(applicationID, groupID, acl, page, pageSize, sortOrder, sortBy)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<GroupApplicationModel>>>>() {
                @Override
                public Observable<ServiceResponse<List<GroupApplicationModel>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<GroupApplicationModel>> clientResponse = getApplicationGroupAssociationsDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Gets a list of application group associations.
     *
     * @param applicationID The application identifier.
     * @param groupID The group identifier.
     * @param acl Gets or sets the access control level permissions.
     * @param page Gets or sets the page number.
     * @param pageSize Gets or sets the size of the page.
     * @param sortOrder Gets or sets the order. Possible values include: 'Unspecified', 'Ascending', 'Descending'
     * @param sortBy Gets or sets the column to order by. Possible values include: 'Unspecified', 'DrawerID', 'ApplicationID', 'GroupID', 'UserID', 'QueueID', 'Acl'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;GroupApplicationModel&gt; object if successful.
     */
    public List<GroupApplicationModel> getApplicationGroupAssociations(int applicationID, Integer groupID, Integer acl, Integer page, Integer pageSize, String sortOrder, String sortBy) {
        return getApplicationGroupAssociationsWithServiceResponseAsync(applicationID, groupID, acl, page, pageSize, sortOrder, sortBy).toBlocking().single().body();
    }

    /**
     * Gets a list of application group associations.
     *
     * @param applicationID The application identifier.
     * @param groupID The group identifier.
     * @param acl Gets or sets the access control level permissions.
     * @param page Gets or sets the page number.
     * @param pageSize Gets or sets the size of the page.
     * @param sortOrder Gets or sets the order. Possible values include: 'Unspecified', 'Ascending', 'Descending'
     * @param sortBy Gets or sets the column to order by. Possible values include: 'Unspecified', 'DrawerID', 'ApplicationID', 'GroupID', 'UserID', 'QueueID', 'Acl'
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<GroupApplicationModel>> getApplicationGroupAssociationsAsync(int applicationID, Integer groupID, Integer acl, Integer page, Integer pageSize, String sortOrder, String sortBy, final ServiceCallback<List<GroupApplicationModel>> serviceCallback) {
        return ServiceFuture.fromResponse(getApplicationGroupAssociationsWithServiceResponseAsync(applicationID, groupID, acl, page, pageSize, sortOrder, sortBy), serviceCallback);
    }

    /**
     * Gets a list of application group associations.
     *
     * @param applicationID The application identifier.
     * @param groupID The group identifier.
     * @param acl Gets or sets the access control level permissions.
     * @param page Gets or sets the page number.
     * @param pageSize Gets or sets the size of the page.
     * @param sortOrder Gets or sets the order. Possible values include: 'Unspecified', 'Ascending', 'Descending'
     * @param sortBy Gets or sets the column to order by. Possible values include: 'Unspecified', 'DrawerID', 'ApplicationID', 'GroupID', 'UserID', 'QueueID', 'Acl'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;GroupApplicationModel&gt; object
     */
    public Observable<List<GroupApplicationModel>> getApplicationGroupAssociationsAsync(int applicationID, Integer groupID, Integer acl, Integer page, Integer pageSize, String sortOrder, String sortBy) {
        return getApplicationGroupAssociationsWithServiceResponseAsync(applicationID, groupID, acl, page, pageSize, sortOrder, sortBy).map(new Func1<ServiceResponse<List<GroupApplicationModel>>, List<GroupApplicationModel>>() {
            @Override
            public List<GroupApplicationModel> call(ServiceResponse<List<GroupApplicationModel>> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets a list of application group associations.
     *
     * @param applicationID The application identifier.
     * @param groupID The group identifier.
     * @param acl Gets or sets the access control level permissions.
     * @param page Gets or sets the page number.
     * @param pageSize Gets or sets the size of the page.
     * @param sortOrder Gets or sets the order. Possible values include: 'Unspecified', 'Ascending', 'Descending'
     * @param sortBy Gets or sets the column to order by. Possible values include: 'Unspecified', 'DrawerID', 'ApplicationID', 'GroupID', 'UserID', 'QueueID', 'Acl'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;GroupApplicationModel&gt; object
     */
    public Observable<ServiceResponse<List<GroupApplicationModel>>> getApplicationGroupAssociationsWithServiceResponseAsync(int applicationID, Integer groupID, Integer acl, Integer page, Integer pageSize, String sortOrder, String sortBy) {
        return service.getApplicationGroupAssociations(applicationID, groupID, acl, page, pageSize, sortOrder, sortBy)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<GroupApplicationModel>>>>() {
                @Override
                public Observable<ServiceResponse<List<GroupApplicationModel>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<GroupApplicationModel>> clientResponse = getApplicationGroupAssociationsDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<List<GroupApplicationModel>> getApplicationGroupAssociationsDelegate(Response<ResponseBody> response) throws RestException, IOException {
        return this.restClient().responseBuilderFactory().<List<GroupApplicationModel>, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<List<GroupApplicationModel>>() { }.getType())
                .register(403, new TypeToken<Void>() { }.getType())
                .build(response);
    }

    /**
     * Gets a list of group application associations.
     *
     * @param groupID The group identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;GroupApplicationModel&gt; object if successful.
     */
    public List<GroupApplicationModel> getGroupApplicationAssociations(int groupID) {
        return getGroupApplicationAssociationsWithServiceResponseAsync(groupID).toBlocking().single().body();
    }

    /**
     * Gets a list of group application associations.
     *
     * @param groupID The group identifier.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<GroupApplicationModel>> getGroupApplicationAssociationsAsync(int groupID, final ServiceCallback<List<GroupApplicationModel>> serviceCallback) {
        return ServiceFuture.fromResponse(getGroupApplicationAssociationsWithServiceResponseAsync(groupID), serviceCallback);
    }

    /**
     * Gets a list of group application associations.
     *
     * @param groupID The group identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;GroupApplicationModel&gt; object
     */
    public Observable<List<GroupApplicationModel>> getGroupApplicationAssociationsAsync(int groupID) {
        return getGroupApplicationAssociationsWithServiceResponseAsync(groupID).map(new Func1<ServiceResponse<List<GroupApplicationModel>>, List<GroupApplicationModel>>() {
            @Override
            public List<GroupApplicationModel> call(ServiceResponse<List<GroupApplicationModel>> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets a list of group application associations.
     *
     * @param groupID The group identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;GroupApplicationModel&gt; object
     */
    public Observable<ServiceResponse<List<GroupApplicationModel>>> getGroupApplicationAssociationsWithServiceResponseAsync(int groupID) {
        final Integer applicationID = null;
        final Integer acl = null;
        final Integer page = null;
        final Integer pageSize = null;
        final String sortOrder = null;
        final String sortBy = null;
        return service.getGroupApplicationAssociations(groupID, applicationID, acl, page, pageSize, sortOrder, sortBy)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<GroupApplicationModel>>>>() {
                @Override
                public Observable<ServiceResponse<List<GroupApplicationModel>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<GroupApplicationModel>> clientResponse = getGroupApplicationAssociationsDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Gets a list of group application associations.
     *
     * @param groupID The group identifier.
     * @param applicationID The application identifier.
     * @param acl Gets or sets the access control level permissions.
     * @param page Gets or sets the page number.
     * @param pageSize Gets or sets the size of the page.
     * @param sortOrder Gets or sets the order. Possible values include: 'Unspecified', 'Ascending', 'Descending'
     * @param sortBy Gets or sets the column to order by. Possible values include: 'Unspecified', 'DrawerID', 'ApplicationID', 'GroupID', 'UserID', 'QueueID', 'Acl'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;GroupApplicationModel&gt; object if successful.
     */
    public List<GroupApplicationModel> getGroupApplicationAssociations(int groupID, Integer applicationID, Integer acl, Integer page, Integer pageSize, String sortOrder, String sortBy) {
        return getGroupApplicationAssociationsWithServiceResponseAsync(groupID, applicationID, acl, page, pageSize, sortOrder, sortBy).toBlocking().single().body();
    }

    /**
     * Gets a list of group application associations.
     *
     * @param groupID The group identifier.
     * @param applicationID The application identifier.
     * @param acl Gets or sets the access control level permissions.
     * @param page Gets or sets the page number.
     * @param pageSize Gets or sets the size of the page.
     * @param sortOrder Gets or sets the order. Possible values include: 'Unspecified', 'Ascending', 'Descending'
     * @param sortBy Gets or sets the column to order by. Possible values include: 'Unspecified', 'DrawerID', 'ApplicationID', 'GroupID', 'UserID', 'QueueID', 'Acl'
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<GroupApplicationModel>> getGroupApplicationAssociationsAsync(int groupID, Integer applicationID, Integer acl, Integer page, Integer pageSize, String sortOrder, String sortBy, final ServiceCallback<List<GroupApplicationModel>> serviceCallback) {
        return ServiceFuture.fromResponse(getGroupApplicationAssociationsWithServiceResponseAsync(groupID, applicationID, acl, page, pageSize, sortOrder, sortBy), serviceCallback);
    }

    /**
     * Gets a list of group application associations.
     *
     * @param groupID The group identifier.
     * @param applicationID The application identifier.
     * @param acl Gets or sets the access control level permissions.
     * @param page Gets or sets the page number.
     * @param pageSize Gets or sets the size of the page.
     * @param sortOrder Gets or sets the order. Possible values include: 'Unspecified', 'Ascending', 'Descending'
     * @param sortBy Gets or sets the column to order by. Possible values include: 'Unspecified', 'DrawerID', 'ApplicationID', 'GroupID', 'UserID', 'QueueID', 'Acl'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;GroupApplicationModel&gt; object
     */
    public Observable<List<GroupApplicationModel>> getGroupApplicationAssociationsAsync(int groupID, Integer applicationID, Integer acl, Integer page, Integer pageSize, String sortOrder, String sortBy) {
        return getGroupApplicationAssociationsWithServiceResponseAsync(groupID, applicationID, acl, page, pageSize, sortOrder, sortBy).map(new Func1<ServiceResponse<List<GroupApplicationModel>>, List<GroupApplicationModel>>() {
            @Override
            public List<GroupApplicationModel> call(ServiceResponse<List<GroupApplicationModel>> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets a list of group application associations.
     *
     * @param groupID The group identifier.
     * @param applicationID The application identifier.
     * @param acl Gets or sets the access control level permissions.
     * @param page Gets or sets the page number.
     * @param pageSize Gets or sets the size of the page.
     * @param sortOrder Gets or sets the order. Possible values include: 'Unspecified', 'Ascending', 'Descending'
     * @param sortBy Gets or sets the column to order by. Possible values include: 'Unspecified', 'DrawerID', 'ApplicationID', 'GroupID', 'UserID', 'QueueID', 'Acl'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;GroupApplicationModel&gt; object
     */
    public Observable<ServiceResponse<List<GroupApplicationModel>>> getGroupApplicationAssociationsWithServiceResponseAsync(int groupID, Integer applicationID, Integer acl, Integer page, Integer pageSize, String sortOrder, String sortBy) {
        return service.getGroupApplicationAssociations(groupID, applicationID, acl, page, pageSize, sortOrder, sortBy)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<GroupApplicationModel>>>>() {
                @Override
                public Observable<ServiceResponse<List<GroupApplicationModel>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<GroupApplicationModel>> clientResponse = getGroupApplicationAssociationsDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<List<GroupApplicationModel>> getGroupApplicationAssociationsDelegate(Response<ResponseBody> response) throws RestException, IOException {
        return this.restClient().responseBuilderFactory().<List<GroupApplicationModel>, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<List<GroupApplicationModel>>() { }.getType())
                .register(403, new TypeToken<Void>() { }.getType())
                .build(response);
    }

    /**
     * Inserts/Updates the application group association.
     *
     * @param groupID The group identifier.
     * @param applicationID The application identifier.
     * @param model The model.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object createOrUpdateApplicationGroupAssociation(int groupID, int applicationID, GroupApplicationModel model) {
        return createOrUpdateApplicationGroupAssociationWithServiceResponseAsync(groupID, applicationID, model).toBlocking().single().body();
    }

    /**
     * Inserts/Updates the application group association.
     *
     * @param groupID The group identifier.
     * @param applicationID The application identifier.
     * @param model The model.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> createOrUpdateApplicationGroupAssociationAsync(int groupID, int applicationID, GroupApplicationModel model, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromResponse(createOrUpdateApplicationGroupAssociationWithServiceResponseAsync(groupID, applicationID, model), serviceCallback);
    }

    /**
     * Inserts/Updates the application group association.
     *
     * @param groupID The group identifier.
     * @param applicationID The application identifier.
     * @param model The model.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> createOrUpdateApplicationGroupAssociationAsync(int groupID, int applicationID, GroupApplicationModel model) {
        return createOrUpdateApplicationGroupAssociationWithServiceResponseAsync(groupID, applicationID, model).map(new Func1<ServiceResponse<Object>, Object>() {
            @Override
            public Object call(ServiceResponse<Object> response) {
                return response.body();
            }
        });
    }

    /**
     * Inserts/Updates the application group association.
     *
     * @param groupID The group identifier.
     * @param applicationID The application identifier.
     * @param model The model.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> createOrUpdateApplicationGroupAssociationWithServiceResponseAsync(int groupID, int applicationID, GroupApplicationModel model) {
        if (model == null) {
            throw new IllegalArgumentException("Parameter model is required and cannot be null.");
        }
        Validator.validate(model);
        return service.createOrUpdateApplicationGroupAssociation(groupID, applicationID, model)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = createOrUpdateApplicationGroupAssociationDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Object> createOrUpdateApplicationGroupAssociationDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<Object, RestException>newInstance(this.serializerAdapter())
                .register(204, new TypeToken<Object>() { }.getType())
                .register(403, new TypeToken<Void>() { }.getType())
                .build(response);
    }

    /**
     * Deletes a application group association;.
     *
     * @param groupID The group identifier.
     * @param applicationID The application identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object deleteApplicationGroupAssociation(int groupID, int applicationID) {
        return deleteApplicationGroupAssociationWithServiceResponseAsync(groupID, applicationID).toBlocking().single().body();
    }

    /**
     * Deletes a application group association;.
     *
     * @param groupID The group identifier.
     * @param applicationID The application identifier.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> deleteApplicationGroupAssociationAsync(int groupID, int applicationID, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromResponse(deleteApplicationGroupAssociationWithServiceResponseAsync(groupID, applicationID), serviceCallback);
    }

    /**
     * Deletes a application group association;.
     *
     * @param groupID The group identifier.
     * @param applicationID The application identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> deleteApplicationGroupAssociationAsync(int groupID, int applicationID) {
        return deleteApplicationGroupAssociationWithServiceResponseAsync(groupID, applicationID).map(new Func1<ServiceResponse<Object>, Object>() {
            @Override
            public Object call(ServiceResponse<Object> response) {
                return response.body();
            }
        });
    }

    /**
     * Deletes a application group association;.
     *
     * @param groupID The group identifier.
     * @param applicationID The application identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> deleteApplicationGroupAssociationWithServiceResponseAsync(int groupID, int applicationID) {
        return service.deleteApplicationGroupAssociation(groupID, applicationID)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = deleteApplicationGroupAssociationDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Object> deleteApplicationGroupAssociationDelegate(Response<ResponseBody> response) throws RestException, IOException {
        return this.restClient().responseBuilderFactory().<Object, RestException>newInstance(this.serializerAdapter())
                .register(204, new TypeToken<Object>() { }.getType())
                .register(403, new TypeToken<Void>() { }.getType())
                .register(404, new TypeToken<Void>() { }.getType())
                .register(500, new TypeToken<Void>() { }.getType())
                .build(response);
    }

    /**
     * Inserts/Updates the group application association.
     *
     * @param groupID The group identifier.
     * @param applicationID The application identifier.
     * @param model The model.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object createOrUpdateGroupApplicationAssociation(int groupID, int applicationID, GroupApplicationModel model) {
        return createOrUpdateGroupApplicationAssociationWithServiceResponseAsync(groupID, applicationID, model).toBlocking().single().body();
    }

    /**
     * Inserts/Updates the group application association.
     *
     * @param groupID The group identifier.
     * @param applicationID The application identifier.
     * @param model The model.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> createOrUpdateGroupApplicationAssociationAsync(int groupID, int applicationID, GroupApplicationModel model, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromResponse(createOrUpdateGroupApplicationAssociationWithServiceResponseAsync(groupID, applicationID, model), serviceCallback);
    }

    /**
     * Inserts/Updates the group application association.
     *
     * @param groupID The group identifier.
     * @param applicationID The application identifier.
     * @param model The model.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> createOrUpdateGroupApplicationAssociationAsync(int groupID, int applicationID, GroupApplicationModel model) {
        return createOrUpdateGroupApplicationAssociationWithServiceResponseAsync(groupID, applicationID, model).map(new Func1<ServiceResponse<Object>, Object>() {
            @Override
            public Object call(ServiceResponse<Object> response) {
                return response.body();
            }
        });
    }

    /**
     * Inserts/Updates the group application association.
     *
     * @param groupID The group identifier.
     * @param applicationID The application identifier.
     * @param model The model.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> createOrUpdateGroupApplicationAssociationWithServiceResponseAsync(int groupID, int applicationID, GroupApplicationModel model) {
        if (model == null) {
            throw new IllegalArgumentException("Parameter model is required and cannot be null.");
        }
        Validator.validate(model);
        return service.createOrUpdateGroupApplicationAssociation(groupID, applicationID, model)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = createOrUpdateGroupApplicationAssociationDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Object> createOrUpdateGroupApplicationAssociationDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<Object, RestException>newInstance(this.serializerAdapter())
                .register(204, new TypeToken<Object>() { }.getType())
                .register(403, new TypeToken<Void>() { }.getType())
                .build(response);
    }

    /**
     * Deletes a group application association;.
     *
     * @param groupID The group identifier.
     * @param applicationID The application identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object deleteGroupApplicationAssociation(int groupID, int applicationID) {
        return deleteGroupApplicationAssociationWithServiceResponseAsync(groupID, applicationID).toBlocking().single().body();
    }

    /**
     * Deletes a group application association;.
     *
     * @param groupID The group identifier.
     * @param applicationID The application identifier.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> deleteGroupApplicationAssociationAsync(int groupID, int applicationID, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromResponse(deleteGroupApplicationAssociationWithServiceResponseAsync(groupID, applicationID), serviceCallback);
    }

    /**
     * Deletes a group application association;.
     *
     * @param groupID The group identifier.
     * @param applicationID The application identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> deleteGroupApplicationAssociationAsync(int groupID, int applicationID) {
        return deleteGroupApplicationAssociationWithServiceResponseAsync(groupID, applicationID).map(new Func1<ServiceResponse<Object>, Object>() {
            @Override
            public Object call(ServiceResponse<Object> response) {
                return response.body();
            }
        });
    }

    /**
     * Deletes a group application association;.
     *
     * @param groupID The group identifier.
     * @param applicationID The application identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> deleteGroupApplicationAssociationWithServiceResponseAsync(int groupID, int applicationID) {
        return service.deleteGroupApplicationAssociation(groupID, applicationID)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = deleteGroupApplicationAssociationDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Object> deleteGroupApplicationAssociationDelegate(Response<ResponseBody> response) throws RestException, IOException {
        return this.restClient().responseBuilderFactory().<Object, RestException>newInstance(this.serializerAdapter())
                .register(204, new TypeToken<Object>() { }.getType())
                .register(403, new TypeToken<Void>() { }.getType())
                .register(404, new TypeToken<Void>() { }.getType())
                .register(500, new TypeToken<Void>() { }.getType())
                .build(response);
    }

    /**
     * Gets a list of drawer user associations.
     *
     * @param drawerID The drawer identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;UserDrawerModel&gt; object if successful.
     */
    public List<UserDrawerModel> getDrawerUserAssociations(int drawerID) {
        return getDrawerUserAssociationsWithServiceResponseAsync(drawerID).toBlocking().single().body();
    }

    /**
     * Gets a list of drawer user associations.
     *
     * @param drawerID The drawer identifier.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<UserDrawerModel>> getDrawerUserAssociationsAsync(int drawerID, final ServiceCallback<List<UserDrawerModel>> serviceCallback) {
        return ServiceFuture.fromResponse(getDrawerUserAssociationsWithServiceResponseAsync(drawerID), serviceCallback);
    }

    /**
     * Gets a list of drawer user associations.
     *
     * @param drawerID The drawer identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;UserDrawerModel&gt; object
     */
    public Observable<List<UserDrawerModel>> getDrawerUserAssociationsAsync(int drawerID) {
        return getDrawerUserAssociationsWithServiceResponseAsync(drawerID).map(new Func1<ServiceResponse<List<UserDrawerModel>>, List<UserDrawerModel>>() {
            @Override
            public List<UserDrawerModel> call(ServiceResponse<List<UserDrawerModel>> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets a list of drawer user associations.
     *
     * @param drawerID The drawer identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;UserDrawerModel&gt; object
     */
    public Observable<ServiceResponse<List<UserDrawerModel>>> getDrawerUserAssociationsWithServiceResponseAsync(int drawerID) {
        final Integer userID = null;
        final Integer acl = null;
        final Integer page = null;
        final Integer pageSize = null;
        final String sortOrder = null;
        final String sortBy = null;
        return service.getDrawerUserAssociations(drawerID, userID, acl, page, pageSize, sortOrder, sortBy)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<UserDrawerModel>>>>() {
                @Override
                public Observable<ServiceResponse<List<UserDrawerModel>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<UserDrawerModel>> clientResponse = getDrawerUserAssociationsDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Gets a list of drawer user associations.
     *
     * @param drawerID The drawer identifier.
     * @param userID The user identifier.
     * @param acl Gets or sets the access control level permissions.
     * @param page Gets or sets the page number.
     * @param pageSize Gets or sets the size of the page.
     * @param sortOrder Gets or sets the order. Possible values include: 'Unspecified', 'Ascending', 'Descending'
     * @param sortBy Gets or sets the column to order by. Possible values include: 'Unspecified', 'DrawerID', 'ApplicationID', 'GroupID', 'UserID', 'QueueID', 'Acl'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;UserDrawerModel&gt; object if successful.
     */
    public List<UserDrawerModel> getDrawerUserAssociations(int drawerID, Integer userID, Integer acl, Integer page, Integer pageSize, String sortOrder, String sortBy) {
        return getDrawerUserAssociationsWithServiceResponseAsync(drawerID, userID, acl, page, pageSize, sortOrder, sortBy).toBlocking().single().body();
    }

    /**
     * Gets a list of drawer user associations.
     *
     * @param drawerID The drawer identifier.
     * @param userID The user identifier.
     * @param acl Gets or sets the access control level permissions.
     * @param page Gets or sets the page number.
     * @param pageSize Gets or sets the size of the page.
     * @param sortOrder Gets or sets the order. Possible values include: 'Unspecified', 'Ascending', 'Descending'
     * @param sortBy Gets or sets the column to order by. Possible values include: 'Unspecified', 'DrawerID', 'ApplicationID', 'GroupID', 'UserID', 'QueueID', 'Acl'
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<UserDrawerModel>> getDrawerUserAssociationsAsync(int drawerID, Integer userID, Integer acl, Integer page, Integer pageSize, String sortOrder, String sortBy, final ServiceCallback<List<UserDrawerModel>> serviceCallback) {
        return ServiceFuture.fromResponse(getDrawerUserAssociationsWithServiceResponseAsync(drawerID, userID, acl, page, pageSize, sortOrder, sortBy), serviceCallback);
    }

    /**
     * Gets a list of drawer user associations.
     *
     * @param drawerID The drawer identifier.
     * @param userID The user identifier.
     * @param acl Gets or sets the access control level permissions.
     * @param page Gets or sets the page number.
     * @param pageSize Gets or sets the size of the page.
     * @param sortOrder Gets or sets the order. Possible values include: 'Unspecified', 'Ascending', 'Descending'
     * @param sortBy Gets or sets the column to order by. Possible values include: 'Unspecified', 'DrawerID', 'ApplicationID', 'GroupID', 'UserID', 'QueueID', 'Acl'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;UserDrawerModel&gt; object
     */
    public Observable<List<UserDrawerModel>> getDrawerUserAssociationsAsync(int drawerID, Integer userID, Integer acl, Integer page, Integer pageSize, String sortOrder, String sortBy) {
        return getDrawerUserAssociationsWithServiceResponseAsync(drawerID, userID, acl, page, pageSize, sortOrder, sortBy).map(new Func1<ServiceResponse<List<UserDrawerModel>>, List<UserDrawerModel>>() {
            @Override
            public List<UserDrawerModel> call(ServiceResponse<List<UserDrawerModel>> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets a list of drawer user associations.
     *
     * @param drawerID The drawer identifier.
     * @param userID The user identifier.
     * @param acl Gets or sets the access control level permissions.
     * @param page Gets or sets the page number.
     * @param pageSize Gets or sets the size of the page.
     * @param sortOrder Gets or sets the order. Possible values include: 'Unspecified', 'Ascending', 'Descending'
     * @param sortBy Gets or sets the column to order by. Possible values include: 'Unspecified', 'DrawerID', 'ApplicationID', 'GroupID', 'UserID', 'QueueID', 'Acl'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;UserDrawerModel&gt; object
     */
    public Observable<ServiceResponse<List<UserDrawerModel>>> getDrawerUserAssociationsWithServiceResponseAsync(int drawerID, Integer userID, Integer acl, Integer page, Integer pageSize, String sortOrder, String sortBy) {
        return service.getDrawerUserAssociations(drawerID, userID, acl, page, pageSize, sortOrder, sortBy)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<UserDrawerModel>>>>() {
                @Override
                public Observable<ServiceResponse<List<UserDrawerModel>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<UserDrawerModel>> clientResponse = getDrawerUserAssociationsDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<List<UserDrawerModel>> getDrawerUserAssociationsDelegate(Response<ResponseBody> response) throws RestException, IOException {
        return this.restClient().responseBuilderFactory().<List<UserDrawerModel>, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<List<UserDrawerModel>>() { }.getType())
                .register(403, new TypeToken<Void>() { }.getType())
                .build(response);
    }

    /**
     * Gets a list of user drawer associations.
     *
     * @param userID The user identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;UserDrawerModel&gt; object if successful.
     */
    public List<UserDrawerModel> getUserDrawerAssociations(int userID) {
        return getUserDrawerAssociationsWithServiceResponseAsync(userID).toBlocking().single().body();
    }

    /**
     * Gets a list of user drawer associations.
     *
     * @param userID The user identifier.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<UserDrawerModel>> getUserDrawerAssociationsAsync(int userID, final ServiceCallback<List<UserDrawerModel>> serviceCallback) {
        return ServiceFuture.fromResponse(getUserDrawerAssociationsWithServiceResponseAsync(userID), serviceCallback);
    }

    /**
     * Gets a list of user drawer associations.
     *
     * @param userID The user identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;UserDrawerModel&gt; object
     */
    public Observable<List<UserDrawerModel>> getUserDrawerAssociationsAsync(int userID) {
        return getUserDrawerAssociationsWithServiceResponseAsync(userID).map(new Func1<ServiceResponse<List<UserDrawerModel>>, List<UserDrawerModel>>() {
            @Override
            public List<UserDrawerModel> call(ServiceResponse<List<UserDrawerModel>> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets a list of user drawer associations.
     *
     * @param userID The user identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;UserDrawerModel&gt; object
     */
    public Observable<ServiceResponse<List<UserDrawerModel>>> getUserDrawerAssociationsWithServiceResponseAsync(int userID) {
        final Integer drawerID = null;
        final Integer acl = null;
        final Integer page = null;
        final Integer pageSize = null;
        final String sortOrder = null;
        final String sortBy = null;
        return service.getUserDrawerAssociations(userID, drawerID, acl, page, pageSize, sortOrder, sortBy)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<UserDrawerModel>>>>() {
                @Override
                public Observable<ServiceResponse<List<UserDrawerModel>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<UserDrawerModel>> clientResponse = getUserDrawerAssociationsDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Gets a list of user drawer associations.
     *
     * @param userID The user identifier.
     * @param drawerID The drawer identifier.
     * @param acl Gets or sets the access control level permissions.
     * @param page Gets or sets the page number.
     * @param pageSize Gets or sets the size of the page.
     * @param sortOrder Gets or sets the order. Possible values include: 'Unspecified', 'Ascending', 'Descending'
     * @param sortBy Gets or sets the column to order by. Possible values include: 'Unspecified', 'DrawerID', 'ApplicationID', 'GroupID', 'UserID', 'QueueID', 'Acl'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;UserDrawerModel&gt; object if successful.
     */
    public List<UserDrawerModel> getUserDrawerAssociations(int userID, Integer drawerID, Integer acl, Integer page, Integer pageSize, String sortOrder, String sortBy) {
        return getUserDrawerAssociationsWithServiceResponseAsync(userID, drawerID, acl, page, pageSize, sortOrder, sortBy).toBlocking().single().body();
    }

    /**
     * Gets a list of user drawer associations.
     *
     * @param userID The user identifier.
     * @param drawerID The drawer identifier.
     * @param acl Gets or sets the access control level permissions.
     * @param page Gets or sets the page number.
     * @param pageSize Gets or sets the size of the page.
     * @param sortOrder Gets or sets the order. Possible values include: 'Unspecified', 'Ascending', 'Descending'
     * @param sortBy Gets or sets the column to order by. Possible values include: 'Unspecified', 'DrawerID', 'ApplicationID', 'GroupID', 'UserID', 'QueueID', 'Acl'
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<UserDrawerModel>> getUserDrawerAssociationsAsync(int userID, Integer drawerID, Integer acl, Integer page, Integer pageSize, String sortOrder, String sortBy, final ServiceCallback<List<UserDrawerModel>> serviceCallback) {
        return ServiceFuture.fromResponse(getUserDrawerAssociationsWithServiceResponseAsync(userID, drawerID, acl, page, pageSize, sortOrder, sortBy), serviceCallback);
    }

    /**
     * Gets a list of user drawer associations.
     *
     * @param userID The user identifier.
     * @param drawerID The drawer identifier.
     * @param acl Gets or sets the access control level permissions.
     * @param page Gets or sets the page number.
     * @param pageSize Gets or sets the size of the page.
     * @param sortOrder Gets or sets the order. Possible values include: 'Unspecified', 'Ascending', 'Descending'
     * @param sortBy Gets or sets the column to order by. Possible values include: 'Unspecified', 'DrawerID', 'ApplicationID', 'GroupID', 'UserID', 'QueueID', 'Acl'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;UserDrawerModel&gt; object
     */
    public Observable<List<UserDrawerModel>> getUserDrawerAssociationsAsync(int userID, Integer drawerID, Integer acl, Integer page, Integer pageSize, String sortOrder, String sortBy) {
        return getUserDrawerAssociationsWithServiceResponseAsync(userID, drawerID, acl, page, pageSize, sortOrder, sortBy).map(new Func1<ServiceResponse<List<UserDrawerModel>>, List<UserDrawerModel>>() {
            @Override
            public List<UserDrawerModel> call(ServiceResponse<List<UserDrawerModel>> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets a list of user drawer associations.
     *
     * @param userID The user identifier.
     * @param drawerID The drawer identifier.
     * @param acl Gets or sets the access control level permissions.
     * @param page Gets or sets the page number.
     * @param pageSize Gets or sets the size of the page.
     * @param sortOrder Gets or sets the order. Possible values include: 'Unspecified', 'Ascending', 'Descending'
     * @param sortBy Gets or sets the column to order by. Possible values include: 'Unspecified', 'DrawerID', 'ApplicationID', 'GroupID', 'UserID', 'QueueID', 'Acl'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;UserDrawerModel&gt; object
     */
    public Observable<ServiceResponse<List<UserDrawerModel>>> getUserDrawerAssociationsWithServiceResponseAsync(int userID, Integer drawerID, Integer acl, Integer page, Integer pageSize, String sortOrder, String sortBy) {
        return service.getUserDrawerAssociations(userID, drawerID, acl, page, pageSize, sortOrder, sortBy)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<UserDrawerModel>>>>() {
                @Override
                public Observable<ServiceResponse<List<UserDrawerModel>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<UserDrawerModel>> clientResponse = getUserDrawerAssociationsDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<List<UserDrawerModel>> getUserDrawerAssociationsDelegate(Response<ResponseBody> response) throws RestException, IOException {
        return this.restClient().responseBuilderFactory().<List<UserDrawerModel>, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<List<UserDrawerModel>>() { }.getType())
                .register(403, new TypeToken<Void>() { }.getType())
                .build(response);
    }

    /**
     * Inserts/Updates the drawer user association.
     *
     * @param userID The user identifier.
     * @param drawerID The drawer identifier.
     * @param model The model.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object createOrUpdateDrawerUserAssociation(int userID, int drawerID, UserDrawerModel model) {
        return createOrUpdateDrawerUserAssociationWithServiceResponseAsync(userID, drawerID, model).toBlocking().single().body();
    }

    /**
     * Inserts/Updates the drawer user association.
     *
     * @param userID The user identifier.
     * @param drawerID The drawer identifier.
     * @param model The model.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> createOrUpdateDrawerUserAssociationAsync(int userID, int drawerID, UserDrawerModel model, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromResponse(createOrUpdateDrawerUserAssociationWithServiceResponseAsync(userID, drawerID, model), serviceCallback);
    }

    /**
     * Inserts/Updates the drawer user association.
     *
     * @param userID The user identifier.
     * @param drawerID The drawer identifier.
     * @param model The model.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> createOrUpdateDrawerUserAssociationAsync(int userID, int drawerID, UserDrawerModel model) {
        return createOrUpdateDrawerUserAssociationWithServiceResponseAsync(userID, drawerID, model).map(new Func1<ServiceResponse<Object>, Object>() {
            @Override
            public Object call(ServiceResponse<Object> response) {
                return response.body();
            }
        });
    }

    /**
     * Inserts/Updates the drawer user association.
     *
     * @param userID The user identifier.
     * @param drawerID The drawer identifier.
     * @param model The model.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> createOrUpdateDrawerUserAssociationWithServiceResponseAsync(int userID, int drawerID, UserDrawerModel model) {
        if (model == null) {
            throw new IllegalArgumentException("Parameter model is required and cannot be null.");
        }
        Validator.validate(model);
        return service.createOrUpdateDrawerUserAssociation(userID, drawerID, model)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = createOrUpdateDrawerUserAssociationDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Object> createOrUpdateDrawerUserAssociationDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<Object, RestException>newInstance(this.serializerAdapter())
                .register(204, new TypeToken<Object>() { }.getType())
                .register(403, new TypeToken<Void>() { }.getType())
                .build(response);
    }

    /**
     * Deletes a drawer user association;.
     *
     * @param userID The user identifier.
     * @param drawerID The drawer identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object deleteDrawerUserAssociation(int userID, int drawerID) {
        return deleteDrawerUserAssociationWithServiceResponseAsync(userID, drawerID).toBlocking().single().body();
    }

    /**
     * Deletes a drawer user association;.
     *
     * @param userID The user identifier.
     * @param drawerID The drawer identifier.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> deleteDrawerUserAssociationAsync(int userID, int drawerID, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromResponse(deleteDrawerUserAssociationWithServiceResponseAsync(userID, drawerID), serviceCallback);
    }

    /**
     * Deletes a drawer user association;.
     *
     * @param userID The user identifier.
     * @param drawerID The drawer identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> deleteDrawerUserAssociationAsync(int userID, int drawerID) {
        return deleteDrawerUserAssociationWithServiceResponseAsync(userID, drawerID).map(new Func1<ServiceResponse<Object>, Object>() {
            @Override
            public Object call(ServiceResponse<Object> response) {
                return response.body();
            }
        });
    }

    /**
     * Deletes a drawer user association;.
     *
     * @param userID The user identifier.
     * @param drawerID The drawer identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> deleteDrawerUserAssociationWithServiceResponseAsync(int userID, int drawerID) {
        return service.deleteDrawerUserAssociation(userID, drawerID)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = deleteDrawerUserAssociationDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Object> deleteDrawerUserAssociationDelegate(Response<ResponseBody> response) throws RestException, IOException {
        return this.restClient().responseBuilderFactory().<Object, RestException>newInstance(this.serializerAdapter())
                .register(204, new TypeToken<Object>() { }.getType())
                .register(403, new TypeToken<Void>() { }.getType())
                .register(404, new TypeToken<Void>() { }.getType())
                .build(response);
    }

    /**
     * Inserts/Updates the user drawer association.
     *
     * @param userID The user identifier.
     * @param drawerID The drawer identifier.
     * @param model The model.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object createOrUpdateUserDrawerAssociation(int userID, int drawerID, UserDrawerModel model) {
        return createOrUpdateUserDrawerAssociationWithServiceResponseAsync(userID, drawerID, model).toBlocking().single().body();
    }

    /**
     * Inserts/Updates the user drawer association.
     *
     * @param userID The user identifier.
     * @param drawerID The drawer identifier.
     * @param model The model.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> createOrUpdateUserDrawerAssociationAsync(int userID, int drawerID, UserDrawerModel model, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromResponse(createOrUpdateUserDrawerAssociationWithServiceResponseAsync(userID, drawerID, model), serviceCallback);
    }

    /**
     * Inserts/Updates the user drawer association.
     *
     * @param userID The user identifier.
     * @param drawerID The drawer identifier.
     * @param model The model.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> createOrUpdateUserDrawerAssociationAsync(int userID, int drawerID, UserDrawerModel model) {
        return createOrUpdateUserDrawerAssociationWithServiceResponseAsync(userID, drawerID, model).map(new Func1<ServiceResponse<Object>, Object>() {
            @Override
            public Object call(ServiceResponse<Object> response) {
                return response.body();
            }
        });
    }

    /**
     * Inserts/Updates the user drawer association.
     *
     * @param userID The user identifier.
     * @param drawerID The drawer identifier.
     * @param model The model.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> createOrUpdateUserDrawerAssociationWithServiceResponseAsync(int userID, int drawerID, UserDrawerModel model) {
        if (model == null) {
            throw new IllegalArgumentException("Parameter model is required and cannot be null.");
        }
        Validator.validate(model);
        return service.createOrUpdateUserDrawerAssociation(userID, drawerID, model)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = createOrUpdateUserDrawerAssociationDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Object> createOrUpdateUserDrawerAssociationDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<Object, RestException>newInstance(this.serializerAdapter())
                .register(204, new TypeToken<Object>() { }.getType())
                .register(403, new TypeToken<Void>() { }.getType())
                .build(response);
    }

    /**
     * Deletes a user drawer association;.
     *
     * @param userID The user identifier.
     * @param drawerID The drawer identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object deleteUserDrawerAssociation(int userID, int drawerID) {
        return deleteUserDrawerAssociationWithServiceResponseAsync(userID, drawerID).toBlocking().single().body();
    }

    /**
     * Deletes a user drawer association;.
     *
     * @param userID The user identifier.
     * @param drawerID The drawer identifier.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> deleteUserDrawerAssociationAsync(int userID, int drawerID, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromResponse(deleteUserDrawerAssociationWithServiceResponseAsync(userID, drawerID), serviceCallback);
    }

    /**
     * Deletes a user drawer association;.
     *
     * @param userID The user identifier.
     * @param drawerID The drawer identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> deleteUserDrawerAssociationAsync(int userID, int drawerID) {
        return deleteUserDrawerAssociationWithServiceResponseAsync(userID, drawerID).map(new Func1<ServiceResponse<Object>, Object>() {
            @Override
            public Object call(ServiceResponse<Object> response) {
                return response.body();
            }
        });
    }

    /**
     * Deletes a user drawer association;.
     *
     * @param userID The user identifier.
     * @param drawerID The drawer identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> deleteUserDrawerAssociationWithServiceResponseAsync(int userID, int drawerID) {
        return service.deleteUserDrawerAssociation(userID, drawerID)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = deleteUserDrawerAssociationDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Object> deleteUserDrawerAssociationDelegate(Response<ResponseBody> response) throws RestException, IOException {
        return this.restClient().responseBuilderFactory().<Object, RestException>newInstance(this.serializerAdapter())
                .register(204, new TypeToken<Object>() { }.getType())
                .register(403, new TypeToken<Void>() { }.getType())
                .register(404, new TypeToken<Void>() { }.getType())
                .build(response);
    }

    /**
     * Gets a list of queue user associations.
     *
     * @param queueID The queue identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;UserQueueModel&gt; object if successful.
     */
    public List<UserQueueModel> getQueueUserAssociations(int queueID) {
        return getQueueUserAssociationsWithServiceResponseAsync(queueID).toBlocking().single().body();
    }

    /**
     * Gets a list of queue user associations.
     *
     * @param queueID The queue identifier.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<UserQueueModel>> getQueueUserAssociationsAsync(int queueID, final ServiceCallback<List<UserQueueModel>> serviceCallback) {
        return ServiceFuture.fromResponse(getQueueUserAssociationsWithServiceResponseAsync(queueID), serviceCallback);
    }

    /**
     * Gets a list of queue user associations.
     *
     * @param queueID The queue identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;UserQueueModel&gt; object
     */
    public Observable<List<UserQueueModel>> getQueueUserAssociationsAsync(int queueID) {
        return getQueueUserAssociationsWithServiceResponseAsync(queueID).map(new Func1<ServiceResponse<List<UserQueueModel>>, List<UserQueueModel>>() {
            @Override
            public List<UserQueueModel> call(ServiceResponse<List<UserQueueModel>> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets a list of queue user associations.
     *
     * @param queueID The queue identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;UserQueueModel&gt; object
     */
    public Observable<ServiceResponse<List<UserQueueModel>>> getQueueUserAssociationsWithServiceResponseAsync(int queueID) {
        final Integer userID = null;
        final Integer acl = null;
        final Integer page = null;
        final Integer pageSize = null;
        final String sortOrder = null;
        final String sortBy = null;
        return service.getQueueUserAssociations(queueID, userID, acl, page, pageSize, sortOrder, sortBy)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<UserQueueModel>>>>() {
                @Override
                public Observable<ServiceResponse<List<UserQueueModel>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<UserQueueModel>> clientResponse = getQueueUserAssociationsDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Gets a list of queue user associations.
     *
     * @param queueID The queue identifier.
     * @param userID The user identifier.
     * @param acl Gets or sets the access control level permissions.
     * @param page Gets or sets the page number.
     * @param pageSize Gets or sets the size of the page.
     * @param sortOrder Gets or sets the order. Possible values include: 'Unspecified', 'Ascending', 'Descending'
     * @param sortBy Gets or sets the column to order by. Possible values include: 'Unspecified', 'DrawerID', 'ApplicationID', 'GroupID', 'UserID', 'QueueID', 'Acl'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;UserQueueModel&gt; object if successful.
     */
    public List<UserQueueModel> getQueueUserAssociations(int queueID, Integer userID, Integer acl, Integer page, Integer pageSize, String sortOrder, String sortBy) {
        return getQueueUserAssociationsWithServiceResponseAsync(queueID, userID, acl, page, pageSize, sortOrder, sortBy).toBlocking().single().body();
    }

    /**
     * Gets a list of queue user associations.
     *
     * @param queueID The queue identifier.
     * @param userID The user identifier.
     * @param acl Gets or sets the access control level permissions.
     * @param page Gets or sets the page number.
     * @param pageSize Gets or sets the size of the page.
     * @param sortOrder Gets or sets the order. Possible values include: 'Unspecified', 'Ascending', 'Descending'
     * @param sortBy Gets or sets the column to order by. Possible values include: 'Unspecified', 'DrawerID', 'ApplicationID', 'GroupID', 'UserID', 'QueueID', 'Acl'
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<UserQueueModel>> getQueueUserAssociationsAsync(int queueID, Integer userID, Integer acl, Integer page, Integer pageSize, String sortOrder, String sortBy, final ServiceCallback<List<UserQueueModel>> serviceCallback) {
        return ServiceFuture.fromResponse(getQueueUserAssociationsWithServiceResponseAsync(queueID, userID, acl, page, pageSize, sortOrder, sortBy), serviceCallback);
    }

    /**
     * Gets a list of queue user associations.
     *
     * @param queueID The queue identifier.
     * @param userID The user identifier.
     * @param acl Gets or sets the access control level permissions.
     * @param page Gets or sets the page number.
     * @param pageSize Gets or sets the size of the page.
     * @param sortOrder Gets or sets the order. Possible values include: 'Unspecified', 'Ascending', 'Descending'
     * @param sortBy Gets or sets the column to order by. Possible values include: 'Unspecified', 'DrawerID', 'ApplicationID', 'GroupID', 'UserID', 'QueueID', 'Acl'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;UserQueueModel&gt; object
     */
    public Observable<List<UserQueueModel>> getQueueUserAssociationsAsync(int queueID, Integer userID, Integer acl, Integer page, Integer pageSize, String sortOrder, String sortBy) {
        return getQueueUserAssociationsWithServiceResponseAsync(queueID, userID, acl, page, pageSize, sortOrder, sortBy).map(new Func1<ServiceResponse<List<UserQueueModel>>, List<UserQueueModel>>() {
            @Override
            public List<UserQueueModel> call(ServiceResponse<List<UserQueueModel>> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets a list of queue user associations.
     *
     * @param queueID The queue identifier.
     * @param userID The user identifier.
     * @param acl Gets or sets the access control level permissions.
     * @param page Gets or sets the page number.
     * @param pageSize Gets or sets the size of the page.
     * @param sortOrder Gets or sets the order. Possible values include: 'Unspecified', 'Ascending', 'Descending'
     * @param sortBy Gets or sets the column to order by. Possible values include: 'Unspecified', 'DrawerID', 'ApplicationID', 'GroupID', 'UserID', 'QueueID', 'Acl'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;UserQueueModel&gt; object
     */
    public Observable<ServiceResponse<List<UserQueueModel>>> getQueueUserAssociationsWithServiceResponseAsync(int queueID, Integer userID, Integer acl, Integer page, Integer pageSize, String sortOrder, String sortBy) {
        return service.getQueueUserAssociations(queueID, userID, acl, page, pageSize, sortOrder, sortBy)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<UserQueueModel>>>>() {
                @Override
                public Observable<ServiceResponse<List<UserQueueModel>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<UserQueueModel>> clientResponse = getQueueUserAssociationsDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<List<UserQueueModel>> getQueueUserAssociationsDelegate(Response<ResponseBody> response) throws RestException, IOException {
        return this.restClient().responseBuilderFactory().<List<UserQueueModel>, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<List<UserQueueModel>>() { }.getType())
                .register(403, new TypeToken<Void>() { }.getType())
                .build(response);
    }

    /**
     * Gets a list of user queue associations.
     *
     * @param userID The user identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;UserQueueModel&gt; object if successful.
     */
    public List<UserQueueModel> getUserQueueAssociations(int userID) {
        return getUserQueueAssociationsWithServiceResponseAsync(userID).toBlocking().single().body();
    }

    /**
     * Gets a list of user queue associations.
     *
     * @param userID The user identifier.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<UserQueueModel>> getUserQueueAssociationsAsync(int userID, final ServiceCallback<List<UserQueueModel>> serviceCallback) {
        return ServiceFuture.fromResponse(getUserQueueAssociationsWithServiceResponseAsync(userID), serviceCallback);
    }

    /**
     * Gets a list of user queue associations.
     *
     * @param userID The user identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;UserQueueModel&gt; object
     */
    public Observable<List<UserQueueModel>> getUserQueueAssociationsAsync(int userID) {
        return getUserQueueAssociationsWithServiceResponseAsync(userID).map(new Func1<ServiceResponse<List<UserQueueModel>>, List<UserQueueModel>>() {
            @Override
            public List<UserQueueModel> call(ServiceResponse<List<UserQueueModel>> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets a list of user queue associations.
     *
     * @param userID The user identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;UserQueueModel&gt; object
     */
    public Observable<ServiceResponse<List<UserQueueModel>>> getUserQueueAssociationsWithServiceResponseAsync(int userID) {
        final Integer queueID = null;
        final Integer acl = null;
        final Integer page = null;
        final Integer pageSize = null;
        final String sortOrder = null;
        final String sortBy = null;
        return service.getUserQueueAssociations(userID, queueID, acl, page, pageSize, sortOrder, sortBy)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<UserQueueModel>>>>() {
                @Override
                public Observable<ServiceResponse<List<UserQueueModel>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<UserQueueModel>> clientResponse = getUserQueueAssociationsDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Gets a list of user queue associations.
     *
     * @param userID The user identifier.
     * @param queueID The queue identifier.
     * @param acl Gets or sets the access control level permissions.
     * @param page Gets or sets the page number.
     * @param pageSize Gets or sets the size of the page.
     * @param sortOrder Gets or sets the order. Possible values include: 'Unspecified', 'Ascending', 'Descending'
     * @param sortBy Gets or sets the column to order by. Possible values include: 'Unspecified', 'DrawerID', 'ApplicationID', 'GroupID', 'UserID', 'QueueID', 'Acl'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;UserQueueModel&gt; object if successful.
     */
    public List<UserQueueModel> getUserQueueAssociations(int userID, Integer queueID, Integer acl, Integer page, Integer pageSize, String sortOrder, String sortBy) {
        return getUserQueueAssociationsWithServiceResponseAsync(userID, queueID, acl, page, pageSize, sortOrder, sortBy).toBlocking().single().body();
    }

    /**
     * Gets a list of user queue associations.
     *
     * @param userID The user identifier.
     * @param queueID The queue identifier.
     * @param acl Gets or sets the access control level permissions.
     * @param page Gets or sets the page number.
     * @param pageSize Gets or sets the size of the page.
     * @param sortOrder Gets or sets the order. Possible values include: 'Unspecified', 'Ascending', 'Descending'
     * @param sortBy Gets or sets the column to order by. Possible values include: 'Unspecified', 'DrawerID', 'ApplicationID', 'GroupID', 'UserID', 'QueueID', 'Acl'
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<UserQueueModel>> getUserQueueAssociationsAsync(int userID, Integer queueID, Integer acl, Integer page, Integer pageSize, String sortOrder, String sortBy, final ServiceCallback<List<UserQueueModel>> serviceCallback) {
        return ServiceFuture.fromResponse(getUserQueueAssociationsWithServiceResponseAsync(userID, queueID, acl, page, pageSize, sortOrder, sortBy), serviceCallback);
    }

    /**
     * Gets a list of user queue associations.
     *
     * @param userID The user identifier.
     * @param queueID The queue identifier.
     * @param acl Gets or sets the access control level permissions.
     * @param page Gets or sets the page number.
     * @param pageSize Gets or sets the size of the page.
     * @param sortOrder Gets or sets the order. Possible values include: 'Unspecified', 'Ascending', 'Descending'
     * @param sortBy Gets or sets the column to order by. Possible values include: 'Unspecified', 'DrawerID', 'ApplicationID', 'GroupID', 'UserID', 'QueueID', 'Acl'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;UserQueueModel&gt; object
     */
    public Observable<List<UserQueueModel>> getUserQueueAssociationsAsync(int userID, Integer queueID, Integer acl, Integer page, Integer pageSize, String sortOrder, String sortBy) {
        return getUserQueueAssociationsWithServiceResponseAsync(userID, queueID, acl, page, pageSize, sortOrder, sortBy).map(new Func1<ServiceResponse<List<UserQueueModel>>, List<UserQueueModel>>() {
            @Override
            public List<UserQueueModel> call(ServiceResponse<List<UserQueueModel>> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets a list of user queue associations.
     *
     * @param userID The user identifier.
     * @param queueID The queue identifier.
     * @param acl Gets or sets the access control level permissions.
     * @param page Gets or sets the page number.
     * @param pageSize Gets or sets the size of the page.
     * @param sortOrder Gets or sets the order. Possible values include: 'Unspecified', 'Ascending', 'Descending'
     * @param sortBy Gets or sets the column to order by. Possible values include: 'Unspecified', 'DrawerID', 'ApplicationID', 'GroupID', 'UserID', 'QueueID', 'Acl'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;UserQueueModel&gt; object
     */
    public Observable<ServiceResponse<List<UserQueueModel>>> getUserQueueAssociationsWithServiceResponseAsync(int userID, Integer queueID, Integer acl, Integer page, Integer pageSize, String sortOrder, String sortBy) {
        return service.getUserQueueAssociations(userID, queueID, acl, page, pageSize, sortOrder, sortBy)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<UserQueueModel>>>>() {
                @Override
                public Observable<ServiceResponse<List<UserQueueModel>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<UserQueueModel>> clientResponse = getUserQueueAssociationsDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<List<UserQueueModel>> getUserQueueAssociationsDelegate(Response<ResponseBody> response) throws RestException, IOException {
        return this.restClient().responseBuilderFactory().<List<UserQueueModel>, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<List<UserQueueModel>>() { }.getType())
                .register(403, new TypeToken<Void>() { }.getType())
                .build(response);
    }

    /**
     * Inserts/Updates the queue user association.
     *
     * @param userID The user identifier.
     * @param queueID The queue identifier.
     * @param model The model.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object createOrUpdateQueueUserAssociation(int userID, int queueID, UserQueueModel model) {
        return createOrUpdateQueueUserAssociationWithServiceResponseAsync(userID, queueID, model).toBlocking().single().body();
    }

    /**
     * Inserts/Updates the queue user association.
     *
     * @param userID The user identifier.
     * @param queueID The queue identifier.
     * @param model The model.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> createOrUpdateQueueUserAssociationAsync(int userID, int queueID, UserQueueModel model, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromResponse(createOrUpdateQueueUserAssociationWithServiceResponseAsync(userID, queueID, model), serviceCallback);
    }

    /**
     * Inserts/Updates the queue user association.
     *
     * @param userID The user identifier.
     * @param queueID The queue identifier.
     * @param model The model.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> createOrUpdateQueueUserAssociationAsync(int userID, int queueID, UserQueueModel model) {
        return createOrUpdateQueueUserAssociationWithServiceResponseAsync(userID, queueID, model).map(new Func1<ServiceResponse<Object>, Object>() {
            @Override
            public Object call(ServiceResponse<Object> response) {
                return response.body();
            }
        });
    }

    /**
     * Inserts/Updates the queue user association.
     *
     * @param userID The user identifier.
     * @param queueID The queue identifier.
     * @param model The model.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> createOrUpdateQueueUserAssociationWithServiceResponseAsync(int userID, int queueID, UserQueueModel model) {
        if (model == null) {
            throw new IllegalArgumentException("Parameter model is required and cannot be null.");
        }
        Validator.validate(model);
        return service.createOrUpdateQueueUserAssociation(userID, queueID, model)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = createOrUpdateQueueUserAssociationDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Object> createOrUpdateQueueUserAssociationDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<Object, RestException>newInstance(this.serializerAdapter())
                .register(204, new TypeToken<Object>() { }.getType())
                .register(403, new TypeToken<Void>() { }.getType())
                .build(response);
    }

    /**
     * Deletes a queue user association;.
     *
     * @param userID The user identifier.
     * @param queueID The queue identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object deleteQueueUserAssociation(int userID, int queueID) {
        return deleteQueueUserAssociationWithServiceResponseAsync(userID, queueID).toBlocking().single().body();
    }

    /**
     * Deletes a queue user association;.
     *
     * @param userID The user identifier.
     * @param queueID The queue identifier.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> deleteQueueUserAssociationAsync(int userID, int queueID, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromResponse(deleteQueueUserAssociationWithServiceResponseAsync(userID, queueID), serviceCallback);
    }

    /**
     * Deletes a queue user association;.
     *
     * @param userID The user identifier.
     * @param queueID The queue identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> deleteQueueUserAssociationAsync(int userID, int queueID) {
        return deleteQueueUserAssociationWithServiceResponseAsync(userID, queueID).map(new Func1<ServiceResponse<Object>, Object>() {
            @Override
            public Object call(ServiceResponse<Object> response) {
                return response.body();
            }
        });
    }

    /**
     * Deletes a queue user association;.
     *
     * @param userID The user identifier.
     * @param queueID The queue identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> deleteQueueUserAssociationWithServiceResponseAsync(int userID, int queueID) {
        return service.deleteQueueUserAssociation(userID, queueID)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = deleteQueueUserAssociationDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Object> deleteQueueUserAssociationDelegate(Response<ResponseBody> response) throws RestException, IOException {
        return this.restClient().responseBuilderFactory().<Object, RestException>newInstance(this.serializerAdapter())
                .register(204, new TypeToken<Object>() { }.getType())
                .register(403, new TypeToken<Void>() { }.getType())
                .register(404, new TypeToken<Void>() { }.getType())
                .build(response);
    }

    /**
     * Inserts/Updates the user queue association.
     *
     * @param userID The user identifier.
     * @param queueID The queue identifier.
     * @param model The model.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object createOrUpdateUserQueueAssociation(int userID, int queueID, UserQueueModel model) {
        return createOrUpdateUserQueueAssociationWithServiceResponseAsync(userID, queueID, model).toBlocking().single().body();
    }

    /**
     * Inserts/Updates the user queue association.
     *
     * @param userID The user identifier.
     * @param queueID The queue identifier.
     * @param model The model.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> createOrUpdateUserQueueAssociationAsync(int userID, int queueID, UserQueueModel model, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromResponse(createOrUpdateUserQueueAssociationWithServiceResponseAsync(userID, queueID, model), serviceCallback);
    }

    /**
     * Inserts/Updates the user queue association.
     *
     * @param userID The user identifier.
     * @param queueID The queue identifier.
     * @param model The model.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> createOrUpdateUserQueueAssociationAsync(int userID, int queueID, UserQueueModel model) {
        return createOrUpdateUserQueueAssociationWithServiceResponseAsync(userID, queueID, model).map(new Func1<ServiceResponse<Object>, Object>() {
            @Override
            public Object call(ServiceResponse<Object> response) {
                return response.body();
            }
        });
    }

    /**
     * Inserts/Updates the user queue association.
     *
     * @param userID The user identifier.
     * @param queueID The queue identifier.
     * @param model The model.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> createOrUpdateUserQueueAssociationWithServiceResponseAsync(int userID, int queueID, UserQueueModel model) {
        if (model == null) {
            throw new IllegalArgumentException("Parameter model is required and cannot be null.");
        }
        Validator.validate(model);
        return service.createOrUpdateUserQueueAssociation(userID, queueID, model)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = createOrUpdateUserQueueAssociationDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Object> createOrUpdateUserQueueAssociationDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<Object, RestException>newInstance(this.serializerAdapter())
                .register(204, new TypeToken<Object>() { }.getType())
                .register(403, new TypeToken<Void>() { }.getType())
                .build(response);
    }

    /**
     * Deletes a user queue association;.
     *
     * @param userID The user identifier.
     * @param queueID The queue identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object deleteUserQueueAssociation(int userID, int queueID) {
        return deleteUserQueueAssociationWithServiceResponseAsync(userID, queueID).toBlocking().single().body();
    }

    /**
     * Deletes a user queue association;.
     *
     * @param userID The user identifier.
     * @param queueID The queue identifier.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> deleteUserQueueAssociationAsync(int userID, int queueID, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromResponse(deleteUserQueueAssociationWithServiceResponseAsync(userID, queueID), serviceCallback);
    }

    /**
     * Deletes a user queue association;.
     *
     * @param userID The user identifier.
     * @param queueID The queue identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> deleteUserQueueAssociationAsync(int userID, int queueID) {
        return deleteUserQueueAssociationWithServiceResponseAsync(userID, queueID).map(new Func1<ServiceResponse<Object>, Object>() {
            @Override
            public Object call(ServiceResponse<Object> response) {
                return response.body();
            }
        });
    }

    /**
     * Deletes a user queue association;.
     *
     * @param userID The user identifier.
     * @param queueID The queue identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> deleteUserQueueAssociationWithServiceResponseAsync(int userID, int queueID) {
        return service.deleteUserQueueAssociation(userID, queueID)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = deleteUserQueueAssociationDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Object> deleteUserQueueAssociationDelegate(Response<ResponseBody> response) throws RestException, IOException {
        return this.restClient().responseBuilderFactory().<Object, RestException>newInstance(this.serializerAdapter())
                .register(204, new TypeToken<Object>() { }.getType())
                .register(403, new TypeToken<Void>() { }.getType())
                .register(404, new TypeToken<Void>() { }.getType())
                .build(response);
    }

    /**
     * Gets a list of application user associations.
     *
     * @param applicationID The application identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;UserApplicationModel&gt; object if successful.
     */
    public List<UserApplicationModel> getApplicationUserAssociations(int applicationID) {
        return getApplicationUserAssociationsWithServiceResponseAsync(applicationID).toBlocking().single().body();
    }

    /**
     * Gets a list of application user associations.
     *
     * @param applicationID The application identifier.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<UserApplicationModel>> getApplicationUserAssociationsAsync(int applicationID, final ServiceCallback<List<UserApplicationModel>> serviceCallback) {
        return ServiceFuture.fromResponse(getApplicationUserAssociationsWithServiceResponseAsync(applicationID), serviceCallback);
    }

    /**
     * Gets a list of application user associations.
     *
     * @param applicationID The application identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;UserApplicationModel&gt; object
     */
    public Observable<List<UserApplicationModel>> getApplicationUserAssociationsAsync(int applicationID) {
        return getApplicationUserAssociationsWithServiceResponseAsync(applicationID).map(new Func1<ServiceResponse<List<UserApplicationModel>>, List<UserApplicationModel>>() {
            @Override
            public List<UserApplicationModel> call(ServiceResponse<List<UserApplicationModel>> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets a list of application user associations.
     *
     * @param applicationID The application identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;UserApplicationModel&gt; object
     */
    public Observable<ServiceResponse<List<UserApplicationModel>>> getApplicationUserAssociationsWithServiceResponseAsync(int applicationID) {
        final Integer userID = null;
        final Integer acl = null;
        final Integer page = null;
        final Integer pageSize = null;
        final String sortOrder = null;
        final String sortBy = null;
        return service.getApplicationUserAssociations(applicationID, userID, acl, page, pageSize, sortOrder, sortBy)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<UserApplicationModel>>>>() {
                @Override
                public Observable<ServiceResponse<List<UserApplicationModel>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<UserApplicationModel>> clientResponse = getApplicationUserAssociationsDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Gets a list of application user associations.
     *
     * @param applicationID The application identifier.
     * @param userID The user identifier.
     * @param acl Gets or sets the access control level permissions.
     * @param page Gets or sets the page number.
     * @param pageSize Gets or sets the size of the page.
     * @param sortOrder Gets or sets the order. Possible values include: 'Unspecified', 'Ascending', 'Descending'
     * @param sortBy Gets or sets the column to order by. Possible values include: 'Unspecified', 'DrawerID', 'ApplicationID', 'GroupID', 'UserID', 'QueueID', 'Acl'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;UserApplicationModel&gt; object if successful.
     */
    public List<UserApplicationModel> getApplicationUserAssociations(int applicationID, Integer userID, Integer acl, Integer page, Integer pageSize, String sortOrder, String sortBy) {
        return getApplicationUserAssociationsWithServiceResponseAsync(applicationID, userID, acl, page, pageSize, sortOrder, sortBy).toBlocking().single().body();
    }

    /**
     * Gets a list of application user associations.
     *
     * @param applicationID The application identifier.
     * @param userID The user identifier.
     * @param acl Gets or sets the access control level permissions.
     * @param page Gets or sets the page number.
     * @param pageSize Gets or sets the size of the page.
     * @param sortOrder Gets or sets the order. Possible values include: 'Unspecified', 'Ascending', 'Descending'
     * @param sortBy Gets or sets the column to order by. Possible values include: 'Unspecified', 'DrawerID', 'ApplicationID', 'GroupID', 'UserID', 'QueueID', 'Acl'
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<UserApplicationModel>> getApplicationUserAssociationsAsync(int applicationID, Integer userID, Integer acl, Integer page, Integer pageSize, String sortOrder, String sortBy, final ServiceCallback<List<UserApplicationModel>> serviceCallback) {
        return ServiceFuture.fromResponse(getApplicationUserAssociationsWithServiceResponseAsync(applicationID, userID, acl, page, pageSize, sortOrder, sortBy), serviceCallback);
    }

    /**
     * Gets a list of application user associations.
     *
     * @param applicationID The application identifier.
     * @param userID The user identifier.
     * @param acl Gets or sets the access control level permissions.
     * @param page Gets or sets the page number.
     * @param pageSize Gets or sets the size of the page.
     * @param sortOrder Gets or sets the order. Possible values include: 'Unspecified', 'Ascending', 'Descending'
     * @param sortBy Gets or sets the column to order by. Possible values include: 'Unspecified', 'DrawerID', 'ApplicationID', 'GroupID', 'UserID', 'QueueID', 'Acl'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;UserApplicationModel&gt; object
     */
    public Observable<List<UserApplicationModel>> getApplicationUserAssociationsAsync(int applicationID, Integer userID, Integer acl, Integer page, Integer pageSize, String sortOrder, String sortBy) {
        return getApplicationUserAssociationsWithServiceResponseAsync(applicationID, userID, acl, page, pageSize, sortOrder, sortBy).map(new Func1<ServiceResponse<List<UserApplicationModel>>, List<UserApplicationModel>>() {
            @Override
            public List<UserApplicationModel> call(ServiceResponse<List<UserApplicationModel>> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets a list of application user associations.
     *
     * @param applicationID The application identifier.
     * @param userID The user identifier.
     * @param acl Gets or sets the access control level permissions.
     * @param page Gets or sets the page number.
     * @param pageSize Gets or sets the size of the page.
     * @param sortOrder Gets or sets the order. Possible values include: 'Unspecified', 'Ascending', 'Descending'
     * @param sortBy Gets or sets the column to order by. Possible values include: 'Unspecified', 'DrawerID', 'ApplicationID', 'GroupID', 'UserID', 'QueueID', 'Acl'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;UserApplicationModel&gt; object
     */
    public Observable<ServiceResponse<List<UserApplicationModel>>> getApplicationUserAssociationsWithServiceResponseAsync(int applicationID, Integer userID, Integer acl, Integer page, Integer pageSize, String sortOrder, String sortBy) {
        return service.getApplicationUserAssociations(applicationID, userID, acl, page, pageSize, sortOrder, sortBy)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<UserApplicationModel>>>>() {
                @Override
                public Observable<ServiceResponse<List<UserApplicationModel>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<UserApplicationModel>> clientResponse = getApplicationUserAssociationsDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<List<UserApplicationModel>> getApplicationUserAssociationsDelegate(Response<ResponseBody> response) throws RestException, IOException {
        return this.restClient().responseBuilderFactory().<List<UserApplicationModel>, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<List<UserApplicationModel>>() { }.getType())
                .register(403, new TypeToken<Void>() { }.getType())
                .build(response);
    }

    /**
     * Gets a list of user application associations.
     *
     * @param userID The user identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;UserApplicationModel&gt; object if successful.
     */
    public List<UserApplicationModel> getUserApplicationAssociations(int userID) {
        return getUserApplicationAssociationsWithServiceResponseAsync(userID).toBlocking().single().body();
    }

    /**
     * Gets a list of user application associations.
     *
     * @param userID The user identifier.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<UserApplicationModel>> getUserApplicationAssociationsAsync(int userID, final ServiceCallback<List<UserApplicationModel>> serviceCallback) {
        return ServiceFuture.fromResponse(getUserApplicationAssociationsWithServiceResponseAsync(userID), serviceCallback);
    }

    /**
     * Gets a list of user application associations.
     *
     * @param userID The user identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;UserApplicationModel&gt; object
     */
    public Observable<List<UserApplicationModel>> getUserApplicationAssociationsAsync(int userID) {
        return getUserApplicationAssociationsWithServiceResponseAsync(userID).map(new Func1<ServiceResponse<List<UserApplicationModel>>, List<UserApplicationModel>>() {
            @Override
            public List<UserApplicationModel> call(ServiceResponse<List<UserApplicationModel>> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets a list of user application associations.
     *
     * @param userID The user identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;UserApplicationModel&gt; object
     */
    public Observable<ServiceResponse<List<UserApplicationModel>>> getUserApplicationAssociationsWithServiceResponseAsync(int userID) {
        final Integer applicationID = null;
        final Integer acl = null;
        final Integer page = null;
        final Integer pageSize = null;
        final String sortOrder = null;
        final String sortBy = null;
        return service.getUserApplicationAssociations(userID, applicationID, acl, page, pageSize, sortOrder, sortBy)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<UserApplicationModel>>>>() {
                @Override
                public Observable<ServiceResponse<List<UserApplicationModel>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<UserApplicationModel>> clientResponse = getUserApplicationAssociationsDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Gets a list of user application associations.
     *
     * @param userID The user identifier.
     * @param applicationID The application identifier.
     * @param acl Gets or sets the access control level permissions.
     * @param page Gets or sets the page number.
     * @param pageSize Gets or sets the size of the page.
     * @param sortOrder Gets or sets the order. Possible values include: 'Unspecified', 'Ascending', 'Descending'
     * @param sortBy Gets or sets the column to order by. Possible values include: 'Unspecified', 'DrawerID', 'ApplicationID', 'GroupID', 'UserID', 'QueueID', 'Acl'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;UserApplicationModel&gt; object if successful.
     */
    public List<UserApplicationModel> getUserApplicationAssociations(int userID, Integer applicationID, Integer acl, Integer page, Integer pageSize, String sortOrder, String sortBy) {
        return getUserApplicationAssociationsWithServiceResponseAsync(userID, applicationID, acl, page, pageSize, sortOrder, sortBy).toBlocking().single().body();
    }

    /**
     * Gets a list of user application associations.
     *
     * @param userID The user identifier.
     * @param applicationID The application identifier.
     * @param acl Gets or sets the access control level permissions.
     * @param page Gets or sets the page number.
     * @param pageSize Gets or sets the size of the page.
     * @param sortOrder Gets or sets the order. Possible values include: 'Unspecified', 'Ascending', 'Descending'
     * @param sortBy Gets or sets the column to order by. Possible values include: 'Unspecified', 'DrawerID', 'ApplicationID', 'GroupID', 'UserID', 'QueueID', 'Acl'
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<UserApplicationModel>> getUserApplicationAssociationsAsync(int userID, Integer applicationID, Integer acl, Integer page, Integer pageSize, String sortOrder, String sortBy, final ServiceCallback<List<UserApplicationModel>> serviceCallback) {
        return ServiceFuture.fromResponse(getUserApplicationAssociationsWithServiceResponseAsync(userID, applicationID, acl, page, pageSize, sortOrder, sortBy), serviceCallback);
    }

    /**
     * Gets a list of user application associations.
     *
     * @param userID The user identifier.
     * @param applicationID The application identifier.
     * @param acl Gets or sets the access control level permissions.
     * @param page Gets or sets the page number.
     * @param pageSize Gets or sets the size of the page.
     * @param sortOrder Gets or sets the order. Possible values include: 'Unspecified', 'Ascending', 'Descending'
     * @param sortBy Gets or sets the column to order by. Possible values include: 'Unspecified', 'DrawerID', 'ApplicationID', 'GroupID', 'UserID', 'QueueID', 'Acl'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;UserApplicationModel&gt; object
     */
    public Observable<List<UserApplicationModel>> getUserApplicationAssociationsAsync(int userID, Integer applicationID, Integer acl, Integer page, Integer pageSize, String sortOrder, String sortBy) {
        return getUserApplicationAssociationsWithServiceResponseAsync(userID, applicationID, acl, page, pageSize, sortOrder, sortBy).map(new Func1<ServiceResponse<List<UserApplicationModel>>, List<UserApplicationModel>>() {
            @Override
            public List<UserApplicationModel> call(ServiceResponse<List<UserApplicationModel>> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets a list of user application associations.
     *
     * @param userID The user identifier.
     * @param applicationID The application identifier.
     * @param acl Gets or sets the access control level permissions.
     * @param page Gets or sets the page number.
     * @param pageSize Gets or sets the size of the page.
     * @param sortOrder Gets or sets the order. Possible values include: 'Unspecified', 'Ascending', 'Descending'
     * @param sortBy Gets or sets the column to order by. Possible values include: 'Unspecified', 'DrawerID', 'ApplicationID', 'GroupID', 'UserID', 'QueueID', 'Acl'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;UserApplicationModel&gt; object
     */
    public Observable<ServiceResponse<List<UserApplicationModel>>> getUserApplicationAssociationsWithServiceResponseAsync(int userID, Integer applicationID, Integer acl, Integer page, Integer pageSize, String sortOrder, String sortBy) {
        return service.getUserApplicationAssociations(userID, applicationID, acl, page, pageSize, sortOrder, sortBy)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<UserApplicationModel>>>>() {
                @Override
                public Observable<ServiceResponse<List<UserApplicationModel>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<UserApplicationModel>> clientResponse = getUserApplicationAssociationsDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<List<UserApplicationModel>> getUserApplicationAssociationsDelegate(Response<ResponseBody> response) throws RestException, IOException {
        return this.restClient().responseBuilderFactory().<List<UserApplicationModel>, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<List<UserApplicationModel>>() { }.getType())
                .register(403, new TypeToken<Void>() { }.getType())
                .build(response);
    }

    /**
     * Inserts/Updates the application user association.
     *
     * @param userID The user identifier.
     * @param applicationID The application identifier.
     * @param model The model.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object createOrUpdateApplicationUserAssociation(int userID, int applicationID, UserApplicationModel model) {
        return createOrUpdateApplicationUserAssociationWithServiceResponseAsync(userID, applicationID, model).toBlocking().single().body();
    }

    /**
     * Inserts/Updates the application user association.
     *
     * @param userID The user identifier.
     * @param applicationID The application identifier.
     * @param model The model.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> createOrUpdateApplicationUserAssociationAsync(int userID, int applicationID, UserApplicationModel model, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromResponse(createOrUpdateApplicationUserAssociationWithServiceResponseAsync(userID, applicationID, model), serviceCallback);
    }

    /**
     * Inserts/Updates the application user association.
     *
     * @param userID The user identifier.
     * @param applicationID The application identifier.
     * @param model The model.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> createOrUpdateApplicationUserAssociationAsync(int userID, int applicationID, UserApplicationModel model) {
        return createOrUpdateApplicationUserAssociationWithServiceResponseAsync(userID, applicationID, model).map(new Func1<ServiceResponse<Object>, Object>() {
            @Override
            public Object call(ServiceResponse<Object> response) {
                return response.body();
            }
        });
    }

    /**
     * Inserts/Updates the application user association.
     *
     * @param userID The user identifier.
     * @param applicationID The application identifier.
     * @param model The model.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> createOrUpdateApplicationUserAssociationWithServiceResponseAsync(int userID, int applicationID, UserApplicationModel model) {
        if (model == null) {
            throw new IllegalArgumentException("Parameter model is required and cannot be null.");
        }
        Validator.validate(model);
        return service.createOrUpdateApplicationUserAssociation(userID, applicationID, model)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = createOrUpdateApplicationUserAssociationDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Object> createOrUpdateApplicationUserAssociationDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<Object, RestException>newInstance(this.serializerAdapter())
                .register(204, new TypeToken<Object>() { }.getType())
                .register(403, new TypeToken<Void>() { }.getType())
                .build(response);
    }

    /**
     * Deletes an application user association;.
     *
     * @param userID The user identifier.
     * @param applicationID The application identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object deleteApplicationUserAssociation(int userID, int applicationID) {
        return deleteApplicationUserAssociationWithServiceResponseAsync(userID, applicationID).toBlocking().single().body();
    }

    /**
     * Deletes an application user association;.
     *
     * @param userID The user identifier.
     * @param applicationID The application identifier.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> deleteApplicationUserAssociationAsync(int userID, int applicationID, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromResponse(deleteApplicationUserAssociationWithServiceResponseAsync(userID, applicationID), serviceCallback);
    }

    /**
     * Deletes an application user association;.
     *
     * @param userID The user identifier.
     * @param applicationID The application identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> deleteApplicationUserAssociationAsync(int userID, int applicationID) {
        return deleteApplicationUserAssociationWithServiceResponseAsync(userID, applicationID).map(new Func1<ServiceResponse<Object>, Object>() {
            @Override
            public Object call(ServiceResponse<Object> response) {
                return response.body();
            }
        });
    }

    /**
     * Deletes an application user association;.
     *
     * @param userID The user identifier.
     * @param applicationID The application identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> deleteApplicationUserAssociationWithServiceResponseAsync(int userID, int applicationID) {
        return service.deleteApplicationUserAssociation(userID, applicationID)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = deleteApplicationUserAssociationDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Object> deleteApplicationUserAssociationDelegate(Response<ResponseBody> response) throws RestException, IOException {
        return this.restClient().responseBuilderFactory().<Object, RestException>newInstance(this.serializerAdapter())
                .register(204, new TypeToken<Object>() { }.getType())
                .register(403, new TypeToken<Void>() { }.getType())
                .register(404, new TypeToken<Void>() { }.getType())
                .build(response);
    }

    /**
     * Inserts/Updates the user application association.
     *
     * @param userID The user identifier.
     * @param applicationID The application identifier.
     * @param model The model.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object createOrUpdateUserApplicationAssociation(int userID, int applicationID, UserApplicationModel model) {
        return createOrUpdateUserApplicationAssociationWithServiceResponseAsync(userID, applicationID, model).toBlocking().single().body();
    }

    /**
     * Inserts/Updates the user application association.
     *
     * @param userID The user identifier.
     * @param applicationID The application identifier.
     * @param model The model.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> createOrUpdateUserApplicationAssociationAsync(int userID, int applicationID, UserApplicationModel model, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromResponse(createOrUpdateUserApplicationAssociationWithServiceResponseAsync(userID, applicationID, model), serviceCallback);
    }

    /**
     * Inserts/Updates the user application association.
     *
     * @param userID The user identifier.
     * @param applicationID The application identifier.
     * @param model The model.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> createOrUpdateUserApplicationAssociationAsync(int userID, int applicationID, UserApplicationModel model) {
        return createOrUpdateUserApplicationAssociationWithServiceResponseAsync(userID, applicationID, model).map(new Func1<ServiceResponse<Object>, Object>() {
            @Override
            public Object call(ServiceResponse<Object> response) {
                return response.body();
            }
        });
    }

    /**
     * Inserts/Updates the user application association.
     *
     * @param userID The user identifier.
     * @param applicationID The application identifier.
     * @param model The model.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> createOrUpdateUserApplicationAssociationWithServiceResponseAsync(int userID, int applicationID, UserApplicationModel model) {
        if (model == null) {
            throw new IllegalArgumentException("Parameter model is required and cannot be null.");
        }
        Validator.validate(model);
        return service.createOrUpdateUserApplicationAssociation(userID, applicationID, model)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = createOrUpdateUserApplicationAssociationDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Object> createOrUpdateUserApplicationAssociationDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<Object, RestException>newInstance(this.serializerAdapter())
                .register(204, new TypeToken<Object>() { }.getType())
                .register(403, new TypeToken<Void>() { }.getType())
                .build(response);
    }

    /**
     * Deletes a user application association;.
     *
     * @param userID The user identifier.
     * @param applicationID The application identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object deleteUserApplicationAssociation(int userID, int applicationID) {
        return deleteUserApplicationAssociationWithServiceResponseAsync(userID, applicationID).toBlocking().single().body();
    }

    /**
     * Deletes a user application association;.
     *
     * @param userID The user identifier.
     * @param applicationID The application identifier.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> deleteUserApplicationAssociationAsync(int userID, int applicationID, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromResponse(deleteUserApplicationAssociationWithServiceResponseAsync(userID, applicationID), serviceCallback);
    }

    /**
     * Deletes a user application association;.
     *
     * @param userID The user identifier.
     * @param applicationID The application identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> deleteUserApplicationAssociationAsync(int userID, int applicationID) {
        return deleteUserApplicationAssociationWithServiceResponseAsync(userID, applicationID).map(new Func1<ServiceResponse<Object>, Object>() {
            @Override
            public Object call(ServiceResponse<Object> response) {
                return response.body();
            }
        });
    }

    /**
     * Deletes a user application association;.
     *
     * @param userID The user identifier.
     * @param applicationID The application identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> deleteUserApplicationAssociationWithServiceResponseAsync(int userID, int applicationID) {
        return service.deleteUserApplicationAssociation(userID, applicationID)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = deleteUserApplicationAssociationDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Object> deleteUserApplicationAssociationDelegate(Response<ResponseBody> response) throws RestException, IOException {
        return this.restClient().responseBuilderFactory().<Object, RestException>newInstance(this.serializerAdapter())
                .register(204, new TypeToken<Object>() { }.getType())
                .register(403, new TypeToken<Void>() { }.getType())
                .register(404, new TypeToken<Void>() { }.getType())
                .build(response);
    }

    /**
     * Gets a paged list of attachment metadata.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;AttachmentModel&gt; object if successful.
     */
    public List<AttachmentModel> getAttachmentsByFilter() {
        return getAttachmentsByFilterWithServiceResponseAsync().toBlocking().single().body();
    }

    /**
     * Gets a paged list of attachment metadata.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<AttachmentModel>> getAttachmentsByFilterAsync(final ServiceCallback<List<AttachmentModel>> serviceCallback) {
        return ServiceFuture.fromResponse(getAttachmentsByFilterWithServiceResponseAsync(), serviceCallback);
    }

    /**
     * Gets a paged list of attachment metadata.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;AttachmentModel&gt; object
     */
    public Observable<List<AttachmentModel>> getAttachmentsByFilterAsync() {
        return getAttachmentsByFilterWithServiceResponseAsync().map(new Func1<ServiceResponse<List<AttachmentModel>>, List<AttachmentModel>>() {
            @Override
            public List<AttachmentModel> call(ServiceResponse<List<AttachmentModel>> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets a paged list of attachment metadata.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;AttachmentModel&gt; object
     */
    public Observable<ServiceResponse<List<AttachmentModel>>> getAttachmentsByFilterWithServiceResponseAsync() {
        final String type = null;
        final String extension = null;
        final Long minSize = null;
        final Long maxSize = null;
        final Integer acl = null;
        final Integer entityID = null;
        final Integer drawerID = null;
        final String name = null;
        final Integer creatorUserID = null;
        final Integer modifierUserID = null;
        final DateTime minInsertionTime = null;
        final DateTime maxInsertionTime = null;
        final DateTime minModificationTime = null;
        final DateTime maxModificationTime = null;
        final Integer page = null;
        final Integer pageSize = null;
        final String sortOrder = null;
        final String sortBy = null;
        return service.getAttachmentsByFilter(type, extension, minSize, maxSize, acl, entityID, drawerID, name, creatorUserID, modifierUserID, minInsertionTime, maxInsertionTime, minModificationTime, maxModificationTime, page, pageSize, sortOrder, sortBy)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<AttachmentModel>>>>() {
                @Override
                public Observable<ServiceResponse<List<AttachmentModel>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<AttachmentModel>> clientResponse = getAttachmentsByFilterDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Gets a paged list of attachment metadata.
     *
     * @param type Gets or sets the type. Possible values include: 'Standard', 'EntityLink', 'WebLink'
     * @param extension Gets or sets the extension.
     * @param minSize Gets or sets the minimum size.
     * @param maxSize Gets or sets the maximum size.
     * @param acl Gets or sets the access control list.
     * @param entityID Gets or sets the entity identifier.
     * @param drawerID Gets or sets the drawer identifier.
     * @param name Gets or sets the name.
     * @param creatorUserID Gets or sets the creator user identifier.
     * @param modifierUserID Gets or sets the modifier user identifier.
     * @param minInsertionTime Gets or sets the minimum insertion time.
     * @param maxInsertionTime Gets or sets the maximum insertion time.
     * @param minModificationTime Gets or sets the minimum modification time.
     * @param maxModificationTime Gets or sets the maximum modification time.
     * @param page Gets or sets the page number.
     * @param pageSize Gets or sets the size of the page.
     * @param sortOrder Gets or sets the order. Possible values include: 'Unspecified', 'Ascending', 'Descending'
     * @param sortBy Gets or sets the column to order by. Possible values include: 'PageNumber', 'ID', 'Type', 'InsertionTime', 'ModificationTime', 'CrossReferenceID', 'SubType', 'Extension', 'Name'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;AttachmentModel&gt; object if successful.
     */
    public List<AttachmentModel> getAttachmentsByFilter(String type, String extension, Long minSize, Long maxSize, Integer acl, Integer entityID, Integer drawerID, String name, Integer creatorUserID, Integer modifierUserID, DateTime minInsertionTime, DateTime maxInsertionTime, DateTime minModificationTime, DateTime maxModificationTime, Integer page, Integer pageSize, String sortOrder, String sortBy) {
        return getAttachmentsByFilterWithServiceResponseAsync(type, extension, minSize, maxSize, acl, entityID, drawerID, name, creatorUserID, modifierUserID, minInsertionTime, maxInsertionTime, minModificationTime, maxModificationTime, page, pageSize, sortOrder, sortBy).toBlocking().single().body();
    }

    /**
     * Gets a paged list of attachment metadata.
     *
     * @param type Gets or sets the type. Possible values include: 'Standard', 'EntityLink', 'WebLink'
     * @param extension Gets or sets the extension.
     * @param minSize Gets or sets the minimum size.
     * @param maxSize Gets or sets the maximum size.
     * @param acl Gets or sets the access control list.
     * @param entityID Gets or sets the entity identifier.
     * @param drawerID Gets or sets the drawer identifier.
     * @param name Gets or sets the name.
     * @param creatorUserID Gets or sets the creator user identifier.
     * @param modifierUserID Gets or sets the modifier user identifier.
     * @param minInsertionTime Gets or sets the minimum insertion time.
     * @param maxInsertionTime Gets or sets the maximum insertion time.
     * @param minModificationTime Gets or sets the minimum modification time.
     * @param maxModificationTime Gets or sets the maximum modification time.
     * @param page Gets or sets the page number.
     * @param pageSize Gets or sets the size of the page.
     * @param sortOrder Gets or sets the order. Possible values include: 'Unspecified', 'Ascending', 'Descending'
     * @param sortBy Gets or sets the column to order by. Possible values include: 'PageNumber', 'ID', 'Type', 'InsertionTime', 'ModificationTime', 'CrossReferenceID', 'SubType', 'Extension', 'Name'
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<AttachmentModel>> getAttachmentsByFilterAsync(String type, String extension, Long minSize, Long maxSize, Integer acl, Integer entityID, Integer drawerID, String name, Integer creatorUserID, Integer modifierUserID, DateTime minInsertionTime, DateTime maxInsertionTime, DateTime minModificationTime, DateTime maxModificationTime, Integer page, Integer pageSize, String sortOrder, String sortBy, final ServiceCallback<List<AttachmentModel>> serviceCallback) {
        return ServiceFuture.fromResponse(getAttachmentsByFilterWithServiceResponseAsync(type, extension, minSize, maxSize, acl, entityID, drawerID, name, creatorUserID, modifierUserID, minInsertionTime, maxInsertionTime, minModificationTime, maxModificationTime, page, pageSize, sortOrder, sortBy), serviceCallback);
    }

    /**
     * Gets a paged list of attachment metadata.
     *
     * @param type Gets or sets the type. Possible values include: 'Standard', 'EntityLink', 'WebLink'
     * @param extension Gets or sets the extension.
     * @param minSize Gets or sets the minimum size.
     * @param maxSize Gets or sets the maximum size.
     * @param acl Gets or sets the access control list.
     * @param entityID Gets or sets the entity identifier.
     * @param drawerID Gets or sets the drawer identifier.
     * @param name Gets or sets the name.
     * @param creatorUserID Gets or sets the creator user identifier.
     * @param modifierUserID Gets or sets the modifier user identifier.
     * @param minInsertionTime Gets or sets the minimum insertion time.
     * @param maxInsertionTime Gets or sets the maximum insertion time.
     * @param minModificationTime Gets or sets the minimum modification time.
     * @param maxModificationTime Gets or sets the maximum modification time.
     * @param page Gets or sets the page number.
     * @param pageSize Gets or sets the size of the page.
     * @param sortOrder Gets or sets the order. Possible values include: 'Unspecified', 'Ascending', 'Descending'
     * @param sortBy Gets or sets the column to order by. Possible values include: 'PageNumber', 'ID', 'Type', 'InsertionTime', 'ModificationTime', 'CrossReferenceID', 'SubType', 'Extension', 'Name'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;AttachmentModel&gt; object
     */
    public Observable<List<AttachmentModel>> getAttachmentsByFilterAsync(String type, String extension, Long minSize, Long maxSize, Integer acl, Integer entityID, Integer drawerID, String name, Integer creatorUserID, Integer modifierUserID, DateTime minInsertionTime, DateTime maxInsertionTime, DateTime minModificationTime, DateTime maxModificationTime, Integer page, Integer pageSize, String sortOrder, String sortBy) {
        return getAttachmentsByFilterWithServiceResponseAsync(type, extension, minSize, maxSize, acl, entityID, drawerID, name, creatorUserID, modifierUserID, minInsertionTime, maxInsertionTime, minModificationTime, maxModificationTime, page, pageSize, sortOrder, sortBy).map(new Func1<ServiceResponse<List<AttachmentModel>>, List<AttachmentModel>>() {
            @Override
            public List<AttachmentModel> call(ServiceResponse<List<AttachmentModel>> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets a paged list of attachment metadata.
     *
     * @param type Gets or sets the type. Possible values include: 'Standard', 'EntityLink', 'WebLink'
     * @param extension Gets or sets the extension.
     * @param minSize Gets or sets the minimum size.
     * @param maxSize Gets or sets the maximum size.
     * @param acl Gets or sets the access control list.
     * @param entityID Gets or sets the entity identifier.
     * @param drawerID Gets or sets the drawer identifier.
     * @param name Gets or sets the name.
     * @param creatorUserID Gets or sets the creator user identifier.
     * @param modifierUserID Gets or sets the modifier user identifier.
     * @param minInsertionTime Gets or sets the minimum insertion time.
     * @param maxInsertionTime Gets or sets the maximum insertion time.
     * @param minModificationTime Gets or sets the minimum modification time.
     * @param maxModificationTime Gets or sets the maximum modification time.
     * @param page Gets or sets the page number.
     * @param pageSize Gets or sets the size of the page.
     * @param sortOrder Gets or sets the order. Possible values include: 'Unspecified', 'Ascending', 'Descending'
     * @param sortBy Gets or sets the column to order by. Possible values include: 'PageNumber', 'ID', 'Type', 'InsertionTime', 'ModificationTime', 'CrossReferenceID', 'SubType', 'Extension', 'Name'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;AttachmentModel&gt; object
     */
    public Observable<ServiceResponse<List<AttachmentModel>>> getAttachmentsByFilterWithServiceResponseAsync(String type, String extension, Long minSize, Long maxSize, Integer acl, Integer entityID, Integer drawerID, String name, Integer creatorUserID, Integer modifierUserID, DateTime minInsertionTime, DateTime maxInsertionTime, DateTime minModificationTime, DateTime maxModificationTime, Integer page, Integer pageSize, String sortOrder, String sortBy) {
        return service.getAttachmentsByFilter(type, extension, minSize, maxSize, acl, entityID, drawerID, name, creatorUserID, modifierUserID, minInsertionTime, maxInsertionTime, minModificationTime, maxModificationTime, page, pageSize, sortOrder, sortBy)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<AttachmentModel>>>>() {
                @Override
                public Observable<ServiceResponse<List<AttachmentModel>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<AttachmentModel>> clientResponse = getAttachmentsByFilterDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<List<AttachmentModel>> getAttachmentsByFilterDelegate(Response<ResponseBody> response) throws RestException, IOException {
        return this.restClient().responseBuilderFactory().<List<AttachmentModel>, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<List<AttachmentModel>>() { }.getType())
                .build(response);
    }

    /**
     * Gets a single attachment metadata based on its unique identifier.
     *
     * @param drawer The drawer identifier.
     * @param id The attachment identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the AttachmentModel object if successful.
     */
    public AttachmentModel getAttachmentById(int drawer, int id) {
        return getAttachmentByIdWithServiceResponseAsync(drawer, id).toBlocking().single().body();
    }

    /**
     * Gets a single attachment metadata based on its unique identifier.
     *
     * @param drawer The drawer identifier.
     * @param id The attachment identifier.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<AttachmentModel> getAttachmentByIdAsync(int drawer, int id, final ServiceCallback<AttachmentModel> serviceCallback) {
        return ServiceFuture.fromResponse(getAttachmentByIdWithServiceResponseAsync(drawer, id), serviceCallback);
    }

    /**
     * Gets a single attachment metadata based on its unique identifier.
     *
     * @param drawer The drawer identifier.
     * @param id The attachment identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the AttachmentModel object
     */
    public Observable<AttachmentModel> getAttachmentByIdAsync(int drawer, int id) {
        return getAttachmentByIdWithServiceResponseAsync(drawer, id).map(new Func1<ServiceResponse<AttachmentModel>, AttachmentModel>() {
            @Override
            public AttachmentModel call(ServiceResponse<AttachmentModel> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets a single attachment metadata based on its unique identifier.
     *
     * @param drawer The drawer identifier.
     * @param id The attachment identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the AttachmentModel object
     */
    public Observable<ServiceResponse<AttachmentModel>> getAttachmentByIdWithServiceResponseAsync(int drawer, int id) {
        return service.getAttachmentById(drawer, id)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<AttachmentModel>>>() {
                @Override
                public Observable<ServiceResponse<AttachmentModel>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<AttachmentModel> clientResponse = getAttachmentByIdDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<AttachmentModel> getAttachmentByIdDelegate(Response<ResponseBody> response) throws RestException, IOException {
        return this.restClient().responseBuilderFactory().<AttachmentModel, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<AttachmentModel>() { }.getType())
                .register(404, new TypeToken<Void>() { }.getType())
                .build(response);
    }

    /**
     * Updates a specified attachment's metadata..
     *
     * @param drawer The drawer identifier.
     * @param id The attachment identifier.
     * @param model The model.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object updateAttachment(int drawer, int id, UpdateAttachmentRequestModel model) {
        return updateAttachmentWithServiceResponseAsync(drawer, id, model).toBlocking().single().body();
    }

    /**
     * Updates a specified attachment's metadata..
     *
     * @param drawer The drawer identifier.
     * @param id The attachment identifier.
     * @param model The model.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> updateAttachmentAsync(int drawer, int id, UpdateAttachmentRequestModel model, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromResponse(updateAttachmentWithServiceResponseAsync(drawer, id, model), serviceCallback);
    }

    /**
     * Updates a specified attachment's metadata..
     *
     * @param drawer The drawer identifier.
     * @param id The attachment identifier.
     * @param model The model.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> updateAttachmentAsync(int drawer, int id, UpdateAttachmentRequestModel model) {
        return updateAttachmentWithServiceResponseAsync(drawer, id, model).map(new Func1<ServiceResponse<Object>, Object>() {
            @Override
            public Object call(ServiceResponse<Object> response) {
                return response.body();
            }
        });
    }

    /**
     * Updates a specified attachment's metadata..
     *
     * @param drawer The drawer identifier.
     * @param id The attachment identifier.
     * @param model The model.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> updateAttachmentWithServiceResponseAsync(int drawer, int id, UpdateAttachmentRequestModel model) {
        if (model == null) {
            throw new IllegalArgumentException("Parameter model is required and cannot be null.");
        }
        Validator.validate(model);
        return service.updateAttachment(drawer, id, model)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = updateAttachmentDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Object> updateAttachmentDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<Object, RestException>newInstance(this.serializerAdapter())
                .register(204, new TypeToken<Object>() { }.getType())
                .register(403, new TypeToken<Void>() { }.getType())
                .register(404, new TypeToken<Void>() { }.getType())
                .build(response);
    }

    /**
     * Deletes an attachment.
     *
     * @param drawer The drawer identifier.
     * @param id The attachment identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object deleteAttachment(int drawer, int id) {
        return deleteAttachmentWithServiceResponseAsync(drawer, id).toBlocking().single().body();
    }

    /**
     * Deletes an attachment.
     *
     * @param drawer The drawer identifier.
     * @param id The attachment identifier.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> deleteAttachmentAsync(int drawer, int id, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromResponse(deleteAttachmentWithServiceResponseAsync(drawer, id), serviceCallback);
    }

    /**
     * Deletes an attachment.
     *
     * @param drawer The drawer identifier.
     * @param id The attachment identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> deleteAttachmentAsync(int drawer, int id) {
        return deleteAttachmentWithServiceResponseAsync(drawer, id).map(new Func1<ServiceResponse<Object>, Object>() {
            @Override
            public Object call(ServiceResponse<Object> response) {
                return response.body();
            }
        });
    }

    /**
     * Deletes an attachment.
     *
     * @param drawer The drawer identifier.
     * @param id The attachment identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> deleteAttachmentWithServiceResponseAsync(int drawer, int id) {
        return service.deleteAttachment(drawer, id)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = deleteAttachmentDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Object> deleteAttachmentDelegate(Response<ResponseBody> response) throws RestException, IOException {
        return this.restClient().responseBuilderFactory().<Object, RestException>newInstance(this.serializerAdapter())
                .register(204, new TypeToken<Object>() { }.getType())
                .register(403, new TypeToken<Void>() { }.getType())
                .register(404, new TypeToken<Void>() { }.getType())
                .build(response);
    }

    /**
     * Gets an attachment's file content.
     *
     * @param drawer The drawer identifier.
     * @param id The attachment identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object getAttachmentFileContent(int drawer, int id) {
        return getAttachmentFileContentWithServiceResponseAsync(drawer, id).toBlocking().single().body();
    }

    /**
     * Gets an attachment's file content.
     *
     * @param drawer The drawer identifier.
     * @param id The attachment identifier.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> getAttachmentFileContentAsync(int drawer, int id, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromResponse(getAttachmentFileContentWithServiceResponseAsync(drawer, id), serviceCallback);
    }

    /**
     * Gets an attachment's file content.
     *
     * @param drawer The drawer identifier.
     * @param id The attachment identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> getAttachmentFileContentAsync(int drawer, int id) {
        return getAttachmentFileContentWithServiceResponseAsync(drawer, id).map(new Func1<ServiceResponse<Object>, Object>() {
            @Override
            public Object call(ServiceResponse<Object> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets an attachment's file content.
     *
     * @param drawer The drawer identifier.
     * @param id The attachment identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> getAttachmentFileContentWithServiceResponseAsync(int drawer, int id) {
        return service.getAttachmentFileContent(drawer, id)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = getAttachmentFileContentDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Object> getAttachmentFileContentDelegate(Response<ResponseBody> response) throws RestException, IOException {
        return this.restClient().responseBuilderFactory().<Object, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<Object>() { }.getType())
                .register(403, new TypeToken<Void>() { }.getType())
                .register(404, new TypeToken<Void>() { }.getType())
                .build(response);
    }

    /**
     * Inserts a new file attachment.
     *
     * @param drawer The drawer identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the AttachmentModel object if successful.
     */
    public AttachmentModel createAttachment(int drawer) {
        return createAttachmentWithServiceResponseAsync(drawer).toBlocking().single().body();
    }

    /**
     * Inserts a new file attachment.
     *
     * @param drawer The drawer identifier.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<AttachmentModel> createAttachmentAsync(int drawer, final ServiceCallback<AttachmentModel> serviceCallback) {
        return ServiceFuture.fromResponse(createAttachmentWithServiceResponseAsync(drawer), serviceCallback);
    }

    /**
     * Inserts a new file attachment.
     *
     * @param drawer The drawer identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the AttachmentModel object
     */
    public Observable<AttachmentModel> createAttachmentAsync(int drawer) {
        return createAttachmentWithServiceResponseAsync(drawer).map(new Func1<ServiceResponse<AttachmentModel>, AttachmentModel>() {
            @Override
            public AttachmentModel call(ServiceResponse<AttachmentModel> response) {
                return response.body();
            }
        });
    }

    /**
     * Inserts a new file attachment.
     *
     * @param drawer The drawer identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the AttachmentModel object
     */
    public Observable<ServiceResponse<AttachmentModel>> createAttachmentWithServiceResponseAsync(int drawer) {
        return service.createAttachment(drawer)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<AttachmentModel>>>() {
                @Override
                public Observable<ServiceResponse<AttachmentModel>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<AttachmentModel> clientResponse = createAttachmentDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<AttachmentModel> createAttachmentDelegate(Response<ResponseBody> response) throws RestException, IOException {
        return this.restClient().responseBuilderFactory().<AttachmentModel, RestException>newInstance(this.serializerAdapter())
                .register(201, new TypeToken<AttachmentModel>() { }.getType())
                .register(400, new TypeToken<Void>() { }.getType())
                .register(403, new TypeToken<Void>() { }.getType())
                .register(404, new TypeToken<Void>() { }.getType())
                .build(response);
    }

    /**
     * Archives an attachment.
     *
     * @param drawer The drawer identifier.
     * @param id The attachment identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object archiveAttachment(int drawer, int id) {
        return archiveAttachmentWithServiceResponseAsync(drawer, id).toBlocking().single().body();
    }

    /**
     * Archives an attachment.
     *
     * @param drawer The drawer identifier.
     * @param id The attachment identifier.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> archiveAttachmentAsync(int drawer, int id, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromResponse(archiveAttachmentWithServiceResponseAsync(drawer, id), serviceCallback);
    }

    /**
     * Archives an attachment.
     *
     * @param drawer The drawer identifier.
     * @param id The attachment identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> archiveAttachmentAsync(int drawer, int id) {
        return archiveAttachmentWithServiceResponseAsync(drawer, id).map(new Func1<ServiceResponse<Object>, Object>() {
            @Override
            public Object call(ServiceResponse<Object> response) {
                return response.body();
            }
        });
    }

    /**
     * Archives an attachment.
     *
     * @param drawer The drawer identifier.
     * @param id The attachment identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> archiveAttachmentWithServiceResponseAsync(int drawer, int id) {
        return service.archiveAttachment(drawer, id)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = archiveAttachmentDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Object> archiveAttachmentDelegate(Response<ResponseBody> response) throws RestException, IOException {
        return this.restClient().responseBuilderFactory().<Object, RestException>newInstance(this.serializerAdapter())
                .register(204, new TypeToken<Object>() { }.getType())
                .register(400, new TypeToken<Void>() { }.getType())
                .register(403, new TypeToken<Void>() { }.getType())
                .register(404, new TypeToken<Void>() { }.getType())
                .build(response);
    }

    /**
     * Gets the paged list of attachment versions.
     *
     * @param drawer The drawer identifier.
     * @param id The attachment identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;AttachmentVersionModel&gt; object if successful.
     */
    public List<AttachmentVersionModel> getAttachmentVersionsByFilter(int drawer, int id) {
        return getAttachmentVersionsByFilterWithServiceResponseAsync(drawer, id).toBlocking().single().body();
    }

    /**
     * Gets the paged list of attachment versions.
     *
     * @param drawer The drawer identifier.
     * @param id The attachment identifier.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<AttachmentVersionModel>> getAttachmentVersionsByFilterAsync(int drawer, int id, final ServiceCallback<List<AttachmentVersionModel>> serviceCallback) {
        return ServiceFuture.fromResponse(getAttachmentVersionsByFilterWithServiceResponseAsync(drawer, id), serviceCallback);
    }

    /**
     * Gets the paged list of attachment versions.
     *
     * @param drawer The drawer identifier.
     * @param id The attachment identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;AttachmentVersionModel&gt; object
     */
    public Observable<List<AttachmentVersionModel>> getAttachmentVersionsByFilterAsync(int drawer, int id) {
        return getAttachmentVersionsByFilterWithServiceResponseAsync(drawer, id).map(new Func1<ServiceResponse<List<AttachmentVersionModel>>, List<AttachmentVersionModel>>() {
            @Override
            public List<AttachmentVersionModel> call(ServiceResponse<List<AttachmentVersionModel>> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets the paged list of attachment versions.
     *
     * @param drawer The drawer identifier.
     * @param id The attachment identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;AttachmentVersionModel&gt; object
     */
    public Observable<ServiceResponse<List<AttachmentVersionModel>>> getAttachmentVersionsByFilterWithServiceResponseAsync(int drawer, int id) {
        final Integer version = null;
        final Integer creatorUserID = null;
        final Integer accessorUserID = null;
        final DateTime minAccessTime = null;
        final DateTime maxAccessTime = null;
        final DateTime minCreationTime = null;
        final DateTime maxCreationTime = null;
        final DateTime minModificationTime = null;
        final DateTime maxModificationTime = null;
        final Integer page = null;
        final Integer pageSize = null;
        final String sortOrder = null;
        final String sortBy = null;
        return service.getAttachmentVersionsByFilter(drawer, id, version, creatorUserID, accessorUserID, minAccessTime, maxAccessTime, minCreationTime, maxCreationTime, minModificationTime, maxModificationTime, page, pageSize, sortOrder, sortBy)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<AttachmentVersionModel>>>>() {
                @Override
                public Observable<ServiceResponse<List<AttachmentVersionModel>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<AttachmentVersionModel>> clientResponse = getAttachmentVersionsByFilterDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Gets the paged list of attachment versions.
     *
     * @param drawer The drawer identifier.
     * @param id The attachment identifier.
     * @param version Gets or sets the indexed version value.
     * @param creatorUserID Gets or sets the creator identifier.
     * @param accessorUserID Gets or sets the identifier of the user who accessed the attachment version.
     * @param minAccessTime Gets or sets the min time the version was last accessed.
     * @param maxAccessTime Gets or sets the max time the version was last accessed.
     * @param minCreationTime Gets or sets the min creation time of the attachment version.
     * @param maxCreationTime Gets or sets the max creation time of the attachment version.
     * @param minModificationTime Gets or sets the min modification time of the attachment version.
     * @param maxModificationTime Gets or sets the max modification time of the attachment version.
     * @param page Gets or sets the page number.
     * @param pageSize Gets or sets the size of the page.
     * @param sortOrder Gets or sets the order. Possible values include: 'Unspecified', 'Ascending', 'Descending'
     * @param sortBy Gets or sets the column to order by. Possible values include: 'Version', 'CreatorUserID', 'AccessorUserID', 'AccessTime', 'CreationTime', 'ModificationTime'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;AttachmentVersionModel&gt; object if successful.
     */
    public List<AttachmentVersionModel> getAttachmentVersionsByFilter(int drawer, int id, Integer version, Integer creatorUserID, Integer accessorUserID, DateTime minAccessTime, DateTime maxAccessTime, DateTime minCreationTime, DateTime maxCreationTime, DateTime minModificationTime, DateTime maxModificationTime, Integer page, Integer pageSize, String sortOrder, String sortBy) {
        return getAttachmentVersionsByFilterWithServiceResponseAsync(drawer, id, version, creatorUserID, accessorUserID, minAccessTime, maxAccessTime, minCreationTime, maxCreationTime, minModificationTime, maxModificationTime, page, pageSize, sortOrder, sortBy).toBlocking().single().body();
    }

    /**
     * Gets the paged list of attachment versions.
     *
     * @param drawer The drawer identifier.
     * @param id The attachment identifier.
     * @param version Gets or sets the indexed version value.
     * @param creatorUserID Gets or sets the creator identifier.
     * @param accessorUserID Gets or sets the identifier of the user who accessed the attachment version.
     * @param minAccessTime Gets or sets the min time the version was last accessed.
     * @param maxAccessTime Gets or sets the max time the version was last accessed.
     * @param minCreationTime Gets or sets the min creation time of the attachment version.
     * @param maxCreationTime Gets or sets the max creation time of the attachment version.
     * @param minModificationTime Gets or sets the min modification time of the attachment version.
     * @param maxModificationTime Gets or sets the max modification time of the attachment version.
     * @param page Gets or sets the page number.
     * @param pageSize Gets or sets the size of the page.
     * @param sortOrder Gets or sets the order. Possible values include: 'Unspecified', 'Ascending', 'Descending'
     * @param sortBy Gets or sets the column to order by. Possible values include: 'Version', 'CreatorUserID', 'AccessorUserID', 'AccessTime', 'CreationTime', 'ModificationTime'
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<AttachmentVersionModel>> getAttachmentVersionsByFilterAsync(int drawer, int id, Integer version, Integer creatorUserID, Integer accessorUserID, DateTime minAccessTime, DateTime maxAccessTime, DateTime minCreationTime, DateTime maxCreationTime, DateTime minModificationTime, DateTime maxModificationTime, Integer page, Integer pageSize, String sortOrder, String sortBy, final ServiceCallback<List<AttachmentVersionModel>> serviceCallback) {
        return ServiceFuture.fromResponse(getAttachmentVersionsByFilterWithServiceResponseAsync(drawer, id, version, creatorUserID, accessorUserID, minAccessTime, maxAccessTime, minCreationTime, maxCreationTime, minModificationTime, maxModificationTime, page, pageSize, sortOrder, sortBy), serviceCallback);
    }

    /**
     * Gets the paged list of attachment versions.
     *
     * @param drawer The drawer identifier.
     * @param id The attachment identifier.
     * @param version Gets or sets the indexed version value.
     * @param creatorUserID Gets or sets the creator identifier.
     * @param accessorUserID Gets or sets the identifier of the user who accessed the attachment version.
     * @param minAccessTime Gets or sets the min time the version was last accessed.
     * @param maxAccessTime Gets or sets the max time the version was last accessed.
     * @param minCreationTime Gets or sets the min creation time of the attachment version.
     * @param maxCreationTime Gets or sets the max creation time of the attachment version.
     * @param minModificationTime Gets or sets the min modification time of the attachment version.
     * @param maxModificationTime Gets or sets the max modification time of the attachment version.
     * @param page Gets or sets the page number.
     * @param pageSize Gets or sets the size of the page.
     * @param sortOrder Gets or sets the order. Possible values include: 'Unspecified', 'Ascending', 'Descending'
     * @param sortBy Gets or sets the column to order by. Possible values include: 'Version', 'CreatorUserID', 'AccessorUserID', 'AccessTime', 'CreationTime', 'ModificationTime'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;AttachmentVersionModel&gt; object
     */
    public Observable<List<AttachmentVersionModel>> getAttachmentVersionsByFilterAsync(int drawer, int id, Integer version, Integer creatorUserID, Integer accessorUserID, DateTime minAccessTime, DateTime maxAccessTime, DateTime minCreationTime, DateTime maxCreationTime, DateTime minModificationTime, DateTime maxModificationTime, Integer page, Integer pageSize, String sortOrder, String sortBy) {
        return getAttachmentVersionsByFilterWithServiceResponseAsync(drawer, id, version, creatorUserID, accessorUserID, minAccessTime, maxAccessTime, minCreationTime, maxCreationTime, minModificationTime, maxModificationTime, page, pageSize, sortOrder, sortBy).map(new Func1<ServiceResponse<List<AttachmentVersionModel>>, List<AttachmentVersionModel>>() {
            @Override
            public List<AttachmentVersionModel> call(ServiceResponse<List<AttachmentVersionModel>> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets the paged list of attachment versions.
     *
     * @param drawer The drawer identifier.
     * @param id The attachment identifier.
     * @param version Gets or sets the indexed version value.
     * @param creatorUserID Gets or sets the creator identifier.
     * @param accessorUserID Gets or sets the identifier of the user who accessed the attachment version.
     * @param minAccessTime Gets or sets the min time the version was last accessed.
     * @param maxAccessTime Gets or sets the max time the version was last accessed.
     * @param minCreationTime Gets or sets the min creation time of the attachment version.
     * @param maxCreationTime Gets or sets the max creation time of the attachment version.
     * @param minModificationTime Gets or sets the min modification time of the attachment version.
     * @param maxModificationTime Gets or sets the max modification time of the attachment version.
     * @param page Gets or sets the page number.
     * @param pageSize Gets or sets the size of the page.
     * @param sortOrder Gets or sets the order. Possible values include: 'Unspecified', 'Ascending', 'Descending'
     * @param sortBy Gets or sets the column to order by. Possible values include: 'Version', 'CreatorUserID', 'AccessorUserID', 'AccessTime', 'CreationTime', 'ModificationTime'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;AttachmentVersionModel&gt; object
     */
    public Observable<ServiceResponse<List<AttachmentVersionModel>>> getAttachmentVersionsByFilterWithServiceResponseAsync(int drawer, int id, Integer version, Integer creatorUserID, Integer accessorUserID, DateTime minAccessTime, DateTime maxAccessTime, DateTime minCreationTime, DateTime maxCreationTime, DateTime minModificationTime, DateTime maxModificationTime, Integer page, Integer pageSize, String sortOrder, String sortBy) {
        return service.getAttachmentVersionsByFilter(drawer, id, version, creatorUserID, accessorUserID, minAccessTime, maxAccessTime, minCreationTime, maxCreationTime, minModificationTime, maxModificationTime, page, pageSize, sortOrder, sortBy)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<AttachmentVersionModel>>>>() {
                @Override
                public Observable<ServiceResponse<List<AttachmentVersionModel>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<AttachmentVersionModel>> clientResponse = getAttachmentVersionsByFilterDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<List<AttachmentVersionModel>> getAttachmentVersionsByFilterDelegate(Response<ResponseBody> response) throws RestException, IOException {
        return this.restClient().responseBuilderFactory().<List<AttachmentVersionModel>, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<List<AttachmentVersionModel>>() { }.getType())
                .register(404, new TypeToken<Void>() { }.getType())
                .build(response);
    }

    /**
     * Gets a file for a specified attachment version.
     *
     * @param drawer The drawer identifier.
     * @param id The attachment identifier.
     * @param versionID The version identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object getAttachmentVersionFileContent(int drawer, int id, int versionID) {
        return getAttachmentVersionFileContentWithServiceResponseAsync(drawer, id, versionID).toBlocking().single().body();
    }

    /**
     * Gets a file for a specified attachment version.
     *
     * @param drawer The drawer identifier.
     * @param id The attachment identifier.
     * @param versionID The version identifier.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> getAttachmentVersionFileContentAsync(int drawer, int id, int versionID, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromResponse(getAttachmentVersionFileContentWithServiceResponseAsync(drawer, id, versionID), serviceCallback);
    }

    /**
     * Gets a file for a specified attachment version.
     *
     * @param drawer The drawer identifier.
     * @param id The attachment identifier.
     * @param versionID The version identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> getAttachmentVersionFileContentAsync(int drawer, int id, int versionID) {
        return getAttachmentVersionFileContentWithServiceResponseAsync(drawer, id, versionID).map(new Func1<ServiceResponse<Object>, Object>() {
            @Override
            public Object call(ServiceResponse<Object> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets a file for a specified attachment version.
     *
     * @param drawer The drawer identifier.
     * @param id The attachment identifier.
     * @param versionID The version identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> getAttachmentVersionFileContentWithServiceResponseAsync(int drawer, int id, int versionID) {
        return service.getAttachmentVersionFileContent(drawer, id, versionID)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = getAttachmentVersionFileContentDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Object> getAttachmentVersionFileContentDelegate(Response<ResponseBody> response) throws RestException, IOException {
        return this.restClient().responseBuilderFactory().<Object, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<Object>() { }.getType())
                .register(403, new TypeToken<Void>() { }.getType())
                .register(404, new TypeToken<Void>() { }.getType())
                .build(response);
    }

    /**
     * Checks out the attachment file.
     *
     * @param drawer The drawer identifier.
     * @param id The attachment identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object checkOutAttachment(int drawer, int id) {
        return checkOutAttachmentWithServiceResponseAsync(drawer, id).toBlocking().single().body();
    }

    /**
     * Checks out the attachment file.
     *
     * @param drawer The drawer identifier.
     * @param id The attachment identifier.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> checkOutAttachmentAsync(int drawer, int id, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromResponse(checkOutAttachmentWithServiceResponseAsync(drawer, id), serviceCallback);
    }

    /**
     * Checks out the attachment file.
     *
     * @param drawer The drawer identifier.
     * @param id The attachment identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> checkOutAttachmentAsync(int drawer, int id) {
        return checkOutAttachmentWithServiceResponseAsync(drawer, id).map(new Func1<ServiceResponse<Object>, Object>() {
            @Override
            public Object call(ServiceResponse<Object> response) {
                return response.body();
            }
        });
    }

    /**
     * Checks out the attachment file.
     *
     * @param drawer The drawer identifier.
     * @param id The attachment identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> checkOutAttachmentWithServiceResponseAsync(int drawer, int id) {
        return service.checkOutAttachment(drawer, id)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = checkOutAttachmentDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Object> checkOutAttachmentDelegate(Response<ResponseBody> response) throws RestException, IOException {
        return this.restClient().responseBuilderFactory().<Object, RestException>newInstance(this.serializerAdapter())
                .register(204, new TypeToken<Object>() { }.getType())
                .register(400, new TypeToken<Void>() { }.getType())
                .register(403, new TypeToken<Void>() { }.getType())
                .register(404, new TypeToken<Void>() { }.getType())
                .build(response);
    }

    /**
     * Undoes the attachment check out of the attachment file.
     *
     * @param drawer The drawer identifier.
     * @param id The attachment identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object undoCheckOutAttachment(int drawer, int id) {
        return undoCheckOutAttachmentWithServiceResponseAsync(drawer, id).toBlocking().single().body();
    }

    /**
     * Undoes the attachment check out of the attachment file.
     *
     * @param drawer The drawer identifier.
     * @param id The attachment identifier.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> undoCheckOutAttachmentAsync(int drawer, int id, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromResponse(undoCheckOutAttachmentWithServiceResponseAsync(drawer, id), serviceCallback);
    }

    /**
     * Undoes the attachment check out of the attachment file.
     *
     * @param drawer The drawer identifier.
     * @param id The attachment identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> undoCheckOutAttachmentAsync(int drawer, int id) {
        return undoCheckOutAttachmentWithServiceResponseAsync(drawer, id).map(new Func1<ServiceResponse<Object>, Object>() {
            @Override
            public Object call(ServiceResponse<Object> response) {
                return response.body();
            }
        });
    }

    /**
     * Undoes the attachment check out of the attachment file.
     *
     * @param drawer The drawer identifier.
     * @param id The attachment identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> undoCheckOutAttachmentWithServiceResponseAsync(int drawer, int id) {
        return service.undoCheckOutAttachment(drawer, id)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = undoCheckOutAttachmentDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Object> undoCheckOutAttachmentDelegate(Response<ResponseBody> response) throws RestException, IOException {
        return this.restClient().responseBuilderFactory().<Object, RestException>newInstance(this.serializerAdapter())
                .register(204, new TypeToken<Object>() { }.getType())
                .register(400, new TypeToken<Void>() { }.getType())
                .register(403, new TypeToken<Void>() { }.getType())
                .register(404, new TypeToken<Void>() { }.getType())
                .build(response);
    }

    /**
     * Checks in the new version of attachment file.
     *
     * @param drawer The drawer identifier.
     * @param id The attachment identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object checkInAttachment(int drawer, int id) {
        return checkInAttachmentWithServiceResponseAsync(drawer, id).toBlocking().single().body();
    }

    /**
     * Checks in the new version of attachment file.
     *
     * @param drawer The drawer identifier.
     * @param id The attachment identifier.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> checkInAttachmentAsync(int drawer, int id, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromResponse(checkInAttachmentWithServiceResponseAsync(drawer, id), serviceCallback);
    }

    /**
     * Checks in the new version of attachment file.
     *
     * @param drawer The drawer identifier.
     * @param id The attachment identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> checkInAttachmentAsync(int drawer, int id) {
        return checkInAttachmentWithServiceResponseAsync(drawer, id).map(new Func1<ServiceResponse<Object>, Object>() {
            @Override
            public Object call(ServiceResponse<Object> response) {
                return response.body();
            }
        });
    }

    /**
     * Checks in the new version of attachment file.
     *
     * @param drawer The drawer identifier.
     * @param id The attachment identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> checkInAttachmentWithServiceResponseAsync(int drawer, int id) {
        return service.checkInAttachment(drawer, id)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = checkInAttachmentDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Object> checkInAttachmentDelegate(Response<ResponseBody> response) throws RestException, IOException {
        return this.restClient().responseBuilderFactory().<Object, RestException>newInstance(this.serializerAdapter())
                .register(204, new TypeToken<Object>() { }.getType())
                .register(400, new TypeToken<Void>() { }.getType())
                .register(403, new TypeToken<Void>() { }.getType())
                .register(404, new TypeToken<Void>() { }.getType())
                .build(response);
    }

    /**
     * Rolls back to a specified version the attachment file.
     *
     * @param drawer The drawer identifier.
     * @param id The attachment identifier.
     * @param versionID The version identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object rollbackAttachmentVersion(int drawer, int id, int versionID) {
        return rollbackAttachmentVersionWithServiceResponseAsync(drawer, id, versionID).toBlocking().single().body();
    }

    /**
     * Rolls back to a specified version the attachment file.
     *
     * @param drawer The drawer identifier.
     * @param id The attachment identifier.
     * @param versionID The version identifier.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> rollbackAttachmentVersionAsync(int drawer, int id, int versionID, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromResponse(rollbackAttachmentVersionWithServiceResponseAsync(drawer, id, versionID), serviceCallback);
    }

    /**
     * Rolls back to a specified version the attachment file.
     *
     * @param drawer The drawer identifier.
     * @param id The attachment identifier.
     * @param versionID The version identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> rollbackAttachmentVersionAsync(int drawer, int id, int versionID) {
        return rollbackAttachmentVersionWithServiceResponseAsync(drawer, id, versionID).map(new Func1<ServiceResponse<Object>, Object>() {
            @Override
            public Object call(ServiceResponse<Object> response) {
                return response.body();
            }
        });
    }

    /**
     * Rolls back to a specified version the attachment file.
     *
     * @param drawer The drawer identifier.
     * @param id The attachment identifier.
     * @param versionID The version identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> rollbackAttachmentVersionWithServiceResponseAsync(int drawer, int id, int versionID) {
        return service.rollbackAttachmentVersion(drawer, id, versionID)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = rollbackAttachmentVersionDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Object> rollbackAttachmentVersionDelegate(Response<ResponseBody> response) throws RestException, IOException {
        return this.restClient().responseBuilderFactory().<Object, RestException>newInstance(this.serializerAdapter())
                .register(204, new TypeToken<Object>() { }.getType())
                .register(400, new TypeToken<Void>() { }.getType())
                .register(403, new TypeToken<Void>() { }.getType())
                .register(404, new TypeToken<Void>() { }.getType())
                .build(response);
    }

    /**
     * Gets a list of all available drawers.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;DrawerModel&gt; object if successful.
     */
    public List<DrawerModel> getAllDrawers() {
        return getAllDrawersWithServiceResponseAsync().toBlocking().single().body();
    }

    /**
     * Gets a list of all available drawers.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<DrawerModel>> getAllDrawersAsync(final ServiceCallback<List<DrawerModel>> serviceCallback) {
        return ServiceFuture.fromResponse(getAllDrawersWithServiceResponseAsync(), serviceCallback);
    }

    /**
     * Gets a list of all available drawers.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;DrawerModel&gt; object
     */
    public Observable<List<DrawerModel>> getAllDrawersAsync() {
        return getAllDrawersWithServiceResponseAsync().map(new Func1<ServiceResponse<List<DrawerModel>>, List<DrawerModel>>() {
            @Override
            public List<DrawerModel> call(ServiceResponse<List<DrawerModel>> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets a list of all available drawers.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;DrawerModel&gt; object
     */
    public Observable<ServiceResponse<List<DrawerModel>>> getAllDrawersWithServiceResponseAsync() {
        return service.getAllDrawers()
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<DrawerModel>>>>() {
                @Override
                public Observable<ServiceResponse<List<DrawerModel>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<DrawerModel>> clientResponse = getAllDrawersDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<List<DrawerModel>> getAllDrawersDelegate(Response<ResponseBody> response) throws RestException, IOException {
        return this.restClient().responseBuilderFactory().<List<DrawerModel>, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<List<DrawerModel>>() { }.getType())
                .build(response);
    }

    /**
     * Gets a single drawer by its unique identifier.
     *
     * @param id The drawer identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the DrawerModel object if successful.
     */
    public DrawerModel getDrawerById(int id) {
        return getDrawerByIdWithServiceResponseAsync(id).toBlocking().single().body();
    }

    /**
     * Gets a single drawer by its unique identifier.
     *
     * @param id The drawer identifier.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<DrawerModel> getDrawerByIdAsync(int id, final ServiceCallback<DrawerModel> serviceCallback) {
        return ServiceFuture.fromResponse(getDrawerByIdWithServiceResponseAsync(id), serviceCallback);
    }

    /**
     * Gets a single drawer by its unique identifier.
     *
     * @param id The drawer identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the DrawerModel object
     */
    public Observable<DrawerModel> getDrawerByIdAsync(int id) {
        return getDrawerByIdWithServiceResponseAsync(id).map(new Func1<ServiceResponse<DrawerModel>, DrawerModel>() {
            @Override
            public DrawerModel call(ServiceResponse<DrawerModel> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets a single drawer by its unique identifier.
     *
     * @param id The drawer identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the DrawerModel object
     */
    public Observable<ServiceResponse<DrawerModel>> getDrawerByIdWithServiceResponseAsync(int id) {
        return service.getDrawerById(id)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<DrawerModel>>>() {
                @Override
                public Observable<ServiceResponse<DrawerModel>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<DrawerModel> clientResponse = getDrawerByIdDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<DrawerModel> getDrawerByIdDelegate(Response<ResponseBody> response) throws RestException, IOException {
        return this.restClient().responseBuilderFactory().<DrawerModel, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<DrawerModel>() { }.getType())
                .register(404, new TypeToken<Void>() { }.getType())
                .build(response);
    }

    /**
     * Updates a specified drawer.
     *
     * @param id The drawer identifier.
     * @param model The model.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object updateDrawer(int id, DrawerBase model) {
        return updateDrawerWithServiceResponseAsync(id, model).toBlocking().single().body();
    }

    /**
     * Updates a specified drawer.
     *
     * @param id The drawer identifier.
     * @param model The model.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> updateDrawerAsync(int id, DrawerBase model, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromResponse(updateDrawerWithServiceResponseAsync(id, model), serviceCallback);
    }

    /**
     * Updates a specified drawer.
     *
     * @param id The drawer identifier.
     * @param model The model.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> updateDrawerAsync(int id, DrawerBase model) {
        return updateDrawerWithServiceResponseAsync(id, model).map(new Func1<ServiceResponse<Object>, Object>() {
            @Override
            public Object call(ServiceResponse<Object> response) {
                return response.body();
            }
        });
    }

    /**
     * Updates a specified drawer.
     *
     * @param id The drawer identifier.
     * @param model The model.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> updateDrawerWithServiceResponseAsync(int id, DrawerBase model) {
        if (model == null) {
            throw new IllegalArgumentException("Parameter model is required and cannot be null.");
        }
        Validator.validate(model);
        return service.updateDrawer(id, model)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = updateDrawerDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Object> updateDrawerDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<Object, RestException>newInstance(this.serializerAdapter())
                .register(204, new TypeToken<Object>() { }.getType())
                .register(403, new TypeToken<Void>() { }.getType())
                .register(404, new TypeToken<Void>() { }.getType())
                .build(response);
    }

    /**
     * Gets a single drawer by its name.
     *
     * @param name The drawer name.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the DrawerModel object if successful.
     */
    public DrawerModel getDrawerByName(String name) {
        return getDrawerByNameWithServiceResponseAsync(name).toBlocking().single().body();
    }

    /**
     * Gets a single drawer by its name.
     *
     * @param name The drawer name.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<DrawerModel> getDrawerByNameAsync(String name, final ServiceCallback<DrawerModel> serviceCallback) {
        return ServiceFuture.fromResponse(getDrawerByNameWithServiceResponseAsync(name), serviceCallback);
    }

    /**
     * Gets a single drawer by its name.
     *
     * @param name The drawer name.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the DrawerModel object
     */
    public Observable<DrawerModel> getDrawerByNameAsync(String name) {
        return getDrawerByNameWithServiceResponseAsync(name).map(new Func1<ServiceResponse<DrawerModel>, DrawerModel>() {
            @Override
            public DrawerModel call(ServiceResponse<DrawerModel> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets a single drawer by its name.
     *
     * @param name The drawer name.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the DrawerModel object
     */
    public Observable<ServiceResponse<DrawerModel>> getDrawerByNameWithServiceResponseAsync(String name) {
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        return service.getDrawerByName(name)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<DrawerModel>>>() {
                @Override
                public Observable<ServiceResponse<DrawerModel>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<DrawerModel> clientResponse = getDrawerByNameDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<DrawerModel> getDrawerByNameDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<DrawerModel, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<DrawerModel>() { }.getType())
                .register(404, new TypeToken<Void>() { }.getType())
                .build(response);
    }

    /**
     * Gets a paged list of entity summaries.
     *
     * @param drawerID Gets or sets the drawer identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;GetEntityBaseResponse&gt; object if successful.
     */
    public List<GetEntityBaseResponse> getEntitiesByFilter(int drawerID) {
        return getEntitiesByFilterWithServiceResponseAsync(drawerID).toBlocking().single().body();
    }

    /**
     * Gets a paged list of entity summaries.
     *
     * @param drawerID Gets or sets the drawer identifier.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<GetEntityBaseResponse>> getEntitiesByFilterAsync(int drawerID, final ServiceCallback<List<GetEntityBaseResponse>> serviceCallback) {
        return ServiceFuture.fromResponse(getEntitiesByFilterWithServiceResponseAsync(drawerID), serviceCallback);
    }

    /**
     * Gets a paged list of entity summaries.
     *
     * @param drawerID Gets or sets the drawer identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;GetEntityBaseResponse&gt; object
     */
    public Observable<List<GetEntityBaseResponse>> getEntitiesByFilterAsync(int drawerID) {
        return getEntitiesByFilterWithServiceResponseAsync(drawerID).map(new Func1<ServiceResponse<List<GetEntityBaseResponse>>, List<GetEntityBaseResponse>>() {
            @Override
            public List<GetEntityBaseResponse> call(ServiceResponse<List<GetEntityBaseResponse>> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets a paged list of entity summaries.
     *
     * @param drawerID Gets or sets the drawer identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;GetEntityBaseResponse&gt; object
     */
    public Observable<ServiceResponse<List<GetEntityBaseResponse>>> getEntitiesByFilterWithServiceResponseAsync(int drawerID) {
        final Integer acl = null;
        final Integer type = null;
        final String name = null;
        final String state = null;
        final Integer referenceCount = null;
        final Integer attachCount = null;
        final Integer noteCount = null;
        final Integer ownerUserID = null;
        final Integer ownerGroupID = null;
        final Integer creatorUserID = null;
        final Integer creatorGroupID = null;
        final Integer modifierUserID = null;
        final Integer modifierGroupID = null;
        final DateTime minCreationTime = null;
        final DateTime maxCreationTime = null;
        final DateTime minModificationTime = null;
        final DateTime maxModificationTime = null;
        final List<Object> metadata = null;
        final Integer page = null;
        final Integer pageSize = null;
        final String sortOrder = null;
        final String sortBy = null;
        String metadataConverted = this.serializerAdapter().serializeList(metadata, CollectionFormat.MULTI);
        return service.getEntitiesByFilter(drawerID, acl, type, name, state, referenceCount, attachCount, noteCount, ownerUserID, ownerGroupID, creatorUserID, creatorGroupID, modifierUserID, modifierGroupID, minCreationTime, maxCreationTime, minModificationTime, maxModificationTime, metadataConverted, page, pageSize, sortOrder, sortBy)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<GetEntityBaseResponse>>>>() {
                @Override
                public Observable<ServiceResponse<List<GetEntityBaseResponse>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<GetEntityBaseResponse>> clientResponse = getEntitiesByFilterDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Gets a paged list of entity summaries.
     *
     * @param drawerID Gets or sets the drawer identifier.
     * @param acl Gets or sets the access control list.
     * @param type Gets or sets the type of the entity.
     * @param name Gets or sets the name.
     * @param state Gets or sets the state. Possible values include: 'Undefined', 'Available', 'Locked', 'Suspended', 'Archived', 'Deleted', 'Canceled', 'Complete', 'Reviewed', 'ReviewedSuspended', 'ReviewedComplete', 'Rejected', 'RoutingSlipOpen', 'ReviewedRoutingSlipOpen'
     * @param referenceCount Gets or sets the reference count.
     * @param attachCount Gets or sets the attach count.
     * @param noteCount Gets or sets the note count.
     * @param ownerUserID Gets or sets the owner user identifier.
     * @param ownerGroupID Gets or sets the owner group identifier.
     * @param creatorUserID Gets or sets the creator user identifier.
     * @param creatorGroupID Gets or sets the creator group identifier.
     * @param modifierUserID Gets or sets the modifier user identifier.
     * @param modifierGroupID Gets or sets the modifier group identifier.
     * @param minCreationTime Gets or sets the minimum creation time.
     * @param maxCreationTime Gets or sets the maximum creation time.
     * @param minModificationTime Gets or sets the minimum modification time.
     * @param maxModificationTime Gets or sets the maximum modification time.
     * @param metadata Gets or sets the metadata.
     * @param page Gets or sets the page number.
     * @param pageSize Gets or sets the size of the page.
     * @param sortOrder Gets or sets the order. Possible values include: 'Unspecified', 'Ascending', 'Descending'
     * @param sortBy Gets or sets the column to order by. Possible values include: 'ID', 'Type', 'CreationTime', 'ModificationTime', 'State', 'Name'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;GetEntityBaseResponse&gt; object if successful.
     */
    public List<GetEntityBaseResponse> getEntitiesByFilter(int drawerID, Integer acl, Integer type, String name, String state, Integer referenceCount, Integer attachCount, Integer noteCount, Integer ownerUserID, Integer ownerGroupID, Integer creatorUserID, Integer creatorGroupID, Integer modifierUserID, Integer modifierGroupID, DateTime minCreationTime, DateTime maxCreationTime, DateTime minModificationTime, DateTime maxModificationTime, List<Object> metadata, Integer page, Integer pageSize, String sortOrder, String sortBy) {
        return getEntitiesByFilterWithServiceResponseAsync(drawerID, acl, type, name, state, referenceCount, attachCount, noteCount, ownerUserID, ownerGroupID, creatorUserID, creatorGroupID, modifierUserID, modifierGroupID, minCreationTime, maxCreationTime, minModificationTime, maxModificationTime, metadata, page, pageSize, sortOrder, sortBy).toBlocking().single().body();
    }

    /**
     * Gets a paged list of entity summaries.
     *
     * @param drawerID Gets or sets the drawer identifier.
     * @param acl Gets or sets the access control list.
     * @param type Gets or sets the type of the entity.
     * @param name Gets or sets the name.
     * @param state Gets or sets the state. Possible values include: 'Undefined', 'Available', 'Locked', 'Suspended', 'Archived', 'Deleted', 'Canceled', 'Complete', 'Reviewed', 'ReviewedSuspended', 'ReviewedComplete', 'Rejected', 'RoutingSlipOpen', 'ReviewedRoutingSlipOpen'
     * @param referenceCount Gets or sets the reference count.
     * @param attachCount Gets or sets the attach count.
     * @param noteCount Gets or sets the note count.
     * @param ownerUserID Gets or sets the owner user identifier.
     * @param ownerGroupID Gets or sets the owner group identifier.
     * @param creatorUserID Gets or sets the creator user identifier.
     * @param creatorGroupID Gets or sets the creator group identifier.
     * @param modifierUserID Gets or sets the modifier user identifier.
     * @param modifierGroupID Gets or sets the modifier group identifier.
     * @param minCreationTime Gets or sets the minimum creation time.
     * @param maxCreationTime Gets or sets the maximum creation time.
     * @param minModificationTime Gets or sets the minimum modification time.
     * @param maxModificationTime Gets or sets the maximum modification time.
     * @param metadata Gets or sets the metadata.
     * @param page Gets or sets the page number.
     * @param pageSize Gets or sets the size of the page.
     * @param sortOrder Gets or sets the order. Possible values include: 'Unspecified', 'Ascending', 'Descending'
     * @param sortBy Gets or sets the column to order by. Possible values include: 'ID', 'Type', 'CreationTime', 'ModificationTime', 'State', 'Name'
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<GetEntityBaseResponse>> getEntitiesByFilterAsync(int drawerID, Integer acl, Integer type, String name, String state, Integer referenceCount, Integer attachCount, Integer noteCount, Integer ownerUserID, Integer ownerGroupID, Integer creatorUserID, Integer creatorGroupID, Integer modifierUserID, Integer modifierGroupID, DateTime minCreationTime, DateTime maxCreationTime, DateTime minModificationTime, DateTime maxModificationTime, List<Object> metadata, Integer page, Integer pageSize, String sortOrder, String sortBy, final ServiceCallback<List<GetEntityBaseResponse>> serviceCallback) {
        return ServiceFuture.fromResponse(getEntitiesByFilterWithServiceResponseAsync(drawerID, acl, type, name, state, referenceCount, attachCount, noteCount, ownerUserID, ownerGroupID, creatorUserID, creatorGroupID, modifierUserID, modifierGroupID, minCreationTime, maxCreationTime, minModificationTime, maxModificationTime, metadata, page, pageSize, sortOrder, sortBy), serviceCallback);
    }

    /**
     * Gets a paged list of entity summaries.
     *
     * @param drawerID Gets or sets the drawer identifier.
     * @param acl Gets or sets the access control list.
     * @param type Gets or sets the type of the entity.
     * @param name Gets or sets the name.
     * @param state Gets or sets the state. Possible values include: 'Undefined', 'Available', 'Locked', 'Suspended', 'Archived', 'Deleted', 'Canceled', 'Complete', 'Reviewed', 'ReviewedSuspended', 'ReviewedComplete', 'Rejected', 'RoutingSlipOpen', 'ReviewedRoutingSlipOpen'
     * @param referenceCount Gets or sets the reference count.
     * @param attachCount Gets or sets the attach count.
     * @param noteCount Gets or sets the note count.
     * @param ownerUserID Gets or sets the owner user identifier.
     * @param ownerGroupID Gets or sets the owner group identifier.
     * @param creatorUserID Gets or sets the creator user identifier.
     * @param creatorGroupID Gets or sets the creator group identifier.
     * @param modifierUserID Gets or sets the modifier user identifier.
     * @param modifierGroupID Gets or sets the modifier group identifier.
     * @param minCreationTime Gets or sets the minimum creation time.
     * @param maxCreationTime Gets or sets the maximum creation time.
     * @param minModificationTime Gets or sets the minimum modification time.
     * @param maxModificationTime Gets or sets the maximum modification time.
     * @param metadata Gets or sets the metadata.
     * @param page Gets or sets the page number.
     * @param pageSize Gets or sets the size of the page.
     * @param sortOrder Gets or sets the order. Possible values include: 'Unspecified', 'Ascending', 'Descending'
     * @param sortBy Gets or sets the column to order by. Possible values include: 'ID', 'Type', 'CreationTime', 'ModificationTime', 'State', 'Name'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;GetEntityBaseResponse&gt; object
     */
    public Observable<List<GetEntityBaseResponse>> getEntitiesByFilterAsync(int drawerID, Integer acl, Integer type, String name, String state, Integer referenceCount, Integer attachCount, Integer noteCount, Integer ownerUserID, Integer ownerGroupID, Integer creatorUserID, Integer creatorGroupID, Integer modifierUserID, Integer modifierGroupID, DateTime minCreationTime, DateTime maxCreationTime, DateTime minModificationTime, DateTime maxModificationTime, List<Object> metadata, Integer page, Integer pageSize, String sortOrder, String sortBy) {
        return getEntitiesByFilterWithServiceResponseAsync(drawerID, acl, type, name, state, referenceCount, attachCount, noteCount, ownerUserID, ownerGroupID, creatorUserID, creatorGroupID, modifierUserID, modifierGroupID, minCreationTime, maxCreationTime, minModificationTime, maxModificationTime, metadata, page, pageSize, sortOrder, sortBy).map(new Func1<ServiceResponse<List<GetEntityBaseResponse>>, List<GetEntityBaseResponse>>() {
            @Override
            public List<GetEntityBaseResponse> call(ServiceResponse<List<GetEntityBaseResponse>> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets a paged list of entity summaries.
     *
     * @param drawerID Gets or sets the drawer identifier.
     * @param acl Gets or sets the access control list.
     * @param type Gets or sets the type of the entity.
     * @param name Gets or sets the name.
     * @param state Gets or sets the state. Possible values include: 'Undefined', 'Available', 'Locked', 'Suspended', 'Archived', 'Deleted', 'Canceled', 'Complete', 'Reviewed', 'ReviewedSuspended', 'ReviewedComplete', 'Rejected', 'RoutingSlipOpen', 'ReviewedRoutingSlipOpen'
     * @param referenceCount Gets or sets the reference count.
     * @param attachCount Gets or sets the attach count.
     * @param noteCount Gets or sets the note count.
     * @param ownerUserID Gets or sets the owner user identifier.
     * @param ownerGroupID Gets or sets the owner group identifier.
     * @param creatorUserID Gets or sets the creator user identifier.
     * @param creatorGroupID Gets or sets the creator group identifier.
     * @param modifierUserID Gets or sets the modifier user identifier.
     * @param modifierGroupID Gets or sets the modifier group identifier.
     * @param minCreationTime Gets or sets the minimum creation time.
     * @param maxCreationTime Gets or sets the maximum creation time.
     * @param minModificationTime Gets or sets the minimum modification time.
     * @param maxModificationTime Gets or sets the maximum modification time.
     * @param metadata Gets or sets the metadata.
     * @param page Gets or sets the page number.
     * @param pageSize Gets or sets the size of the page.
     * @param sortOrder Gets or sets the order. Possible values include: 'Unspecified', 'Ascending', 'Descending'
     * @param sortBy Gets or sets the column to order by. Possible values include: 'ID', 'Type', 'CreationTime', 'ModificationTime', 'State', 'Name'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;GetEntityBaseResponse&gt; object
     */
    public Observable<ServiceResponse<List<GetEntityBaseResponse>>> getEntitiesByFilterWithServiceResponseAsync(int drawerID, Integer acl, Integer type, String name, String state, Integer referenceCount, Integer attachCount, Integer noteCount, Integer ownerUserID, Integer ownerGroupID, Integer creatorUserID, Integer creatorGroupID, Integer modifierUserID, Integer modifierGroupID, DateTime minCreationTime, DateTime maxCreationTime, DateTime minModificationTime, DateTime maxModificationTime, List<Object> metadata, Integer page, Integer pageSize, String sortOrder, String sortBy) {
        Validator.validate(metadata);
        String metadataConverted = this.serializerAdapter().serializeList(metadata, CollectionFormat.MULTI);
        return service.getEntitiesByFilter(drawerID, acl, type, name, state, referenceCount, attachCount, noteCount, ownerUserID, ownerGroupID, creatorUserID, creatorGroupID, modifierUserID, modifierGroupID, minCreationTime, maxCreationTime, minModificationTime, maxModificationTime, metadataConverted, page, pageSize, sortOrder, sortBy)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<GetEntityBaseResponse>>>>() {
                @Override
                public Observable<ServiceResponse<List<GetEntityBaseResponse>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<GetEntityBaseResponse>> clientResponse = getEntitiesByFilterDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<List<GetEntityBaseResponse>> getEntitiesByFilterDelegate(Response<ResponseBody> response) throws RestException, IOException {
        return this.restClient().responseBuilderFactory().<List<GetEntityBaseResponse>, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<List<GetEntityBaseResponse>>() { }.getType())
                .build(response);
    }

    /**
     * Gets a single entity complete with all profile metadata.
     *
     * @param drawer The drawer identifier.
     * @param id The entity identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the EntityModel object if successful.
     */
    public EntityModel getEntityById(int drawer, int id) {
        return getEntityByIdWithServiceResponseAsync(drawer, id).toBlocking().single().body();
    }

    /**
     * Gets a single entity complete with all profile metadata.
     *
     * @param drawer The drawer identifier.
     * @param id The entity identifier.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<EntityModel> getEntityByIdAsync(int drawer, int id, final ServiceCallback<EntityModel> serviceCallback) {
        return ServiceFuture.fromResponse(getEntityByIdWithServiceResponseAsync(drawer, id), serviceCallback);
    }

    /**
     * Gets a single entity complete with all profile metadata.
     *
     * @param drawer The drawer identifier.
     * @param id The entity identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the EntityModel object
     */
    public Observable<EntityModel> getEntityByIdAsync(int drawer, int id) {
        return getEntityByIdWithServiceResponseAsync(drawer, id).map(new Func1<ServiceResponse<EntityModel>, EntityModel>() {
            @Override
            public EntityModel call(ServiceResponse<EntityModel> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets a single entity complete with all profile metadata.
     *
     * @param drawer The drawer identifier.
     * @param id The entity identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the EntityModel object
     */
    public Observable<ServiceResponse<EntityModel>> getEntityByIdWithServiceResponseAsync(int drawer, int id) {
        return service.getEntityById(drawer, id)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<EntityModel>>>() {
                @Override
                public Observable<ServiceResponse<EntityModel>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<EntityModel> clientResponse = getEntityByIdDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<EntityModel> getEntityByIdDelegate(Response<ResponseBody> response) throws RestException, IOException {
        return this.restClient().responseBuilderFactory().<EntityModel, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<EntityModel>() { }.getType())
                .register(403, new TypeToken<Void>() { }.getType())
                .register(404, new TypeToken<Void>() { }.getType())
                .build(response);
    }

    /**
     * Updates a specified entity.
     *
     * @param drawer The drawer identifier.
     * @param id The entity identifier.
     * @param model The entity model.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object updateEntity(int drawer, int id, UpdateEntityRequestModel model) {
        return updateEntityWithServiceResponseAsync(drawer, id, model).toBlocking().single().body();
    }

    /**
     * Updates a specified entity.
     *
     * @param drawer The drawer identifier.
     * @param id The entity identifier.
     * @param model The entity model.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> updateEntityAsync(int drawer, int id, UpdateEntityRequestModel model, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromResponse(updateEntityWithServiceResponseAsync(drawer, id, model), serviceCallback);
    }

    /**
     * Updates a specified entity.
     *
     * @param drawer The drawer identifier.
     * @param id The entity identifier.
     * @param model The entity model.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> updateEntityAsync(int drawer, int id, UpdateEntityRequestModel model) {
        return updateEntityWithServiceResponseAsync(drawer, id, model).map(new Func1<ServiceResponse<Object>, Object>() {
            @Override
            public Object call(ServiceResponse<Object> response) {
                return response.body();
            }
        });
    }

    /**
     * Updates a specified entity.
     *
     * @param drawer The drawer identifier.
     * @param id The entity identifier.
     * @param model The entity model.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> updateEntityWithServiceResponseAsync(int drawer, int id, UpdateEntityRequestModel model) {
        if (model == null) {
            throw new IllegalArgumentException("Parameter model is required and cannot be null.");
        }
        Validator.validate(model);
        return service.updateEntity(drawer, id, model)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = updateEntityDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Object> updateEntityDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<Object, RestException>newInstance(this.serializerAdapter())
                .register(204, new TypeToken<Object>() { }.getType())
                .register(403, new TypeToken<Void>() { }.getType())
                .register(404, new TypeToken<Void>() { }.getType())
                .build(response);
    }

    /**
     * Deletes a specified entity.
     *
     * @param drawer The drawer identifier.
     * @param id The entity identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object deleteEntity(int drawer, int id) {
        return deleteEntityWithServiceResponseAsync(drawer, id).toBlocking().single().body();
    }

    /**
     * Deletes a specified entity.
     *
     * @param drawer The drawer identifier.
     * @param id The entity identifier.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> deleteEntityAsync(int drawer, int id, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromResponse(deleteEntityWithServiceResponseAsync(drawer, id), serviceCallback);
    }

    /**
     * Deletes a specified entity.
     *
     * @param drawer The drawer identifier.
     * @param id The entity identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> deleteEntityAsync(int drawer, int id) {
        return deleteEntityWithServiceResponseAsync(drawer, id).map(new Func1<ServiceResponse<Object>, Object>() {
            @Override
            public Object call(ServiceResponse<Object> response) {
                return response.body();
            }
        });
    }

    /**
     * Deletes a specified entity.
     *
     * @param drawer The drawer identifier.
     * @param id The entity identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> deleteEntityWithServiceResponseAsync(int drawer, int id) {
        return service.deleteEntity(drawer, id)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = deleteEntityDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Object> deleteEntityDelegate(Response<ResponseBody> response) throws RestException, IOException {
        return this.restClient().responseBuilderFactory().<Object, RestException>newInstance(this.serializerAdapter())
                .register(204, new TypeToken<Object>() { }.getType())
                .register(403, new TypeToken<Void>() { }.getType())
                .register(404, new TypeToken<Void>() { }.getType())
                .build(response);
    }

    /**
     * Creates a new entity.
     *
     * @param drawer The drawer identifier.
     * @param model The entity model.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the EntityModel object if successful.
     */
    public EntityModel createEntity(int drawer, InsertEntityRequestModel model) {
        return createEntityWithServiceResponseAsync(drawer, model).toBlocking().single().body();
    }

    /**
     * Creates a new entity.
     *
     * @param drawer The drawer identifier.
     * @param model The entity model.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<EntityModel> createEntityAsync(int drawer, InsertEntityRequestModel model, final ServiceCallback<EntityModel> serviceCallback) {
        return ServiceFuture.fromResponse(createEntityWithServiceResponseAsync(drawer, model), serviceCallback);
    }

    /**
     * Creates a new entity.
     *
     * @param drawer The drawer identifier.
     * @param model The entity model.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the EntityModel object
     */
    public Observable<EntityModel> createEntityAsync(int drawer, InsertEntityRequestModel model) {
        return createEntityWithServiceResponseAsync(drawer, model).map(new Func1<ServiceResponse<EntityModel>, EntityModel>() {
            @Override
            public EntityModel call(ServiceResponse<EntityModel> response) {
                return response.body();
            }
        });
    }

    /**
     * Creates a new entity.
     *
     * @param drawer The drawer identifier.
     * @param model The entity model.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the EntityModel object
     */
    public Observable<ServiceResponse<EntityModel>> createEntityWithServiceResponseAsync(int drawer, InsertEntityRequestModel model) {
        if (model == null) {
            throw new IllegalArgumentException("Parameter model is required and cannot be null.");
        }
        Validator.validate(model);
        return service.createEntity(drawer, model)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<EntityModel>>>() {
                @Override
                public Observable<ServiceResponse<EntityModel>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<EntityModel> clientResponse = createEntityDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<EntityModel> createEntityDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<EntityModel, RestException>newInstance(this.serializerAdapter())
                .register(201, new TypeToken<EntityModel>() { }.getType())
                .register(404, new TypeToken<Void>() { }.getType())
                .build(response);
    }

    /**
     * Copies the contents of an entity.
     *
     * @param drawer The drawer.
     * @param id The entity identifier.
     * @param model The model.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the EntityModel object if successful.
     */
    public EntityModel copyEntity(int drawer, int id, EntityContentModel model) {
        return copyEntityWithServiceResponseAsync(drawer, id, model).toBlocking().single().body();
    }

    /**
     * Copies the contents of an entity.
     *
     * @param drawer The drawer.
     * @param id The entity identifier.
     * @param model The model.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<EntityModel> copyEntityAsync(int drawer, int id, EntityContentModel model, final ServiceCallback<EntityModel> serviceCallback) {
        return ServiceFuture.fromResponse(copyEntityWithServiceResponseAsync(drawer, id, model), serviceCallback);
    }

    /**
     * Copies the contents of an entity.
     *
     * @param drawer The drawer.
     * @param id The entity identifier.
     * @param model The model.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the EntityModel object
     */
    public Observable<EntityModel> copyEntityAsync(int drawer, int id, EntityContentModel model) {
        return copyEntityWithServiceResponseAsync(drawer, id, model).map(new Func1<ServiceResponse<EntityModel>, EntityModel>() {
            @Override
            public EntityModel call(ServiceResponse<EntityModel> response) {
                return response.body();
            }
        });
    }

    /**
     * Copies the contents of an entity.
     *
     * @param drawer The drawer.
     * @param id The entity identifier.
     * @param model The model.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the EntityModel object
     */
    public Observable<ServiceResponse<EntityModel>> copyEntityWithServiceResponseAsync(int drawer, int id, EntityContentModel model) {
        if (model == null) {
            throw new IllegalArgumentException("Parameter model is required and cannot be null.");
        }
        Validator.validate(model);
        return service.copyEntity(drawer, id, model)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<EntityModel>>>() {
                @Override
                public Observable<ServiceResponse<EntityModel>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<EntityModel> clientResponse = copyEntityDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<EntityModel> copyEntityDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<EntityModel, RestException>newInstance(this.serializerAdapter())
                .register(201, new TypeToken<EntityModel>() { }.getType())
                .register(404, new TypeToken<Void>() { }.getType())
                .build(response);
    }

    /**
     * Gets a paged list of events.
     *
     * @param drawerID Gets or sets the drawer identifier.
     * @param entityID Gets or sets the entity identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;EventModel&gt; object if successful.
     */
    public List<EventModel> getEventsByFilter(int drawerID, int entityID) {
        return getEventsByFilterWithServiceResponseAsync(drawerID, entityID).toBlocking().single().body();
    }

    /**
     * Gets a paged list of events.
     *
     * @param drawerID Gets or sets the drawer identifier.
     * @param entityID Gets or sets the entity identifier.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<EventModel>> getEventsByFilterAsync(int drawerID, int entityID, final ServiceCallback<List<EventModel>> serviceCallback) {
        return ServiceFuture.fromResponse(getEventsByFilterWithServiceResponseAsync(drawerID, entityID), serviceCallback);
    }

    /**
     * Gets a paged list of events.
     *
     * @param drawerID Gets or sets the drawer identifier.
     * @param entityID Gets or sets the entity identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;EventModel&gt; object
     */
    public Observable<List<EventModel>> getEventsByFilterAsync(int drawerID, int entityID) {
        return getEventsByFilterWithServiceResponseAsync(drawerID, entityID).map(new Func1<ServiceResponse<List<EventModel>>, List<EventModel>>() {
            @Override
            public List<EventModel> call(ServiceResponse<List<EventModel>> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets a paged list of events.
     *
     * @param drawerID Gets or sets the drawer identifier.
     * @param entityID Gets or sets the entity identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;EventModel&gt; object
     */
    public Observable<ServiceResponse<List<EventModel>>> getEventsByFilterWithServiceResponseAsync(int drawerID, int entityID) {
        final String type = null;
        final DateTime minEventTime = null;
        final DateTime maxEventTime = null;
        final Integer eventUserID = null;
        final Integer eventGroupID = null;
        final String category = null;
        final String classParameter = null;
        final String operation = null;
        final Integer minProcessingTime = null;
        final Integer maxProcessingTime = null;
        final Integer page = null;
        final Integer pageSize = null;
        final String sortOrder = null;
        final String sortBy = null;
        return service.getEventsByFilter(drawerID, entityID, type, minEventTime, maxEventTime, eventUserID, eventGroupID, category, classParameter, operation, minProcessingTime, maxProcessingTime, page, pageSize, sortOrder, sortBy)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<EventModel>>>>() {
                @Override
                public Observable<ServiceResponse<List<EventModel>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<EventModel>> clientResponse = getEventsByFilterDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Gets a paged list of events.
     *
     * @param drawerID Gets or sets the drawer identifier.
     * @param entityID Gets or sets the entity identifier.
     * @param type Gets or sets the type. Possible values include: 'Undefined', 'Fatal', 'Warning', 'Info', 'Debug', 'Process', 'RPC', 'SQL', 'DDE'
     * @param minEventTime Gets or sets the minimum event time.
     * @param maxEventTime Gets or sets the maximum event time.
     * @param eventUserID Gets or sets the event user identifier.
     * @param eventGroupID Gets or sets the event group identifier.
     * @param category Gets or sets the category. Possible values include: 'Undefined', 'Entity', 'Profile', 'Attachment', 'Discussion', 'Field', 'Workflow'
     * @param classParameter Gets or sets the class. Possible values include: 'Undefined', 'Application', 'Security', 'System'
     * @param operation Gets or sets the operation. Possible values include: 'Undefined', 'Insert', 'Update', 'Delete', 'Copy', 'Lock', 'Unlock', 'Open', 'Close', 'Checkout', 'Checkin', 'View', 'Merge', 'Split', 'Classify', 'Null', 'OpenWF', 'Remove', 'ReturnToTop', 'ReturnToBottom', 'Accept', 'Suspend', 'Reject', 'Route', 'Forward', 'Reply', 'Reassign', 'Reset', 'Override', 'Rollback', 'Archive'
     * @param minProcessingTime Gets or sets the minimum processing time.
     * @param maxProcessingTime Gets or sets the maximum processing time.
     * @param page Gets or sets the page number.
     * @param pageSize Gets or sets the size of the page.
     * @param sortOrder Gets or sets the order. Possible values include: 'Unspecified', 'Ascending', 'Descending'
     * @param sortBy Gets or sets the column to order by. Possible values include: 'ID', 'Type', 'EventTime'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;EventModel&gt; object if successful.
     */
    public List<EventModel> getEventsByFilter(int drawerID, int entityID, String type, DateTime minEventTime, DateTime maxEventTime, Integer eventUserID, Integer eventGroupID, String category, String classParameter, String operation, Integer minProcessingTime, Integer maxProcessingTime, Integer page, Integer pageSize, String sortOrder, String sortBy) {
        return getEventsByFilterWithServiceResponseAsync(drawerID, entityID, type, minEventTime, maxEventTime, eventUserID, eventGroupID, category, classParameter, operation, minProcessingTime, maxProcessingTime, page, pageSize, sortOrder, sortBy).toBlocking().single().body();
    }

    /**
     * Gets a paged list of events.
     *
     * @param drawerID Gets or sets the drawer identifier.
     * @param entityID Gets or sets the entity identifier.
     * @param type Gets or sets the type. Possible values include: 'Undefined', 'Fatal', 'Warning', 'Info', 'Debug', 'Process', 'RPC', 'SQL', 'DDE'
     * @param minEventTime Gets or sets the minimum event time.
     * @param maxEventTime Gets or sets the maximum event time.
     * @param eventUserID Gets or sets the event user identifier.
     * @param eventGroupID Gets or sets the event group identifier.
     * @param category Gets or sets the category. Possible values include: 'Undefined', 'Entity', 'Profile', 'Attachment', 'Discussion', 'Field', 'Workflow'
     * @param classParameter Gets or sets the class. Possible values include: 'Undefined', 'Application', 'Security', 'System'
     * @param operation Gets or sets the operation. Possible values include: 'Undefined', 'Insert', 'Update', 'Delete', 'Copy', 'Lock', 'Unlock', 'Open', 'Close', 'Checkout', 'Checkin', 'View', 'Merge', 'Split', 'Classify', 'Null', 'OpenWF', 'Remove', 'ReturnToTop', 'ReturnToBottom', 'Accept', 'Suspend', 'Reject', 'Route', 'Forward', 'Reply', 'Reassign', 'Reset', 'Override', 'Rollback', 'Archive'
     * @param minProcessingTime Gets or sets the minimum processing time.
     * @param maxProcessingTime Gets or sets the maximum processing time.
     * @param page Gets or sets the page number.
     * @param pageSize Gets or sets the size of the page.
     * @param sortOrder Gets or sets the order. Possible values include: 'Unspecified', 'Ascending', 'Descending'
     * @param sortBy Gets or sets the column to order by. Possible values include: 'ID', 'Type', 'EventTime'
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<EventModel>> getEventsByFilterAsync(int drawerID, int entityID, String type, DateTime minEventTime, DateTime maxEventTime, Integer eventUserID, Integer eventGroupID, String category, String classParameter, String operation, Integer minProcessingTime, Integer maxProcessingTime, Integer page, Integer pageSize, String sortOrder, String sortBy, final ServiceCallback<List<EventModel>> serviceCallback) {
        return ServiceFuture.fromResponse(getEventsByFilterWithServiceResponseAsync(drawerID, entityID, type, minEventTime, maxEventTime, eventUserID, eventGroupID, category, classParameter, operation, minProcessingTime, maxProcessingTime, page, pageSize, sortOrder, sortBy), serviceCallback);
    }

    /**
     * Gets a paged list of events.
     *
     * @param drawerID Gets or sets the drawer identifier.
     * @param entityID Gets or sets the entity identifier.
     * @param type Gets or sets the type. Possible values include: 'Undefined', 'Fatal', 'Warning', 'Info', 'Debug', 'Process', 'RPC', 'SQL', 'DDE'
     * @param minEventTime Gets or sets the minimum event time.
     * @param maxEventTime Gets or sets the maximum event time.
     * @param eventUserID Gets or sets the event user identifier.
     * @param eventGroupID Gets or sets the event group identifier.
     * @param category Gets or sets the category. Possible values include: 'Undefined', 'Entity', 'Profile', 'Attachment', 'Discussion', 'Field', 'Workflow'
     * @param classParameter Gets or sets the class. Possible values include: 'Undefined', 'Application', 'Security', 'System'
     * @param operation Gets or sets the operation. Possible values include: 'Undefined', 'Insert', 'Update', 'Delete', 'Copy', 'Lock', 'Unlock', 'Open', 'Close', 'Checkout', 'Checkin', 'View', 'Merge', 'Split', 'Classify', 'Null', 'OpenWF', 'Remove', 'ReturnToTop', 'ReturnToBottom', 'Accept', 'Suspend', 'Reject', 'Route', 'Forward', 'Reply', 'Reassign', 'Reset', 'Override', 'Rollback', 'Archive'
     * @param minProcessingTime Gets or sets the minimum processing time.
     * @param maxProcessingTime Gets or sets the maximum processing time.
     * @param page Gets or sets the page number.
     * @param pageSize Gets or sets the size of the page.
     * @param sortOrder Gets or sets the order. Possible values include: 'Unspecified', 'Ascending', 'Descending'
     * @param sortBy Gets or sets the column to order by. Possible values include: 'ID', 'Type', 'EventTime'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;EventModel&gt; object
     */
    public Observable<List<EventModel>> getEventsByFilterAsync(int drawerID, int entityID, String type, DateTime minEventTime, DateTime maxEventTime, Integer eventUserID, Integer eventGroupID, String category, String classParameter, String operation, Integer minProcessingTime, Integer maxProcessingTime, Integer page, Integer pageSize, String sortOrder, String sortBy) {
        return getEventsByFilterWithServiceResponseAsync(drawerID, entityID, type, minEventTime, maxEventTime, eventUserID, eventGroupID, category, classParameter, operation, minProcessingTime, maxProcessingTime, page, pageSize, sortOrder, sortBy).map(new Func1<ServiceResponse<List<EventModel>>, List<EventModel>>() {
            @Override
            public List<EventModel> call(ServiceResponse<List<EventModel>> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets a paged list of events.
     *
     * @param drawerID Gets or sets the drawer identifier.
     * @param entityID Gets or sets the entity identifier.
     * @param type Gets or sets the type. Possible values include: 'Undefined', 'Fatal', 'Warning', 'Info', 'Debug', 'Process', 'RPC', 'SQL', 'DDE'
     * @param minEventTime Gets or sets the minimum event time.
     * @param maxEventTime Gets or sets the maximum event time.
     * @param eventUserID Gets or sets the event user identifier.
     * @param eventGroupID Gets or sets the event group identifier.
     * @param category Gets or sets the category. Possible values include: 'Undefined', 'Entity', 'Profile', 'Attachment', 'Discussion', 'Field', 'Workflow'
     * @param classParameter Gets or sets the class. Possible values include: 'Undefined', 'Application', 'Security', 'System'
     * @param operation Gets or sets the operation. Possible values include: 'Undefined', 'Insert', 'Update', 'Delete', 'Copy', 'Lock', 'Unlock', 'Open', 'Close', 'Checkout', 'Checkin', 'View', 'Merge', 'Split', 'Classify', 'Null', 'OpenWF', 'Remove', 'ReturnToTop', 'ReturnToBottom', 'Accept', 'Suspend', 'Reject', 'Route', 'Forward', 'Reply', 'Reassign', 'Reset', 'Override', 'Rollback', 'Archive'
     * @param minProcessingTime Gets or sets the minimum processing time.
     * @param maxProcessingTime Gets or sets the maximum processing time.
     * @param page Gets or sets the page number.
     * @param pageSize Gets or sets the size of the page.
     * @param sortOrder Gets or sets the order. Possible values include: 'Unspecified', 'Ascending', 'Descending'
     * @param sortBy Gets or sets the column to order by. Possible values include: 'ID', 'Type', 'EventTime'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;EventModel&gt; object
     */
    public Observable<ServiceResponse<List<EventModel>>> getEventsByFilterWithServiceResponseAsync(int drawerID, int entityID, String type, DateTime minEventTime, DateTime maxEventTime, Integer eventUserID, Integer eventGroupID, String category, String classParameter, String operation, Integer minProcessingTime, Integer maxProcessingTime, Integer page, Integer pageSize, String sortOrder, String sortBy) {
        return service.getEventsByFilter(drawerID, entityID, type, minEventTime, maxEventTime, eventUserID, eventGroupID, category, classParameter, operation, minProcessingTime, maxProcessingTime, page, pageSize, sortOrder, sortBy)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<EventModel>>>>() {
                @Override
                public Observable<ServiceResponse<List<EventModel>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<EventModel>> clientResponse = getEventsByFilterDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<List<EventModel>> getEventsByFilterDelegate(Response<ResponseBody> response) throws RestException, IOException {
        return this.restClient().responseBuilderFactory().<List<EventModel>, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<List<EventModel>>() { }.getType())
                .build(response);
    }

    /**
     * Retrieves a single event based on its unique identifier.
     *
     * @param drawer The drawer identifier.
     * @param id The event identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the EventModel object if successful.
     */
    public EventModel getEventById(int drawer, int id) {
        return getEventByIdWithServiceResponseAsync(drawer, id).toBlocking().single().body();
    }

    /**
     * Retrieves a single event based on its unique identifier.
     *
     * @param drawer The drawer identifier.
     * @param id The event identifier.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<EventModel> getEventByIdAsync(int drawer, int id, final ServiceCallback<EventModel> serviceCallback) {
        return ServiceFuture.fromResponse(getEventByIdWithServiceResponseAsync(drawer, id), serviceCallback);
    }

    /**
     * Retrieves a single event based on its unique identifier.
     *
     * @param drawer The drawer identifier.
     * @param id The event identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the EventModel object
     */
    public Observable<EventModel> getEventByIdAsync(int drawer, int id) {
        return getEventByIdWithServiceResponseAsync(drawer, id).map(new Func1<ServiceResponse<EventModel>, EventModel>() {
            @Override
            public EventModel call(ServiceResponse<EventModel> response) {
                return response.body();
            }
        });
    }

    /**
     * Retrieves a single event based on its unique identifier.
     *
     * @param drawer The drawer identifier.
     * @param id The event identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the EventModel object
     */
    public Observable<ServiceResponse<EventModel>> getEventByIdWithServiceResponseAsync(int drawer, int id) {
        return service.getEventById(drawer, id)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<EventModel>>>() {
                @Override
                public Observable<ServiceResponse<EventModel>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<EventModel> clientResponse = getEventByIdDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<EventModel> getEventByIdDelegate(Response<ResponseBody> response) throws RestException, IOException {
        return this.restClient().responseBuilderFactory().<EventModel, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<EventModel>() { }.getType())
                .register(404, new TypeToken<Void>() { }.getType())
                .build(response);
    }

    /**
     * Creates a new event.
     *
     * @param drawer The drawer identifier.
     * @param model The event model.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the EventModel object if successful.
     */
    public EventModel createEvent(int drawer, EventModel model) {
        return createEventWithServiceResponseAsync(drawer, model).toBlocking().single().body();
    }

    /**
     * Creates a new event.
     *
     * @param drawer The drawer identifier.
     * @param model The event model.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<EventModel> createEventAsync(int drawer, EventModel model, final ServiceCallback<EventModel> serviceCallback) {
        return ServiceFuture.fromResponse(createEventWithServiceResponseAsync(drawer, model), serviceCallback);
    }

    /**
     * Creates a new event.
     *
     * @param drawer The drawer identifier.
     * @param model The event model.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the EventModel object
     */
    public Observable<EventModel> createEventAsync(int drawer, EventModel model) {
        return createEventWithServiceResponseAsync(drawer, model).map(new Func1<ServiceResponse<EventModel>, EventModel>() {
            @Override
            public EventModel call(ServiceResponse<EventModel> response) {
                return response.body();
            }
        });
    }

    /**
     * Creates a new event.
     *
     * @param drawer The drawer identifier.
     * @param model The event model.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the EventModel object
     */
    public Observable<ServiceResponse<EventModel>> createEventWithServiceResponseAsync(int drawer, EventModel model) {
        if (model == null) {
            throw new IllegalArgumentException("Parameter model is required and cannot be null.");
        }
        Validator.validate(model);
        return service.createEvent(drawer, model)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<EventModel>>>() {
                @Override
                public Observable<ServiceResponse<EventModel>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<EventModel> clientResponse = createEventDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<EventModel> createEventDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<EventModel, RestException>newInstance(this.serializerAdapter())
                .register(201, new TypeToken<EventModel>() { }.getType())
                .register(404, new TypeToken<Void>() { }.getType())
                .build(response);
    }

    /**
     * Gets a paged list of extension rows.
     *
     * @param drawerID Gets or sets the drawer identifier.
     * @param entityID Gets or sets the entity identifier.
     * @param profileID Gets or sets the profile identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;ExtensionModel&gt; object if successful.
     */
    public List<ExtensionModel> getExtensionsByFilter(int drawerID, int entityID, int profileID) {
        return getExtensionsByFilterWithServiceResponseAsync(drawerID, entityID, profileID).toBlocking().single().body();
    }

    /**
     * Gets a paged list of extension rows.
     *
     * @param drawerID Gets or sets the drawer identifier.
     * @param entityID Gets or sets the entity identifier.
     * @param profileID Gets or sets the profile identifier.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<ExtensionModel>> getExtensionsByFilterAsync(int drawerID, int entityID, int profileID, final ServiceCallback<List<ExtensionModel>> serviceCallback) {
        return ServiceFuture.fromResponse(getExtensionsByFilterWithServiceResponseAsync(drawerID, entityID, profileID), serviceCallback);
    }

    /**
     * Gets a paged list of extension rows.
     *
     * @param drawerID Gets or sets the drawer identifier.
     * @param entityID Gets or sets the entity identifier.
     * @param profileID Gets or sets the profile identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;ExtensionModel&gt; object
     */
    public Observable<List<ExtensionModel>> getExtensionsByFilterAsync(int drawerID, int entityID, int profileID) {
        return getExtensionsByFilterWithServiceResponseAsync(drawerID, entityID, profileID).map(new Func1<ServiceResponse<List<ExtensionModel>>, List<ExtensionModel>>() {
            @Override
            public List<ExtensionModel> call(ServiceResponse<List<ExtensionModel>> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets a paged list of extension rows.
     *
     * @param drawerID Gets or sets the drawer identifier.
     * @param entityID Gets or sets the entity identifier.
     * @param profileID Gets or sets the profile identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;ExtensionModel&gt; object
     */
    public Observable<ServiceResponse<List<ExtensionModel>>> getExtensionsByFilterWithServiceResponseAsync(int drawerID, int entityID, int profileID) {
        final Integer iD = null;
        final Integer type = null;
        final Integer page = null;
        final Integer pageSize = null;
        final String sortOrder = null;
        final String sortBy = null;
        return service.getExtensionsByFilter(drawerID, entityID, profileID, iD, type, page, pageSize, sortOrder, sortBy)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<ExtensionModel>>>>() {
                @Override
                public Observable<ServiceResponse<List<ExtensionModel>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<ExtensionModel>> clientResponse = getExtensionsByFilterDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Gets a paged list of extension rows.
     *
     * @param drawerID Gets or sets the drawer identifier.
     * @param entityID Gets or sets the entity identifier.
     * @param profileID Gets or sets the profile identifier.
     * @param iD Gets or sets the extension identifier.
     * @param type Gets or sets the type of the extension.
     * @param page Gets or sets the page number.
     * @param pageSize Gets or sets the size of the page.
     * @param sortOrder Gets or sets the order. Possible values include: 'Unspecified', 'Ascending', 'Descending'
     * @param sortBy Gets or sets the column to order by. Possible values include: 'RowNumber', 'ID', 'Type', 'String', 'Integer', 'Double', 'Date'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;ExtensionModel&gt; object if successful.
     */
    public List<ExtensionModel> getExtensionsByFilter(int drawerID, int entityID, int profileID, Integer iD, Integer type, Integer page, Integer pageSize, String sortOrder, String sortBy) {
        return getExtensionsByFilterWithServiceResponseAsync(drawerID, entityID, profileID, iD, type, page, pageSize, sortOrder, sortBy).toBlocking().single().body();
    }

    /**
     * Gets a paged list of extension rows.
     *
     * @param drawerID Gets or sets the drawer identifier.
     * @param entityID Gets or sets the entity identifier.
     * @param profileID Gets or sets the profile identifier.
     * @param iD Gets or sets the extension identifier.
     * @param type Gets or sets the type of the extension.
     * @param page Gets or sets the page number.
     * @param pageSize Gets or sets the size of the page.
     * @param sortOrder Gets or sets the order. Possible values include: 'Unspecified', 'Ascending', 'Descending'
     * @param sortBy Gets or sets the column to order by. Possible values include: 'RowNumber', 'ID', 'Type', 'String', 'Integer', 'Double', 'Date'
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<ExtensionModel>> getExtensionsByFilterAsync(int drawerID, int entityID, int profileID, Integer iD, Integer type, Integer page, Integer pageSize, String sortOrder, String sortBy, final ServiceCallback<List<ExtensionModel>> serviceCallback) {
        return ServiceFuture.fromResponse(getExtensionsByFilterWithServiceResponseAsync(drawerID, entityID, profileID, iD, type, page, pageSize, sortOrder, sortBy), serviceCallback);
    }

    /**
     * Gets a paged list of extension rows.
     *
     * @param drawerID Gets or sets the drawer identifier.
     * @param entityID Gets or sets the entity identifier.
     * @param profileID Gets or sets the profile identifier.
     * @param iD Gets or sets the extension identifier.
     * @param type Gets or sets the type of the extension.
     * @param page Gets or sets the page number.
     * @param pageSize Gets or sets the size of the page.
     * @param sortOrder Gets or sets the order. Possible values include: 'Unspecified', 'Ascending', 'Descending'
     * @param sortBy Gets or sets the column to order by. Possible values include: 'RowNumber', 'ID', 'Type', 'String', 'Integer', 'Double', 'Date'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;ExtensionModel&gt; object
     */
    public Observable<List<ExtensionModel>> getExtensionsByFilterAsync(int drawerID, int entityID, int profileID, Integer iD, Integer type, Integer page, Integer pageSize, String sortOrder, String sortBy) {
        return getExtensionsByFilterWithServiceResponseAsync(drawerID, entityID, profileID, iD, type, page, pageSize, sortOrder, sortBy).map(new Func1<ServiceResponse<List<ExtensionModel>>, List<ExtensionModel>>() {
            @Override
            public List<ExtensionModel> call(ServiceResponse<List<ExtensionModel>> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets a paged list of extension rows.
     *
     * @param drawerID Gets or sets the drawer identifier.
     * @param entityID Gets or sets the entity identifier.
     * @param profileID Gets or sets the profile identifier.
     * @param iD Gets or sets the extension identifier.
     * @param type Gets or sets the type of the extension.
     * @param page Gets or sets the page number.
     * @param pageSize Gets or sets the size of the page.
     * @param sortOrder Gets or sets the order. Possible values include: 'Unspecified', 'Ascending', 'Descending'
     * @param sortBy Gets or sets the column to order by. Possible values include: 'RowNumber', 'ID', 'Type', 'String', 'Integer', 'Double', 'Date'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;ExtensionModel&gt; object
     */
    public Observable<ServiceResponse<List<ExtensionModel>>> getExtensionsByFilterWithServiceResponseAsync(int drawerID, int entityID, int profileID, Integer iD, Integer type, Integer page, Integer pageSize, String sortOrder, String sortBy) {
        return service.getExtensionsByFilter(drawerID, entityID, profileID, iD, type, page, pageSize, sortOrder, sortBy)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<ExtensionModel>>>>() {
                @Override
                public Observable<ServiceResponse<List<ExtensionModel>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<ExtensionModel>> clientResponse = getExtensionsByFilterDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<List<ExtensionModel>> getExtensionsByFilterDelegate(Response<ResponseBody> response) throws RestException, IOException {
        return this.restClient().responseBuilderFactory().<List<ExtensionModel>, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<List<ExtensionModel>>() { }.getType())
                .build(response);
    }

    /**
     * Gets a paged list of flows.
     *
     * @param drawerID Gets or sets the drawer identifier.
     * @param entityID Gets or sets the entity identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;FlowModel&gt; object if successful.
     */
    public List<FlowModel> getFlowsByFilter(int drawerID, int entityID) {
        return getFlowsByFilterWithServiceResponseAsync(drawerID, entityID).toBlocking().single().body();
    }

    /**
     * Gets a paged list of flows.
     *
     * @param drawerID Gets or sets the drawer identifier.
     * @param entityID Gets or sets the entity identifier.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<FlowModel>> getFlowsByFilterAsync(int drawerID, int entityID, final ServiceCallback<List<FlowModel>> serviceCallback) {
        return ServiceFuture.fromResponse(getFlowsByFilterWithServiceResponseAsync(drawerID, entityID), serviceCallback);
    }

    /**
     * Gets a paged list of flows.
     *
     * @param drawerID Gets or sets the drawer identifier.
     * @param entityID Gets or sets the entity identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;FlowModel&gt; object
     */
    public Observable<List<FlowModel>> getFlowsByFilterAsync(int drawerID, int entityID) {
        return getFlowsByFilterWithServiceResponseAsync(drawerID, entityID).map(new Func1<ServiceResponse<List<FlowModel>>, List<FlowModel>>() {
            @Override
            public List<FlowModel> call(ServiceResponse<List<FlowModel>> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets a paged list of flows.
     *
     * @param drawerID Gets or sets the drawer identifier.
     * @param entityID Gets or sets the entity identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;FlowModel&gt; object
     */
    public Observable<ServiceResponse<List<FlowModel>>> getFlowsByFilterWithServiceResponseAsync(int drawerID, int entityID) {
        final String type = null;
        final Integer queueID = null;
        final DateTime minWorkflowTime = null;
        final DateTime maxWorkflowTime = null;
        final DateTime minInsertionTime = null;
        final DateTime maxInsertionTime = null;
        final Integer workflowUserID = null;
        final Integer workflowGroupID = null;
        final String operation = null;
        final String category = null;
        final String status = null;
        final String state = null;
        final Integer minIndex1 = null;
        final Integer maxIndex1 = null;
        final Integer minIndex2 = null;
        final Integer maxIndex2 = null;
        final Integer page = null;
        final Integer pageSize = null;
        final String sortOrder = null;
        final String sortBy = null;
        return service.getFlowsByFilter(drawerID, entityID, type, queueID, minWorkflowTime, maxWorkflowTime, minInsertionTime, maxInsertionTime, workflowUserID, workflowGroupID, operation, category, status, state, minIndex1, maxIndex1, minIndex2, maxIndex2, page, pageSize, sortOrder, sortBy)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<FlowModel>>>>() {
                @Override
                public Observable<ServiceResponse<List<FlowModel>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<FlowModel>> clientResponse = getFlowsByFilterDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Gets a paged list of flows.
     *
     * @param drawerID Gets or sets the drawer identifier.
     * @param entityID Gets or sets the entity identifier.
     * @param type Gets or sets the type. Possible values include: 'None', 'Workflow', 'Fatal', 'Warning', 'Info', 'Debug', 'Process', 'Rpc', 'Sql', 'Dde'
     * @param queueID Gets or sets the queue identifier.
     * @param minWorkflowTime Gets or sets the minimum workflow time.
     * @param maxWorkflowTime Gets or sets the maximum workflow time.
     * @param minInsertionTime Gets or sets the minimum insertion time.
     * @param maxInsertionTime Gets or sets the maximum insertion time.
     * @param workflowUserID Gets or sets the workflow user identifier.
     * @param workflowGroupID Gets or sets the workflow group identifier.
     * @param operation Gets or sets the operation. Possible values include: 'None', 'Update', 'Reset', 'Override', 'Null'
     * @param category Gets or sets the category. Possible values include: 'None', 'Direct', 'AdHoc', 'Production', 'Review', 'Reset', 'RoutingSlip', 'ReviewRoutingSlip', 'Override'
     * @param status Gets or sets the status. Possible values include: 'None', 'Approved', 'Rejected', 'Suspended', 'ApprovedR', 'NoneR'
     * @param state Gets or sets the state. Possible values include: 'None', 'Processed', 'Pending', 'Waiting', 'ProcessedR', 'Override', 'OverrideR', 'WaitingR'
     * @param minIndex1 Gets or sets the minimum index 1.
     * @param maxIndex1 Gets or sets the maximum index 1.
     * @param minIndex2 Gets or sets the minimum index 2.
     * @param maxIndex2 Gets or sets the maximum index 2.
     * @param page Gets or sets the page number.
     * @param pageSize Gets or sets the size of the page.
     * @param sortOrder Gets or sets the order. Possible values include: 'Unspecified', 'Ascending', 'Descending'
     * @param sortBy Gets or sets the column to order by. Possible values include: 'ID', 'Type', 'QueueID', 'WorkflowTime', 'InsertionTime', 'Index'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;FlowModel&gt; object if successful.
     */
    public List<FlowModel> getFlowsByFilter(int drawerID, int entityID, String type, Integer queueID, DateTime minWorkflowTime, DateTime maxWorkflowTime, DateTime minInsertionTime, DateTime maxInsertionTime, Integer workflowUserID, Integer workflowGroupID, String operation, String category, String status, String state, Integer minIndex1, Integer maxIndex1, Integer minIndex2, Integer maxIndex2, Integer page, Integer pageSize, String sortOrder, String sortBy) {
        return getFlowsByFilterWithServiceResponseAsync(drawerID, entityID, type, queueID, minWorkflowTime, maxWorkflowTime, minInsertionTime, maxInsertionTime, workflowUserID, workflowGroupID, operation, category, status, state, minIndex1, maxIndex1, minIndex2, maxIndex2, page, pageSize, sortOrder, sortBy).toBlocking().single().body();
    }

    /**
     * Gets a paged list of flows.
     *
     * @param drawerID Gets or sets the drawer identifier.
     * @param entityID Gets or sets the entity identifier.
     * @param type Gets or sets the type. Possible values include: 'None', 'Workflow', 'Fatal', 'Warning', 'Info', 'Debug', 'Process', 'Rpc', 'Sql', 'Dde'
     * @param queueID Gets or sets the queue identifier.
     * @param minWorkflowTime Gets or sets the minimum workflow time.
     * @param maxWorkflowTime Gets or sets the maximum workflow time.
     * @param minInsertionTime Gets or sets the minimum insertion time.
     * @param maxInsertionTime Gets or sets the maximum insertion time.
     * @param workflowUserID Gets or sets the workflow user identifier.
     * @param workflowGroupID Gets or sets the workflow group identifier.
     * @param operation Gets or sets the operation. Possible values include: 'None', 'Update', 'Reset', 'Override', 'Null'
     * @param category Gets or sets the category. Possible values include: 'None', 'Direct', 'AdHoc', 'Production', 'Review', 'Reset', 'RoutingSlip', 'ReviewRoutingSlip', 'Override'
     * @param status Gets or sets the status. Possible values include: 'None', 'Approved', 'Rejected', 'Suspended', 'ApprovedR', 'NoneR'
     * @param state Gets or sets the state. Possible values include: 'None', 'Processed', 'Pending', 'Waiting', 'ProcessedR', 'Override', 'OverrideR', 'WaitingR'
     * @param minIndex1 Gets or sets the minimum index 1.
     * @param maxIndex1 Gets or sets the maximum index 1.
     * @param minIndex2 Gets or sets the minimum index 2.
     * @param maxIndex2 Gets or sets the maximum index 2.
     * @param page Gets or sets the page number.
     * @param pageSize Gets or sets the size of the page.
     * @param sortOrder Gets or sets the order. Possible values include: 'Unspecified', 'Ascending', 'Descending'
     * @param sortBy Gets or sets the column to order by. Possible values include: 'ID', 'Type', 'QueueID', 'WorkflowTime', 'InsertionTime', 'Index'
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<FlowModel>> getFlowsByFilterAsync(int drawerID, int entityID, String type, Integer queueID, DateTime minWorkflowTime, DateTime maxWorkflowTime, DateTime minInsertionTime, DateTime maxInsertionTime, Integer workflowUserID, Integer workflowGroupID, String operation, String category, String status, String state, Integer minIndex1, Integer maxIndex1, Integer minIndex2, Integer maxIndex2, Integer page, Integer pageSize, String sortOrder, String sortBy, final ServiceCallback<List<FlowModel>> serviceCallback) {
        return ServiceFuture.fromResponse(getFlowsByFilterWithServiceResponseAsync(drawerID, entityID, type, queueID, minWorkflowTime, maxWorkflowTime, minInsertionTime, maxInsertionTime, workflowUserID, workflowGroupID, operation, category, status, state, minIndex1, maxIndex1, minIndex2, maxIndex2, page, pageSize, sortOrder, sortBy), serviceCallback);
    }

    /**
     * Gets a paged list of flows.
     *
     * @param drawerID Gets or sets the drawer identifier.
     * @param entityID Gets or sets the entity identifier.
     * @param type Gets or sets the type. Possible values include: 'None', 'Workflow', 'Fatal', 'Warning', 'Info', 'Debug', 'Process', 'Rpc', 'Sql', 'Dde'
     * @param queueID Gets or sets the queue identifier.
     * @param minWorkflowTime Gets or sets the minimum workflow time.
     * @param maxWorkflowTime Gets or sets the maximum workflow time.
     * @param minInsertionTime Gets or sets the minimum insertion time.
     * @param maxInsertionTime Gets or sets the maximum insertion time.
     * @param workflowUserID Gets or sets the workflow user identifier.
     * @param workflowGroupID Gets or sets the workflow group identifier.
     * @param operation Gets or sets the operation. Possible values include: 'None', 'Update', 'Reset', 'Override', 'Null'
     * @param category Gets or sets the category. Possible values include: 'None', 'Direct', 'AdHoc', 'Production', 'Review', 'Reset', 'RoutingSlip', 'ReviewRoutingSlip', 'Override'
     * @param status Gets or sets the status. Possible values include: 'None', 'Approved', 'Rejected', 'Suspended', 'ApprovedR', 'NoneR'
     * @param state Gets or sets the state. Possible values include: 'None', 'Processed', 'Pending', 'Waiting', 'ProcessedR', 'Override', 'OverrideR', 'WaitingR'
     * @param minIndex1 Gets or sets the minimum index 1.
     * @param maxIndex1 Gets or sets the maximum index 1.
     * @param minIndex2 Gets or sets the minimum index 2.
     * @param maxIndex2 Gets or sets the maximum index 2.
     * @param page Gets or sets the page number.
     * @param pageSize Gets or sets the size of the page.
     * @param sortOrder Gets or sets the order. Possible values include: 'Unspecified', 'Ascending', 'Descending'
     * @param sortBy Gets or sets the column to order by. Possible values include: 'ID', 'Type', 'QueueID', 'WorkflowTime', 'InsertionTime', 'Index'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;FlowModel&gt; object
     */
    public Observable<List<FlowModel>> getFlowsByFilterAsync(int drawerID, int entityID, String type, Integer queueID, DateTime minWorkflowTime, DateTime maxWorkflowTime, DateTime minInsertionTime, DateTime maxInsertionTime, Integer workflowUserID, Integer workflowGroupID, String operation, String category, String status, String state, Integer minIndex1, Integer maxIndex1, Integer minIndex2, Integer maxIndex2, Integer page, Integer pageSize, String sortOrder, String sortBy) {
        return getFlowsByFilterWithServiceResponseAsync(drawerID, entityID, type, queueID, minWorkflowTime, maxWorkflowTime, minInsertionTime, maxInsertionTime, workflowUserID, workflowGroupID, operation, category, status, state, minIndex1, maxIndex1, minIndex2, maxIndex2, page, pageSize, sortOrder, sortBy).map(new Func1<ServiceResponse<List<FlowModel>>, List<FlowModel>>() {
            @Override
            public List<FlowModel> call(ServiceResponse<List<FlowModel>> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets a paged list of flows.
     *
     * @param drawerID Gets or sets the drawer identifier.
     * @param entityID Gets or sets the entity identifier.
     * @param type Gets or sets the type. Possible values include: 'None', 'Workflow', 'Fatal', 'Warning', 'Info', 'Debug', 'Process', 'Rpc', 'Sql', 'Dde'
     * @param queueID Gets or sets the queue identifier.
     * @param minWorkflowTime Gets or sets the minimum workflow time.
     * @param maxWorkflowTime Gets or sets the maximum workflow time.
     * @param minInsertionTime Gets or sets the minimum insertion time.
     * @param maxInsertionTime Gets or sets the maximum insertion time.
     * @param workflowUserID Gets or sets the workflow user identifier.
     * @param workflowGroupID Gets or sets the workflow group identifier.
     * @param operation Gets or sets the operation. Possible values include: 'None', 'Update', 'Reset', 'Override', 'Null'
     * @param category Gets or sets the category. Possible values include: 'None', 'Direct', 'AdHoc', 'Production', 'Review', 'Reset', 'RoutingSlip', 'ReviewRoutingSlip', 'Override'
     * @param status Gets or sets the status. Possible values include: 'None', 'Approved', 'Rejected', 'Suspended', 'ApprovedR', 'NoneR'
     * @param state Gets or sets the state. Possible values include: 'None', 'Processed', 'Pending', 'Waiting', 'ProcessedR', 'Override', 'OverrideR', 'WaitingR'
     * @param minIndex1 Gets or sets the minimum index 1.
     * @param maxIndex1 Gets or sets the maximum index 1.
     * @param minIndex2 Gets or sets the minimum index 2.
     * @param maxIndex2 Gets or sets the maximum index 2.
     * @param page Gets or sets the page number.
     * @param pageSize Gets or sets the size of the page.
     * @param sortOrder Gets or sets the order. Possible values include: 'Unspecified', 'Ascending', 'Descending'
     * @param sortBy Gets or sets the column to order by. Possible values include: 'ID', 'Type', 'QueueID', 'WorkflowTime', 'InsertionTime', 'Index'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;FlowModel&gt; object
     */
    public Observable<ServiceResponse<List<FlowModel>>> getFlowsByFilterWithServiceResponseAsync(int drawerID, int entityID, String type, Integer queueID, DateTime minWorkflowTime, DateTime maxWorkflowTime, DateTime minInsertionTime, DateTime maxInsertionTime, Integer workflowUserID, Integer workflowGroupID, String operation, String category, String status, String state, Integer minIndex1, Integer maxIndex1, Integer minIndex2, Integer maxIndex2, Integer page, Integer pageSize, String sortOrder, String sortBy) {
        return service.getFlowsByFilter(drawerID, entityID, type, queueID, minWorkflowTime, maxWorkflowTime, minInsertionTime, maxInsertionTime, workflowUserID, workflowGroupID, operation, category, status, state, minIndex1, maxIndex1, minIndex2, maxIndex2, page, pageSize, sortOrder, sortBy)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<FlowModel>>>>() {
                @Override
                public Observable<ServiceResponse<List<FlowModel>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<FlowModel>> clientResponse = getFlowsByFilterDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<List<FlowModel>> getFlowsByFilterDelegate(Response<ResponseBody> response) throws RestException, IOException {
        return this.restClient().responseBuilderFactory().<List<FlowModel>, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<List<FlowModel>>() { }.getType())
                .build(response);
    }

    /**
     * Gets a single flow based on its unique identifier.
     *
     * @param drawer The drawer identifier.
     * @param id The flow identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the FlowModel object if successful.
     */
    public FlowModel getFlowById(int drawer, int id) {
        return getFlowByIdWithServiceResponseAsync(drawer, id).toBlocking().single().body();
    }

    /**
     * Gets a single flow based on its unique identifier.
     *
     * @param drawer The drawer identifier.
     * @param id The flow identifier.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<FlowModel> getFlowByIdAsync(int drawer, int id, final ServiceCallback<FlowModel> serviceCallback) {
        return ServiceFuture.fromResponse(getFlowByIdWithServiceResponseAsync(drawer, id), serviceCallback);
    }

    /**
     * Gets a single flow based on its unique identifier.
     *
     * @param drawer The drawer identifier.
     * @param id The flow identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the FlowModel object
     */
    public Observable<FlowModel> getFlowByIdAsync(int drawer, int id) {
        return getFlowByIdWithServiceResponseAsync(drawer, id).map(new Func1<ServiceResponse<FlowModel>, FlowModel>() {
            @Override
            public FlowModel call(ServiceResponse<FlowModel> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets a single flow based on its unique identifier.
     *
     * @param drawer The drawer identifier.
     * @param id The flow identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the FlowModel object
     */
    public Observable<ServiceResponse<FlowModel>> getFlowByIdWithServiceResponseAsync(int drawer, int id) {
        return service.getFlowById(drawer, id)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<FlowModel>>>() {
                @Override
                public Observable<ServiceResponse<FlowModel>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<FlowModel> clientResponse = getFlowByIdDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<FlowModel> getFlowByIdDelegate(Response<ResponseBody> response) throws RestException, IOException {
        return this.restClient().responseBuilderFactory().<FlowModel, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<FlowModel>() { }.getType())
                .register(404, new TypeToken<Void>() { }.getType())
                .build(response);
    }

    /**
     * Gets a paged list of entity template definitions.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;EntityDefinitionModel&gt; object if successful.
     */
    public List<EntityDefinitionModel> getTemplatesByFilter() {
        return getTemplatesByFilterWithServiceResponseAsync().toBlocking().single().body();
    }

    /**
     * Gets a paged list of entity template definitions.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<EntityDefinitionModel>> getTemplatesByFilterAsync(final ServiceCallback<List<EntityDefinitionModel>> serviceCallback) {
        return ServiceFuture.fromResponse(getTemplatesByFilterWithServiceResponseAsync(), serviceCallback);
    }

    /**
     * Gets a paged list of entity template definitions.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;EntityDefinitionModel&gt; object
     */
    public Observable<List<EntityDefinitionModel>> getTemplatesByFilterAsync() {
        return getTemplatesByFilterWithServiceResponseAsync().map(new Func1<ServiceResponse<List<EntityDefinitionModel>>, List<EntityDefinitionModel>>() {
            @Override
            public List<EntityDefinitionModel> call(ServiceResponse<List<EntityDefinitionModel>> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets a paged list of entity template definitions.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;EntityDefinitionModel&gt; object
     */
    public Observable<ServiceResponse<List<EntityDefinitionModel>>> getTemplatesByFilterWithServiceResponseAsync() {
        final Integer drawerID = null;
        final String name = null;
        final String category = null;
        final Integer page = null;
        final Integer pageSize = null;
        final String sortOrder = null;
        final Integer sortBy = null;
        return service.getTemplatesByFilter(drawerID, name, category, page, pageSize, sortOrder, sortBy)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<EntityDefinitionModel>>>>() {
                @Override
                public Observable<ServiceResponse<List<EntityDefinitionModel>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<EntityDefinitionModel>> clientResponse = getTemplatesByFilterDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Gets a paged list of entity template definitions.
     *
     * @param drawerID Gets or sets the drawer identifier.
     * @param name Gets or sets the name.
     * @param category Gets or sets the category.
     * @param page Gets or sets the page number.
     * @param pageSize Gets or sets the size of the page.
     * @param sortOrder Gets or sets the order. Possible values include: 'Unspecified', 'Ascending', 'Descending'
     * @param sortBy Gets or sets the column to order by.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;EntityDefinitionModel&gt; object if successful.
     */
    public List<EntityDefinitionModel> getTemplatesByFilter(Integer drawerID, String name, String category, Integer page, Integer pageSize, String sortOrder, Integer sortBy) {
        return getTemplatesByFilterWithServiceResponseAsync(drawerID, name, category, page, pageSize, sortOrder, sortBy).toBlocking().single().body();
    }

    /**
     * Gets a paged list of entity template definitions.
     *
     * @param drawerID Gets or sets the drawer identifier.
     * @param name Gets or sets the name.
     * @param category Gets or sets the category.
     * @param page Gets or sets the page number.
     * @param pageSize Gets or sets the size of the page.
     * @param sortOrder Gets or sets the order. Possible values include: 'Unspecified', 'Ascending', 'Descending'
     * @param sortBy Gets or sets the column to order by.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<EntityDefinitionModel>> getTemplatesByFilterAsync(Integer drawerID, String name, String category, Integer page, Integer pageSize, String sortOrder, Integer sortBy, final ServiceCallback<List<EntityDefinitionModel>> serviceCallback) {
        return ServiceFuture.fromResponse(getTemplatesByFilterWithServiceResponseAsync(drawerID, name, category, page, pageSize, sortOrder, sortBy), serviceCallback);
    }

    /**
     * Gets a paged list of entity template definitions.
     *
     * @param drawerID Gets or sets the drawer identifier.
     * @param name Gets or sets the name.
     * @param category Gets or sets the category.
     * @param page Gets or sets the page number.
     * @param pageSize Gets or sets the size of the page.
     * @param sortOrder Gets or sets the order. Possible values include: 'Unspecified', 'Ascending', 'Descending'
     * @param sortBy Gets or sets the column to order by.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;EntityDefinitionModel&gt; object
     */
    public Observable<List<EntityDefinitionModel>> getTemplatesByFilterAsync(Integer drawerID, String name, String category, Integer page, Integer pageSize, String sortOrder, Integer sortBy) {
        return getTemplatesByFilterWithServiceResponseAsync(drawerID, name, category, page, pageSize, sortOrder, sortBy).map(new Func1<ServiceResponse<List<EntityDefinitionModel>>, List<EntityDefinitionModel>>() {
            @Override
            public List<EntityDefinitionModel> call(ServiceResponse<List<EntityDefinitionModel>> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets a paged list of entity template definitions.
     *
     * @param drawerID Gets or sets the drawer identifier.
     * @param name Gets or sets the name.
     * @param category Gets or sets the category.
     * @param page Gets or sets the page number.
     * @param pageSize Gets or sets the size of the page.
     * @param sortOrder Gets or sets the order. Possible values include: 'Unspecified', 'Ascending', 'Descending'
     * @param sortBy Gets or sets the column to order by.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;EntityDefinitionModel&gt; object
     */
    public Observable<ServiceResponse<List<EntityDefinitionModel>>> getTemplatesByFilterWithServiceResponseAsync(Integer drawerID, String name, String category, Integer page, Integer pageSize, String sortOrder, Integer sortBy) {
        return service.getTemplatesByFilter(drawerID, name, category, page, pageSize, sortOrder, sortBy)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<EntityDefinitionModel>>>>() {
                @Override
                public Observable<ServiceResponse<List<EntityDefinitionModel>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<EntityDefinitionModel>> clientResponse = getTemplatesByFilterDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<List<EntityDefinitionModel>> getTemplatesByFilterDelegate(Response<ResponseBody> response) throws RestException, IOException {
        return this.restClient().responseBuilderFactory().<List<EntityDefinitionModel>, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<List<EntityDefinitionModel>>() { }.getType())
                .build(response);
    }

    /**
     * Creates a new entity template definition.
     *
     * @param model The entity template model.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the EntityDefinitionModel object if successful.
     */
    public EntityDefinitionModel createTemplate(EntityDefinitionBase model) {
        return createTemplateWithServiceResponseAsync(model).toBlocking().single().body();
    }

    /**
     * Creates a new entity template definition.
     *
     * @param model The entity template model.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<EntityDefinitionModel> createTemplateAsync(EntityDefinitionBase model, final ServiceCallback<EntityDefinitionModel> serviceCallback) {
        return ServiceFuture.fromResponse(createTemplateWithServiceResponseAsync(model), serviceCallback);
    }

    /**
     * Creates a new entity template definition.
     *
     * @param model The entity template model.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the EntityDefinitionModel object
     */
    public Observable<EntityDefinitionModel> createTemplateAsync(EntityDefinitionBase model) {
        return createTemplateWithServiceResponseAsync(model).map(new Func1<ServiceResponse<EntityDefinitionModel>, EntityDefinitionModel>() {
            @Override
            public EntityDefinitionModel call(ServiceResponse<EntityDefinitionModel> response) {
                return response.body();
            }
        });
    }

    /**
     * Creates a new entity template definition.
     *
     * @param model The entity template model.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the EntityDefinitionModel object
     */
    public Observable<ServiceResponse<EntityDefinitionModel>> createTemplateWithServiceResponseAsync(EntityDefinitionBase model) {
        if (model == null) {
            throw new IllegalArgumentException("Parameter model is required and cannot be null.");
        }
        Validator.validate(model);
        return service.createTemplate(model)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<EntityDefinitionModel>>>() {
                @Override
                public Observable<ServiceResponse<EntityDefinitionModel>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<EntityDefinitionModel> clientResponse = createTemplateDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<EntityDefinitionModel> createTemplateDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<EntityDefinitionModel, RestException>newInstance(this.serializerAdapter())
                .register(201, new TypeToken<EntityDefinitionModel>() { }.getType())
                .register(403, new TypeToken<Void>() { }.getType())
                .register(404, new TypeToken<Void>() { }.getType())
                .register(409, new TypeToken<Void>() { }.getType())
                .build(response);
    }

    /**
     * Gets a single entity template definition by its type.
     *
     * @param type The unique template type.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the EntityDefinitionModel object if successful.
     */
    public EntityDefinitionModel getTemplateByType(int type) {
        return getTemplateByTypeWithServiceResponseAsync(type).toBlocking().single().body();
    }

    /**
     * Gets a single entity template definition by its type.
     *
     * @param type The unique template type.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<EntityDefinitionModel> getTemplateByTypeAsync(int type, final ServiceCallback<EntityDefinitionModel> serviceCallback) {
        return ServiceFuture.fromResponse(getTemplateByTypeWithServiceResponseAsync(type), serviceCallback);
    }

    /**
     * Gets a single entity template definition by its type.
     *
     * @param type The unique template type.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the EntityDefinitionModel object
     */
    public Observable<EntityDefinitionModel> getTemplateByTypeAsync(int type) {
        return getTemplateByTypeWithServiceResponseAsync(type).map(new Func1<ServiceResponse<EntityDefinitionModel>, EntityDefinitionModel>() {
            @Override
            public EntityDefinitionModel call(ServiceResponse<EntityDefinitionModel> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets a single entity template definition by its type.
     *
     * @param type The unique template type.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the EntityDefinitionModel object
     */
    public Observable<ServiceResponse<EntityDefinitionModel>> getTemplateByTypeWithServiceResponseAsync(int type) {
        return service.getTemplateByType(type)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<EntityDefinitionModel>>>() {
                @Override
                public Observable<ServiceResponse<EntityDefinitionModel>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<EntityDefinitionModel> clientResponse = getTemplateByTypeDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<EntityDefinitionModel> getTemplateByTypeDelegate(Response<ResponseBody> response) throws RestException, IOException {
        return this.restClient().responseBuilderFactory().<EntityDefinitionModel, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<EntityDefinitionModel>() { }.getType())
                .register(404, new TypeToken<Void>() { }.getType())
                .build(response);
    }

    /**
     * Updates a specified entity template definition by type.
     *
     * @param type The unique template type.
     * @param model The entity template model.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object updateTemplateByType(int type, UpdateEntityDefinitionRequestModel model) {
        return updateTemplateByTypeWithServiceResponseAsync(type, model).toBlocking().single().body();
    }

    /**
     * Updates a specified entity template definition by type.
     *
     * @param type The unique template type.
     * @param model The entity template model.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> updateTemplateByTypeAsync(int type, UpdateEntityDefinitionRequestModel model, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromResponse(updateTemplateByTypeWithServiceResponseAsync(type, model), serviceCallback);
    }

    /**
     * Updates a specified entity template definition by type.
     *
     * @param type The unique template type.
     * @param model The entity template model.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> updateTemplateByTypeAsync(int type, UpdateEntityDefinitionRequestModel model) {
        return updateTemplateByTypeWithServiceResponseAsync(type, model).map(new Func1<ServiceResponse<Object>, Object>() {
            @Override
            public Object call(ServiceResponse<Object> response) {
                return response.body();
            }
        });
    }

    /**
     * Updates a specified entity template definition by type.
     *
     * @param type The unique template type.
     * @param model The entity template model.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> updateTemplateByTypeWithServiceResponseAsync(int type, UpdateEntityDefinitionRequestModel model) {
        if (model == null) {
            throw new IllegalArgumentException("Parameter model is required and cannot be null.");
        }
        Validator.validate(model);
        return service.updateTemplateByType(type, model)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = updateTemplateByTypeDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Object> updateTemplateByTypeDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<Object, RestException>newInstance(this.serializerAdapter())
                .register(204, new TypeToken<Object>() { }.getType())
                .register(403, new TypeToken<Void>() { }.getType())
                .register(404, new TypeToken<Void>() { }.getType())
                .build(response);
    }

    /**
     * Deletes a specified entity template definition by type.
     *
     * @param type The unique template type.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object deleteTemplateByType(int type) {
        return deleteTemplateByTypeWithServiceResponseAsync(type).toBlocking().single().body();
    }

    /**
     * Deletes a specified entity template definition by type.
     *
     * @param type The unique template type.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> deleteTemplateByTypeAsync(int type, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromResponse(deleteTemplateByTypeWithServiceResponseAsync(type), serviceCallback);
    }

    /**
     * Deletes a specified entity template definition by type.
     *
     * @param type The unique template type.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> deleteTemplateByTypeAsync(int type) {
        return deleteTemplateByTypeWithServiceResponseAsync(type).map(new Func1<ServiceResponse<Object>, Object>() {
            @Override
            public Object call(ServiceResponse<Object> response) {
                return response.body();
            }
        });
    }

    /**
     * Deletes a specified entity template definition by type.
     *
     * @param type The unique template type.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> deleteTemplateByTypeWithServiceResponseAsync(int type) {
        return service.deleteTemplateByType(type)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = deleteTemplateByTypeDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Object> deleteTemplateByTypeDelegate(Response<ResponseBody> response) throws RestException, IOException {
        return this.restClient().responseBuilderFactory().<Object, RestException>newInstance(this.serializerAdapter())
                .register(204, new TypeToken<Object>() { }.getType())
                .register(403, new TypeToken<Void>() { }.getType())
                .register(404, new TypeToken<Void>() { }.getType())
                .build(response);
    }

    /**
     * Gets a single entity template definition by its unique identifier.
     *
     * @param id The template identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the EntityDefinitionModel object if successful.
     */
    public EntityDefinitionModel getTemplateById(String id) {
        return getTemplateByIdWithServiceResponseAsync(id).toBlocking().single().body();
    }

    /**
     * Gets a single entity template definition by its unique identifier.
     *
     * @param id The template identifier.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<EntityDefinitionModel> getTemplateByIdAsync(String id, final ServiceCallback<EntityDefinitionModel> serviceCallback) {
        return ServiceFuture.fromResponse(getTemplateByIdWithServiceResponseAsync(id), serviceCallback);
    }

    /**
     * Gets a single entity template definition by its unique identifier.
     *
     * @param id The template identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the EntityDefinitionModel object
     */
    public Observable<EntityDefinitionModel> getTemplateByIdAsync(String id) {
        return getTemplateByIdWithServiceResponseAsync(id).map(new Func1<ServiceResponse<EntityDefinitionModel>, EntityDefinitionModel>() {
            @Override
            public EntityDefinitionModel call(ServiceResponse<EntityDefinitionModel> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets a single entity template definition by its unique identifier.
     *
     * @param id The template identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the EntityDefinitionModel object
     */
    public Observable<ServiceResponse<EntityDefinitionModel>> getTemplateByIdWithServiceResponseAsync(String id) {
        if (id == null) {
            throw new IllegalArgumentException("Parameter id is required and cannot be null.");
        }
        return service.getTemplateById(id)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<EntityDefinitionModel>>>() {
                @Override
                public Observable<ServiceResponse<EntityDefinitionModel>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<EntityDefinitionModel> clientResponse = getTemplateByIdDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<EntityDefinitionModel> getTemplateByIdDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<EntityDefinitionModel, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<EntityDefinitionModel>() { }.getType())
                .register(404, new TypeToken<Void>() { }.getType())
                .build(response);
    }

    /**
     * Updates a specified entity template definition by identifier.
     *
     * @param id The unique template identifier.
     * @param model The entity template model.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object updateTemplateById(String id, UpdateEntityDefinitionRequestModel model) {
        return updateTemplateByIdWithServiceResponseAsync(id, model).toBlocking().single().body();
    }

    /**
     * Updates a specified entity template definition by identifier.
     *
     * @param id The unique template identifier.
     * @param model The entity template model.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> updateTemplateByIdAsync(String id, UpdateEntityDefinitionRequestModel model, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromResponse(updateTemplateByIdWithServiceResponseAsync(id, model), serviceCallback);
    }

    /**
     * Updates a specified entity template definition by identifier.
     *
     * @param id The unique template identifier.
     * @param model The entity template model.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> updateTemplateByIdAsync(String id, UpdateEntityDefinitionRequestModel model) {
        return updateTemplateByIdWithServiceResponseAsync(id, model).map(new Func1<ServiceResponse<Object>, Object>() {
            @Override
            public Object call(ServiceResponse<Object> response) {
                return response.body();
            }
        });
    }

    /**
     * Updates a specified entity template definition by identifier.
     *
     * @param id The unique template identifier.
     * @param model The entity template model.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> updateTemplateByIdWithServiceResponseAsync(String id, UpdateEntityDefinitionRequestModel model) {
        if (id == null) {
            throw new IllegalArgumentException("Parameter id is required and cannot be null.");
        }
        if (model == null) {
            throw new IllegalArgumentException("Parameter model is required and cannot be null.");
        }
        Validator.validate(model);
        return service.updateTemplateById(id, model)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = updateTemplateByIdDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Object> updateTemplateByIdDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<Object, RestException>newInstance(this.serializerAdapter())
                .register(204, new TypeToken<Object>() { }.getType())
                .register(403, new TypeToken<Void>() { }.getType())
                .register(404, new TypeToken<Void>() { }.getType())
                .build(response);
    }

    /**
     * Deletes a specified entity template definition by identifier.
     *
     * @param id The unique template identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object deleteTemplateById(String id) {
        return deleteTemplateByIdWithServiceResponseAsync(id).toBlocking().single().body();
    }

    /**
     * Deletes a specified entity template definition by identifier.
     *
     * @param id The unique template identifier.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> deleteTemplateByIdAsync(String id, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromResponse(deleteTemplateByIdWithServiceResponseAsync(id), serviceCallback);
    }

    /**
     * Deletes a specified entity template definition by identifier.
     *
     * @param id The unique template identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> deleteTemplateByIdAsync(String id) {
        return deleteTemplateByIdWithServiceResponseAsync(id).map(new Func1<ServiceResponse<Object>, Object>() {
            @Override
            public Object call(ServiceResponse<Object> response) {
                return response.body();
            }
        });
    }

    /**
     * Deletes a specified entity template definition by identifier.
     *
     * @param id The unique template identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> deleteTemplateByIdWithServiceResponseAsync(String id) {
        if (id == null) {
            throw new IllegalArgumentException("Parameter id is required and cannot be null.");
        }
        return service.deleteTemplateById(id)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = deleteTemplateByIdDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Object> deleteTemplateByIdDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<Object, RestException>newInstance(this.serializerAdapter())
                .register(204, new TypeToken<Object>() { }.getType())
                .register(403, new TypeToken<Void>() { }.getType())
                .register(404, new TypeToken<Void>() { }.getType())
                .build(response);
    }

    /**
     * Validates the specified template field.
     *
     * @param type The template type.
     * @param fieldID The field name.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the FieldValidationModel object if successful.
     */
    public FieldValidationModel validateTemplateField(int type, String fieldID) {
        return validateTemplateFieldWithServiceResponseAsync(type, fieldID).toBlocking().single().body();
    }

    /**
     * Validates the specified template field.
     *
     * @param type The template type.
     * @param fieldID The field name.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<FieldValidationModel> validateTemplateFieldAsync(int type, String fieldID, final ServiceCallback<FieldValidationModel> serviceCallback) {
        return ServiceFuture.fromResponse(validateTemplateFieldWithServiceResponseAsync(type, fieldID), serviceCallback);
    }

    /**
     * Validates the specified template field.
     *
     * @param type The template type.
     * @param fieldID The field name.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the FieldValidationModel object
     */
    public Observable<FieldValidationModel> validateTemplateFieldAsync(int type, String fieldID) {
        return validateTemplateFieldWithServiceResponseAsync(type, fieldID).map(new Func1<ServiceResponse<FieldValidationModel>, FieldValidationModel>() {
            @Override
            public FieldValidationModel call(ServiceResponse<FieldValidationModel> response) {
                return response.body();
            }
        });
    }

    /**
     * Validates the specified template field.
     *
     * @param type The template type.
     * @param fieldID The field name.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the FieldValidationModel object
     */
    public Observable<ServiceResponse<FieldValidationModel>> validateTemplateFieldWithServiceResponseAsync(int type, String fieldID) {
        if (fieldID == null) {
            throw new IllegalArgumentException("Parameter fieldID is required and cannot be null.");
        }
        final String sortColumn = null;
        final List<Object> metadata = null;
        final Integer page = null;
        final Integer pageSize = null;
        final String sortOrder = null;
        final Integer sortBy = null;
        String metadataConverted = this.serializerAdapter().serializeList(metadata, CollectionFormat.MULTI);
        return service.validateTemplateField(type, fieldID, sortColumn, metadataConverted, page, pageSize, sortOrder, sortBy)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<FieldValidationModel>>>() {
                @Override
                public Observable<ServiceResponse<FieldValidationModel>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<FieldValidationModel> clientResponse = validateTemplateFieldDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Validates the specified template field.
     *
     * @param type The template type.
     * @param fieldID The field name.
     * @param sortColumn Gets or sets the sort column.
     * @param metadata Gets or sets the metadata search options.
     * @param page Gets or sets the page number.
     * @param pageSize Gets or sets the size of the page.
     * @param sortOrder Gets or sets the order. Possible values include: 'Unspecified', 'Ascending', 'Descending'
     * @param sortBy Gets or sets the column to order by.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the FieldValidationModel object if successful.
     */
    public FieldValidationModel validateTemplateField(int type, String fieldID, String sortColumn, List<Object> metadata, Integer page, Integer pageSize, String sortOrder, Integer sortBy) {
        return validateTemplateFieldWithServiceResponseAsync(type, fieldID, sortColumn, metadata, page, pageSize, sortOrder, sortBy).toBlocking().single().body();
    }

    /**
     * Validates the specified template field.
     *
     * @param type The template type.
     * @param fieldID The field name.
     * @param sortColumn Gets or sets the sort column.
     * @param metadata Gets or sets the metadata search options.
     * @param page Gets or sets the page number.
     * @param pageSize Gets or sets the size of the page.
     * @param sortOrder Gets or sets the order. Possible values include: 'Unspecified', 'Ascending', 'Descending'
     * @param sortBy Gets or sets the column to order by.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<FieldValidationModel> validateTemplateFieldAsync(int type, String fieldID, String sortColumn, List<Object> metadata, Integer page, Integer pageSize, String sortOrder, Integer sortBy, final ServiceCallback<FieldValidationModel> serviceCallback) {
        return ServiceFuture.fromResponse(validateTemplateFieldWithServiceResponseAsync(type, fieldID, sortColumn, metadata, page, pageSize, sortOrder, sortBy), serviceCallback);
    }

    /**
     * Validates the specified template field.
     *
     * @param type The template type.
     * @param fieldID The field name.
     * @param sortColumn Gets or sets the sort column.
     * @param metadata Gets or sets the metadata search options.
     * @param page Gets or sets the page number.
     * @param pageSize Gets or sets the size of the page.
     * @param sortOrder Gets or sets the order. Possible values include: 'Unspecified', 'Ascending', 'Descending'
     * @param sortBy Gets or sets the column to order by.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the FieldValidationModel object
     */
    public Observable<FieldValidationModel> validateTemplateFieldAsync(int type, String fieldID, String sortColumn, List<Object> metadata, Integer page, Integer pageSize, String sortOrder, Integer sortBy) {
        return validateTemplateFieldWithServiceResponseAsync(type, fieldID, sortColumn, metadata, page, pageSize, sortOrder, sortBy).map(new Func1<ServiceResponse<FieldValidationModel>, FieldValidationModel>() {
            @Override
            public FieldValidationModel call(ServiceResponse<FieldValidationModel> response) {
                return response.body();
            }
        });
    }

    /**
     * Validates the specified template field.
     *
     * @param type The template type.
     * @param fieldID The field name.
     * @param sortColumn Gets or sets the sort column.
     * @param metadata Gets or sets the metadata search options.
     * @param page Gets or sets the page number.
     * @param pageSize Gets or sets the size of the page.
     * @param sortOrder Gets or sets the order. Possible values include: 'Unspecified', 'Ascending', 'Descending'
     * @param sortBy Gets or sets the column to order by.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the FieldValidationModel object
     */
    public Observable<ServiceResponse<FieldValidationModel>> validateTemplateFieldWithServiceResponseAsync(int type, String fieldID, String sortColumn, List<Object> metadata, Integer page, Integer pageSize, String sortOrder, Integer sortBy) {
        if (fieldID == null) {
            throw new IllegalArgumentException("Parameter fieldID is required and cannot be null.");
        }
        Validator.validate(metadata);
        String metadataConverted = this.serializerAdapter().serializeList(metadata, CollectionFormat.MULTI);
        return service.validateTemplateField(type, fieldID, sortColumn, metadataConverted, page, pageSize, sortOrder, sortBy)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<FieldValidationModel>>>() {
                @Override
                public Observable<ServiceResponse<FieldValidationModel>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<FieldValidationModel> clientResponse = validateTemplateFieldDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<FieldValidationModel> validateTemplateFieldDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<FieldValidationModel, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<FieldValidationModel>() { }.getType())
                .register(404, new TypeToken<Void>() { }.getType())
                .build(response);
    }

    /**
     * Gets a paged list of groups.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;GroupModel&gt; object if successful.
     */
    public List<GroupModel> getGroupsByFilter() {
        return getGroupsByFilterWithServiceResponseAsync().toBlocking().single().body();
    }

    /**
     * Gets a paged list of groups.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<GroupModel>> getGroupsByFilterAsync(final ServiceCallback<List<GroupModel>> serviceCallback) {
        return ServiceFuture.fromResponse(getGroupsByFilterWithServiceResponseAsync(), serviceCallback);
    }

    /**
     * Gets a paged list of groups.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;GroupModel&gt; object
     */
    public Observable<List<GroupModel>> getGroupsByFilterAsync() {
        return getGroupsByFilterWithServiceResponseAsync().map(new Func1<ServiceResponse<List<GroupModel>>, List<GroupModel>>() {
            @Override
            public List<GroupModel> call(ServiceResponse<List<GroupModel>> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets a paged list of groups.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;GroupModel&gt; object
     */
    public Observable<ServiceResponse<List<GroupModel>>> getGroupsByFilterWithServiceResponseAsync() {
        final Integer iD = null;
        final Integer userID = null;
        final String name = null;
        final String type = null;
        final String state = null;
        final Integer page = null;
        final Integer pageSize = null;
        final String sortOrder = null;
        final String sortBy = null;
        return service.getGroupsByFilter(iD, userID, name, type, state, page, pageSize, sortOrder, sortBy)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<GroupModel>>>>() {
                @Override
                public Observable<ServiceResponse<List<GroupModel>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<GroupModel>> clientResponse = getGroupsByFilterDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Gets a paged list of groups.
     *
     * @param iD Gets or sets the group identifier.
     * @param userID Gets or sets the user identifier.
     * @param name Gets or sets the name.
     * @param type Gets or sets the type. Possible values include: 'Generic', 'Access', 'Role'
     * @param state Gets or sets the state. Possible values include: 'Inactive', 'Active'
     * @param page Gets or sets the page number.
     * @param pageSize Gets or sets the size of the page.
     * @param sortOrder Gets or sets the order. Possible values include: 'Unspecified', 'Ascending', 'Descending'
     * @param sortBy Gets or sets the column to order by. Possible values include: 'ID', 'Name', 'Type', 'State'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;GroupModel&gt; object if successful.
     */
    public List<GroupModel> getGroupsByFilter(Integer iD, Integer userID, String name, String type, String state, Integer page, Integer pageSize, String sortOrder, String sortBy) {
        return getGroupsByFilterWithServiceResponseAsync(iD, userID, name, type, state, page, pageSize, sortOrder, sortBy).toBlocking().single().body();
    }

    /**
     * Gets a paged list of groups.
     *
     * @param iD Gets or sets the group identifier.
     * @param userID Gets or sets the user identifier.
     * @param name Gets or sets the name.
     * @param type Gets or sets the type. Possible values include: 'Generic', 'Access', 'Role'
     * @param state Gets or sets the state. Possible values include: 'Inactive', 'Active'
     * @param page Gets or sets the page number.
     * @param pageSize Gets or sets the size of the page.
     * @param sortOrder Gets or sets the order. Possible values include: 'Unspecified', 'Ascending', 'Descending'
     * @param sortBy Gets or sets the column to order by. Possible values include: 'ID', 'Name', 'Type', 'State'
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<GroupModel>> getGroupsByFilterAsync(Integer iD, Integer userID, String name, String type, String state, Integer page, Integer pageSize, String sortOrder, String sortBy, final ServiceCallback<List<GroupModel>> serviceCallback) {
        return ServiceFuture.fromResponse(getGroupsByFilterWithServiceResponseAsync(iD, userID, name, type, state, page, pageSize, sortOrder, sortBy), serviceCallback);
    }

    /**
     * Gets a paged list of groups.
     *
     * @param iD Gets or sets the group identifier.
     * @param userID Gets or sets the user identifier.
     * @param name Gets or sets the name.
     * @param type Gets or sets the type. Possible values include: 'Generic', 'Access', 'Role'
     * @param state Gets or sets the state. Possible values include: 'Inactive', 'Active'
     * @param page Gets or sets the page number.
     * @param pageSize Gets or sets the size of the page.
     * @param sortOrder Gets or sets the order. Possible values include: 'Unspecified', 'Ascending', 'Descending'
     * @param sortBy Gets or sets the column to order by. Possible values include: 'ID', 'Name', 'Type', 'State'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;GroupModel&gt; object
     */
    public Observable<List<GroupModel>> getGroupsByFilterAsync(Integer iD, Integer userID, String name, String type, String state, Integer page, Integer pageSize, String sortOrder, String sortBy) {
        return getGroupsByFilterWithServiceResponseAsync(iD, userID, name, type, state, page, pageSize, sortOrder, sortBy).map(new Func1<ServiceResponse<List<GroupModel>>, List<GroupModel>>() {
            @Override
            public List<GroupModel> call(ServiceResponse<List<GroupModel>> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets a paged list of groups.
     *
     * @param iD Gets or sets the group identifier.
     * @param userID Gets or sets the user identifier.
     * @param name Gets or sets the name.
     * @param type Gets or sets the type. Possible values include: 'Generic', 'Access', 'Role'
     * @param state Gets or sets the state. Possible values include: 'Inactive', 'Active'
     * @param page Gets or sets the page number.
     * @param pageSize Gets or sets the size of the page.
     * @param sortOrder Gets or sets the order. Possible values include: 'Unspecified', 'Ascending', 'Descending'
     * @param sortBy Gets or sets the column to order by. Possible values include: 'ID', 'Name', 'Type', 'State'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;GroupModel&gt; object
     */
    public Observable<ServiceResponse<List<GroupModel>>> getGroupsByFilterWithServiceResponseAsync(Integer iD, Integer userID, String name, String type, String state, Integer page, Integer pageSize, String sortOrder, String sortBy) {
        return service.getGroupsByFilter(iD, userID, name, type, state, page, pageSize, sortOrder, sortBy)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<GroupModel>>>>() {
                @Override
                public Observable<ServiceResponse<List<GroupModel>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<GroupModel>> clientResponse = getGroupsByFilterDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<List<GroupModel>> getGroupsByFilterDelegate(Response<ResponseBody> response) throws RestException, IOException {
        return this.restClient().responseBuilderFactory().<List<GroupModel>, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<List<GroupModel>>() { }.getType())
                .register(403, new TypeToken<Void>() { }.getType())
                .build(response);
    }

    /**
     * Creates a new group.
     *
     * @param model The group model.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the GroupModel object if successful.
     */
    public GroupModel createGroup(InsertGroupRequestModel model) {
        return createGroupWithServiceResponseAsync(model).toBlocking().single().body();
    }

    /**
     * Creates a new group.
     *
     * @param model The group model.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<GroupModel> createGroupAsync(InsertGroupRequestModel model, final ServiceCallback<GroupModel> serviceCallback) {
        return ServiceFuture.fromResponse(createGroupWithServiceResponseAsync(model), serviceCallback);
    }

    /**
     * Creates a new group.
     *
     * @param model The group model.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the GroupModel object
     */
    public Observable<GroupModel> createGroupAsync(InsertGroupRequestModel model) {
        return createGroupWithServiceResponseAsync(model).map(new Func1<ServiceResponse<GroupModel>, GroupModel>() {
            @Override
            public GroupModel call(ServiceResponse<GroupModel> response) {
                return response.body();
            }
        });
    }

    /**
     * Creates a new group.
     *
     * @param model The group model.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the GroupModel object
     */
    public Observable<ServiceResponse<GroupModel>> createGroupWithServiceResponseAsync(InsertGroupRequestModel model) {
        if (model == null) {
            throw new IllegalArgumentException("Parameter model is required and cannot be null.");
        }
        Validator.validate(model);
        return service.createGroup(model)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<GroupModel>>>() {
                @Override
                public Observable<ServiceResponse<GroupModel>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<GroupModel> clientResponse = createGroupDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<GroupModel> createGroupDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<GroupModel, RestException>newInstance(this.serializerAdapter())
                .register(201, new TypeToken<GroupModel>() { }.getType())
                .register(403, new TypeToken<Void>() { }.getType())
                .register(409, new TypeToken<Void>() { }.getType())
                .build(response);
    }

    /**
     * Gets a single group by its unique identifier.
     *
     * @param id The group identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the GroupModel object if successful.
     */
    public GroupModel getGroupById(int id) {
        return getGroupByIdWithServiceResponseAsync(id).toBlocking().single().body();
    }

    /**
     * Gets a single group by its unique identifier.
     *
     * @param id The group identifier.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<GroupModel> getGroupByIdAsync(int id, final ServiceCallback<GroupModel> serviceCallback) {
        return ServiceFuture.fromResponse(getGroupByIdWithServiceResponseAsync(id), serviceCallback);
    }

    /**
     * Gets a single group by its unique identifier.
     *
     * @param id The group identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the GroupModel object
     */
    public Observable<GroupModel> getGroupByIdAsync(int id) {
        return getGroupByIdWithServiceResponseAsync(id).map(new Func1<ServiceResponse<GroupModel>, GroupModel>() {
            @Override
            public GroupModel call(ServiceResponse<GroupModel> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets a single group by its unique identifier.
     *
     * @param id The group identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the GroupModel object
     */
    public Observable<ServiceResponse<GroupModel>> getGroupByIdWithServiceResponseAsync(int id) {
        return service.getGroupById(id)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<GroupModel>>>() {
                @Override
                public Observable<ServiceResponse<GroupModel>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<GroupModel> clientResponse = getGroupByIdDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<GroupModel> getGroupByIdDelegate(Response<ResponseBody> response) throws RestException, IOException {
        return this.restClient().responseBuilderFactory().<GroupModel, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<GroupModel>() { }.getType())
                .register(403, new TypeToken<Void>() { }.getType())
                .register(404, new TypeToken<Void>() { }.getType())
                .build(response);
    }

    /**
     * Updates a specified group.
     *
     * @param id The group identifier.
     * @param model The group model.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object updateGroup(int id, GroupBase model) {
        return updateGroupWithServiceResponseAsync(id, model).toBlocking().single().body();
    }

    /**
     * Updates a specified group.
     *
     * @param id The group identifier.
     * @param model The group model.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> updateGroupAsync(int id, GroupBase model, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromResponse(updateGroupWithServiceResponseAsync(id, model), serviceCallback);
    }

    /**
     * Updates a specified group.
     *
     * @param id The group identifier.
     * @param model The group model.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> updateGroupAsync(int id, GroupBase model) {
        return updateGroupWithServiceResponseAsync(id, model).map(new Func1<ServiceResponse<Object>, Object>() {
            @Override
            public Object call(ServiceResponse<Object> response) {
                return response.body();
            }
        });
    }

    /**
     * Updates a specified group.
     *
     * @param id The group identifier.
     * @param model The group model.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> updateGroupWithServiceResponseAsync(int id, GroupBase model) {
        if (model == null) {
            throw new IllegalArgumentException("Parameter model is required and cannot be null.");
        }
        Validator.validate(model);
        return service.updateGroup(id, model)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = updateGroupDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Object> updateGroupDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<Object, RestException>newInstance(this.serializerAdapter())
                .register(204, new TypeToken<Object>() { }.getType())
                .register(403, new TypeToken<Void>() { }.getType())
                .register(404, new TypeToken<Void>() { }.getType())
                .register(500, new TypeToken<Void>() { }.getType())
                .build(response);
    }

    /**
     * Deactivates a group and removes all group associations.
     *
     * @param id The group identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object deleteGroup(int id) {
        return deleteGroupWithServiceResponseAsync(id).toBlocking().single().body();
    }

    /**
     * Deactivates a group and removes all group associations.
     *
     * @param id The group identifier.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> deleteGroupAsync(int id, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromResponse(deleteGroupWithServiceResponseAsync(id), serviceCallback);
    }

    /**
     * Deactivates a group and removes all group associations.
     *
     * @param id The group identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> deleteGroupAsync(int id) {
        return deleteGroupWithServiceResponseAsync(id).map(new Func1<ServiceResponse<Object>, Object>() {
            @Override
            public Object call(ServiceResponse<Object> response) {
                return response.body();
            }
        });
    }

    /**
     * Deactivates a group and removes all group associations.
     *
     * @param id The group identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> deleteGroupWithServiceResponseAsync(int id) {
        return service.deleteGroup(id)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = deleteGroupDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Object> deleteGroupDelegate(Response<ResponseBody> response) throws RestException, IOException {
        return this.restClient().responseBuilderFactory().<Object, RestException>newInstance(this.serializerAdapter())
                .register(204, new TypeToken<Object>() { }.getType())
                .register(403, new TypeToken<Void>() { }.getType())
                .register(404, new TypeToken<Void>() { }.getType())
                .register(500, new TypeToken<Void>() { }.getType())
                .build(response);
    }

    /**
     * Gets a paged list of entity links.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;EntityLinkModel&gt; object if successful.
     */
    public List<EntityLinkModel> getLinksByFilter() {
        return getLinksByFilterWithServiceResponseAsync().toBlocking().single().body();
    }

    /**
     * Gets a paged list of entity links.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<EntityLinkModel>> getLinksByFilterAsync(final ServiceCallback<List<EntityLinkModel>> serviceCallback) {
        return ServiceFuture.fromResponse(getLinksByFilterWithServiceResponseAsync(), serviceCallback);
    }

    /**
     * Gets a paged list of entity links.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;EntityLinkModel&gt; object
     */
    public Observable<List<EntityLinkModel>> getLinksByFilterAsync() {
        return getLinksByFilterWithServiceResponseAsync().map(new Func1<ServiceResponse<List<EntityLinkModel>>, List<EntityLinkModel>>() {
            @Override
            public List<EntityLinkModel> call(ServiceResponse<List<EntityLinkModel>> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets a paged list of entity links.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;EntityLinkModel&gt; object
     */
    public Observable<ServiceResponse<List<EntityLinkModel>>> getLinksByFilterWithServiceResponseAsync() {
        final Integer childEntityID = null;
        final Integer childDrawerID = null;
        final Integer childType = null;
        final Integer acl = null;
        final Integer entityID = null;
        final Integer drawerID = null;
        final String name = null;
        final Integer creatorUserID = null;
        final Integer modifierUserID = null;
        final DateTime minInsertionTime = null;
        final DateTime maxInsertionTime = null;
        final DateTime minModificationTime = null;
        final DateTime maxModificationTime = null;
        final Integer page = null;
        final Integer pageSize = null;
        final String sortOrder = null;
        final String sortBy = null;
        return service.getLinksByFilter(childEntityID, childDrawerID, childType, acl, entityID, drawerID, name, creatorUserID, modifierUserID, minInsertionTime, maxInsertionTime, minModificationTime, maxModificationTime, page, pageSize, sortOrder, sortBy)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<EntityLinkModel>>>>() {
                @Override
                public Observable<ServiceResponse<List<EntityLinkModel>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<EntityLinkModel>> clientResponse = getLinksByFilterDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Gets a paged list of entity links.
     *
     * @param childEntityID Gets or sets the child entity identifier.
     * @param childDrawerID Gets or sets the child drawer identifier.
     * @param childType Gets or sets the type of the child.
     * @param acl Gets or sets the access control list.
     * @param entityID Gets or sets the entity identifier.
     * @param drawerID Gets or sets the drawer identifier.
     * @param name Gets or sets the name.
     * @param creatorUserID Gets or sets the creator user identifier.
     * @param modifierUserID Gets or sets the modifier user identifier.
     * @param minInsertionTime Gets or sets the minimum insertion time.
     * @param maxInsertionTime Gets or sets the maximum insertion time.
     * @param minModificationTime Gets or sets the minimum modification time.
     * @param maxModificationTime Gets or sets the maximum modification time.
     * @param page Gets or sets the page number.
     * @param pageSize Gets or sets the size of the page.
     * @param sortOrder Gets or sets the order. Possible values include: 'Unspecified', 'Ascending', 'Descending'
     * @param sortBy Gets or sets the column to order by. Possible values include: 'PageNumber', 'ID', 'Type', 'InsertionTime', 'ModificationTime', 'CrossReferenceID', 'SubType', 'Extension', 'Name'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;EntityLinkModel&gt; object if successful.
     */
    public List<EntityLinkModel> getLinksByFilter(Integer childEntityID, Integer childDrawerID, Integer childType, Integer acl, Integer entityID, Integer drawerID, String name, Integer creatorUserID, Integer modifierUserID, DateTime minInsertionTime, DateTime maxInsertionTime, DateTime minModificationTime, DateTime maxModificationTime, Integer page, Integer pageSize, String sortOrder, String sortBy) {
        return getLinksByFilterWithServiceResponseAsync(childEntityID, childDrawerID, childType, acl, entityID, drawerID, name, creatorUserID, modifierUserID, minInsertionTime, maxInsertionTime, minModificationTime, maxModificationTime, page, pageSize, sortOrder, sortBy).toBlocking().single().body();
    }

    /**
     * Gets a paged list of entity links.
     *
     * @param childEntityID Gets or sets the child entity identifier.
     * @param childDrawerID Gets or sets the child drawer identifier.
     * @param childType Gets or sets the type of the child.
     * @param acl Gets or sets the access control list.
     * @param entityID Gets or sets the entity identifier.
     * @param drawerID Gets or sets the drawer identifier.
     * @param name Gets or sets the name.
     * @param creatorUserID Gets or sets the creator user identifier.
     * @param modifierUserID Gets or sets the modifier user identifier.
     * @param minInsertionTime Gets or sets the minimum insertion time.
     * @param maxInsertionTime Gets or sets the maximum insertion time.
     * @param minModificationTime Gets or sets the minimum modification time.
     * @param maxModificationTime Gets or sets the maximum modification time.
     * @param page Gets or sets the page number.
     * @param pageSize Gets or sets the size of the page.
     * @param sortOrder Gets or sets the order. Possible values include: 'Unspecified', 'Ascending', 'Descending'
     * @param sortBy Gets or sets the column to order by. Possible values include: 'PageNumber', 'ID', 'Type', 'InsertionTime', 'ModificationTime', 'CrossReferenceID', 'SubType', 'Extension', 'Name'
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<EntityLinkModel>> getLinksByFilterAsync(Integer childEntityID, Integer childDrawerID, Integer childType, Integer acl, Integer entityID, Integer drawerID, String name, Integer creatorUserID, Integer modifierUserID, DateTime minInsertionTime, DateTime maxInsertionTime, DateTime minModificationTime, DateTime maxModificationTime, Integer page, Integer pageSize, String sortOrder, String sortBy, final ServiceCallback<List<EntityLinkModel>> serviceCallback) {
        return ServiceFuture.fromResponse(getLinksByFilterWithServiceResponseAsync(childEntityID, childDrawerID, childType, acl, entityID, drawerID, name, creatorUserID, modifierUserID, minInsertionTime, maxInsertionTime, minModificationTime, maxModificationTime, page, pageSize, sortOrder, sortBy), serviceCallback);
    }

    /**
     * Gets a paged list of entity links.
     *
     * @param childEntityID Gets or sets the child entity identifier.
     * @param childDrawerID Gets or sets the child drawer identifier.
     * @param childType Gets or sets the type of the child.
     * @param acl Gets or sets the access control list.
     * @param entityID Gets or sets the entity identifier.
     * @param drawerID Gets or sets the drawer identifier.
     * @param name Gets or sets the name.
     * @param creatorUserID Gets or sets the creator user identifier.
     * @param modifierUserID Gets or sets the modifier user identifier.
     * @param minInsertionTime Gets or sets the minimum insertion time.
     * @param maxInsertionTime Gets or sets the maximum insertion time.
     * @param minModificationTime Gets or sets the minimum modification time.
     * @param maxModificationTime Gets or sets the maximum modification time.
     * @param page Gets or sets the page number.
     * @param pageSize Gets or sets the size of the page.
     * @param sortOrder Gets or sets the order. Possible values include: 'Unspecified', 'Ascending', 'Descending'
     * @param sortBy Gets or sets the column to order by. Possible values include: 'PageNumber', 'ID', 'Type', 'InsertionTime', 'ModificationTime', 'CrossReferenceID', 'SubType', 'Extension', 'Name'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;EntityLinkModel&gt; object
     */
    public Observable<List<EntityLinkModel>> getLinksByFilterAsync(Integer childEntityID, Integer childDrawerID, Integer childType, Integer acl, Integer entityID, Integer drawerID, String name, Integer creatorUserID, Integer modifierUserID, DateTime minInsertionTime, DateTime maxInsertionTime, DateTime minModificationTime, DateTime maxModificationTime, Integer page, Integer pageSize, String sortOrder, String sortBy) {
        return getLinksByFilterWithServiceResponseAsync(childEntityID, childDrawerID, childType, acl, entityID, drawerID, name, creatorUserID, modifierUserID, minInsertionTime, maxInsertionTime, minModificationTime, maxModificationTime, page, pageSize, sortOrder, sortBy).map(new Func1<ServiceResponse<List<EntityLinkModel>>, List<EntityLinkModel>>() {
            @Override
            public List<EntityLinkModel> call(ServiceResponse<List<EntityLinkModel>> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets a paged list of entity links.
     *
     * @param childEntityID Gets or sets the child entity identifier.
     * @param childDrawerID Gets or sets the child drawer identifier.
     * @param childType Gets or sets the type of the child.
     * @param acl Gets or sets the access control list.
     * @param entityID Gets or sets the entity identifier.
     * @param drawerID Gets or sets the drawer identifier.
     * @param name Gets or sets the name.
     * @param creatorUserID Gets or sets the creator user identifier.
     * @param modifierUserID Gets or sets the modifier user identifier.
     * @param minInsertionTime Gets or sets the minimum insertion time.
     * @param maxInsertionTime Gets or sets the maximum insertion time.
     * @param minModificationTime Gets or sets the minimum modification time.
     * @param maxModificationTime Gets or sets the maximum modification time.
     * @param page Gets or sets the page number.
     * @param pageSize Gets or sets the size of the page.
     * @param sortOrder Gets or sets the order. Possible values include: 'Unspecified', 'Ascending', 'Descending'
     * @param sortBy Gets or sets the column to order by. Possible values include: 'PageNumber', 'ID', 'Type', 'InsertionTime', 'ModificationTime', 'CrossReferenceID', 'SubType', 'Extension', 'Name'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;EntityLinkModel&gt; object
     */
    public Observable<ServiceResponse<List<EntityLinkModel>>> getLinksByFilterWithServiceResponseAsync(Integer childEntityID, Integer childDrawerID, Integer childType, Integer acl, Integer entityID, Integer drawerID, String name, Integer creatorUserID, Integer modifierUserID, DateTime minInsertionTime, DateTime maxInsertionTime, DateTime minModificationTime, DateTime maxModificationTime, Integer page, Integer pageSize, String sortOrder, String sortBy) {
        return service.getLinksByFilter(childEntityID, childDrawerID, childType, acl, entityID, drawerID, name, creatorUserID, modifierUserID, minInsertionTime, maxInsertionTime, minModificationTime, maxModificationTime, page, pageSize, sortOrder, sortBy)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<EntityLinkModel>>>>() {
                @Override
                public Observable<ServiceResponse<List<EntityLinkModel>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<EntityLinkModel>> clientResponse = getLinksByFilterDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<List<EntityLinkModel>> getLinksByFilterDelegate(Response<ResponseBody> response) throws RestException, IOException {
        return this.restClient().responseBuilderFactory().<List<EntityLinkModel>, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<List<EntityLinkModel>>() { }.getType())
                .build(response);
    }

    /**
     * Gets a link based on its unique identifier.
     *
     * @param drawer The drawer identifier.
     * @param id The link identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the EntityLinkModel object if successful.
     */
    public EntityLinkModel getLinkById(int drawer, int id) {
        return getLinkByIdWithServiceResponseAsync(drawer, id).toBlocking().single().body();
    }

    /**
     * Gets a link based on its unique identifier.
     *
     * @param drawer The drawer identifier.
     * @param id The link identifier.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<EntityLinkModel> getLinkByIdAsync(int drawer, int id, final ServiceCallback<EntityLinkModel> serviceCallback) {
        return ServiceFuture.fromResponse(getLinkByIdWithServiceResponseAsync(drawer, id), serviceCallback);
    }

    /**
     * Gets a link based on its unique identifier.
     *
     * @param drawer The drawer identifier.
     * @param id The link identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the EntityLinkModel object
     */
    public Observable<EntityLinkModel> getLinkByIdAsync(int drawer, int id) {
        return getLinkByIdWithServiceResponseAsync(drawer, id).map(new Func1<ServiceResponse<EntityLinkModel>, EntityLinkModel>() {
            @Override
            public EntityLinkModel call(ServiceResponse<EntityLinkModel> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets a link based on its unique identifier.
     *
     * @param drawer The drawer identifier.
     * @param id The link identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the EntityLinkModel object
     */
    public Observable<ServiceResponse<EntityLinkModel>> getLinkByIdWithServiceResponseAsync(int drawer, int id) {
        return service.getLinkById(drawer, id)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<EntityLinkModel>>>() {
                @Override
                public Observable<ServiceResponse<EntityLinkModel>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<EntityLinkModel> clientResponse = getLinkByIdDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<EntityLinkModel> getLinkByIdDelegate(Response<ResponseBody> response) throws RestException, IOException {
        return this.restClient().responseBuilderFactory().<EntityLinkModel, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<EntityLinkModel>() { }.getType())
                .register(403, new TypeToken<Void>() { }.getType())
                .register(404, new TypeToken<Void>() { }.getType())
                .build(response);
    }

    /**
     * Updates a specified link.
     *
     * @param drawer The drawer identifier.
     * @param id The link identifier.
     * @param model The model.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object updateLink(int drawer, int id, UpdateEntityLinkRequestModel model) {
        return updateLinkWithServiceResponseAsync(drawer, id, model).toBlocking().single().body();
    }

    /**
     * Updates a specified link.
     *
     * @param drawer The drawer identifier.
     * @param id The link identifier.
     * @param model The model.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> updateLinkAsync(int drawer, int id, UpdateEntityLinkRequestModel model, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromResponse(updateLinkWithServiceResponseAsync(drawer, id, model), serviceCallback);
    }

    /**
     * Updates a specified link.
     *
     * @param drawer The drawer identifier.
     * @param id The link identifier.
     * @param model The model.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> updateLinkAsync(int drawer, int id, UpdateEntityLinkRequestModel model) {
        return updateLinkWithServiceResponseAsync(drawer, id, model).map(new Func1<ServiceResponse<Object>, Object>() {
            @Override
            public Object call(ServiceResponse<Object> response) {
                return response.body();
            }
        });
    }

    /**
     * Updates a specified link.
     *
     * @param drawer The drawer identifier.
     * @param id The link identifier.
     * @param model The model.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> updateLinkWithServiceResponseAsync(int drawer, int id, UpdateEntityLinkRequestModel model) {
        if (model == null) {
            throw new IllegalArgumentException("Parameter model is required and cannot be null.");
        }
        Validator.validate(model);
        return service.updateLink(drawer, id, model)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = updateLinkDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Object> updateLinkDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<Object, RestException>newInstance(this.serializerAdapter())
                .register(204, new TypeToken<Object>() { }.getType())
                .register(403, new TypeToken<Void>() { }.getType())
                .register(404, new TypeToken<Void>() { }.getType())
                .build(response);
    }

    /**
     * Deletes a specified link.
     *
     * @param drawer The drawer identifier.
     * @param id The link identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object deleteLink(int drawer, int id) {
        return deleteLinkWithServiceResponseAsync(drawer, id).toBlocking().single().body();
    }

    /**
     * Deletes a specified link.
     *
     * @param drawer The drawer identifier.
     * @param id The link identifier.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> deleteLinkAsync(int drawer, int id, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromResponse(deleteLinkWithServiceResponseAsync(drawer, id), serviceCallback);
    }

    /**
     * Deletes a specified link.
     *
     * @param drawer The drawer identifier.
     * @param id The link identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> deleteLinkAsync(int drawer, int id) {
        return deleteLinkWithServiceResponseAsync(drawer, id).map(new Func1<ServiceResponse<Object>, Object>() {
            @Override
            public Object call(ServiceResponse<Object> response) {
                return response.body();
            }
        });
    }

    /**
     * Deletes a specified link.
     *
     * @param drawer The drawer identifier.
     * @param id The link identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> deleteLinkWithServiceResponseAsync(int drawer, int id) {
        return service.deleteLink(drawer, id)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = deleteLinkDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Object> deleteLinkDelegate(Response<ResponseBody> response) throws RestException, IOException {
        return this.restClient().responseBuilderFactory().<Object, RestException>newInstance(this.serializerAdapter())
                .register(204, new TypeToken<Object>() { }.getType())
                .register(403, new TypeToken<Void>() { }.getType())
                .register(404, new TypeToken<Void>() { }.getType())
                .build(response);
    }

    /**
     * Creates a new link.
     *
     * @param drawer The drawer identifier.
     * @param model The link model.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the EntityLinkModel object if successful.
     */
    public EntityLinkModel createLink(int drawer, InsertEntityLinkRequestModel model) {
        return createLinkWithServiceResponseAsync(drawer, model).toBlocking().single().body();
    }

    /**
     * Creates a new link.
     *
     * @param drawer The drawer identifier.
     * @param model The link model.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<EntityLinkModel> createLinkAsync(int drawer, InsertEntityLinkRequestModel model, final ServiceCallback<EntityLinkModel> serviceCallback) {
        return ServiceFuture.fromResponse(createLinkWithServiceResponseAsync(drawer, model), serviceCallback);
    }

    /**
     * Creates a new link.
     *
     * @param drawer The drawer identifier.
     * @param model The link model.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the EntityLinkModel object
     */
    public Observable<EntityLinkModel> createLinkAsync(int drawer, InsertEntityLinkRequestModel model) {
        return createLinkWithServiceResponseAsync(drawer, model).map(new Func1<ServiceResponse<EntityLinkModel>, EntityLinkModel>() {
            @Override
            public EntityLinkModel call(ServiceResponse<EntityLinkModel> response) {
                return response.body();
            }
        });
    }

    /**
     * Creates a new link.
     *
     * @param drawer The drawer identifier.
     * @param model The link model.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the EntityLinkModel object
     */
    public Observable<ServiceResponse<EntityLinkModel>> createLinkWithServiceResponseAsync(int drawer, InsertEntityLinkRequestModel model) {
        if (model == null) {
            throw new IllegalArgumentException("Parameter model is required and cannot be null.");
        }
        Validator.validate(model);
        return service.createLink(drawer, model)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<EntityLinkModel>>>() {
                @Override
                public Observable<ServiceResponse<EntityLinkModel>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<EntityLinkModel> clientResponse = createLinkDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<EntityLinkModel> createLinkDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<EntityLinkModel, RestException>newInstance(this.serializerAdapter())
                .register(201, new TypeToken<EntityLinkModel>() { }.getType())
                .register(403, new TypeToken<Void>() { }.getType())
                .register(404, new TypeToken<Void>() { }.getType())
                .register(409, new TypeToken<Void>() { }.getType())
                .build(response);
    }

    /**
     * Gets a lock for a single entity based on its unique identifier.
     *
     * @param drawer The drawer identifier.
     * @param id The entity identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the LockModel object if successful.
     */
    public LockModel getLocksByFilter(int drawer, int id) {
        return getLocksByFilterWithServiceResponseAsync(drawer, id).toBlocking().single().body();
    }

    /**
     * Gets a lock for a single entity based on its unique identifier.
     *
     * @param drawer The drawer identifier.
     * @param id The entity identifier.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<LockModel> getLocksByFilterAsync(int drawer, int id, final ServiceCallback<LockModel> serviceCallback) {
        return ServiceFuture.fromResponse(getLocksByFilterWithServiceResponseAsync(drawer, id), serviceCallback);
    }

    /**
     * Gets a lock for a single entity based on its unique identifier.
     *
     * @param drawer The drawer identifier.
     * @param id The entity identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the LockModel object
     */
    public Observable<LockModel> getLocksByFilterAsync(int drawer, int id) {
        return getLocksByFilterWithServiceResponseAsync(drawer, id).map(new Func1<ServiceResponse<LockModel>, LockModel>() {
            @Override
            public LockModel call(ServiceResponse<LockModel> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets a lock for a single entity based on its unique identifier.
     *
     * @param drawer The drawer identifier.
     * @param id The entity identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the LockModel object
     */
    public Observable<ServiceResponse<LockModel>> getLocksByFilterWithServiceResponseAsync(int drawer, int id) {
        return service.getLocksByFilter(drawer, id)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<LockModel>>>() {
                @Override
                public Observable<ServiceResponse<LockModel>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<LockModel> clientResponse = getLocksByFilterDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<LockModel> getLocksByFilterDelegate(Response<ResponseBody> response) throws RestException, IOException {
        return this.restClient().responseBuilderFactory().<LockModel, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<LockModel>() { }.getType())
                .register(404, new TypeToken<Void>() { }.getType())
                .build(response);
    }

    /**
     * Inserts or updates lock on a specified entity.
     *
     * @param drawer The drawer identifier.
     * @param id The entity identifier.
     * @param model The lock model.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object createOrUpdateLock(int drawer, int id, UpdateLockRequestModel model) {
        return createOrUpdateLockWithServiceResponseAsync(drawer, id, model).toBlocking().single().body();
    }

    /**
     * Inserts or updates lock on a specified entity.
     *
     * @param drawer The drawer identifier.
     * @param id The entity identifier.
     * @param model The lock model.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> createOrUpdateLockAsync(int drawer, int id, UpdateLockRequestModel model, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromResponse(createOrUpdateLockWithServiceResponseAsync(drawer, id, model), serviceCallback);
    }

    /**
     * Inserts or updates lock on a specified entity.
     *
     * @param drawer The drawer identifier.
     * @param id The entity identifier.
     * @param model The lock model.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> createOrUpdateLockAsync(int drawer, int id, UpdateLockRequestModel model) {
        return createOrUpdateLockWithServiceResponseAsync(drawer, id, model).map(new Func1<ServiceResponse<Object>, Object>() {
            @Override
            public Object call(ServiceResponse<Object> response) {
                return response.body();
            }
        });
    }

    /**
     * Inserts or updates lock on a specified entity.
     *
     * @param drawer The drawer identifier.
     * @param id The entity identifier.
     * @param model The lock model.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> createOrUpdateLockWithServiceResponseAsync(int drawer, int id, UpdateLockRequestModel model) {
        if (model == null) {
            throw new IllegalArgumentException("Parameter model is required and cannot be null.");
        }
        Validator.validate(model);
        return service.createOrUpdateLock(drawer, id, model)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = createOrUpdateLockDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Object> createOrUpdateLockDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<Object, RestException>newInstance(this.serializerAdapter())
                .register(201, new TypeToken<Object>() { }.getType())
                .register(403, new TypeToken<Void>() { }.getType())
                .register(404, new TypeToken<Void>() { }.getType())
                .build(response);
    }

    /**
     * Deletes a lock on a specified entity.
     *
     * @param drawer The drawer identifier.
     * @param id The entity identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object deleteLock(int drawer, int id) {
        return deleteLockWithServiceResponseAsync(drawer, id).toBlocking().single().body();
    }

    /**
     * Deletes a lock on a specified entity.
     *
     * @param drawer The drawer identifier.
     * @param id The entity identifier.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> deleteLockAsync(int drawer, int id, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromResponse(deleteLockWithServiceResponseAsync(drawer, id), serviceCallback);
    }

    /**
     * Deletes a lock on a specified entity.
     *
     * @param drawer The drawer identifier.
     * @param id The entity identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> deleteLockAsync(int drawer, int id) {
        return deleteLockWithServiceResponseAsync(drawer, id).map(new Func1<ServiceResponse<Object>, Object>() {
            @Override
            public Object call(ServiceResponse<Object> response) {
                return response.body();
            }
        });
    }

    /**
     * Deletes a lock on a specified entity.
     *
     * @param drawer The drawer identifier.
     * @param id The entity identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> deleteLockWithServiceResponseAsync(int drawer, int id) {
        return service.deleteLock(drawer, id)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = deleteLockDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Object> deleteLockDelegate(Response<ResponseBody> response) throws RestException, IOException {
        return this.restClient().responseBuilderFactory().<Object, RestException>newInstance(this.serializerAdapter())
                .register(204, new TypeToken<Object>() { }.getType())
                .register(403, new TypeToken<Void>() { }.getType())
                .register(404, new TypeToken<Void>() { }.getType())
                .build(response);
    }

    /**
     * Gets a paged list of notes.
     *
     * @param drawerID Gets or sets the drawer identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;NoteModel&gt; object if successful.
     */
    public List<NoteModel> getNotesByFilter(int drawerID) {
        return getNotesByFilterWithServiceResponseAsync(drawerID).toBlocking().single().body();
    }

    /**
     * Gets a paged list of notes.
     *
     * @param drawerID Gets or sets the drawer identifier.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<NoteModel>> getNotesByFilterAsync(int drawerID, final ServiceCallback<List<NoteModel>> serviceCallback) {
        return ServiceFuture.fromResponse(getNotesByFilterWithServiceResponseAsync(drawerID), serviceCallback);
    }

    /**
     * Gets a paged list of notes.
     *
     * @param drawerID Gets or sets the drawer identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;NoteModel&gt; object
     */
    public Observable<List<NoteModel>> getNotesByFilterAsync(int drawerID) {
        return getNotesByFilterWithServiceResponseAsync(drawerID).map(new Func1<ServiceResponse<List<NoteModel>>, List<NoteModel>>() {
            @Override
            public List<NoteModel> call(ServiceResponse<List<NoteModel>> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets a paged list of notes.
     *
     * @param drawerID Gets or sets the drawer identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;NoteModel&gt; object
     */
    public Observable<ServiceResponse<List<NoteModel>>> getNotesByFilterWithServiceResponseAsync(int drawerID) {
        final Integer entityID = null;
        final String name = null;
        final Integer creatorUserID = null;
        final Integer modifierUserID = null;
        final DateTime minCreationTime = null;
        final DateTime maxCreationTime = null;
        final DateTime minModificationTime = null;
        final DateTime maxModificationTime = null;
        final Integer parentID = null;
        final Integer page = null;
        final Integer pageSize = null;
        final String sortOrder = null;
        final String sortBy = null;
        return service.getNotesByFilter(drawerID, entityID, name, creatorUserID, modifierUserID, minCreationTime, maxCreationTime, minModificationTime, maxModificationTime, parentID, page, pageSize, sortOrder, sortBy)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<NoteModel>>>>() {
                @Override
                public Observable<ServiceResponse<List<NoteModel>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<NoteModel>> clientResponse = getNotesByFilterDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Gets a paged list of notes.
     *
     * @param drawerID Gets or sets the drawer identifier.
     * @param entityID Gets or sets the entity identifier.
     * @param name Gets or sets the name.
     * @param creatorUserID Gets or sets the creator user identifier.
     * @param modifierUserID Gets or sets the modifier user identifier.
     * @param minCreationTime Gets or sets the minimum creation time.
     * @param maxCreationTime Gets or sets the maximum creation time.
     * @param minModificationTime Gets or sets the minimum modification time.
     * @param maxModificationTime Gets or sets the maximum modification time.
     * @param parentID Gets or sets the parent note identifier.
     * @param page Gets or sets the page number.
     * @param pageSize Gets or sets the size of the page.
     * @param sortOrder Gets or sets the order. Possible values include: 'Unspecified', 'Ascending', 'Descending'
     * @param sortBy Gets or sets the column to order by. Possible values include: 'ID', 'EntityID', 'Name', 'CreationTime', 'ModificationTime'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;NoteModel&gt; object if successful.
     */
    public List<NoteModel> getNotesByFilter(int drawerID, Integer entityID, String name, Integer creatorUserID, Integer modifierUserID, DateTime minCreationTime, DateTime maxCreationTime, DateTime minModificationTime, DateTime maxModificationTime, Integer parentID, Integer page, Integer pageSize, String sortOrder, String sortBy) {
        return getNotesByFilterWithServiceResponseAsync(drawerID, entityID, name, creatorUserID, modifierUserID, minCreationTime, maxCreationTime, minModificationTime, maxModificationTime, parentID, page, pageSize, sortOrder, sortBy).toBlocking().single().body();
    }

    /**
     * Gets a paged list of notes.
     *
     * @param drawerID Gets or sets the drawer identifier.
     * @param entityID Gets or sets the entity identifier.
     * @param name Gets or sets the name.
     * @param creatorUserID Gets or sets the creator user identifier.
     * @param modifierUserID Gets or sets the modifier user identifier.
     * @param minCreationTime Gets or sets the minimum creation time.
     * @param maxCreationTime Gets or sets the maximum creation time.
     * @param minModificationTime Gets or sets the minimum modification time.
     * @param maxModificationTime Gets or sets the maximum modification time.
     * @param parentID Gets or sets the parent note identifier.
     * @param page Gets or sets the page number.
     * @param pageSize Gets or sets the size of the page.
     * @param sortOrder Gets or sets the order. Possible values include: 'Unspecified', 'Ascending', 'Descending'
     * @param sortBy Gets or sets the column to order by. Possible values include: 'ID', 'EntityID', 'Name', 'CreationTime', 'ModificationTime'
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<NoteModel>> getNotesByFilterAsync(int drawerID, Integer entityID, String name, Integer creatorUserID, Integer modifierUserID, DateTime minCreationTime, DateTime maxCreationTime, DateTime minModificationTime, DateTime maxModificationTime, Integer parentID, Integer page, Integer pageSize, String sortOrder, String sortBy, final ServiceCallback<List<NoteModel>> serviceCallback) {
        return ServiceFuture.fromResponse(getNotesByFilterWithServiceResponseAsync(drawerID, entityID, name, creatorUserID, modifierUserID, minCreationTime, maxCreationTime, minModificationTime, maxModificationTime, parentID, page, pageSize, sortOrder, sortBy), serviceCallback);
    }

    /**
     * Gets a paged list of notes.
     *
     * @param drawerID Gets or sets the drawer identifier.
     * @param entityID Gets or sets the entity identifier.
     * @param name Gets or sets the name.
     * @param creatorUserID Gets or sets the creator user identifier.
     * @param modifierUserID Gets or sets the modifier user identifier.
     * @param minCreationTime Gets or sets the minimum creation time.
     * @param maxCreationTime Gets or sets the maximum creation time.
     * @param minModificationTime Gets or sets the minimum modification time.
     * @param maxModificationTime Gets or sets the maximum modification time.
     * @param parentID Gets or sets the parent note identifier.
     * @param page Gets or sets the page number.
     * @param pageSize Gets or sets the size of the page.
     * @param sortOrder Gets or sets the order. Possible values include: 'Unspecified', 'Ascending', 'Descending'
     * @param sortBy Gets or sets the column to order by. Possible values include: 'ID', 'EntityID', 'Name', 'CreationTime', 'ModificationTime'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;NoteModel&gt; object
     */
    public Observable<List<NoteModel>> getNotesByFilterAsync(int drawerID, Integer entityID, String name, Integer creatorUserID, Integer modifierUserID, DateTime minCreationTime, DateTime maxCreationTime, DateTime minModificationTime, DateTime maxModificationTime, Integer parentID, Integer page, Integer pageSize, String sortOrder, String sortBy) {
        return getNotesByFilterWithServiceResponseAsync(drawerID, entityID, name, creatorUserID, modifierUserID, minCreationTime, maxCreationTime, minModificationTime, maxModificationTime, parentID, page, pageSize, sortOrder, sortBy).map(new Func1<ServiceResponse<List<NoteModel>>, List<NoteModel>>() {
            @Override
            public List<NoteModel> call(ServiceResponse<List<NoteModel>> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets a paged list of notes.
     *
     * @param drawerID Gets or sets the drawer identifier.
     * @param entityID Gets or sets the entity identifier.
     * @param name Gets or sets the name.
     * @param creatorUserID Gets or sets the creator user identifier.
     * @param modifierUserID Gets or sets the modifier user identifier.
     * @param minCreationTime Gets or sets the minimum creation time.
     * @param maxCreationTime Gets or sets the maximum creation time.
     * @param minModificationTime Gets or sets the minimum modification time.
     * @param maxModificationTime Gets or sets the maximum modification time.
     * @param parentID Gets or sets the parent note identifier.
     * @param page Gets or sets the page number.
     * @param pageSize Gets or sets the size of the page.
     * @param sortOrder Gets or sets the order. Possible values include: 'Unspecified', 'Ascending', 'Descending'
     * @param sortBy Gets or sets the column to order by. Possible values include: 'ID', 'EntityID', 'Name', 'CreationTime', 'ModificationTime'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;NoteModel&gt; object
     */
    public Observable<ServiceResponse<List<NoteModel>>> getNotesByFilterWithServiceResponseAsync(int drawerID, Integer entityID, String name, Integer creatorUserID, Integer modifierUserID, DateTime minCreationTime, DateTime maxCreationTime, DateTime minModificationTime, DateTime maxModificationTime, Integer parentID, Integer page, Integer pageSize, String sortOrder, String sortBy) {
        return service.getNotesByFilter(drawerID, entityID, name, creatorUserID, modifierUserID, minCreationTime, maxCreationTime, minModificationTime, maxModificationTime, parentID, page, pageSize, sortOrder, sortBy)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<NoteModel>>>>() {
                @Override
                public Observable<ServiceResponse<List<NoteModel>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<NoteModel>> clientResponse = getNotesByFilterDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<List<NoteModel>> getNotesByFilterDelegate(Response<ResponseBody> response) throws RestException, IOException {
        return this.restClient().responseBuilderFactory().<List<NoteModel>, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<List<NoteModel>>() { }.getType())
                .build(response);
    }

    /**
     * Gets a note by its unique identifier.
     *
     * @param drawer The drawer identifier.
     * @param id The note identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the NoteModel object if successful.
     */
    public NoteModel getNoteById(int drawer, int id) {
        return getNoteByIdWithServiceResponseAsync(drawer, id).toBlocking().single().body();
    }

    /**
     * Gets a note by its unique identifier.
     *
     * @param drawer The drawer identifier.
     * @param id The note identifier.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<NoteModel> getNoteByIdAsync(int drawer, int id, final ServiceCallback<NoteModel> serviceCallback) {
        return ServiceFuture.fromResponse(getNoteByIdWithServiceResponseAsync(drawer, id), serviceCallback);
    }

    /**
     * Gets a note by its unique identifier.
     *
     * @param drawer The drawer identifier.
     * @param id The note identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the NoteModel object
     */
    public Observable<NoteModel> getNoteByIdAsync(int drawer, int id) {
        return getNoteByIdWithServiceResponseAsync(drawer, id).map(new Func1<ServiceResponse<NoteModel>, NoteModel>() {
            @Override
            public NoteModel call(ServiceResponse<NoteModel> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets a note by its unique identifier.
     *
     * @param drawer The drawer identifier.
     * @param id The note identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the NoteModel object
     */
    public Observable<ServiceResponse<NoteModel>> getNoteByIdWithServiceResponseAsync(int drawer, int id) {
        return service.getNoteById(drawer, id)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<NoteModel>>>() {
                @Override
                public Observable<ServiceResponse<NoteModel>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<NoteModel> clientResponse = getNoteByIdDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<NoteModel> getNoteByIdDelegate(Response<ResponseBody> response) throws RestException, IOException {
        return this.restClient().responseBuilderFactory().<NoteModel, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<NoteModel>() { }.getType())
                .register(403, new TypeToken<Void>() { }.getType())
                .register(404, new TypeToken<Void>() { }.getType())
                .build(response);
    }

    /**
     * Updates a specified note.
     *
     * @param drawer The drawer identifier.
     * @param id The note identifier.
     * @param model The note model.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object updateNote(int drawer, int id, NoteBase model) {
        return updateNoteWithServiceResponseAsync(drawer, id, model).toBlocking().single().body();
    }

    /**
     * Updates a specified note.
     *
     * @param drawer The drawer identifier.
     * @param id The note identifier.
     * @param model The note model.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> updateNoteAsync(int drawer, int id, NoteBase model, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromResponse(updateNoteWithServiceResponseAsync(drawer, id, model), serviceCallback);
    }

    /**
     * Updates a specified note.
     *
     * @param drawer The drawer identifier.
     * @param id The note identifier.
     * @param model The note model.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> updateNoteAsync(int drawer, int id, NoteBase model) {
        return updateNoteWithServiceResponseAsync(drawer, id, model).map(new Func1<ServiceResponse<Object>, Object>() {
            @Override
            public Object call(ServiceResponse<Object> response) {
                return response.body();
            }
        });
    }

    /**
     * Updates a specified note.
     *
     * @param drawer The drawer identifier.
     * @param id The note identifier.
     * @param model The note model.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> updateNoteWithServiceResponseAsync(int drawer, int id, NoteBase model) {
        if (model == null) {
            throw new IllegalArgumentException("Parameter model is required and cannot be null.");
        }
        Validator.validate(model);
        return service.updateNote(drawer, id, model)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = updateNoteDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Object> updateNoteDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<Object, RestException>newInstance(this.serializerAdapter())
                .register(204, new TypeToken<Object>() { }.getType())
                .register(403, new TypeToken<Void>() { }.getType())
                .register(404, new TypeToken<Void>() { }.getType())
                .build(response);
    }

    /**
     * Deletes a specified note.
     *
     * @param drawer The drawer identifier.
     * @param id The note identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object deleteNote(int drawer, int id) {
        return deleteNoteWithServiceResponseAsync(drawer, id).toBlocking().single().body();
    }

    /**
     * Deletes a specified note.
     *
     * @param drawer The drawer identifier.
     * @param id The note identifier.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> deleteNoteAsync(int drawer, int id, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromResponse(deleteNoteWithServiceResponseAsync(drawer, id), serviceCallback);
    }

    /**
     * Deletes a specified note.
     *
     * @param drawer The drawer identifier.
     * @param id The note identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> deleteNoteAsync(int drawer, int id) {
        return deleteNoteWithServiceResponseAsync(drawer, id).map(new Func1<ServiceResponse<Object>, Object>() {
            @Override
            public Object call(ServiceResponse<Object> response) {
                return response.body();
            }
        });
    }

    /**
     * Deletes a specified note.
     *
     * @param drawer The drawer identifier.
     * @param id The note identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> deleteNoteWithServiceResponseAsync(int drawer, int id) {
        return service.deleteNote(drawer, id)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = deleteNoteDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Object> deleteNoteDelegate(Response<ResponseBody> response) throws RestException, IOException {
        return this.restClient().responseBuilderFactory().<Object, RestException>newInstance(this.serializerAdapter())
                .register(204, new TypeToken<Object>() { }.getType())
                .register(403, new TypeToken<Void>() { }.getType())
                .register(404, new TypeToken<Void>() { }.getType())
                .build(response);
    }

    /**
     * Creates a new note.
     *
     * @param drawer The drawer identifier.
     * @param model The note model.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the NoteModel object if successful.
     */
    public NoteModel createNote(int drawer, InsertNoteRequestModel model) {
        return createNoteWithServiceResponseAsync(drawer, model).toBlocking().single().body();
    }

    /**
     * Creates a new note.
     *
     * @param drawer The drawer identifier.
     * @param model The note model.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<NoteModel> createNoteAsync(int drawer, InsertNoteRequestModel model, final ServiceCallback<NoteModel> serviceCallback) {
        return ServiceFuture.fromResponse(createNoteWithServiceResponseAsync(drawer, model), serviceCallback);
    }

    /**
     * Creates a new note.
     *
     * @param drawer The drawer identifier.
     * @param model The note model.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the NoteModel object
     */
    public Observable<NoteModel> createNoteAsync(int drawer, InsertNoteRequestModel model) {
        return createNoteWithServiceResponseAsync(drawer, model).map(new Func1<ServiceResponse<NoteModel>, NoteModel>() {
            @Override
            public NoteModel call(ServiceResponse<NoteModel> response) {
                return response.body();
            }
        });
    }

    /**
     * Creates a new note.
     *
     * @param drawer The drawer identifier.
     * @param model The note model.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the NoteModel object
     */
    public Observable<ServiceResponse<NoteModel>> createNoteWithServiceResponseAsync(int drawer, InsertNoteRequestModel model) {
        if (model == null) {
            throw new IllegalArgumentException("Parameter model is required and cannot be null.");
        }
        Validator.validate(model);
        return service.createNote(drawer, model)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<NoteModel>>>() {
                @Override
                public Observable<ServiceResponse<NoteModel>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<NoteModel> clientResponse = createNoteDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<NoteModel> createNoteDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<NoteModel, RestException>newInstance(this.serializerAdapter())
                .register(201, new TypeToken<NoteModel>() { }.getType())
                .register(403, new TypeToken<Void>() { }.getType())
                .register(404, new TypeToken<Void>() { }.getType())
                .build(response);
    }

    /**
     * Gets a paged list of queue assignments.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;QueueAssignmentModel&gt; object if successful.
     */
    public List<QueueAssignmentModel> getQueueAssignmentsByFilter() {
        return getQueueAssignmentsByFilterWithServiceResponseAsync().toBlocking().single().body();
    }

    /**
     * Gets a paged list of queue assignments.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<QueueAssignmentModel>> getQueueAssignmentsByFilterAsync(final ServiceCallback<List<QueueAssignmentModel>> serviceCallback) {
        return ServiceFuture.fromResponse(getQueueAssignmentsByFilterWithServiceResponseAsync(), serviceCallback);
    }

    /**
     * Gets a paged list of queue assignments.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;QueueAssignmentModel&gt; object
     */
    public Observable<List<QueueAssignmentModel>> getQueueAssignmentsByFilterAsync() {
        return getQueueAssignmentsByFilterWithServiceResponseAsync().map(new Func1<ServiceResponse<List<QueueAssignmentModel>>, List<QueueAssignmentModel>>() {
            @Override
            public List<QueueAssignmentModel> call(ServiceResponse<List<QueueAssignmentModel>> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets a paged list of queue assignments.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;QueueAssignmentModel&gt; object
     */
    public Observable<ServiceResponse<List<QueueAssignmentModel>>> getQueueAssignmentsByFilterWithServiceResponseAsync() {
        final Integer queueID = null;
        final Integer userID = null;
        final Integer groupID = null;
        final String type = null;
        final Integer order = null;
        final String taskSortColumn = null;
        final String state = null;
        final String fetchType = null;
        final Integer page = null;
        final Integer pageSize = null;
        final String sortOrder = null;
        final String sortBy = null;
        return service.getQueueAssignmentsByFilter(queueID, userID, groupID, type, order, taskSortColumn, state, fetchType, page, pageSize, sortOrder, sortBy)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<QueueAssignmentModel>>>>() {
                @Override
                public Observable<ServiceResponse<List<QueueAssignmentModel>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<QueueAssignmentModel>> clientResponse = getQueueAssignmentsByFilterDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Gets a paged list of queue assignments.
     *
     * @param queueID Gets or sets the unique queue identifier.
     * @param userID Gets or sets the user identifier.
     * @param groupID Gets or sets the group identifier.
     * @param type Gets or sets the queue assignment type. Possible values include: 'Unspecified', 'Primary', 'Secondary'
     * @param order Gets or sets the sort order.
     * @param taskSortColumn Gets or sets the task sort column. Possible values include: 'TaskID', 'QueueID', 'DrawerID', 'AddressID', 'ObjectID', 'ObjectType', 'State', 'Priority', 'Description', 'Message1', 'Message2', 'Message3', 'Message4', 'Message5', 'OwnerUserID', 'OwnerGroupID', 'EffectiveUserID', 'EffectiveGroupID', 'PreviousQueueID', 'NextQueueID', 'InsertionTime', 'ResolutionTime', 'TaskFileAttachment', 'ReservedInt1', 'ReservedString1'
     * @param state Gets or sets the state. Possible values include: 'Unspecified', 'Inactive', 'Active'
     * @param fetchType Gets or sets the type of the fetch. Possible values include: 'Unspecified', 'Manual', 'Push'
     * @param page Gets or sets the page number.
     * @param pageSize Gets or sets the size of the page.
     * @param sortOrder Gets or sets the order. Possible values include: 'Unspecified', 'Ascending', 'Descending'
     * @param sortBy Gets or sets the column to order by. Possible values include: 'QueueID', 'UserID', 'GroupID', 'Type', 'State', 'Order', 'FetchType'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;QueueAssignmentModel&gt; object if successful.
     */
    public List<QueueAssignmentModel> getQueueAssignmentsByFilter(Integer queueID, Integer userID, Integer groupID, String type, Integer order, String taskSortColumn, String state, String fetchType, Integer page, Integer pageSize, String sortOrder, String sortBy) {
        return getQueueAssignmentsByFilterWithServiceResponseAsync(queueID, userID, groupID, type, order, taskSortColumn, state, fetchType, page, pageSize, sortOrder, sortBy).toBlocking().single().body();
    }

    /**
     * Gets a paged list of queue assignments.
     *
     * @param queueID Gets or sets the unique queue identifier.
     * @param userID Gets or sets the user identifier.
     * @param groupID Gets or sets the group identifier.
     * @param type Gets or sets the queue assignment type. Possible values include: 'Unspecified', 'Primary', 'Secondary'
     * @param order Gets or sets the sort order.
     * @param taskSortColumn Gets or sets the task sort column. Possible values include: 'TaskID', 'QueueID', 'DrawerID', 'AddressID', 'ObjectID', 'ObjectType', 'State', 'Priority', 'Description', 'Message1', 'Message2', 'Message3', 'Message4', 'Message5', 'OwnerUserID', 'OwnerGroupID', 'EffectiveUserID', 'EffectiveGroupID', 'PreviousQueueID', 'NextQueueID', 'InsertionTime', 'ResolutionTime', 'TaskFileAttachment', 'ReservedInt1', 'ReservedString1'
     * @param state Gets or sets the state. Possible values include: 'Unspecified', 'Inactive', 'Active'
     * @param fetchType Gets or sets the type of the fetch. Possible values include: 'Unspecified', 'Manual', 'Push'
     * @param page Gets or sets the page number.
     * @param pageSize Gets or sets the size of the page.
     * @param sortOrder Gets or sets the order. Possible values include: 'Unspecified', 'Ascending', 'Descending'
     * @param sortBy Gets or sets the column to order by. Possible values include: 'QueueID', 'UserID', 'GroupID', 'Type', 'State', 'Order', 'FetchType'
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<QueueAssignmentModel>> getQueueAssignmentsByFilterAsync(Integer queueID, Integer userID, Integer groupID, String type, Integer order, String taskSortColumn, String state, String fetchType, Integer page, Integer pageSize, String sortOrder, String sortBy, final ServiceCallback<List<QueueAssignmentModel>> serviceCallback) {
        return ServiceFuture.fromResponse(getQueueAssignmentsByFilterWithServiceResponseAsync(queueID, userID, groupID, type, order, taskSortColumn, state, fetchType, page, pageSize, sortOrder, sortBy), serviceCallback);
    }

    /**
     * Gets a paged list of queue assignments.
     *
     * @param queueID Gets or sets the unique queue identifier.
     * @param userID Gets or sets the user identifier.
     * @param groupID Gets or sets the group identifier.
     * @param type Gets or sets the queue assignment type. Possible values include: 'Unspecified', 'Primary', 'Secondary'
     * @param order Gets or sets the sort order.
     * @param taskSortColumn Gets or sets the task sort column. Possible values include: 'TaskID', 'QueueID', 'DrawerID', 'AddressID', 'ObjectID', 'ObjectType', 'State', 'Priority', 'Description', 'Message1', 'Message2', 'Message3', 'Message4', 'Message5', 'OwnerUserID', 'OwnerGroupID', 'EffectiveUserID', 'EffectiveGroupID', 'PreviousQueueID', 'NextQueueID', 'InsertionTime', 'ResolutionTime', 'TaskFileAttachment', 'ReservedInt1', 'ReservedString1'
     * @param state Gets or sets the state. Possible values include: 'Unspecified', 'Inactive', 'Active'
     * @param fetchType Gets or sets the type of the fetch. Possible values include: 'Unspecified', 'Manual', 'Push'
     * @param page Gets or sets the page number.
     * @param pageSize Gets or sets the size of the page.
     * @param sortOrder Gets or sets the order. Possible values include: 'Unspecified', 'Ascending', 'Descending'
     * @param sortBy Gets or sets the column to order by. Possible values include: 'QueueID', 'UserID', 'GroupID', 'Type', 'State', 'Order', 'FetchType'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;QueueAssignmentModel&gt; object
     */
    public Observable<List<QueueAssignmentModel>> getQueueAssignmentsByFilterAsync(Integer queueID, Integer userID, Integer groupID, String type, Integer order, String taskSortColumn, String state, String fetchType, Integer page, Integer pageSize, String sortOrder, String sortBy) {
        return getQueueAssignmentsByFilterWithServiceResponseAsync(queueID, userID, groupID, type, order, taskSortColumn, state, fetchType, page, pageSize, sortOrder, sortBy).map(new Func1<ServiceResponse<List<QueueAssignmentModel>>, List<QueueAssignmentModel>>() {
            @Override
            public List<QueueAssignmentModel> call(ServiceResponse<List<QueueAssignmentModel>> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets a paged list of queue assignments.
     *
     * @param queueID Gets or sets the unique queue identifier.
     * @param userID Gets or sets the user identifier.
     * @param groupID Gets or sets the group identifier.
     * @param type Gets or sets the queue assignment type. Possible values include: 'Unspecified', 'Primary', 'Secondary'
     * @param order Gets or sets the sort order.
     * @param taskSortColumn Gets or sets the task sort column. Possible values include: 'TaskID', 'QueueID', 'DrawerID', 'AddressID', 'ObjectID', 'ObjectType', 'State', 'Priority', 'Description', 'Message1', 'Message2', 'Message3', 'Message4', 'Message5', 'OwnerUserID', 'OwnerGroupID', 'EffectiveUserID', 'EffectiveGroupID', 'PreviousQueueID', 'NextQueueID', 'InsertionTime', 'ResolutionTime', 'TaskFileAttachment', 'ReservedInt1', 'ReservedString1'
     * @param state Gets or sets the state. Possible values include: 'Unspecified', 'Inactive', 'Active'
     * @param fetchType Gets or sets the type of the fetch. Possible values include: 'Unspecified', 'Manual', 'Push'
     * @param page Gets or sets the page number.
     * @param pageSize Gets or sets the size of the page.
     * @param sortOrder Gets or sets the order. Possible values include: 'Unspecified', 'Ascending', 'Descending'
     * @param sortBy Gets or sets the column to order by. Possible values include: 'QueueID', 'UserID', 'GroupID', 'Type', 'State', 'Order', 'FetchType'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;QueueAssignmentModel&gt; object
     */
    public Observable<ServiceResponse<List<QueueAssignmentModel>>> getQueueAssignmentsByFilterWithServiceResponseAsync(Integer queueID, Integer userID, Integer groupID, String type, Integer order, String taskSortColumn, String state, String fetchType, Integer page, Integer pageSize, String sortOrder, String sortBy) {
        return service.getQueueAssignmentsByFilter(queueID, userID, groupID, type, order, taskSortColumn, state, fetchType, page, pageSize, sortOrder, sortBy)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<QueueAssignmentModel>>>>() {
                @Override
                public Observable<ServiceResponse<List<QueueAssignmentModel>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<QueueAssignmentModel>> clientResponse = getQueueAssignmentsByFilterDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<List<QueueAssignmentModel>> getQueueAssignmentsByFilterDelegate(Response<ResponseBody> response) throws RestException, IOException {
        return this.restClient().responseBuilderFactory().<List<QueueAssignmentModel>, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<List<QueueAssignmentModel>>() { }.getType())
                .register(403, new TypeToken<Void>() { }.getType())
                .build(response);
    }

    /**
     * Updates the specified queue assignment.
     *
     * @param model The model.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object updateQueueAssignemnt(QueueAssignmentModel model) {
        return updateQueueAssignemntWithServiceResponseAsync(model).toBlocking().single().body();
    }

    /**
     * Updates the specified queue assignment.
     *
     * @param model The model.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> updateQueueAssignemntAsync(QueueAssignmentModel model, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromResponse(updateQueueAssignemntWithServiceResponseAsync(model), serviceCallback);
    }

    /**
     * Updates the specified queue assignment.
     *
     * @param model The model.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> updateQueueAssignemntAsync(QueueAssignmentModel model) {
        return updateQueueAssignemntWithServiceResponseAsync(model).map(new Func1<ServiceResponse<Object>, Object>() {
            @Override
            public Object call(ServiceResponse<Object> response) {
                return response.body();
            }
        });
    }

    /**
     * Updates the specified queue assignment.
     *
     * @param model The model.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> updateQueueAssignemntWithServiceResponseAsync(QueueAssignmentModel model) {
        if (model == null) {
            throw new IllegalArgumentException("Parameter model is required and cannot be null.");
        }
        Validator.validate(model);
        return service.updateQueueAssignemnt(model)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = updateQueueAssignemntDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Object> updateQueueAssignemntDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<Object, RestException>newInstance(this.serializerAdapter())
                .register(204, new TypeToken<Object>() { }.getType())
                .register(403, new TypeToken<Void>() { }.getType())
                .register(404, new TypeToken<Void>() { }.getType())
                .build(response);
    }

    /**
     * Creates a new queue assignment.
     *
     * @param model The model.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the QueueAssignmentModel object if successful.
     */
    public QueueAssignmentModel createQueueAssignment(InsertQueueAssignmentRequestModel model) {
        return createQueueAssignmentWithServiceResponseAsync(model).toBlocking().single().body();
    }

    /**
     * Creates a new queue assignment.
     *
     * @param model The model.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<QueueAssignmentModel> createQueueAssignmentAsync(InsertQueueAssignmentRequestModel model, final ServiceCallback<QueueAssignmentModel> serviceCallback) {
        return ServiceFuture.fromResponse(createQueueAssignmentWithServiceResponseAsync(model), serviceCallback);
    }

    /**
     * Creates a new queue assignment.
     *
     * @param model The model.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the QueueAssignmentModel object
     */
    public Observable<QueueAssignmentModel> createQueueAssignmentAsync(InsertQueueAssignmentRequestModel model) {
        return createQueueAssignmentWithServiceResponseAsync(model).map(new Func1<ServiceResponse<QueueAssignmentModel>, QueueAssignmentModel>() {
            @Override
            public QueueAssignmentModel call(ServiceResponse<QueueAssignmentModel> response) {
                return response.body();
            }
        });
    }

    /**
     * Creates a new queue assignment.
     *
     * @param model The model.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the QueueAssignmentModel object
     */
    public Observable<ServiceResponse<QueueAssignmentModel>> createQueueAssignmentWithServiceResponseAsync(InsertQueueAssignmentRequestModel model) {
        if (model == null) {
            throw new IllegalArgumentException("Parameter model is required and cannot be null.");
        }
        Validator.validate(model);
        return service.createQueueAssignment(model)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<QueueAssignmentModel>>>() {
                @Override
                public Observable<ServiceResponse<QueueAssignmentModel>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<QueueAssignmentModel> clientResponse = createQueueAssignmentDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<QueueAssignmentModel> createQueueAssignmentDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<QueueAssignmentModel, RestException>newInstance(this.serializerAdapter())
                .register(201, new TypeToken<QueueAssignmentModel>() { }.getType())
                .register(403, new TypeToken<Void>() { }.getType())
                .register(404, new TypeToken<Void>() { }.getType())
                .register(409, new TypeToken<Void>() { }.getType())
                .build(response);
    }

    /**
     * Gets a single queue assignment based on user and queue identifiers.
     *
     * @param userId The user identifier.
     * @param queueId The queue identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the QueueAssignmentModel object if successful.
     */
    public QueueAssignmentModel getQueueAssignmentsById(int userId, int queueId) {
        return getQueueAssignmentsByIdWithServiceResponseAsync(userId, queueId).toBlocking().single().body();
    }

    /**
     * Gets a single queue assignment based on user and queue identifiers.
     *
     * @param userId The user identifier.
     * @param queueId The queue identifier.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<QueueAssignmentModel> getQueueAssignmentsByIdAsync(int userId, int queueId, final ServiceCallback<QueueAssignmentModel> serviceCallback) {
        return ServiceFuture.fromResponse(getQueueAssignmentsByIdWithServiceResponseAsync(userId, queueId), serviceCallback);
    }

    /**
     * Gets a single queue assignment based on user and queue identifiers.
     *
     * @param userId The user identifier.
     * @param queueId The queue identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the QueueAssignmentModel object
     */
    public Observable<QueueAssignmentModel> getQueueAssignmentsByIdAsync(int userId, int queueId) {
        return getQueueAssignmentsByIdWithServiceResponseAsync(userId, queueId).map(new Func1<ServiceResponse<QueueAssignmentModel>, QueueAssignmentModel>() {
            @Override
            public QueueAssignmentModel call(ServiceResponse<QueueAssignmentModel> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets a single queue assignment based on user and queue identifiers.
     *
     * @param userId The user identifier.
     * @param queueId The queue identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the QueueAssignmentModel object
     */
    public Observable<ServiceResponse<QueueAssignmentModel>> getQueueAssignmentsByIdWithServiceResponseAsync(int userId, int queueId) {
        return service.getQueueAssignmentsById(userId, queueId)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<QueueAssignmentModel>>>() {
                @Override
                public Observable<ServiceResponse<QueueAssignmentModel>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<QueueAssignmentModel> clientResponse = getQueueAssignmentsByIdDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<QueueAssignmentModel> getQueueAssignmentsByIdDelegate(Response<ResponseBody> response) throws RestException, IOException {
        return this.restClient().responseBuilderFactory().<QueueAssignmentModel, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<QueueAssignmentModel>() { }.getType())
                .register(403, new TypeToken<Void>() { }.getType())
                .register(404, new TypeToken<Void>() { }.getType())
                .build(response);
    }

    /**
     * Deletes the specified queue assignment.
     *
     * @param userId The user identifier.
     * @param queueId The queue identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object deleteQueueAssignment(int userId, int queueId) {
        return deleteQueueAssignmentWithServiceResponseAsync(userId, queueId).toBlocking().single().body();
    }

    /**
     * Deletes the specified queue assignment.
     *
     * @param userId The user identifier.
     * @param queueId The queue identifier.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> deleteQueueAssignmentAsync(int userId, int queueId, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromResponse(deleteQueueAssignmentWithServiceResponseAsync(userId, queueId), serviceCallback);
    }

    /**
     * Deletes the specified queue assignment.
     *
     * @param userId The user identifier.
     * @param queueId The queue identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> deleteQueueAssignmentAsync(int userId, int queueId) {
        return deleteQueueAssignmentWithServiceResponseAsync(userId, queueId).map(new Func1<ServiceResponse<Object>, Object>() {
            @Override
            public Object call(ServiceResponse<Object> response) {
                return response.body();
            }
        });
    }

    /**
     * Deletes the specified queue assignment.
     *
     * @param userId The user identifier.
     * @param queueId The queue identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> deleteQueueAssignmentWithServiceResponseAsync(int userId, int queueId) {
        return service.deleteQueueAssignment(userId, queueId)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = deleteQueueAssignmentDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Object> deleteQueueAssignmentDelegate(Response<ResponseBody> response) throws RestException, IOException {
        return this.restClient().responseBuilderFactory().<Object, RestException>newInstance(this.serializerAdapter())
                .register(204, new TypeToken<Object>() { }.getType())
                .register(403, new TypeToken<Void>() { }.getType())
                .register(404, new TypeToken<Void>() { }.getType())
                .build(response);
    }

    /**
     * Gets a paged list of queues.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;QueueModel&gt; object if successful.
     */
    public List<QueueModel> getQueuesByFilter() {
        return getQueuesByFilterWithServiceResponseAsync().toBlocking().single().body();
    }

    /**
     * Gets a paged list of queues.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<QueueModel>> getQueuesByFilterAsync(final ServiceCallback<List<QueueModel>> serviceCallback) {
        return ServiceFuture.fromResponse(getQueuesByFilterWithServiceResponseAsync(), serviceCallback);
    }

    /**
     * Gets a paged list of queues.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;QueueModel&gt; object
     */
    public Observable<List<QueueModel>> getQueuesByFilterAsync() {
        return getQueuesByFilterWithServiceResponseAsync().map(new Func1<ServiceResponse<List<QueueModel>>, List<QueueModel>>() {
            @Override
            public List<QueueModel> call(ServiceResponse<List<QueueModel>> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets a paged list of queues.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;QueueModel&gt; object
     */
    public Observable<ServiceResponse<List<QueueModel>>> getQueuesByFilterWithServiceResponseAsync() {
        final Integer iD = null;
        final String name = null;
        final String alias = null;
        final String type = null;
        final Integer access = null;
        final Boolean bypassSecurity = null;
        final Integer page = null;
        final Integer pageSize = null;
        final String sortOrder = null;
        final String sortBy = null;
        return service.getQueuesByFilter(iD, name, alias, type, access, bypassSecurity, page, pageSize, sortOrder, sortBy)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<QueueModel>>>>() {
                @Override
                public Observable<ServiceResponse<List<QueueModel>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<QueueModel>> clientResponse = getQueuesByFilterDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Gets a paged list of queues.
     *
     * @param iD Gets or sets the queue identifier.
     * @param name Gets or sets the name.
     * @param alias Gets or sets the alias.
     * @param type Gets or sets the type. Possible values include: 'Inbound', 'Outbound', 'Access', 'Any', 'Shared', 'Public', 'Recycle', 'Fax', 'Print', 'Scan', 'Ocr', 'Workflow', 'Schedule', 'System', 'Other', 'CdoInfostore', 'CdoFolder'
     * @param access Gets or sets the access level.
     * @param bypassSecurity Gets or sets a value indicating whether to bypass security checks.
     * @param page Gets or sets the page number.
     * @param pageSize Gets or sets the size of the page.
     * @param sortOrder Gets or sets the order. Possible values include: 'Unspecified', 'Ascending', 'Descending'
     * @param sortBy Gets or sets the column to order by. Possible values include: 'ID', 'Type', 'Name', 'Alias'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;QueueModel&gt; object if successful.
     */
    public List<QueueModel> getQueuesByFilter(Integer iD, String name, String alias, String type, Integer access, Boolean bypassSecurity, Integer page, Integer pageSize, String sortOrder, String sortBy) {
        return getQueuesByFilterWithServiceResponseAsync(iD, name, alias, type, access, bypassSecurity, page, pageSize, sortOrder, sortBy).toBlocking().single().body();
    }

    /**
     * Gets a paged list of queues.
     *
     * @param iD Gets or sets the queue identifier.
     * @param name Gets or sets the name.
     * @param alias Gets or sets the alias.
     * @param type Gets or sets the type. Possible values include: 'Inbound', 'Outbound', 'Access', 'Any', 'Shared', 'Public', 'Recycle', 'Fax', 'Print', 'Scan', 'Ocr', 'Workflow', 'Schedule', 'System', 'Other', 'CdoInfostore', 'CdoFolder'
     * @param access Gets or sets the access level.
     * @param bypassSecurity Gets or sets a value indicating whether to bypass security checks.
     * @param page Gets or sets the page number.
     * @param pageSize Gets or sets the size of the page.
     * @param sortOrder Gets or sets the order. Possible values include: 'Unspecified', 'Ascending', 'Descending'
     * @param sortBy Gets or sets the column to order by. Possible values include: 'ID', 'Type', 'Name', 'Alias'
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<QueueModel>> getQueuesByFilterAsync(Integer iD, String name, String alias, String type, Integer access, Boolean bypassSecurity, Integer page, Integer pageSize, String sortOrder, String sortBy, final ServiceCallback<List<QueueModel>> serviceCallback) {
        return ServiceFuture.fromResponse(getQueuesByFilterWithServiceResponseAsync(iD, name, alias, type, access, bypassSecurity, page, pageSize, sortOrder, sortBy), serviceCallback);
    }

    /**
     * Gets a paged list of queues.
     *
     * @param iD Gets or sets the queue identifier.
     * @param name Gets or sets the name.
     * @param alias Gets or sets the alias.
     * @param type Gets or sets the type. Possible values include: 'Inbound', 'Outbound', 'Access', 'Any', 'Shared', 'Public', 'Recycle', 'Fax', 'Print', 'Scan', 'Ocr', 'Workflow', 'Schedule', 'System', 'Other', 'CdoInfostore', 'CdoFolder'
     * @param access Gets or sets the access level.
     * @param bypassSecurity Gets or sets a value indicating whether to bypass security checks.
     * @param page Gets or sets the page number.
     * @param pageSize Gets or sets the size of the page.
     * @param sortOrder Gets or sets the order. Possible values include: 'Unspecified', 'Ascending', 'Descending'
     * @param sortBy Gets or sets the column to order by. Possible values include: 'ID', 'Type', 'Name', 'Alias'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;QueueModel&gt; object
     */
    public Observable<List<QueueModel>> getQueuesByFilterAsync(Integer iD, String name, String alias, String type, Integer access, Boolean bypassSecurity, Integer page, Integer pageSize, String sortOrder, String sortBy) {
        return getQueuesByFilterWithServiceResponseAsync(iD, name, alias, type, access, bypassSecurity, page, pageSize, sortOrder, sortBy).map(new Func1<ServiceResponse<List<QueueModel>>, List<QueueModel>>() {
            @Override
            public List<QueueModel> call(ServiceResponse<List<QueueModel>> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets a paged list of queues.
     *
     * @param iD Gets or sets the queue identifier.
     * @param name Gets or sets the name.
     * @param alias Gets or sets the alias.
     * @param type Gets or sets the type. Possible values include: 'Inbound', 'Outbound', 'Access', 'Any', 'Shared', 'Public', 'Recycle', 'Fax', 'Print', 'Scan', 'Ocr', 'Workflow', 'Schedule', 'System', 'Other', 'CdoInfostore', 'CdoFolder'
     * @param access Gets or sets the access level.
     * @param bypassSecurity Gets or sets a value indicating whether to bypass security checks.
     * @param page Gets or sets the page number.
     * @param pageSize Gets or sets the size of the page.
     * @param sortOrder Gets or sets the order. Possible values include: 'Unspecified', 'Ascending', 'Descending'
     * @param sortBy Gets or sets the column to order by. Possible values include: 'ID', 'Type', 'Name', 'Alias'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;QueueModel&gt; object
     */
    public Observable<ServiceResponse<List<QueueModel>>> getQueuesByFilterWithServiceResponseAsync(Integer iD, String name, String alias, String type, Integer access, Boolean bypassSecurity, Integer page, Integer pageSize, String sortOrder, String sortBy) {
        return service.getQueuesByFilter(iD, name, alias, type, access, bypassSecurity, page, pageSize, sortOrder, sortBy)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<QueueModel>>>>() {
                @Override
                public Observable<ServiceResponse<List<QueueModel>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<QueueModel>> clientResponse = getQueuesByFilterDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<List<QueueModel>> getQueuesByFilterDelegate(Response<ResponseBody> response) throws RestException, IOException {
        return this.restClient().responseBuilderFactory().<List<QueueModel>, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<List<QueueModel>>() { }.getType())
                .build(response);
    }

    /**
     * Creates a new queue.
     *
     * @param model The queue model.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the QueueModel object if successful.
     */
    public QueueModel createQueue(InsertQueueRequestModel model) {
        return createQueueWithServiceResponseAsync(model).toBlocking().single().body();
    }

    /**
     * Creates a new queue.
     *
     * @param model The queue model.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<QueueModel> createQueueAsync(InsertQueueRequestModel model, final ServiceCallback<QueueModel> serviceCallback) {
        return ServiceFuture.fromResponse(createQueueWithServiceResponseAsync(model), serviceCallback);
    }

    /**
     * Creates a new queue.
     *
     * @param model The queue model.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the QueueModel object
     */
    public Observable<QueueModel> createQueueAsync(InsertQueueRequestModel model) {
        return createQueueWithServiceResponseAsync(model).map(new Func1<ServiceResponse<QueueModel>, QueueModel>() {
            @Override
            public QueueModel call(ServiceResponse<QueueModel> response) {
                return response.body();
            }
        });
    }

    /**
     * Creates a new queue.
     *
     * @param model The queue model.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the QueueModel object
     */
    public Observable<ServiceResponse<QueueModel>> createQueueWithServiceResponseAsync(InsertQueueRequestModel model) {
        if (model == null) {
            throw new IllegalArgumentException("Parameter model is required and cannot be null.");
        }
        Validator.validate(model);
        return service.createQueue(model)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<QueueModel>>>() {
                @Override
                public Observable<ServiceResponse<QueueModel>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<QueueModel> clientResponse = createQueueDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<QueueModel> createQueueDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<QueueModel, RestException>newInstance(this.serializerAdapter())
                .register(201, new TypeToken<QueueModel>() { }.getType())
                .register(403, new TypeToken<Void>() { }.getType())
                .build(response);
    }

    /**
     * Gets a single queue by its unique identifier.
     *
     * @param id The queue identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the QueueModel object if successful.
     */
    public QueueModel getQueueById(int id) {
        return getQueueByIdWithServiceResponseAsync(id).toBlocking().single().body();
    }

    /**
     * Gets a single queue by its unique identifier.
     *
     * @param id The queue identifier.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<QueueModel> getQueueByIdAsync(int id, final ServiceCallback<QueueModel> serviceCallback) {
        return ServiceFuture.fromResponse(getQueueByIdWithServiceResponseAsync(id), serviceCallback);
    }

    /**
     * Gets a single queue by its unique identifier.
     *
     * @param id The queue identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the QueueModel object
     */
    public Observable<QueueModel> getQueueByIdAsync(int id) {
        return getQueueByIdWithServiceResponseAsync(id).map(new Func1<ServiceResponse<QueueModel>, QueueModel>() {
            @Override
            public QueueModel call(ServiceResponse<QueueModel> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets a single queue by its unique identifier.
     *
     * @param id The queue identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the QueueModel object
     */
    public Observable<ServiceResponse<QueueModel>> getQueueByIdWithServiceResponseAsync(int id) {
        return service.getQueueById(id)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<QueueModel>>>() {
                @Override
                public Observable<ServiceResponse<QueueModel>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<QueueModel> clientResponse = getQueueByIdDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<QueueModel> getQueueByIdDelegate(Response<ResponseBody> response) throws RestException, IOException {
        return this.restClient().responseBuilderFactory().<QueueModel, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<QueueModel>() { }.getType())
                .register(404, new TypeToken<Void>() { }.getType())
                .build(response);
    }

    /**
     * Updates a specified queue.
     *
     * @param id The unique queue identifier.
     * @param model The queue model.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object updateQueue(int id, QueueBase model) {
        return updateQueueWithServiceResponseAsync(id, model).toBlocking().single().body();
    }

    /**
     * Updates a specified queue.
     *
     * @param id The unique queue identifier.
     * @param model The queue model.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> updateQueueAsync(int id, QueueBase model, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromResponse(updateQueueWithServiceResponseAsync(id, model), serviceCallback);
    }

    /**
     * Updates a specified queue.
     *
     * @param id The unique queue identifier.
     * @param model The queue model.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> updateQueueAsync(int id, QueueBase model) {
        return updateQueueWithServiceResponseAsync(id, model).map(new Func1<ServiceResponse<Object>, Object>() {
            @Override
            public Object call(ServiceResponse<Object> response) {
                return response.body();
            }
        });
    }

    /**
     * Updates a specified queue.
     *
     * @param id The unique queue identifier.
     * @param model The queue model.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> updateQueueWithServiceResponseAsync(int id, QueueBase model) {
        if (model == null) {
            throw new IllegalArgumentException("Parameter model is required and cannot be null.");
        }
        Validator.validate(model);
        return service.updateQueue(id, model)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = updateQueueDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Object> updateQueueDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<Object, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<Object>() { }.getType())
                .register(403, new TypeToken<Void>() { }.getType())
                .register(404, new TypeToken<Void>() { }.getType())
                .build(response);
    }

    /**
     * Deletes a specified queue.
     *
     * @param id The queue identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object deleteQueue(int id) {
        return deleteQueueWithServiceResponseAsync(id).toBlocking().single().body();
    }

    /**
     * Deletes a specified queue.
     *
     * @param id The queue identifier.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> deleteQueueAsync(int id, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromResponse(deleteQueueWithServiceResponseAsync(id), serviceCallback);
    }

    /**
     * Deletes a specified queue.
     *
     * @param id The queue identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> deleteQueueAsync(int id) {
        return deleteQueueWithServiceResponseAsync(id).map(new Func1<ServiceResponse<Object>, Object>() {
            @Override
            public Object call(ServiceResponse<Object> response) {
                return response.body();
            }
        });
    }

    /**
     * Deletes a specified queue.
     *
     * @param id The queue identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> deleteQueueWithServiceResponseAsync(int id) {
        return service.deleteQueue(id)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = deleteQueueDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Object> deleteQueueDelegate(Response<ResponseBody> response) throws RestException, IOException {
        return this.restClient().responseBuilderFactory().<Object, RestException>newInstance(this.serializerAdapter())
                .register(204, new TypeToken<Object>() { }.getType())
                .register(403, new TypeToken<Void>() { }.getType())
                .register(404, new TypeToken<Void>() { }.getType())
                .build(response);
    }

    /**
     * Gets a single queue by its name.
     *
     * @param name The queue name.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the QueueModel object if successful.
     */
    public QueueModel getQueueByName(String name) {
        return getQueueByNameWithServiceResponseAsync(name).toBlocking().single().body();
    }

    /**
     * Gets a single queue by its name.
     *
     * @param name The queue name.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<QueueModel> getQueueByNameAsync(String name, final ServiceCallback<QueueModel> serviceCallback) {
        return ServiceFuture.fromResponse(getQueueByNameWithServiceResponseAsync(name), serviceCallback);
    }

    /**
     * Gets a single queue by its name.
     *
     * @param name The queue name.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the QueueModel object
     */
    public Observable<QueueModel> getQueueByNameAsync(String name) {
        return getQueueByNameWithServiceResponseAsync(name).map(new Func1<ServiceResponse<QueueModel>, QueueModel>() {
            @Override
            public QueueModel call(ServiceResponse<QueueModel> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets a single queue by its name.
     *
     * @param name The queue name.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the QueueModel object
     */
    public Observable<ServiceResponse<QueueModel>> getQueueByNameWithServiceResponseAsync(String name) {
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        return service.getQueueByName(name)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<QueueModel>>>() {
                @Override
                public Observable<ServiceResponse<QueueModel>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<QueueModel> clientResponse = getQueueByNameDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<QueueModel> getQueueByNameDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<QueueModel, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<QueueModel>() { }.getType())
                .register(404, new TypeToken<Void>() { }.getType())
                .build(response);
    }

    /**
     * Gets a paged list of tasks.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;TaskModel&gt; object if successful.
     */
    public List<TaskModel> getTasksByFilter() {
        return getTasksByFilterWithServiceResponseAsync().toBlocking().single().body();
    }

    /**
     * Gets a paged list of tasks.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<TaskModel>> getTasksByFilterAsync(final ServiceCallback<List<TaskModel>> serviceCallback) {
        return ServiceFuture.fromResponse(getTasksByFilterWithServiceResponseAsync(), serviceCallback);
    }

    /**
     * Gets a paged list of tasks.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;TaskModel&gt; object
     */
    public Observable<List<TaskModel>> getTasksByFilterAsync() {
        return getTasksByFilterWithServiceResponseAsync().map(new Func1<ServiceResponse<List<TaskModel>>, List<TaskModel>>() {
            @Override
            public List<TaskModel> call(ServiceResponse<List<TaskModel>> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets a paged list of tasks.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;TaskModel&gt; object
     */
    public Observable<ServiceResponse<List<TaskModel>>> getTasksByFilterWithServiceResponseAsync() {
        final Integer lastTaskID = null;
        final Integer iD = null;
        final Integer type = null;
        final Integer queueID = null;
        final Integer queueType = null;
        final Integer drawerID = null;
        final String description = null;
        final Integer taskID = null;
        final Integer page = null;
        final Integer pageSize = null;
        final String sortOrder = null;
        final String sortBy = null;
        return service.getTasksByFilter(lastTaskID, iD, type, queueID, queueType, drawerID, description, taskID, page, pageSize, sortOrder, sortBy)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<TaskModel>>>>() {
                @Override
                public Observable<ServiceResponse<List<TaskModel>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<TaskModel>> clientResponse = getTasksByFilterDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Gets a paged list of tasks.
     *
     * @param lastTaskID Gets or sets the last task identifier.
     * @param iD Gets or sets the entity identifier.
     * @param type Gets or sets the type of the entity.
     * @param queueID Gets or sets the queue identifier.
     * @param queueType Gets or sets the type of the queue.
     * @param drawerID Gets or sets the drawer identifier.
     * @param description Gets or sets the task description.
     * @param taskID Gets or sets the task identifier.
     * @param page Gets or sets the page number.
     * @param pageSize Gets or sets the size of the page.
     * @param sortOrder Gets or sets the order. Possible values include: 'Unspecified', 'Ascending', 'Descending'
     * @param sortBy Gets or sets the column to order by. Possible values include: 'TaskID', 'QueueID', 'ObjectID', 'Priority', 'Description', 'InsertionTime', 'ResolutionTime', 'ReservedInt1'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;TaskModel&gt; object if successful.
     */
    public List<TaskModel> getTasksByFilter(Integer lastTaskID, Integer iD, Integer type, Integer queueID, Integer queueType, Integer drawerID, String description, Integer taskID, Integer page, Integer pageSize, String sortOrder, String sortBy) {
        return getTasksByFilterWithServiceResponseAsync(lastTaskID, iD, type, queueID, queueType, drawerID, description, taskID, page, pageSize, sortOrder, sortBy).toBlocking().single().body();
    }

    /**
     * Gets a paged list of tasks.
     *
     * @param lastTaskID Gets or sets the last task identifier.
     * @param iD Gets or sets the entity identifier.
     * @param type Gets or sets the type of the entity.
     * @param queueID Gets or sets the queue identifier.
     * @param queueType Gets or sets the type of the queue.
     * @param drawerID Gets or sets the drawer identifier.
     * @param description Gets or sets the task description.
     * @param taskID Gets or sets the task identifier.
     * @param page Gets or sets the page number.
     * @param pageSize Gets or sets the size of the page.
     * @param sortOrder Gets or sets the order. Possible values include: 'Unspecified', 'Ascending', 'Descending'
     * @param sortBy Gets or sets the column to order by. Possible values include: 'TaskID', 'QueueID', 'ObjectID', 'Priority', 'Description', 'InsertionTime', 'ResolutionTime', 'ReservedInt1'
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<TaskModel>> getTasksByFilterAsync(Integer lastTaskID, Integer iD, Integer type, Integer queueID, Integer queueType, Integer drawerID, String description, Integer taskID, Integer page, Integer pageSize, String sortOrder, String sortBy, final ServiceCallback<List<TaskModel>> serviceCallback) {
        return ServiceFuture.fromResponse(getTasksByFilterWithServiceResponseAsync(lastTaskID, iD, type, queueID, queueType, drawerID, description, taskID, page, pageSize, sortOrder, sortBy), serviceCallback);
    }

    /**
     * Gets a paged list of tasks.
     *
     * @param lastTaskID Gets or sets the last task identifier.
     * @param iD Gets or sets the entity identifier.
     * @param type Gets or sets the type of the entity.
     * @param queueID Gets or sets the queue identifier.
     * @param queueType Gets or sets the type of the queue.
     * @param drawerID Gets or sets the drawer identifier.
     * @param description Gets or sets the task description.
     * @param taskID Gets or sets the task identifier.
     * @param page Gets or sets the page number.
     * @param pageSize Gets or sets the size of the page.
     * @param sortOrder Gets or sets the order. Possible values include: 'Unspecified', 'Ascending', 'Descending'
     * @param sortBy Gets or sets the column to order by. Possible values include: 'TaskID', 'QueueID', 'ObjectID', 'Priority', 'Description', 'InsertionTime', 'ResolutionTime', 'ReservedInt1'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;TaskModel&gt; object
     */
    public Observable<List<TaskModel>> getTasksByFilterAsync(Integer lastTaskID, Integer iD, Integer type, Integer queueID, Integer queueType, Integer drawerID, String description, Integer taskID, Integer page, Integer pageSize, String sortOrder, String sortBy) {
        return getTasksByFilterWithServiceResponseAsync(lastTaskID, iD, type, queueID, queueType, drawerID, description, taskID, page, pageSize, sortOrder, sortBy).map(new Func1<ServiceResponse<List<TaskModel>>, List<TaskModel>>() {
            @Override
            public List<TaskModel> call(ServiceResponse<List<TaskModel>> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets a paged list of tasks.
     *
     * @param lastTaskID Gets or sets the last task identifier.
     * @param iD Gets or sets the entity identifier.
     * @param type Gets or sets the type of the entity.
     * @param queueID Gets or sets the queue identifier.
     * @param queueType Gets or sets the type of the queue.
     * @param drawerID Gets or sets the drawer identifier.
     * @param description Gets or sets the task description.
     * @param taskID Gets or sets the task identifier.
     * @param page Gets or sets the page number.
     * @param pageSize Gets or sets the size of the page.
     * @param sortOrder Gets or sets the order. Possible values include: 'Unspecified', 'Ascending', 'Descending'
     * @param sortBy Gets or sets the column to order by. Possible values include: 'TaskID', 'QueueID', 'ObjectID', 'Priority', 'Description', 'InsertionTime', 'ResolutionTime', 'ReservedInt1'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;TaskModel&gt; object
     */
    public Observable<ServiceResponse<List<TaskModel>>> getTasksByFilterWithServiceResponseAsync(Integer lastTaskID, Integer iD, Integer type, Integer queueID, Integer queueType, Integer drawerID, String description, Integer taskID, Integer page, Integer pageSize, String sortOrder, String sortBy) {
        return service.getTasksByFilter(lastTaskID, iD, type, queueID, queueType, drawerID, description, taskID, page, pageSize, sortOrder, sortBy)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<TaskModel>>>>() {
                @Override
                public Observable<ServiceResponse<List<TaskModel>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<TaskModel>> clientResponse = getTasksByFilterDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<List<TaskModel>> getTasksByFilterDelegate(Response<ResponseBody> response) throws RestException, IOException {
        return this.restClient().responseBuilderFactory().<List<TaskModel>, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<List<TaskModel>>() { }.getType())
                .build(response);
    }

    /**
     * Creates a new task.
     *
     * @param model The task model.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object createTask(InsertTaskRequestModel model) {
        return createTaskWithServiceResponseAsync(model).toBlocking().single().body();
    }

    /**
     * Creates a new task.
     *
     * @param model The task model.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> createTaskAsync(InsertTaskRequestModel model, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromResponse(createTaskWithServiceResponseAsync(model), serviceCallback);
    }

    /**
     * Creates a new task.
     *
     * @param model The task model.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> createTaskAsync(InsertTaskRequestModel model) {
        return createTaskWithServiceResponseAsync(model).map(new Func1<ServiceResponse<Object>, Object>() {
            @Override
            public Object call(ServiceResponse<Object> response) {
                return response.body();
            }
        });
    }

    /**
     * Creates a new task.
     *
     * @param model The task model.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> createTaskWithServiceResponseAsync(InsertTaskRequestModel model) {
        if (model == null) {
            throw new IllegalArgumentException("Parameter model is required and cannot be null.");
        }
        Validator.validate(model);
        return service.createTask(model)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = createTaskDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Object> createTaskDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<Object, RestException>newInstance(this.serializerAdapter())
                .register(201, new TypeToken<Object>() { }.getType())
                .register(403, new TypeToken<Void>() { }.getType())
                .register(404, new TypeToken<Void>() { }.getType())
                .register(409, new TypeToken<Void>() { }.getType())
                .build(response);
    }

    /**
     * Gets a single task based on its unique identifier.
     *
     * @param id The identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the TaskModel object if successful.
     */
    public TaskModel getTaskById(int id) {
        return getTaskByIdWithServiceResponseAsync(id).toBlocking().single().body();
    }

    /**
     * Gets a single task based on its unique identifier.
     *
     * @param id The identifier.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<TaskModel> getTaskByIdAsync(int id, final ServiceCallback<TaskModel> serviceCallback) {
        return ServiceFuture.fromResponse(getTaskByIdWithServiceResponseAsync(id), serviceCallback);
    }

    /**
     * Gets a single task based on its unique identifier.
     *
     * @param id The identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the TaskModel object
     */
    public Observable<TaskModel> getTaskByIdAsync(int id) {
        return getTaskByIdWithServiceResponseAsync(id).map(new Func1<ServiceResponse<TaskModel>, TaskModel>() {
            @Override
            public TaskModel call(ServiceResponse<TaskModel> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets a single task based on its unique identifier.
     *
     * @param id The identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the TaskModel object
     */
    public Observable<ServiceResponse<TaskModel>> getTaskByIdWithServiceResponseAsync(int id) {
        return service.getTaskById(id)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<TaskModel>>>() {
                @Override
                public Observable<ServiceResponse<TaskModel>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<TaskModel> clientResponse = getTaskByIdDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<TaskModel> getTaskByIdDelegate(Response<ResponseBody> response) throws RestException, IOException {
        return this.restClient().responseBuilderFactory().<TaskModel, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<TaskModel>() { }.getType())
                .register(404, new TypeToken<Void>() { }.getType())
                .build(response);
    }

    /**
     * Updates a specified task.
     *
     * @param id The identifier.
     * @param model The task model.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object updateTask(int id, TaskBase model) {
        return updateTaskWithServiceResponseAsync(id, model).toBlocking().single().body();
    }

    /**
     * Updates a specified task.
     *
     * @param id The identifier.
     * @param model The task model.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> updateTaskAsync(int id, TaskBase model, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromResponse(updateTaskWithServiceResponseAsync(id, model), serviceCallback);
    }

    /**
     * Updates a specified task.
     *
     * @param id The identifier.
     * @param model The task model.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> updateTaskAsync(int id, TaskBase model) {
        return updateTaskWithServiceResponseAsync(id, model).map(new Func1<ServiceResponse<Object>, Object>() {
            @Override
            public Object call(ServiceResponse<Object> response) {
                return response.body();
            }
        });
    }

    /**
     * Updates a specified task.
     *
     * @param id The identifier.
     * @param model The task model.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> updateTaskWithServiceResponseAsync(int id, TaskBase model) {
        if (model == null) {
            throw new IllegalArgumentException("Parameter model is required and cannot be null.");
        }
        Validator.validate(model);
        return service.updateTask(id, model)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = updateTaskDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Object> updateTaskDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<Object, RestException>newInstance(this.serializerAdapter())
                .register(204, new TypeToken<Object>() { }.getType())
                .register(403, new TypeToken<Void>() { }.getType())
                .register(404, new TypeToken<Void>() { }.getType())
                .build(response);
    }

    /**
     * Deletes a specified task.
     *
     * @param id The identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object deleteTask(int id) {
        return deleteTaskWithServiceResponseAsync(id).toBlocking().single().body();
    }

    /**
     * Deletes a specified task.
     *
     * @param id The identifier.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> deleteTaskAsync(int id, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromResponse(deleteTaskWithServiceResponseAsync(id), serviceCallback);
    }

    /**
     * Deletes a specified task.
     *
     * @param id The identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> deleteTaskAsync(int id) {
        return deleteTaskWithServiceResponseAsync(id).map(new Func1<ServiceResponse<Object>, Object>() {
            @Override
            public Object call(ServiceResponse<Object> response) {
                return response.body();
            }
        });
    }

    /**
     * Deletes a specified task.
     *
     * @param id The identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> deleteTaskWithServiceResponseAsync(int id) {
        return service.deleteTask(id)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = deleteTaskDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Object> deleteTaskDelegate(Response<ResponseBody> response) throws RestException, IOException {
        return this.restClient().responseBuilderFactory().<Object, RestException>newInstance(this.serializerAdapter())
                .register(204, new TypeToken<Object>() { }.getType())
                .register(403, new TypeToken<Void>() { }.getType())
                .register(404, new TypeToken<Void>() { }.getType())
                .build(response);
    }

    /**
     * Gets a single task based on user predefined queue assignment criteria.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the TaskModel object if successful.
     */
    public TaskModel fetchTaskFromQueueAssignment() {
        return fetchTaskFromQueueAssignmentWithServiceResponseAsync().toBlocking().single().body();
    }

    /**
     * Gets a single task based on user predefined queue assignment criteria.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<TaskModel> fetchTaskFromQueueAssignmentAsync(final ServiceCallback<TaskModel> serviceCallback) {
        return ServiceFuture.fromResponse(fetchTaskFromQueueAssignmentWithServiceResponseAsync(), serviceCallback);
    }

    /**
     * Gets a single task based on user predefined queue assignment criteria.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the TaskModel object
     */
    public Observable<TaskModel> fetchTaskFromQueueAssignmentAsync() {
        return fetchTaskFromQueueAssignmentWithServiceResponseAsync().map(new Func1<ServiceResponse<TaskModel>, TaskModel>() {
            @Override
            public TaskModel call(ServiceResponse<TaskModel> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets a single task based on user predefined queue assignment criteria.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the TaskModel object
     */
    public Observable<ServiceResponse<TaskModel>> fetchTaskFromQueueAssignmentWithServiceResponseAsync() {
        return service.fetchTaskFromQueueAssignment()
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<TaskModel>>>() {
                @Override
                public Observable<ServiceResponse<TaskModel>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<TaskModel> clientResponse = fetchTaskFromQueueAssignmentDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<TaskModel> fetchTaskFromQueueAssignmentDelegate(Response<ResponseBody> response) throws RestException, IOException {
        return this.restClient().responseBuilderFactory().<TaskModel, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<TaskModel>() { }.getType())
                .register(404, new TypeToken<Void>() { }.getType())
                .build(response);
    }

    /**
     * Gets a paged list of users.Gets a paged list of users.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;UserModel&gt; object if successful.
     */
    public List<UserModel> getUsersByFilter() {
        return getUsersByFilterWithServiceResponseAsync().toBlocking().single().body();
    }

    /**
     * Gets a paged list of users.Gets a paged list of users.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<UserModel>> getUsersByFilterAsync(final ServiceCallback<List<UserModel>> serviceCallback) {
        return ServiceFuture.fromResponse(getUsersByFilterWithServiceResponseAsync(), serviceCallback);
    }

    /**
     * Gets a paged list of users.Gets a paged list of users.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;UserModel&gt; object
     */
    public Observable<List<UserModel>> getUsersByFilterAsync() {
        return getUsersByFilterWithServiceResponseAsync().map(new Func1<ServiceResponse<List<UserModel>>, List<UserModel>>() {
            @Override
            public List<UserModel> call(ServiceResponse<List<UserModel>> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets a paged list of users.Gets a paged list of users.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;UserModel&gt; object
     */
    public Observable<ServiceResponse<List<UserModel>>> getUsersByFilterWithServiceResponseAsync() {
        final Integer iD = null;
        final Integer primaryGroupID = null;
        final Integer groupID = null;
        final String groupName = null;
        final String username = null;
        final String type = null;
        final String state = null;
        final String fullName = null;
        final Integer page = null;
        final Integer pageSize = null;
        final String sortOrder = null;
        final String sortBy = null;
        return service.getUsersByFilter(iD, primaryGroupID, groupID, groupName, username, type, state, fullName, page, pageSize, sortOrder, sortBy)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<UserModel>>>>() {
                @Override
                public Observable<ServiceResponse<List<UserModel>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<UserModel>> clientResponse = getUsersByFilterDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Gets a paged list of users.Gets a paged list of users.
     *
     * @param iD Gets or sets the identifier.
     * @param primaryGroupID Gets or sets the primary group identifier.
     * @param groupID Gets or sets the group identifier.
     * @param groupName Gets or sets the name of the group.
     * @param username Gets or sets the username.
     * @param type Gets or sets the type. Possible values include: 'ImageDesk', 'PublishDesk', 'FaxDesk', 'CaptureDesk', 'RecognitionDesk', 'PortalUser', 'AdminDesk', 'WorkflowDesk', 'Benchmark', 'ReportDesk', 'ColdDesk', 'PortalDesk', 'WorkflowArchitect', 'DocumentDesk', 'Poweruser'
     * @param state Gets or sets the state. Possible values include: 'Active', 'Inactive'
     * @param fullName Gets or sets the full name.
     * @param page Gets or sets the page number.
     * @param pageSize Gets or sets the size of the page.
     * @param sortOrder Gets or sets the order. Possible values include: 'Unspecified', 'Ascending', 'Descending'
     * @param sortBy Gets or sets the column to order by. Possible values include: 'ID', 'PrimaryGroupID', 'Username', 'UserFullName', 'Type', 'State'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;UserModel&gt; object if successful.
     */
    public List<UserModel> getUsersByFilter(Integer iD, Integer primaryGroupID, Integer groupID, String groupName, String username, String type, String state, String fullName, Integer page, Integer pageSize, String sortOrder, String sortBy) {
        return getUsersByFilterWithServiceResponseAsync(iD, primaryGroupID, groupID, groupName, username, type, state, fullName, page, pageSize, sortOrder, sortBy).toBlocking().single().body();
    }

    /**
     * Gets a paged list of users.Gets a paged list of users.
     *
     * @param iD Gets or sets the identifier.
     * @param primaryGroupID Gets or sets the primary group identifier.
     * @param groupID Gets or sets the group identifier.
     * @param groupName Gets or sets the name of the group.
     * @param username Gets or sets the username.
     * @param type Gets or sets the type. Possible values include: 'ImageDesk', 'PublishDesk', 'FaxDesk', 'CaptureDesk', 'RecognitionDesk', 'PortalUser', 'AdminDesk', 'WorkflowDesk', 'Benchmark', 'ReportDesk', 'ColdDesk', 'PortalDesk', 'WorkflowArchitect', 'DocumentDesk', 'Poweruser'
     * @param state Gets or sets the state. Possible values include: 'Active', 'Inactive'
     * @param fullName Gets or sets the full name.
     * @param page Gets or sets the page number.
     * @param pageSize Gets or sets the size of the page.
     * @param sortOrder Gets or sets the order. Possible values include: 'Unspecified', 'Ascending', 'Descending'
     * @param sortBy Gets or sets the column to order by. Possible values include: 'ID', 'PrimaryGroupID', 'Username', 'UserFullName', 'Type', 'State'
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<UserModel>> getUsersByFilterAsync(Integer iD, Integer primaryGroupID, Integer groupID, String groupName, String username, String type, String state, String fullName, Integer page, Integer pageSize, String sortOrder, String sortBy, final ServiceCallback<List<UserModel>> serviceCallback) {
        return ServiceFuture.fromResponse(getUsersByFilterWithServiceResponseAsync(iD, primaryGroupID, groupID, groupName, username, type, state, fullName, page, pageSize, sortOrder, sortBy), serviceCallback);
    }

    /**
     * Gets a paged list of users.Gets a paged list of users.
     *
     * @param iD Gets or sets the identifier.
     * @param primaryGroupID Gets or sets the primary group identifier.
     * @param groupID Gets or sets the group identifier.
     * @param groupName Gets or sets the name of the group.
     * @param username Gets or sets the username.
     * @param type Gets or sets the type. Possible values include: 'ImageDesk', 'PublishDesk', 'FaxDesk', 'CaptureDesk', 'RecognitionDesk', 'PortalUser', 'AdminDesk', 'WorkflowDesk', 'Benchmark', 'ReportDesk', 'ColdDesk', 'PortalDesk', 'WorkflowArchitect', 'DocumentDesk', 'Poweruser'
     * @param state Gets or sets the state. Possible values include: 'Active', 'Inactive'
     * @param fullName Gets or sets the full name.
     * @param page Gets or sets the page number.
     * @param pageSize Gets or sets the size of the page.
     * @param sortOrder Gets or sets the order. Possible values include: 'Unspecified', 'Ascending', 'Descending'
     * @param sortBy Gets or sets the column to order by. Possible values include: 'ID', 'PrimaryGroupID', 'Username', 'UserFullName', 'Type', 'State'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;UserModel&gt; object
     */
    public Observable<List<UserModel>> getUsersByFilterAsync(Integer iD, Integer primaryGroupID, Integer groupID, String groupName, String username, String type, String state, String fullName, Integer page, Integer pageSize, String sortOrder, String sortBy) {
        return getUsersByFilterWithServiceResponseAsync(iD, primaryGroupID, groupID, groupName, username, type, state, fullName, page, pageSize, sortOrder, sortBy).map(new Func1<ServiceResponse<List<UserModel>>, List<UserModel>>() {
            @Override
            public List<UserModel> call(ServiceResponse<List<UserModel>> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets a paged list of users.Gets a paged list of users.
     *
     * @param iD Gets or sets the identifier.
     * @param primaryGroupID Gets or sets the primary group identifier.
     * @param groupID Gets or sets the group identifier.
     * @param groupName Gets or sets the name of the group.
     * @param username Gets or sets the username.
     * @param type Gets or sets the type. Possible values include: 'ImageDesk', 'PublishDesk', 'FaxDesk', 'CaptureDesk', 'RecognitionDesk', 'PortalUser', 'AdminDesk', 'WorkflowDesk', 'Benchmark', 'ReportDesk', 'ColdDesk', 'PortalDesk', 'WorkflowArchitect', 'DocumentDesk', 'Poweruser'
     * @param state Gets or sets the state. Possible values include: 'Active', 'Inactive'
     * @param fullName Gets or sets the full name.
     * @param page Gets or sets the page number.
     * @param pageSize Gets or sets the size of the page.
     * @param sortOrder Gets or sets the order. Possible values include: 'Unspecified', 'Ascending', 'Descending'
     * @param sortBy Gets or sets the column to order by. Possible values include: 'ID', 'PrimaryGroupID', 'Username', 'UserFullName', 'Type', 'State'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;UserModel&gt; object
     */
    public Observable<ServiceResponse<List<UserModel>>> getUsersByFilterWithServiceResponseAsync(Integer iD, Integer primaryGroupID, Integer groupID, String groupName, String username, String type, String state, String fullName, Integer page, Integer pageSize, String sortOrder, String sortBy) {
        return service.getUsersByFilter(iD, primaryGroupID, groupID, groupName, username, type, state, fullName, page, pageSize, sortOrder, sortBy)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<UserModel>>>>() {
                @Override
                public Observable<ServiceResponse<List<UserModel>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<UserModel>> clientResponse = getUsersByFilterDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<List<UserModel>> getUsersByFilterDelegate(Response<ResponseBody> response) throws RestException, IOException {
        return this.restClient().responseBuilderFactory().<List<UserModel>, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<List<UserModel>>() { }.getType())
                .register(403, new TypeToken<Void>() { }.getType())
                .build(response);
    }

    /**
     * Creates a new user.
     *
     * @param model The user model.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the UserModel object if successful.
     */
    public UserModel createUser(InsertUserRequestModel model) {
        return createUserWithServiceResponseAsync(model).toBlocking().single().body();
    }

    /**
     * Creates a new user.
     *
     * @param model The user model.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<UserModel> createUserAsync(InsertUserRequestModel model, final ServiceCallback<UserModel> serviceCallback) {
        return ServiceFuture.fromResponse(createUserWithServiceResponseAsync(model), serviceCallback);
    }

    /**
     * Creates a new user.
     *
     * @param model The user model.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the UserModel object
     */
    public Observable<UserModel> createUserAsync(InsertUserRequestModel model) {
        return createUserWithServiceResponseAsync(model).map(new Func1<ServiceResponse<UserModel>, UserModel>() {
            @Override
            public UserModel call(ServiceResponse<UserModel> response) {
                return response.body();
            }
        });
    }

    /**
     * Creates a new user.
     *
     * @param model The user model.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the UserModel object
     */
    public Observable<ServiceResponse<UserModel>> createUserWithServiceResponseAsync(InsertUserRequestModel model) {
        if (model == null) {
            throw new IllegalArgumentException("Parameter model is required and cannot be null.");
        }
        Validator.validate(model);
        return service.createUser(model)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<UserModel>>>() {
                @Override
                public Observable<ServiceResponse<UserModel>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<UserModel> clientResponse = createUserDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<UserModel> createUserDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<UserModel, RestException>newInstance(this.serializerAdapter())
                .register(201, new TypeToken<UserModel>() { }.getType())
                .register(403, new TypeToken<Void>() { }.getType())
                .register(409, new TypeToken<Void>() { }.getType())
                .build(response);
    }

    /**
     * Gets a single user by its unique identifier.
     *
     * @param id The user identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the UserModel object if successful.
     */
    public UserModel getUserById(int id) {
        return getUserByIdWithServiceResponseAsync(id).toBlocking().single().body();
    }

    /**
     * Gets a single user by its unique identifier.
     *
     * @param id The user identifier.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<UserModel> getUserByIdAsync(int id, final ServiceCallback<UserModel> serviceCallback) {
        return ServiceFuture.fromResponse(getUserByIdWithServiceResponseAsync(id), serviceCallback);
    }

    /**
     * Gets a single user by its unique identifier.
     *
     * @param id The user identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the UserModel object
     */
    public Observable<UserModel> getUserByIdAsync(int id) {
        return getUserByIdWithServiceResponseAsync(id).map(new Func1<ServiceResponse<UserModel>, UserModel>() {
            @Override
            public UserModel call(ServiceResponse<UserModel> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets a single user by its unique identifier.
     *
     * @param id The user identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the UserModel object
     */
    public Observable<ServiceResponse<UserModel>> getUserByIdWithServiceResponseAsync(int id) {
        return service.getUserById(id)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<UserModel>>>() {
                @Override
                public Observable<ServiceResponse<UserModel>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<UserModel> clientResponse = getUserByIdDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<UserModel> getUserByIdDelegate(Response<ResponseBody> response) throws RestException, IOException {
        return this.restClient().responseBuilderFactory().<UserModel, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<UserModel>() { }.getType())
                .register(403, new TypeToken<Void>() { }.getType())
                .register(404, new TypeToken<Void>() { }.getType())
                .build(response);
    }

    /**
     * Updates a specified user.
     *
     * @param id The user identifier.
     * @param model The user model.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object updateUser(int id, UserBase model) {
        return updateUserWithServiceResponseAsync(id, model).toBlocking().single().body();
    }

    /**
     * Updates a specified user.
     *
     * @param id The user identifier.
     * @param model The user model.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> updateUserAsync(int id, UserBase model, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromResponse(updateUserWithServiceResponseAsync(id, model), serviceCallback);
    }

    /**
     * Updates a specified user.
     *
     * @param id The user identifier.
     * @param model The user model.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> updateUserAsync(int id, UserBase model) {
        return updateUserWithServiceResponseAsync(id, model).map(new Func1<ServiceResponse<Object>, Object>() {
            @Override
            public Object call(ServiceResponse<Object> response) {
                return response.body();
            }
        });
    }

    /**
     * Updates a specified user.
     *
     * @param id The user identifier.
     * @param model The user model.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> updateUserWithServiceResponseAsync(int id, UserBase model) {
        if (model == null) {
            throw new IllegalArgumentException("Parameter model is required and cannot be null.");
        }
        Validator.validate(model);
        return service.updateUser(id, model)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = updateUserDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Object> updateUserDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<Object, RestException>newInstance(this.serializerAdapter())
                .register(204, new TypeToken<Object>() { }.getType())
                .register(403, new TypeToken<Void>() { }.getType())
                .register(404, new TypeToken<Void>() { }.getType())
                .build(response);
    }

    /**
     * Deactivates a specified user and removes all user associations.
     *
     * @param id The user identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object deleteUser(int id) {
        return deleteUserWithServiceResponseAsync(id).toBlocking().single().body();
    }

    /**
     * Deactivates a specified user and removes all user associations.
     *
     * @param id The user identifier.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> deleteUserAsync(int id, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromResponse(deleteUserWithServiceResponseAsync(id), serviceCallback);
    }

    /**
     * Deactivates a specified user and removes all user associations.
     *
     * @param id The user identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> deleteUserAsync(int id) {
        return deleteUserWithServiceResponseAsync(id).map(new Func1<ServiceResponse<Object>, Object>() {
            @Override
            public Object call(ServiceResponse<Object> response) {
                return response.body();
            }
        });
    }

    /**
     * Deactivates a specified user and removes all user associations.
     *
     * @param id The user identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> deleteUserWithServiceResponseAsync(int id) {
        return service.deleteUser(id)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = deleteUserDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Object> deleteUserDelegate(Response<ResponseBody> response) throws RestException, IOException {
        return this.restClient().responseBuilderFactory().<Object, RestException>newInstance(this.serializerAdapter())
                .register(204, new TypeToken<Object>() { }.getType())
                .register(403, new TypeToken<Void>() { }.getType())
                .register(404, new TypeToken<Void>() { }.getType())
                .build(response);
    }

    /**
     * Gets a paged list of workflows.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;WorkflowModel&gt; object if successful.
     */
    public List<WorkflowModel> getWorkflowsByFilter() {
        return getWorkflowsByFilterWithServiceResponseAsync().toBlocking().single().body();
    }

    /**
     * Gets a paged list of workflows.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<WorkflowModel>> getWorkflowsByFilterAsync(final ServiceCallback<List<WorkflowModel>> serviceCallback) {
        return ServiceFuture.fromResponse(getWorkflowsByFilterWithServiceResponseAsync(), serviceCallback);
    }

    /**
     * Gets a paged list of workflows.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;WorkflowModel&gt; object
     */
    public Observable<List<WorkflowModel>> getWorkflowsByFilterAsync() {
        return getWorkflowsByFilterWithServiceResponseAsync().map(new Func1<ServiceResponse<List<WorkflowModel>>, List<WorkflowModel>>() {
            @Override
            public List<WorkflowModel> call(ServiceResponse<List<WorkflowModel>> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets a paged list of workflows.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;WorkflowModel&gt; object
     */
    public Observable<ServiceResponse<List<WorkflowModel>>> getWorkflowsByFilterWithServiceResponseAsync() {
        final Integer applicationID = null;
        final Integer entityType = null;
        final String name = null;
        final Integer page = null;
        final Integer pageSize = null;
        final String sortOrder = null;
        final Integer sortBy = null;
        return service.getWorkflowsByFilter(applicationID, entityType, name, page, pageSize, sortOrder, sortBy)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<WorkflowModel>>>>() {
                @Override
                public Observable<ServiceResponse<List<WorkflowModel>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<WorkflowModel>> clientResponse = getWorkflowsByFilterDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Gets a paged list of workflows.
     *
     * @param applicationID Gets or sets the application identifier.
     * @param entityType Gets or sets the type of the entity.
     * @param name Gets or sets the name.
     * @param page Gets or sets the page number.
     * @param pageSize Gets or sets the size of the page.
     * @param sortOrder Gets or sets the order. Possible values include: 'Unspecified', 'Ascending', 'Descending'
     * @param sortBy Gets or sets the column to order by.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;WorkflowModel&gt; object if successful.
     */
    public List<WorkflowModel> getWorkflowsByFilter(Integer applicationID, Integer entityType, String name, Integer page, Integer pageSize, String sortOrder, Integer sortBy) {
        return getWorkflowsByFilterWithServiceResponseAsync(applicationID, entityType, name, page, pageSize, sortOrder, sortBy).toBlocking().single().body();
    }

    /**
     * Gets a paged list of workflows.
     *
     * @param applicationID Gets or sets the application identifier.
     * @param entityType Gets or sets the type of the entity.
     * @param name Gets or sets the name.
     * @param page Gets or sets the page number.
     * @param pageSize Gets or sets the size of the page.
     * @param sortOrder Gets or sets the order. Possible values include: 'Unspecified', 'Ascending', 'Descending'
     * @param sortBy Gets or sets the column to order by.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<WorkflowModel>> getWorkflowsByFilterAsync(Integer applicationID, Integer entityType, String name, Integer page, Integer pageSize, String sortOrder, Integer sortBy, final ServiceCallback<List<WorkflowModel>> serviceCallback) {
        return ServiceFuture.fromResponse(getWorkflowsByFilterWithServiceResponseAsync(applicationID, entityType, name, page, pageSize, sortOrder, sortBy), serviceCallback);
    }

    /**
     * Gets a paged list of workflows.
     *
     * @param applicationID Gets or sets the application identifier.
     * @param entityType Gets or sets the type of the entity.
     * @param name Gets or sets the name.
     * @param page Gets or sets the page number.
     * @param pageSize Gets or sets the size of the page.
     * @param sortOrder Gets or sets the order. Possible values include: 'Unspecified', 'Ascending', 'Descending'
     * @param sortBy Gets or sets the column to order by.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;WorkflowModel&gt; object
     */
    public Observable<List<WorkflowModel>> getWorkflowsByFilterAsync(Integer applicationID, Integer entityType, String name, Integer page, Integer pageSize, String sortOrder, Integer sortBy) {
        return getWorkflowsByFilterWithServiceResponseAsync(applicationID, entityType, name, page, pageSize, sortOrder, sortBy).map(new Func1<ServiceResponse<List<WorkflowModel>>, List<WorkflowModel>>() {
            @Override
            public List<WorkflowModel> call(ServiceResponse<List<WorkflowModel>> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets a paged list of workflows.
     *
     * @param applicationID Gets or sets the application identifier.
     * @param entityType Gets or sets the type of the entity.
     * @param name Gets or sets the name.
     * @param page Gets or sets the page number.
     * @param pageSize Gets or sets the size of the page.
     * @param sortOrder Gets or sets the order. Possible values include: 'Unspecified', 'Ascending', 'Descending'
     * @param sortBy Gets or sets the column to order by.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;WorkflowModel&gt; object
     */
    public Observable<ServiceResponse<List<WorkflowModel>>> getWorkflowsByFilterWithServiceResponseAsync(Integer applicationID, Integer entityType, String name, Integer page, Integer pageSize, String sortOrder, Integer sortBy) {
        return service.getWorkflowsByFilter(applicationID, entityType, name, page, pageSize, sortOrder, sortBy)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<WorkflowModel>>>>() {
                @Override
                public Observable<ServiceResponse<List<WorkflowModel>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<WorkflowModel>> clientResponse = getWorkflowsByFilterDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<List<WorkflowModel>> getWorkflowsByFilterDelegate(Response<ResponseBody> response) throws RestException, IOException {
        return this.restClient().responseBuilderFactory().<List<WorkflowModel>, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<List<WorkflowModel>>() { }.getType())
                .build(response);
    }

    /**
     * Gets a single workflow based on its unique identifier.
     *
     * @param id The workflow identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the WorkflowModel object if successful.
     */
    public WorkflowModel getWorkflowById(int id) {
        return getWorkflowByIdWithServiceResponseAsync(id).toBlocking().single().body();
    }

    /**
     * Gets a single workflow based on its unique identifier.
     *
     * @param id The workflow identifier.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<WorkflowModel> getWorkflowByIdAsync(int id, final ServiceCallback<WorkflowModel> serviceCallback) {
        return ServiceFuture.fromResponse(getWorkflowByIdWithServiceResponseAsync(id), serviceCallback);
    }

    /**
     * Gets a single workflow based on its unique identifier.
     *
     * @param id The workflow identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the WorkflowModel object
     */
    public Observable<WorkflowModel> getWorkflowByIdAsync(int id) {
        return getWorkflowByIdWithServiceResponseAsync(id).map(new Func1<ServiceResponse<WorkflowModel>, WorkflowModel>() {
            @Override
            public WorkflowModel call(ServiceResponse<WorkflowModel> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets a single workflow based on its unique identifier.
     *
     * @param id The workflow identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the WorkflowModel object
     */
    public Observable<ServiceResponse<WorkflowModel>> getWorkflowByIdWithServiceResponseAsync(int id) {
        return service.getWorkflowById(id)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<WorkflowModel>>>() {
                @Override
                public Observable<ServiceResponse<WorkflowModel>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<WorkflowModel> clientResponse = getWorkflowByIdDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<WorkflowModel> getWorkflowByIdDelegate(Response<ResponseBody> response) throws RestException, IOException {
        return this.restClient().responseBuilderFactory().<WorkflowModel, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<WorkflowModel>() { }.getType())
                .register(404, new TypeToken<Void>() { }.getType())
                .build(response);
    }

    /**
     * Gets queues for a specific workflow.
     *
     * @param id The workflow identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;WorkflowQueueModel&gt; object if successful.
     */
    public List<WorkflowQueueModel> getWorkflowQueuesById(int id) {
        return getWorkflowQueuesByIdWithServiceResponseAsync(id).toBlocking().single().body();
    }

    /**
     * Gets queues for a specific workflow.
     *
     * @param id The workflow identifier.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<WorkflowQueueModel>> getWorkflowQueuesByIdAsync(int id, final ServiceCallback<List<WorkflowQueueModel>> serviceCallback) {
        return ServiceFuture.fromResponse(getWorkflowQueuesByIdWithServiceResponseAsync(id), serviceCallback);
    }

    /**
     * Gets queues for a specific workflow.
     *
     * @param id The workflow identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;WorkflowQueueModel&gt; object
     */
    public Observable<List<WorkflowQueueModel>> getWorkflowQueuesByIdAsync(int id) {
        return getWorkflowQueuesByIdWithServiceResponseAsync(id).map(new Func1<ServiceResponse<List<WorkflowQueueModel>>, List<WorkflowQueueModel>>() {
            @Override
            public List<WorkflowQueueModel> call(ServiceResponse<List<WorkflowQueueModel>> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets queues for a specific workflow.
     *
     * @param id The workflow identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;WorkflowQueueModel&gt; object
     */
    public Observable<ServiceResponse<List<WorkflowQueueModel>>> getWorkflowQueuesByIdWithServiceResponseAsync(int id) {
        return service.getWorkflowQueuesById(id)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<WorkflowQueueModel>>>>() {
                @Override
                public Observable<ServiceResponse<List<WorkflowQueueModel>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<WorkflowQueueModel>> clientResponse = getWorkflowQueuesByIdDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<List<WorkflowQueueModel>> getWorkflowQueuesByIdDelegate(Response<ResponseBody> response) throws RestException, IOException {
        return this.restClient().responseBuilderFactory().<List<WorkflowQueueModel>, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<List<WorkflowQueueModel>>() { }.getType())
                .register(404, new TypeToken<Void>() { }.getType())
                .build(response);
    }

    /**
     * Gets a single entity template definition completed with all profiles definitions as XML entity definition.
     *
     * @param type The unique template type.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the String object if successful.
     */
    public String getXMLTemplateByType(int type) {
        return getXMLTemplateByTypeWithServiceResponseAsync(type).toBlocking().single().body();
    }

    /**
     * Gets a single entity template definition completed with all profiles definitions as XML entity definition.
     *
     * @param type The unique template type.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<String> getXMLTemplateByTypeAsync(int type, final ServiceCallback<String> serviceCallback) {
        return ServiceFuture.fromResponse(getXMLTemplateByTypeWithServiceResponseAsync(type), serviceCallback);
    }

    /**
     * Gets a single entity template definition completed with all profiles definitions as XML entity definition.
     *
     * @param type The unique template type.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the String object
     */
    public Observable<String> getXMLTemplateByTypeAsync(int type) {
        return getXMLTemplateByTypeWithServiceResponseAsync(type).map(new Func1<ServiceResponse<String>, String>() {
            @Override
            public String call(ServiceResponse<String> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets a single entity template definition completed with all profiles definitions as XML entity definition.
     *
     * @param type The unique template type.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the String object
     */
    public Observable<ServiceResponse<String>> getXMLTemplateByTypeWithServiceResponseAsync(int type) {
        return service.getXMLTemplateByType(type)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<String>>>() {
                @Override
                public Observable<ServiceResponse<String>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<String> clientResponse = getXMLTemplateByTypeDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<String> getXMLTemplateByTypeDelegate(Response<ResponseBody> response) throws RestException, IOException {
        return this.restClient().responseBuilderFactory().<String, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<String>() { }.getType())
                .register(404, new TypeToken<Void>() { }.getType())
                .build(response);
    }

    /**
     * Creates a new entity template definition.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the String object if successful.
     */
    public String createXMLTemplate() {
        return createXMLTemplateWithServiceResponseAsync().toBlocking().single().body();
    }

    /**
     * Creates a new entity template definition.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<String> createXMLTemplateAsync(final ServiceCallback<String> serviceCallback) {
        return ServiceFuture.fromResponse(createXMLTemplateWithServiceResponseAsync(), serviceCallback);
    }

    /**
     * Creates a new entity template definition.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the String object
     */
    public Observable<String> createXMLTemplateAsync() {
        return createXMLTemplateWithServiceResponseAsync().map(new Func1<ServiceResponse<String>, String>() {
            @Override
            public String call(ServiceResponse<String> response) {
                return response.body();
            }
        });
    }

    /**
     * Creates a new entity template definition.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the String object
     */
    public Observable<ServiceResponse<String>> createXMLTemplateWithServiceResponseAsync() {
        return service.createXMLTemplate()
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<String>>>() {
                @Override
                public Observable<ServiceResponse<String>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<String> clientResponse = createXMLTemplateDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<String> createXMLTemplateDelegate(Response<ResponseBody> response) throws RestException, IOException {
        return this.restClient().responseBuilderFactory().<String, RestException>newInstance(this.serializerAdapter())
                .register(201, new TypeToken<String>() { }.getType())
                .register(400, new TypeToken<Void>() { }.getType())
                .register(403, new TypeToken<Void>() { }.getType())
                .register(409, new TypeToken<Void>() { }.getType())
                .build(response);
    }

}
