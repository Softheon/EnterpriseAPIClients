# encoding: utf-8
# Code generated by Microsoft (R) AutoRest Code Generator.
# Changes may cause incorrect behavior and will be lost if the code is
# regenerated.

module Softheon.Enterprise.Api.Client
  #
  # A service client - single point of access to the REST API.
  #
  class SoftheonEnterpriseAPI < MsRest::ServiceClient
    include MsRest::Serialization

    # @return [String] the base URI of the service.
    attr_accessor :base_url

    # @return Subscription credentials which uniquely identify client
    # subscription.
    attr_accessor :credentials

    #
    # Creates initializes a new instance of the SoftheonEnterpriseAPI class.
    # @param credentials [MsRest::ServiceClientCredentials] credentials to authorize HTTP requests made by the service client.
    # @param base_url [String] the base URI of the service.
    # @param options [Array] filters to be applied to the HTTP requests.
    #
    def initialize(credentials = nil, base_url = nil, options = nil)
      super(credentials, options)
      @base_url = base_url || 'http://localhost:54963'

      fail ArgumentError, 'invalid type of credentials input parameter' unless credentials.is_a?(MsRest::ServiceClientCredentials) unless credentials.nil?
      @credentials = credentials

      add_telemetry
    end

    #
    # Makes a request and returns the body of the response.
    # @param method [Symbol] with any of the following values :get, :put, :post, :patch, :delete.
    # @param path [String] the path, relative to {base_url}.
    # @param options [Hash{String=>String}] specifying any request options like :body.
    # @return [Hash{String=>String}] containing the body of the response.
    # Example:
    #
    #  request_content = "{'location':'westus','tags':{'tag1':'val1','tag2':'val2'}}"
    #  path = "/path"
    #  options = {
    #    body: request_content,
    #    query_params: {'api-version' => '2016-02-01'}
    #  }
    #  result = @client.make_request(:put, path, options)
    #
    def make_request(method, path, options = {})
      result = make_request_with_http_info(method, path, options)
      result.body unless result.nil?
    end

    #
    # Makes a request and returns the operation response.
    # @param method [Symbol] with any of the following values :get, :put, :post, :patch, :delete.
    # @param path [String] the path, relative to {base_url}.
    # @param options [Hash{String=>String}] specifying any request options like :body.
    # @return [MsRest::HttpOperationResponse] Operation response containing the request, response and status.
    #
    def make_request_with_http_info(method, path, options = {})
      result = make_request_async(method, path, options).value!
      result.body = result.response.body.to_s.empty? ? nil : JSON.load(result.response.body)
      result
    end

    #
    # Makes a request asynchronously.
    # @param method [Symbol] with any of the following values :get, :put, :post, :patch, :delete.
    # @param path [String] the path, relative to {base_url}.
    # @param options [Hash{String=>String}] specifying any request options like :body.
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def make_request_async(method, path, options = {})
      fail ArgumentError, 'method is nil' if method.nil?
      fail ArgumentError, 'path is nil' if path.nil?

      request_url = options[:base_url] || @base_url
      if(!options[:headers].nil? && !options[:headers]['Content-Type'].nil?)
        @request_headers['Content-Type'] = options[:headers]['Content-Type']
      end

      request_headers = @request_headers
      options.merge!({headers: request_headers.merge(options[:headers] || {})})
      options.merge!({credentials: @credentials}) unless @credentials.nil?

      super(request_url, method, path, options)
    end

    #
    # Accepts the task.
    #
    # @param model [WorkflowActionModel] The model.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [Object] operation results.
    #
    def accept_task(model, custom_headers:nil)
      response = accept_task_async(model, custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # Accepts the task.
    #
    # @param model [WorkflowActionModel] The model.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def accept_task_with_http_info(model, custom_headers:nil)
      accept_task_async(model, custom_headers:custom_headers).value!
    end

    #
    # Accepts the task.
    #
    # @param model [WorkflowActionModel] The model.
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def accept_task_async(model, custom_headers:nil)
      fail ArgumentError, 'model is nil' if model.nil?


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'

      # Serialize Request
      request_mapper = Softheon.Enterprise.Api.Client::Models::WorkflowActionModel.mapper()
      request_content = self.serialize(request_mapper,  model)
      request_content = request_content != nil ? JSON.generate(request_content, quirks_mode: true) : nil

      path_template = 'v1/workflow/actions/accept'

      request_url = @base_url || self.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          body: request_content,
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:post, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 204 || status_code == 403 || status_code == 404
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end


        result
      end

      promise.execute
    end

    #
    # Rejects the task.
    #
    # @param model [WorkflowActionModel] The model.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [Object] operation results.
    #
    def reject_task(model, custom_headers:nil)
      response = reject_task_async(model, custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # Rejects the task.
    #
    # @param model [WorkflowActionModel] The model.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def reject_task_with_http_info(model, custom_headers:nil)
      reject_task_async(model, custom_headers:custom_headers).value!
    end

    #
    # Rejects the task.
    #
    # @param model [WorkflowActionModel] The model.
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def reject_task_async(model, custom_headers:nil)
      fail ArgumentError, 'model is nil' if model.nil?


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'

      # Serialize Request
      request_mapper = Softheon.Enterprise.Api.Client::Models::WorkflowActionModel.mapper()
      request_content = self.serialize(request_mapper,  model)
      request_content = request_content != nil ? JSON.generate(request_content, quirks_mode: true) : nil

      path_template = 'v1/workflow/actions/reject'

      request_url = @base_url || self.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          body: request_content,
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:post, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 204 || status_code == 403 || status_code == 404
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end


        result
      end

      promise.execute
    end

    #
    # Suspends the task.
    #
    # @param model [WorkflowActionModel] The model.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [Object] operation results.
    #
    def suspend_task(model, custom_headers:nil)
      response = suspend_task_async(model, custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # Suspends the task.
    #
    # @param model [WorkflowActionModel] The model.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def suspend_task_with_http_info(model, custom_headers:nil)
      suspend_task_async(model, custom_headers:custom_headers).value!
    end

    #
    # Suspends the task.
    #
    # @param model [WorkflowActionModel] The model.
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def suspend_task_async(model, custom_headers:nil)
      fail ArgumentError, 'model is nil' if model.nil?


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'

      # Serialize Request
      request_mapper = Softheon.Enterprise.Api.Client::Models::WorkflowActionModel.mapper()
      request_content = self.serialize(request_mapper,  model)
      request_content = request_content != nil ? JSON.generate(request_content, quirks_mode: true) : nil

      path_template = 'v1/workflow/actions/suspend'

      request_url = @base_url || self.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          body: request_content,
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:post, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 204 || status_code == 403 || status_code == 404
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end


        result
      end

      promise.execute
    end

    #
    # Routes the task.
    #
    # @param model [WorkflowActionRouteModel] The model.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [Object] operation results.
    #
    def route_task(model, custom_headers:nil)
      response = route_task_async(model, custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # Routes the task.
    #
    # @param model [WorkflowActionRouteModel] The model.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def route_task_with_http_info(model, custom_headers:nil)
      route_task_async(model, custom_headers:custom_headers).value!
    end

    #
    # Routes the task.
    #
    # @param model [WorkflowActionRouteModel] The model.
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def route_task_async(model, custom_headers:nil)
      fail ArgumentError, 'model is nil' if model.nil?


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'

      # Serialize Request
      request_mapper = Softheon.Enterprise.Api.Client::Models::WorkflowActionRouteModel.mapper()
      request_content = self.serialize(request_mapper,  model)
      request_content = request_content != nil ? JSON.generate(request_content, quirks_mode: true) : nil

      path_template = 'v1/workflow/actions/route'

      request_url = @base_url || self.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          body: request_content,
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:post, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 204 || status_code == 403 || status_code == 404
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end


        result
      end

      promise.execute
    end

    #
    # Overrides the task.
    #
    # @param model [WorkflowActionModel] The model.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [Object] operation results.
    #
    def override_task(model, custom_headers:nil)
      response = override_task_async(model, custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # Overrides the task.
    #
    # @param model [WorkflowActionModel] The model.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def override_task_with_http_info(model, custom_headers:nil)
      override_task_async(model, custom_headers:custom_headers).value!
    end

    #
    # Overrides the task.
    #
    # @param model [WorkflowActionModel] The model.
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def override_task_async(model, custom_headers:nil)
      fail ArgumentError, 'model is nil' if model.nil?


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'

      # Serialize Request
      request_mapper = Softheon.Enterprise.Api.Client::Models::WorkflowActionModel.mapper()
      request_content = self.serialize(request_mapper,  model)
      request_content = request_content != nil ? JSON.generate(request_content, quirks_mode: true) : nil

      path_template = 'v1/workflow/actions/override'

      request_url = @base_url || self.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          body: request_content,
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:post, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 204 || status_code == 403 || status_code == 404
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end


        result
      end

      promise.execute
    end

    #
    # Resets the task.
    #
    # @param model [WorkflowActionModel] The model.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [Object] operation results.
    #
    def reset_task(model, custom_headers:nil)
      response = reset_task_async(model, custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # Resets the task.
    #
    # @param model [WorkflowActionModel] The model.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def reset_task_with_http_info(model, custom_headers:nil)
      reset_task_async(model, custom_headers:custom_headers).value!
    end

    #
    # Resets the task.
    #
    # @param model [WorkflowActionModel] The model.
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def reset_task_async(model, custom_headers:nil)
      fail ArgumentError, 'model is nil' if model.nil?


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'

      # Serialize Request
      request_mapper = Softheon.Enterprise.Api.Client::Models::WorkflowActionModel.mapper()
      request_content = self.serialize(request_mapper,  model)
      request_content = request_content != nil ? JSON.generate(request_content, quirks_mode: true) : nil

      path_template = 'v1/workflow/actions/reset'

      request_url = @base_url || self.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          body: request_content,
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:post, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 204 || status_code == 403 || status_code == 404
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end


        result
      end

      promise.execute
    end

    #
    # Initializes the Workflow.
    #
    # @param model [WorkflowActionInitializeModel] The model.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [Object] operation results.
    #
    def initialize_entity_workflow(model, custom_headers:nil)
      response = initialize_entity_workflow_async(model, custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # Initializes the Workflow.
    #
    # @param model [WorkflowActionInitializeModel] The model.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def initialize_entity_workflow_with_http_info(model, custom_headers:nil)
      initialize_entity_workflow_async(model, custom_headers:custom_headers).value!
    end

    #
    # Initializes the Workflow.
    #
    # @param model [WorkflowActionInitializeModel] The model.
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def initialize_entity_workflow_async(model, custom_headers:nil)
      fail ArgumentError, 'model is nil' if model.nil?


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'

      # Serialize Request
      request_mapper = Softheon.Enterprise.Api.Client::Models::WorkflowActionInitializeModel.mapper()
      request_content = self.serialize(request_mapper,  model)
      request_content = request_content != nil ? JSON.generate(request_content, quirks_mode: true) : nil

      path_template = 'v1/workflow/actions/initialize'

      request_url = @base_url || self.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          body: request_content,
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:post, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 204 || status_code == 403 || status_code == 404
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end


        result
      end

      promise.execute
    end

    #
    # Gets a list of all available applications.
    #
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [Array] operation results.
    #
    def get_all_applications(custom_headers:nil)
      response = get_all_applications_async(custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # Gets a list of all available applications.
    #
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def get_all_applications_with_http_info(custom_headers:nil)
      get_all_applications_async(custom_headers:custom_headers).value!
    end

    #
    # Gets a list of all available applications.
    #
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def get_all_applications_async(custom_headers:nil)


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'
      path_template = 'v1/directory/applications'

      request_url = @base_url || self.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:get, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = {
              client_side_validation: true,
              required: false,
              serialized_name: 'parsed_response',
              type: {
                name: 'Sequence',
                element: {
                    client_side_validation: true,
                    required: false,
                    serialized_name: 'ApplicationModelElementType',
                    type: {
                      name: 'Composite',
                      class_name: 'ApplicationModel'
                    }
                }
              }
            }
            result.body = self.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # Gets a single application by its unique identifier.
    #
    # @param id [Integer] The unique application identifier.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [ApplicationModel] operation results.
    #
    def get_application_by_id(id, custom_headers:nil)
      response = get_application_by_id_async(id, custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # Gets a single application by its unique identifier.
    #
    # @param id [Integer] The unique application identifier.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def get_application_by_id_with_http_info(id, custom_headers:nil)
      get_application_by_id_async(id, custom_headers:custom_headers).value!
    end

    #
    # Gets a single application by its unique identifier.
    #
    # @param id [Integer] The unique application identifier.
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def get_application_by_id_async(id, custom_headers:nil)
      fail ArgumentError, 'id is nil' if id.nil?


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'
      path_template = 'v1/directory/applications/{id}'

      request_url = @base_url || self.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          path_params: {'id' => id},
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:get, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200 || status_code == 404
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = Softheon.Enterprise.Api.Client::Models::ApplicationModel.mapper()
            result.body = self.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # Gets a single application by its name.
    #
    # @param name [String] The unique application name.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [ApplicationModel] operation results.
    #
    def get_application_by_name(name, custom_headers:nil)
      response = get_application_by_name_async(name, custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # Gets a single application by its name.
    #
    # @param name [String] The unique application name.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def get_application_by_name_with_http_info(name, custom_headers:nil)
      get_application_by_name_async(name, custom_headers:custom_headers).value!
    end

    #
    # Gets a single application by its name.
    #
    # @param name [String] The unique application name.
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def get_application_by_name_async(name, custom_headers:nil)
      fail ArgumentError, 'name is nil' if name.nil?


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'
      path_template = 'v1/directory/applications/{name}'

      request_url = @base_url || self.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          path_params: {'name' => name},
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:get, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200 || status_code == 404
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = Softheon.Enterprise.Api.Client::Models::ApplicationModel.mapper()
            result.body = self.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # Gets a list of drawer group associations.
    #
    # @param drawer_id [Integer] The drawer identifier.
    # @param group_id [Integer] The group identifier.
    # @param acl [Integer] Gets or sets the access control level permissions.
    # @param page [Integer] Gets or sets the page number.
    # @param page_size [Integer] Gets or sets the size of the page.
    # @param sort_order [Enum] Gets or sets the order. Possible values include:
    # 'Unspecified', 'Ascending', 'Descending'
    # @param sort_by [Enum] Gets or sets the column to order by. Possible values
    # include: 'Unspecified', 'DrawerID', 'ApplicationID', 'GroupID', 'UserID',
    # 'QueueID', 'Acl'
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [Array] operation results.
    #
    def get_drawer_group_associations(drawer_id, group_id:nil, acl:nil, page:nil, page_size:nil, sort_order:nil, sort_by:nil, custom_headers:nil)
      response = get_drawer_group_associations_async(drawer_id, group_id:group_id, acl:acl, page:page, page_size:page_size, sort_order:sort_order, sort_by:sort_by, custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # Gets a list of drawer group associations.
    #
    # @param drawer_id [Integer] The drawer identifier.
    # @param group_id [Integer] The group identifier.
    # @param acl [Integer] Gets or sets the access control level permissions.
    # @param page [Integer] Gets or sets the page number.
    # @param page_size [Integer] Gets or sets the size of the page.
    # @param sort_order [Enum] Gets or sets the order. Possible values include:
    # 'Unspecified', 'Ascending', 'Descending'
    # @param sort_by [Enum] Gets or sets the column to order by. Possible values
    # include: 'Unspecified', 'DrawerID', 'ApplicationID', 'GroupID', 'UserID',
    # 'QueueID', 'Acl'
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def get_drawer_group_associations_with_http_info(drawer_id, group_id:nil, acl:nil, page:nil, page_size:nil, sort_order:nil, sort_by:nil, custom_headers:nil)
      get_drawer_group_associations_async(drawer_id, group_id:group_id, acl:acl, page:page, page_size:page_size, sort_order:sort_order, sort_by:sort_by, custom_headers:custom_headers).value!
    end

    #
    # Gets a list of drawer group associations.
    #
    # @param drawer_id [Integer] The drawer identifier.
    # @param group_id [Integer] The group identifier.
    # @param acl [Integer] Gets or sets the access control level permissions.
    # @param page [Integer] Gets or sets the page number.
    # @param page_size [Integer] Gets or sets the size of the page.
    # @param sort_order [Enum] Gets or sets the order. Possible values include:
    # 'Unspecified', 'Ascending', 'Descending'
    # @param sort_by [Enum] Gets or sets the column to order by. Possible values
    # include: 'Unspecified', 'DrawerID', 'ApplicationID', 'GroupID', 'UserID',
    # 'QueueID', 'Acl'
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def get_drawer_group_associations_async(drawer_id, group_id:nil, acl:nil, page:nil, page_size:nil, sort_order:nil, sort_by:nil, custom_headers:nil)
      fail ArgumentError, 'drawer_id is nil' if drawer_id.nil?
      fail ArgumentError, "'page' should satisfy the constraint - 'InclusiveMaximum': '2147483647'" if !page.nil? && page > 2147483647
      fail ArgumentError, "'page' should satisfy the constraint - 'InclusiveMinimum': '1'" if !page.nil? && page < 1
      fail ArgumentError, "'page_size' should satisfy the constraint - 'InclusiveMaximum': '1000'" if !page_size.nil? && page_size > 1000
      fail ArgumentError, "'page_size' should satisfy the constraint - 'InclusiveMinimum': '1'" if !page_size.nil? && page_size < 1


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'
      path_template = 'v1/directory/drawers/{drawerID}/groups'

      request_url = @base_url || self.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          path_params: {'drawerID' => drawer_id},
          query_params: {'groupID' => group_id,'acl' => acl,'page' => page,'pageSize' => page_size,'sortOrder' => sort_order,'sortBy' => sort_by},
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:get, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200 || status_code == 403
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = {
              client_side_validation: true,
              required: false,
              serialized_name: 'parsed_response',
              type: {
                name: 'Sequence',
                element: {
                    client_side_validation: true,
                    required: false,
                    serialized_name: 'GroupDrawerModelElementType',
                    type: {
                      name: 'Composite',
                      class_name: 'GroupDrawerModel'
                    }
                }
              }
            }
            result.body = self.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # Gets a list of group drawer associations.
    #
    # @param group_id [Integer] The group identifier.
    # @param drawer_id [Integer] The drawer identifier.
    # @param acl [Integer] Gets or sets the access control level permissions.
    # @param page [Integer] Gets or sets the page number.
    # @param page_size [Integer] Gets or sets the size of the page.
    # @param sort_order [Enum] Gets or sets the order. Possible values include:
    # 'Unspecified', 'Ascending', 'Descending'
    # @param sort_by [Enum] Gets or sets the column to order by. Possible values
    # include: 'Unspecified', 'DrawerID', 'ApplicationID', 'GroupID', 'UserID',
    # 'QueueID', 'Acl'
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [Array] operation results.
    #
    def get_group_drawer_associations(group_id, drawer_id:nil, acl:nil, page:nil, page_size:nil, sort_order:nil, sort_by:nil, custom_headers:nil)
      response = get_group_drawer_associations_async(group_id, drawer_id:drawer_id, acl:acl, page:page, page_size:page_size, sort_order:sort_order, sort_by:sort_by, custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # Gets a list of group drawer associations.
    #
    # @param group_id [Integer] The group identifier.
    # @param drawer_id [Integer] The drawer identifier.
    # @param acl [Integer] Gets or sets the access control level permissions.
    # @param page [Integer] Gets or sets the page number.
    # @param page_size [Integer] Gets or sets the size of the page.
    # @param sort_order [Enum] Gets or sets the order. Possible values include:
    # 'Unspecified', 'Ascending', 'Descending'
    # @param sort_by [Enum] Gets or sets the column to order by. Possible values
    # include: 'Unspecified', 'DrawerID', 'ApplicationID', 'GroupID', 'UserID',
    # 'QueueID', 'Acl'
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def get_group_drawer_associations_with_http_info(group_id, drawer_id:nil, acl:nil, page:nil, page_size:nil, sort_order:nil, sort_by:nil, custom_headers:nil)
      get_group_drawer_associations_async(group_id, drawer_id:drawer_id, acl:acl, page:page, page_size:page_size, sort_order:sort_order, sort_by:sort_by, custom_headers:custom_headers).value!
    end

    #
    # Gets a list of group drawer associations.
    #
    # @param group_id [Integer] The group identifier.
    # @param drawer_id [Integer] The drawer identifier.
    # @param acl [Integer] Gets or sets the access control level permissions.
    # @param page [Integer] Gets or sets the page number.
    # @param page_size [Integer] Gets or sets the size of the page.
    # @param sort_order [Enum] Gets or sets the order. Possible values include:
    # 'Unspecified', 'Ascending', 'Descending'
    # @param sort_by [Enum] Gets or sets the column to order by. Possible values
    # include: 'Unspecified', 'DrawerID', 'ApplicationID', 'GroupID', 'UserID',
    # 'QueueID', 'Acl'
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def get_group_drawer_associations_async(group_id, drawer_id:nil, acl:nil, page:nil, page_size:nil, sort_order:nil, sort_by:nil, custom_headers:nil)
      fail ArgumentError, 'group_id is nil' if group_id.nil?
      fail ArgumentError, "'page' should satisfy the constraint - 'InclusiveMaximum': '2147483647'" if !page.nil? && page > 2147483647
      fail ArgumentError, "'page' should satisfy the constraint - 'InclusiveMinimum': '1'" if !page.nil? && page < 1
      fail ArgumentError, "'page_size' should satisfy the constraint - 'InclusiveMaximum': '1000'" if !page_size.nil? && page_size > 1000
      fail ArgumentError, "'page_size' should satisfy the constraint - 'InclusiveMinimum': '1'" if !page_size.nil? && page_size < 1


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'
      path_template = 'v1/directory/groups/{groupID}/drawers'

      request_url = @base_url || self.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          path_params: {'groupID' => group_id},
          query_params: {'drawerID' => drawer_id,'acl' => acl,'page' => page,'pageSize' => page_size,'sortOrder' => sort_order,'sortBy' => sort_by},
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:get, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200 || status_code == 403
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = {
              client_side_validation: true,
              required: false,
              serialized_name: 'parsed_response',
              type: {
                name: 'Sequence',
                element: {
                    client_side_validation: true,
                    required: false,
                    serialized_name: 'GroupDrawerModelElementType',
                    type: {
                      name: 'Composite',
                      class_name: 'GroupDrawerModel'
                    }
                }
              }
            }
            result.body = self.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # Inserts/Updates the drawer group association.
    #
    # @param group_id [Integer] The group identifier.
    # @param drawer_id [Integer] The drawer identifier.
    # @param model [GroupDrawerModel] The model.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [Object] operation results.
    #
    def create_or_update_drawer_group_association(group_id, drawer_id, model, custom_headers:nil)
      response = create_or_update_drawer_group_association_async(group_id, drawer_id, model, custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # Inserts/Updates the drawer group association.
    #
    # @param group_id [Integer] The group identifier.
    # @param drawer_id [Integer] The drawer identifier.
    # @param model [GroupDrawerModel] The model.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def create_or_update_drawer_group_association_with_http_info(group_id, drawer_id, model, custom_headers:nil)
      create_or_update_drawer_group_association_async(group_id, drawer_id, model, custom_headers:custom_headers).value!
    end

    #
    # Inserts/Updates the drawer group association.
    #
    # @param group_id [Integer] The group identifier.
    # @param drawer_id [Integer] The drawer identifier.
    # @param model [GroupDrawerModel] The model.
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def create_or_update_drawer_group_association_async(group_id, drawer_id, model, custom_headers:nil)
      fail ArgumentError, 'group_id is nil' if group_id.nil?
      fail ArgumentError, 'drawer_id is nil' if drawer_id.nil?
      fail ArgumentError, 'model is nil' if model.nil?


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'

      # Serialize Request
      request_mapper = Softheon.Enterprise.Api.Client::Models::GroupDrawerModel.mapper()
      request_content = self.serialize(request_mapper,  model)
      request_content = request_content != nil ? JSON.generate(request_content, quirks_mode: true) : nil

      path_template = 'v1/directory/drawers/{drawerID}/groups/{groupID}'

      request_url = @base_url || self.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          path_params: {'groupID' => group_id,'drawerID' => drawer_id},
          body: request_content,
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:put, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 204 || status_code == 403
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end


        result
      end

      promise.execute
    end

    #
    # Deletes a drawer group association;
    #
    # @param group_id [Integer] The group identifier.
    # @param drawer_id [Integer] The drawer identifier.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [Object] operation results.
    #
    def delete_drawer_group_association(group_id, drawer_id, custom_headers:nil)
      response = delete_drawer_group_association_async(group_id, drawer_id, custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # Deletes a drawer group association;
    #
    # @param group_id [Integer] The group identifier.
    # @param drawer_id [Integer] The drawer identifier.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def delete_drawer_group_association_with_http_info(group_id, drawer_id, custom_headers:nil)
      delete_drawer_group_association_async(group_id, drawer_id, custom_headers:custom_headers).value!
    end

    #
    # Deletes a drawer group association;
    #
    # @param group_id [Integer] The group identifier.
    # @param drawer_id [Integer] The drawer identifier.
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def delete_drawer_group_association_async(group_id, drawer_id, custom_headers:nil)
      fail ArgumentError, 'group_id is nil' if group_id.nil?
      fail ArgumentError, 'drawer_id is nil' if drawer_id.nil?


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'
      path_template = 'v1/directory/drawers/{drawerID}/groups/{groupID}'

      request_url = @base_url || self.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          path_params: {'groupID' => group_id,'drawerID' => drawer_id},
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:delete, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 204 || status_code == 403 || status_code == 404
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end


        result
      end

      promise.execute
    end

    #
    # Inserts/Updates the group drawer association.
    #
    # @param group_id [Integer] The group identifier.
    # @param drawer_id [Integer] The drawer identifier.
    # @param model [GroupDrawerModel] The model.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [Object] operation results.
    #
    def create_or_update_group_drawer_association(group_id, drawer_id, model, custom_headers:nil)
      response = create_or_update_group_drawer_association_async(group_id, drawer_id, model, custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # Inserts/Updates the group drawer association.
    #
    # @param group_id [Integer] The group identifier.
    # @param drawer_id [Integer] The drawer identifier.
    # @param model [GroupDrawerModel] The model.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def create_or_update_group_drawer_association_with_http_info(group_id, drawer_id, model, custom_headers:nil)
      create_or_update_group_drawer_association_async(group_id, drawer_id, model, custom_headers:custom_headers).value!
    end

    #
    # Inserts/Updates the group drawer association.
    #
    # @param group_id [Integer] The group identifier.
    # @param drawer_id [Integer] The drawer identifier.
    # @param model [GroupDrawerModel] The model.
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def create_or_update_group_drawer_association_async(group_id, drawer_id, model, custom_headers:nil)
      fail ArgumentError, 'group_id is nil' if group_id.nil?
      fail ArgumentError, 'drawer_id is nil' if drawer_id.nil?
      fail ArgumentError, 'model is nil' if model.nil?


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'

      # Serialize Request
      request_mapper = Softheon.Enterprise.Api.Client::Models::GroupDrawerModel.mapper()
      request_content = self.serialize(request_mapper,  model)
      request_content = request_content != nil ? JSON.generate(request_content, quirks_mode: true) : nil

      path_template = 'v1/directory/groups/{groupID}/drawers/{drawerID}'

      request_url = @base_url || self.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          path_params: {'groupID' => group_id,'drawerID' => drawer_id},
          body: request_content,
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:put, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 204 || status_code == 403
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end


        result
      end

      promise.execute
    end

    #
    # Deletes a group drawer association;
    #
    # @param group_id [Integer] The group identifier.
    # @param drawer_id [Integer] The drawer identifier.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [Object] operation results.
    #
    def delete_group_drawer_association(group_id, drawer_id, custom_headers:nil)
      response = delete_group_drawer_association_async(group_id, drawer_id, custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # Deletes a group drawer association;
    #
    # @param group_id [Integer] The group identifier.
    # @param drawer_id [Integer] The drawer identifier.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def delete_group_drawer_association_with_http_info(group_id, drawer_id, custom_headers:nil)
      delete_group_drawer_association_async(group_id, drawer_id, custom_headers:custom_headers).value!
    end

    #
    # Deletes a group drawer association;
    #
    # @param group_id [Integer] The group identifier.
    # @param drawer_id [Integer] The drawer identifier.
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def delete_group_drawer_association_async(group_id, drawer_id, custom_headers:nil)
      fail ArgumentError, 'group_id is nil' if group_id.nil?
      fail ArgumentError, 'drawer_id is nil' if drawer_id.nil?


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'
      path_template = 'v1/directory/groups/{groupID}/drawers/{drawerID}'

      request_url = @base_url || self.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          path_params: {'groupID' => group_id,'drawerID' => drawer_id},
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:delete, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 204 || status_code == 403 || status_code == 404
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end


        result
      end

      promise.execute
    end

    #
    # Gets a list of user group associations.
    #
    # @param user_id [Integer] The user identifier.
    # @param group_id [Integer] The group identifier.
    # @param acl [Integer] Gets or sets the access control level permissions.
    # @param page [Integer] Gets or sets the page number.
    # @param page_size [Integer] Gets or sets the size of the page.
    # @param sort_order [Enum] Gets or sets the order. Possible values include:
    # 'Unspecified', 'Ascending', 'Descending'
    # @param sort_by [Enum] Gets or sets the column to order by. Possible values
    # include: 'Unspecified', 'DrawerID', 'ApplicationID', 'GroupID', 'UserID',
    # 'QueueID', 'Acl'
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [Array] operation results.
    #
    def get_user_group_associations(user_id, group_id:nil, acl:nil, page:nil, page_size:nil, sort_order:nil, sort_by:nil, custom_headers:nil)
      response = get_user_group_associations_async(user_id, group_id:group_id, acl:acl, page:page, page_size:page_size, sort_order:sort_order, sort_by:sort_by, custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # Gets a list of user group associations.
    #
    # @param user_id [Integer] The user identifier.
    # @param group_id [Integer] The group identifier.
    # @param acl [Integer] Gets or sets the access control level permissions.
    # @param page [Integer] Gets or sets the page number.
    # @param page_size [Integer] Gets or sets the size of the page.
    # @param sort_order [Enum] Gets or sets the order. Possible values include:
    # 'Unspecified', 'Ascending', 'Descending'
    # @param sort_by [Enum] Gets or sets the column to order by. Possible values
    # include: 'Unspecified', 'DrawerID', 'ApplicationID', 'GroupID', 'UserID',
    # 'QueueID', 'Acl'
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def get_user_group_associations_with_http_info(user_id, group_id:nil, acl:nil, page:nil, page_size:nil, sort_order:nil, sort_by:nil, custom_headers:nil)
      get_user_group_associations_async(user_id, group_id:group_id, acl:acl, page:page, page_size:page_size, sort_order:sort_order, sort_by:sort_by, custom_headers:custom_headers).value!
    end

    #
    # Gets a list of user group associations.
    #
    # @param user_id [Integer] The user identifier.
    # @param group_id [Integer] The group identifier.
    # @param acl [Integer] Gets or sets the access control level permissions.
    # @param page [Integer] Gets or sets the page number.
    # @param page_size [Integer] Gets or sets the size of the page.
    # @param sort_order [Enum] Gets or sets the order. Possible values include:
    # 'Unspecified', 'Ascending', 'Descending'
    # @param sort_by [Enum] Gets or sets the column to order by. Possible values
    # include: 'Unspecified', 'DrawerID', 'ApplicationID', 'GroupID', 'UserID',
    # 'QueueID', 'Acl'
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def get_user_group_associations_async(user_id, group_id:nil, acl:nil, page:nil, page_size:nil, sort_order:nil, sort_by:nil, custom_headers:nil)
      fail ArgumentError, 'user_id is nil' if user_id.nil?
      fail ArgumentError, "'page' should satisfy the constraint - 'InclusiveMaximum': '2147483647'" if !page.nil? && page > 2147483647
      fail ArgumentError, "'page' should satisfy the constraint - 'InclusiveMinimum': '1'" if !page.nil? && page < 1
      fail ArgumentError, "'page_size' should satisfy the constraint - 'InclusiveMaximum': '1000'" if !page_size.nil? && page_size > 1000
      fail ArgumentError, "'page_size' should satisfy the constraint - 'InclusiveMinimum': '1'" if !page_size.nil? && page_size < 1


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'
      path_template = 'v1/directory/users/{userID}/groups'

      request_url = @base_url || self.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          path_params: {'userID' => user_id},
          query_params: {'groupID' => group_id,'acl' => acl,'page' => page,'pageSize' => page_size,'sortOrder' => sort_order,'sortBy' => sort_by},
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:get, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200 || status_code == 403
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = {
              client_side_validation: true,
              required: false,
              serialized_name: 'parsed_response',
              type: {
                name: 'Sequence',
                element: {
                    client_side_validation: true,
                    required: false,
                    serialized_name: 'GroupUserModelElementType',
                    type: {
                      name: 'Composite',
                      class_name: 'GroupUserModel'
                    }
                }
              }
            }
            result.body = self.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # Gets a list of group user associations.
    #
    # @param group_id [Integer] The group identifier.
    # @param user_id [Integer] The user identifier.
    # @param acl [Integer] Gets or sets the access control level permissions.
    # @param page [Integer] Gets or sets the page number.
    # @param page_size [Integer] Gets or sets the size of the page.
    # @param sort_order [Enum] Gets or sets the order. Possible values include:
    # 'Unspecified', 'Ascending', 'Descending'
    # @param sort_by [Enum] Gets or sets the column to order by. Possible values
    # include: 'Unspecified', 'DrawerID', 'ApplicationID', 'GroupID', 'UserID',
    # 'QueueID', 'Acl'
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [Array] operation results.
    #
    def get_group_user_associations(group_id, user_id:nil, acl:nil, page:nil, page_size:nil, sort_order:nil, sort_by:nil, custom_headers:nil)
      response = get_group_user_associations_async(group_id, user_id:user_id, acl:acl, page:page, page_size:page_size, sort_order:sort_order, sort_by:sort_by, custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # Gets a list of group user associations.
    #
    # @param group_id [Integer] The group identifier.
    # @param user_id [Integer] The user identifier.
    # @param acl [Integer] Gets or sets the access control level permissions.
    # @param page [Integer] Gets or sets the page number.
    # @param page_size [Integer] Gets or sets the size of the page.
    # @param sort_order [Enum] Gets or sets the order. Possible values include:
    # 'Unspecified', 'Ascending', 'Descending'
    # @param sort_by [Enum] Gets or sets the column to order by. Possible values
    # include: 'Unspecified', 'DrawerID', 'ApplicationID', 'GroupID', 'UserID',
    # 'QueueID', 'Acl'
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def get_group_user_associations_with_http_info(group_id, user_id:nil, acl:nil, page:nil, page_size:nil, sort_order:nil, sort_by:nil, custom_headers:nil)
      get_group_user_associations_async(group_id, user_id:user_id, acl:acl, page:page, page_size:page_size, sort_order:sort_order, sort_by:sort_by, custom_headers:custom_headers).value!
    end

    #
    # Gets a list of group user associations.
    #
    # @param group_id [Integer] The group identifier.
    # @param user_id [Integer] The user identifier.
    # @param acl [Integer] Gets or sets the access control level permissions.
    # @param page [Integer] Gets or sets the page number.
    # @param page_size [Integer] Gets or sets the size of the page.
    # @param sort_order [Enum] Gets or sets the order. Possible values include:
    # 'Unspecified', 'Ascending', 'Descending'
    # @param sort_by [Enum] Gets or sets the column to order by. Possible values
    # include: 'Unspecified', 'DrawerID', 'ApplicationID', 'GroupID', 'UserID',
    # 'QueueID', 'Acl'
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def get_group_user_associations_async(group_id, user_id:nil, acl:nil, page:nil, page_size:nil, sort_order:nil, sort_by:nil, custom_headers:nil)
      fail ArgumentError, 'group_id is nil' if group_id.nil?
      fail ArgumentError, "'page' should satisfy the constraint - 'InclusiveMaximum': '2147483647'" if !page.nil? && page > 2147483647
      fail ArgumentError, "'page' should satisfy the constraint - 'InclusiveMinimum': '1'" if !page.nil? && page < 1
      fail ArgumentError, "'page_size' should satisfy the constraint - 'InclusiveMaximum': '1000'" if !page_size.nil? && page_size > 1000
      fail ArgumentError, "'page_size' should satisfy the constraint - 'InclusiveMinimum': '1'" if !page_size.nil? && page_size < 1


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'
      path_template = 'v1/directory/groups/{groupID}/users'

      request_url = @base_url || self.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          path_params: {'groupID' => group_id},
          query_params: {'userID' => user_id,'acl' => acl,'page' => page,'pageSize' => page_size,'sortOrder' => sort_order,'sortBy' => sort_by},
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:get, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200 || status_code == 403
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = {
              client_side_validation: true,
              required: false,
              serialized_name: 'parsed_response',
              type: {
                name: 'Sequence',
                element: {
                    client_side_validation: true,
                    required: false,
                    serialized_name: 'GroupUserModelElementType',
                    type: {
                      name: 'Composite',
                      class_name: 'GroupUserModel'
                    }
                }
              }
            }
            result.body = self.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # Inserts the user group association.
    #
    # @param group_id [Integer] The group identifier.
    # @param user_id [Integer] The user identifier.
    # @param model [GroupUserModel] The model.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [Object] operation results.
    #
    def create_user_group_association(group_id, user_id, model, custom_headers:nil)
      response = create_user_group_association_async(group_id, user_id, model, custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # Inserts the user group association.
    #
    # @param group_id [Integer] The group identifier.
    # @param user_id [Integer] The user identifier.
    # @param model [GroupUserModel] The model.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def create_user_group_association_with_http_info(group_id, user_id, model, custom_headers:nil)
      create_user_group_association_async(group_id, user_id, model, custom_headers:custom_headers).value!
    end

    #
    # Inserts the user group association.
    #
    # @param group_id [Integer] The group identifier.
    # @param user_id [Integer] The user identifier.
    # @param model [GroupUserModel] The model.
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def create_user_group_association_async(group_id, user_id, model, custom_headers:nil)
      fail ArgumentError, 'group_id is nil' if group_id.nil?
      fail ArgumentError, 'user_id is nil' if user_id.nil?
      fail ArgumentError, 'model is nil' if model.nil?


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'

      # Serialize Request
      request_mapper = Softheon.Enterprise.Api.Client::Models::GroupUserModel.mapper()
      request_content = self.serialize(request_mapper,  model)
      request_content = request_content != nil ? JSON.generate(request_content, quirks_mode: true) : nil

      path_template = 'v1/directory/users/{userID}/groups/{groupID}'

      request_url = @base_url || self.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          path_params: {'groupID' => group_id,'userID' => user_id},
          body: request_content,
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:post, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200 || status_code == 403 || status_code == 409
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end


        result
      end

      promise.execute
    end

    #
    # Deletes a user group association;
    #
    # @param group_id [Integer] The group identifier.
    # @param user_id [Integer] The user identifier.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [Object] operation results.
    #
    def delete_user_group_association(group_id, user_id, custom_headers:nil)
      response = delete_user_group_association_async(group_id, user_id, custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # Deletes a user group association;
    #
    # @param group_id [Integer] The group identifier.
    # @param user_id [Integer] The user identifier.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def delete_user_group_association_with_http_info(group_id, user_id, custom_headers:nil)
      delete_user_group_association_async(group_id, user_id, custom_headers:custom_headers).value!
    end

    #
    # Deletes a user group association;
    #
    # @param group_id [Integer] The group identifier.
    # @param user_id [Integer] The user identifier.
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def delete_user_group_association_async(group_id, user_id, custom_headers:nil)
      fail ArgumentError, 'group_id is nil' if group_id.nil?
      fail ArgumentError, 'user_id is nil' if user_id.nil?


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'
      path_template = 'v1/directory/users/{userID}/groups/{groupID}'

      request_url = @base_url || self.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          path_params: {'groupID' => group_id,'userID' => user_id},
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:delete, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 204 || status_code == 403 || status_code == 404
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end


        result
      end

      promise.execute
    end

    #
    # Inserts the group user association.
    #
    # @param group_id [Integer] The group identifier.
    # @param user_id [Integer] The user identifier.
    # @param model [GroupUserModel] The model.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [Object] operation results.
    #
    def create_group_user_association(group_id, user_id, model, custom_headers:nil)
      response = create_group_user_association_async(group_id, user_id, model, custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # Inserts the group user association.
    #
    # @param group_id [Integer] The group identifier.
    # @param user_id [Integer] The user identifier.
    # @param model [GroupUserModel] The model.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def create_group_user_association_with_http_info(group_id, user_id, model, custom_headers:nil)
      create_group_user_association_async(group_id, user_id, model, custom_headers:custom_headers).value!
    end

    #
    # Inserts the group user association.
    #
    # @param group_id [Integer] The group identifier.
    # @param user_id [Integer] The user identifier.
    # @param model [GroupUserModel] The model.
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def create_group_user_association_async(group_id, user_id, model, custom_headers:nil)
      fail ArgumentError, 'group_id is nil' if group_id.nil?
      fail ArgumentError, 'user_id is nil' if user_id.nil?
      fail ArgumentError, 'model is nil' if model.nil?


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'

      # Serialize Request
      request_mapper = Softheon.Enterprise.Api.Client::Models::GroupUserModel.mapper()
      request_content = self.serialize(request_mapper,  model)
      request_content = request_content != nil ? JSON.generate(request_content, quirks_mode: true) : nil

      path_template = 'v1/directory/groups/{groupID}/users/{userID}'

      request_url = @base_url || self.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          path_params: {'groupID' => group_id,'userID' => user_id},
          body: request_content,
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:post, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200 || status_code == 403 || status_code == 409
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end


        result
      end

      promise.execute
    end

    #
    # Deletes a group user association;
    #
    # @param group_id [Integer] The group identifier.
    # @param user_id [Integer] The user identifier.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [Object] operation results.
    #
    def delete_group_user_association(group_id, user_id, custom_headers:nil)
      response = delete_group_user_association_async(group_id, user_id, custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # Deletes a group user association;
    #
    # @param group_id [Integer] The group identifier.
    # @param user_id [Integer] The user identifier.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def delete_group_user_association_with_http_info(group_id, user_id, custom_headers:nil)
      delete_group_user_association_async(group_id, user_id, custom_headers:custom_headers).value!
    end

    #
    # Deletes a group user association;
    #
    # @param group_id [Integer] The group identifier.
    # @param user_id [Integer] The user identifier.
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def delete_group_user_association_async(group_id, user_id, custom_headers:nil)
      fail ArgumentError, 'group_id is nil' if group_id.nil?
      fail ArgumentError, 'user_id is nil' if user_id.nil?


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'
      path_template = 'v1/directory/groups/{groupID}/users/{userID}'

      request_url = @base_url || self.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          path_params: {'groupID' => group_id,'userID' => user_id},
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:delete, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 204 || status_code == 403 || status_code == 404
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end


        result
      end

      promise.execute
    end

    #
    # Gets a list of queue group associations.
    #
    # @param queue_id [Integer] The queue identifier.
    # @param group_id [Integer] The group identifier.
    # @param acl [Integer] Gets or sets the access control level permissions.
    # @param page [Integer] Gets or sets the page number.
    # @param page_size [Integer] Gets or sets the size of the page.
    # @param sort_order [Enum] Gets or sets the order. Possible values include:
    # 'Unspecified', 'Ascending', 'Descending'
    # @param sort_by [Enum] Gets or sets the column to order by. Possible values
    # include: 'Unspecified', 'DrawerID', 'ApplicationID', 'GroupID', 'UserID',
    # 'QueueID', 'Acl'
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [Array] operation results.
    #
    def get_queue_group_associations(queue_id, group_id:nil, acl:nil, page:nil, page_size:nil, sort_order:nil, sort_by:nil, custom_headers:nil)
      response = get_queue_group_associations_async(queue_id, group_id:group_id, acl:acl, page:page, page_size:page_size, sort_order:sort_order, sort_by:sort_by, custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # Gets a list of queue group associations.
    #
    # @param queue_id [Integer] The queue identifier.
    # @param group_id [Integer] The group identifier.
    # @param acl [Integer] Gets or sets the access control level permissions.
    # @param page [Integer] Gets or sets the page number.
    # @param page_size [Integer] Gets or sets the size of the page.
    # @param sort_order [Enum] Gets or sets the order. Possible values include:
    # 'Unspecified', 'Ascending', 'Descending'
    # @param sort_by [Enum] Gets or sets the column to order by. Possible values
    # include: 'Unspecified', 'DrawerID', 'ApplicationID', 'GroupID', 'UserID',
    # 'QueueID', 'Acl'
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def get_queue_group_associations_with_http_info(queue_id, group_id:nil, acl:nil, page:nil, page_size:nil, sort_order:nil, sort_by:nil, custom_headers:nil)
      get_queue_group_associations_async(queue_id, group_id:group_id, acl:acl, page:page, page_size:page_size, sort_order:sort_order, sort_by:sort_by, custom_headers:custom_headers).value!
    end

    #
    # Gets a list of queue group associations.
    #
    # @param queue_id [Integer] The queue identifier.
    # @param group_id [Integer] The group identifier.
    # @param acl [Integer] Gets or sets the access control level permissions.
    # @param page [Integer] Gets or sets the page number.
    # @param page_size [Integer] Gets or sets the size of the page.
    # @param sort_order [Enum] Gets or sets the order. Possible values include:
    # 'Unspecified', 'Ascending', 'Descending'
    # @param sort_by [Enum] Gets or sets the column to order by. Possible values
    # include: 'Unspecified', 'DrawerID', 'ApplicationID', 'GroupID', 'UserID',
    # 'QueueID', 'Acl'
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def get_queue_group_associations_async(queue_id, group_id:nil, acl:nil, page:nil, page_size:nil, sort_order:nil, sort_by:nil, custom_headers:nil)
      fail ArgumentError, 'queue_id is nil' if queue_id.nil?
      fail ArgumentError, "'page' should satisfy the constraint - 'InclusiveMaximum': '2147483647'" if !page.nil? && page > 2147483647
      fail ArgumentError, "'page' should satisfy the constraint - 'InclusiveMinimum': '1'" if !page.nil? && page < 1
      fail ArgumentError, "'page_size' should satisfy the constraint - 'InclusiveMaximum': '1000'" if !page_size.nil? && page_size > 1000
      fail ArgumentError, "'page_size' should satisfy the constraint - 'InclusiveMinimum': '1'" if !page_size.nil? && page_size < 1


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'
      path_template = 'v1/workflow/queues/{queueID}/groups'

      request_url = @base_url || self.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          path_params: {'queueID' => queue_id},
          query_params: {'groupID' => group_id,'acl' => acl,'page' => page,'pageSize' => page_size,'sortOrder' => sort_order,'sortBy' => sort_by},
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:get, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200 || status_code == 403
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = {
              client_side_validation: true,
              required: false,
              serialized_name: 'parsed_response',
              type: {
                name: 'Sequence',
                element: {
                    client_side_validation: true,
                    required: false,
                    serialized_name: 'GroupQueueModelElementType',
                    type: {
                      name: 'Composite',
                      class_name: 'GroupQueueModel'
                    }
                }
              }
            }
            result.body = self.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # Gets a list of group queue associations.
    #
    # @param group_id [Integer] The group identifier.
    # @param queue_id [Integer] The queue identifier.
    # @param acl [Integer] Gets or sets the access control level permissions.
    # @param page [Integer] Gets or sets the page number.
    # @param page_size [Integer] Gets or sets the size of the page.
    # @param sort_order [Enum] Gets or sets the order. Possible values include:
    # 'Unspecified', 'Ascending', 'Descending'
    # @param sort_by [Enum] Gets or sets the column to order by. Possible values
    # include: 'Unspecified', 'DrawerID', 'ApplicationID', 'GroupID', 'UserID',
    # 'QueueID', 'Acl'
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [Array] operation results.
    #
    def get_group_queue_associations(group_id, queue_id:nil, acl:nil, page:nil, page_size:nil, sort_order:nil, sort_by:nil, custom_headers:nil)
      response = get_group_queue_associations_async(group_id, queue_id:queue_id, acl:acl, page:page, page_size:page_size, sort_order:sort_order, sort_by:sort_by, custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # Gets a list of group queue associations.
    #
    # @param group_id [Integer] The group identifier.
    # @param queue_id [Integer] The queue identifier.
    # @param acl [Integer] Gets or sets the access control level permissions.
    # @param page [Integer] Gets or sets the page number.
    # @param page_size [Integer] Gets or sets the size of the page.
    # @param sort_order [Enum] Gets or sets the order. Possible values include:
    # 'Unspecified', 'Ascending', 'Descending'
    # @param sort_by [Enum] Gets or sets the column to order by. Possible values
    # include: 'Unspecified', 'DrawerID', 'ApplicationID', 'GroupID', 'UserID',
    # 'QueueID', 'Acl'
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def get_group_queue_associations_with_http_info(group_id, queue_id:nil, acl:nil, page:nil, page_size:nil, sort_order:nil, sort_by:nil, custom_headers:nil)
      get_group_queue_associations_async(group_id, queue_id:queue_id, acl:acl, page:page, page_size:page_size, sort_order:sort_order, sort_by:sort_by, custom_headers:custom_headers).value!
    end

    #
    # Gets a list of group queue associations.
    #
    # @param group_id [Integer] The group identifier.
    # @param queue_id [Integer] The queue identifier.
    # @param acl [Integer] Gets or sets the access control level permissions.
    # @param page [Integer] Gets or sets the page number.
    # @param page_size [Integer] Gets or sets the size of the page.
    # @param sort_order [Enum] Gets or sets the order. Possible values include:
    # 'Unspecified', 'Ascending', 'Descending'
    # @param sort_by [Enum] Gets or sets the column to order by. Possible values
    # include: 'Unspecified', 'DrawerID', 'ApplicationID', 'GroupID', 'UserID',
    # 'QueueID', 'Acl'
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def get_group_queue_associations_async(group_id, queue_id:nil, acl:nil, page:nil, page_size:nil, sort_order:nil, sort_by:nil, custom_headers:nil)
      fail ArgumentError, 'group_id is nil' if group_id.nil?
      fail ArgumentError, "'page' should satisfy the constraint - 'InclusiveMaximum': '2147483647'" if !page.nil? && page > 2147483647
      fail ArgumentError, "'page' should satisfy the constraint - 'InclusiveMinimum': '1'" if !page.nil? && page < 1
      fail ArgumentError, "'page_size' should satisfy the constraint - 'InclusiveMaximum': '1000'" if !page_size.nil? && page_size > 1000
      fail ArgumentError, "'page_size' should satisfy the constraint - 'InclusiveMinimum': '1'" if !page_size.nil? && page_size < 1


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'
      path_template = 'v1/directory/groups/{groupID}/queues'

      request_url = @base_url || self.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          path_params: {'groupID' => group_id},
          query_params: {'queueID' => queue_id,'acl' => acl,'page' => page,'pageSize' => page_size,'sortOrder' => sort_order,'sortBy' => sort_by},
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:get, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200 || status_code == 403
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = {
              client_side_validation: true,
              required: false,
              serialized_name: 'parsed_response',
              type: {
                name: 'Sequence',
                element: {
                    client_side_validation: true,
                    required: false,
                    serialized_name: 'GroupQueueModelElementType',
                    type: {
                      name: 'Composite',
                      class_name: 'GroupQueueModel'
                    }
                }
              }
            }
            result.body = self.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # Inserts/Updates the queue group association.
    #
    # @param group_id [Integer] The group identifier.
    # @param queue_id [Integer] The queue identifier.
    # @param model [GroupQueueModel] The model.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [Object] operation results.
    #
    def create_or_update_queue_group_association(group_id, queue_id, model, custom_headers:nil)
      response = create_or_update_queue_group_association_async(group_id, queue_id, model, custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # Inserts/Updates the queue group association.
    #
    # @param group_id [Integer] The group identifier.
    # @param queue_id [Integer] The queue identifier.
    # @param model [GroupQueueModel] The model.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def create_or_update_queue_group_association_with_http_info(group_id, queue_id, model, custom_headers:nil)
      create_or_update_queue_group_association_async(group_id, queue_id, model, custom_headers:custom_headers).value!
    end

    #
    # Inserts/Updates the queue group association.
    #
    # @param group_id [Integer] The group identifier.
    # @param queue_id [Integer] The queue identifier.
    # @param model [GroupQueueModel] The model.
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def create_or_update_queue_group_association_async(group_id, queue_id, model, custom_headers:nil)
      fail ArgumentError, 'group_id is nil' if group_id.nil?
      fail ArgumentError, 'queue_id is nil' if queue_id.nil?
      fail ArgumentError, 'model is nil' if model.nil?


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'

      # Serialize Request
      request_mapper = Softheon.Enterprise.Api.Client::Models::GroupQueueModel.mapper()
      request_content = self.serialize(request_mapper,  model)
      request_content = request_content != nil ? JSON.generate(request_content, quirks_mode: true) : nil

      path_template = 'v1/workflow/queues/{queueID}/groups/{groupID}'

      request_url = @base_url || self.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          path_params: {'groupID' => group_id,'queueID' => queue_id},
          body: request_content,
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:put, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 204 || status_code == 403
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end


        result
      end

      promise.execute
    end

    #
    # Deletes a queue group association;
    #
    # @param group_id [Integer] The group identifier.
    # @param queue_id [Integer] The queue identifier.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [Object] operation results.
    #
    def delete_queue_group_association(group_id, queue_id, custom_headers:nil)
      response = delete_queue_group_association_async(group_id, queue_id, custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # Deletes a queue group association;
    #
    # @param group_id [Integer] The group identifier.
    # @param queue_id [Integer] The queue identifier.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def delete_queue_group_association_with_http_info(group_id, queue_id, custom_headers:nil)
      delete_queue_group_association_async(group_id, queue_id, custom_headers:custom_headers).value!
    end

    #
    # Deletes a queue group association;
    #
    # @param group_id [Integer] The group identifier.
    # @param queue_id [Integer] The queue identifier.
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def delete_queue_group_association_async(group_id, queue_id, custom_headers:nil)
      fail ArgumentError, 'group_id is nil' if group_id.nil?
      fail ArgumentError, 'queue_id is nil' if queue_id.nil?


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'
      path_template = 'v1/workflow/queues/{queueID}/groups/{groupID}'

      request_url = @base_url || self.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          path_params: {'groupID' => group_id,'queueID' => queue_id},
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:delete, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 204 || status_code == 403 || status_code == 404
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end


        result
      end

      promise.execute
    end

    #
    # Inserts/Updates the group queue association.
    #
    # @param group_id [Integer] The group identifier.
    # @param queue_id [Integer] The queue identifier.
    # @param model [GroupQueueModel] The model.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [Object] operation results.
    #
    def create_or_update_group_queue_association(group_id, queue_id, model, custom_headers:nil)
      response = create_or_update_group_queue_association_async(group_id, queue_id, model, custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # Inserts/Updates the group queue association.
    #
    # @param group_id [Integer] The group identifier.
    # @param queue_id [Integer] The queue identifier.
    # @param model [GroupQueueModel] The model.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def create_or_update_group_queue_association_with_http_info(group_id, queue_id, model, custom_headers:nil)
      create_or_update_group_queue_association_async(group_id, queue_id, model, custom_headers:custom_headers).value!
    end

    #
    # Inserts/Updates the group queue association.
    #
    # @param group_id [Integer] The group identifier.
    # @param queue_id [Integer] The queue identifier.
    # @param model [GroupQueueModel] The model.
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def create_or_update_group_queue_association_async(group_id, queue_id, model, custom_headers:nil)
      fail ArgumentError, 'group_id is nil' if group_id.nil?
      fail ArgumentError, 'queue_id is nil' if queue_id.nil?
      fail ArgumentError, 'model is nil' if model.nil?


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'

      # Serialize Request
      request_mapper = Softheon.Enterprise.Api.Client::Models::GroupQueueModel.mapper()
      request_content = self.serialize(request_mapper,  model)
      request_content = request_content != nil ? JSON.generate(request_content, quirks_mode: true) : nil

      path_template = 'v1/directory/groups/{groupID}/queues/{queueID}'

      request_url = @base_url || self.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          path_params: {'groupID' => group_id,'queueID' => queue_id},
          body: request_content,
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:put, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 204 || status_code == 403
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end


        result
      end

      promise.execute
    end

    #
    # Deletes a group queue association;
    #
    # @param group_id [Integer] The group identifier.
    # @param queue_id [Integer] The queue identifier.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [Object] operation results.
    #
    def delete_group_queue_association(group_id, queue_id, custom_headers:nil)
      response = delete_group_queue_association_async(group_id, queue_id, custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # Deletes a group queue association;
    #
    # @param group_id [Integer] The group identifier.
    # @param queue_id [Integer] The queue identifier.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def delete_group_queue_association_with_http_info(group_id, queue_id, custom_headers:nil)
      delete_group_queue_association_async(group_id, queue_id, custom_headers:custom_headers).value!
    end

    #
    # Deletes a group queue association;
    #
    # @param group_id [Integer] The group identifier.
    # @param queue_id [Integer] The queue identifier.
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def delete_group_queue_association_async(group_id, queue_id, custom_headers:nil)
      fail ArgumentError, 'group_id is nil' if group_id.nil?
      fail ArgumentError, 'queue_id is nil' if queue_id.nil?


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'
      path_template = 'v1/directory/groups/{groupID}/queues/{queueID}'

      request_url = @base_url || self.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          path_params: {'groupID' => group_id,'queueID' => queue_id},
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:delete, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 204 || status_code == 403 || status_code == 404
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end


        result
      end

      promise.execute
    end

    #
    # Gets a list of application group associations.
    #
    # @param application_id [Integer] The application identifier.
    # @param group_id [Integer] The group identifier.
    # @param acl [Integer] Gets or sets the access control level permissions.
    # @param page [Integer] Gets or sets the page number.
    # @param page_size [Integer] Gets or sets the size of the page.
    # @param sort_order [Enum] Gets or sets the order. Possible values include:
    # 'Unspecified', 'Ascending', 'Descending'
    # @param sort_by [Enum] Gets or sets the column to order by. Possible values
    # include: 'Unspecified', 'DrawerID', 'ApplicationID', 'GroupID', 'UserID',
    # 'QueueID', 'Acl'
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [Array] operation results.
    #
    def get_application_group_associations(application_id, group_id:nil, acl:nil, page:nil, page_size:nil, sort_order:nil, sort_by:nil, custom_headers:nil)
      response = get_application_group_associations_async(application_id, group_id:group_id, acl:acl, page:page, page_size:page_size, sort_order:sort_order, sort_by:sort_by, custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # Gets a list of application group associations.
    #
    # @param application_id [Integer] The application identifier.
    # @param group_id [Integer] The group identifier.
    # @param acl [Integer] Gets or sets the access control level permissions.
    # @param page [Integer] Gets or sets the page number.
    # @param page_size [Integer] Gets or sets the size of the page.
    # @param sort_order [Enum] Gets or sets the order. Possible values include:
    # 'Unspecified', 'Ascending', 'Descending'
    # @param sort_by [Enum] Gets or sets the column to order by. Possible values
    # include: 'Unspecified', 'DrawerID', 'ApplicationID', 'GroupID', 'UserID',
    # 'QueueID', 'Acl'
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def get_application_group_associations_with_http_info(application_id, group_id:nil, acl:nil, page:nil, page_size:nil, sort_order:nil, sort_by:nil, custom_headers:nil)
      get_application_group_associations_async(application_id, group_id:group_id, acl:acl, page:page, page_size:page_size, sort_order:sort_order, sort_by:sort_by, custom_headers:custom_headers).value!
    end

    #
    # Gets a list of application group associations.
    #
    # @param application_id [Integer] The application identifier.
    # @param group_id [Integer] The group identifier.
    # @param acl [Integer] Gets or sets the access control level permissions.
    # @param page [Integer] Gets or sets the page number.
    # @param page_size [Integer] Gets or sets the size of the page.
    # @param sort_order [Enum] Gets or sets the order. Possible values include:
    # 'Unspecified', 'Ascending', 'Descending'
    # @param sort_by [Enum] Gets or sets the column to order by. Possible values
    # include: 'Unspecified', 'DrawerID', 'ApplicationID', 'GroupID', 'UserID',
    # 'QueueID', 'Acl'
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def get_application_group_associations_async(application_id, group_id:nil, acl:nil, page:nil, page_size:nil, sort_order:nil, sort_by:nil, custom_headers:nil)
      fail ArgumentError, 'application_id is nil' if application_id.nil?
      fail ArgumentError, "'page' should satisfy the constraint - 'InclusiveMaximum': '2147483647'" if !page.nil? && page > 2147483647
      fail ArgumentError, "'page' should satisfy the constraint - 'InclusiveMinimum': '1'" if !page.nil? && page < 1
      fail ArgumentError, "'page_size' should satisfy the constraint - 'InclusiveMaximum': '1000'" if !page_size.nil? && page_size > 1000
      fail ArgumentError, "'page_size' should satisfy the constraint - 'InclusiveMinimum': '1'" if !page_size.nil? && page_size < 1


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'
      path_template = 'v1/directory/applications/{applicationID}/groups'

      request_url = @base_url || self.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          path_params: {'applicationID' => application_id},
          query_params: {'groupID' => group_id,'acl' => acl,'page' => page,'pageSize' => page_size,'sortOrder' => sort_order,'sortBy' => sort_by},
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:get, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200 || status_code == 403
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = {
              client_side_validation: true,
              required: false,
              serialized_name: 'parsed_response',
              type: {
                name: 'Sequence',
                element: {
                    client_side_validation: true,
                    required: false,
                    serialized_name: 'GroupApplicationModelElementType',
                    type: {
                      name: 'Composite',
                      class_name: 'GroupApplicationModel'
                    }
                }
              }
            }
            result.body = self.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # Gets a list of group application associations.
    #
    # @param group_id [Integer] The group identifier.
    # @param application_id [Integer] The application identifier.
    # @param acl [Integer] Gets or sets the access control level permissions.
    # @param page [Integer] Gets or sets the page number.
    # @param page_size [Integer] Gets or sets the size of the page.
    # @param sort_order [Enum] Gets or sets the order. Possible values include:
    # 'Unspecified', 'Ascending', 'Descending'
    # @param sort_by [Enum] Gets or sets the column to order by. Possible values
    # include: 'Unspecified', 'DrawerID', 'ApplicationID', 'GroupID', 'UserID',
    # 'QueueID', 'Acl'
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [Array] operation results.
    #
    def get_group_application_associations(group_id, application_id:nil, acl:nil, page:nil, page_size:nil, sort_order:nil, sort_by:nil, custom_headers:nil)
      response = get_group_application_associations_async(group_id, application_id:application_id, acl:acl, page:page, page_size:page_size, sort_order:sort_order, sort_by:sort_by, custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # Gets a list of group application associations.
    #
    # @param group_id [Integer] The group identifier.
    # @param application_id [Integer] The application identifier.
    # @param acl [Integer] Gets or sets the access control level permissions.
    # @param page [Integer] Gets or sets the page number.
    # @param page_size [Integer] Gets or sets the size of the page.
    # @param sort_order [Enum] Gets or sets the order. Possible values include:
    # 'Unspecified', 'Ascending', 'Descending'
    # @param sort_by [Enum] Gets or sets the column to order by. Possible values
    # include: 'Unspecified', 'DrawerID', 'ApplicationID', 'GroupID', 'UserID',
    # 'QueueID', 'Acl'
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def get_group_application_associations_with_http_info(group_id, application_id:nil, acl:nil, page:nil, page_size:nil, sort_order:nil, sort_by:nil, custom_headers:nil)
      get_group_application_associations_async(group_id, application_id:application_id, acl:acl, page:page, page_size:page_size, sort_order:sort_order, sort_by:sort_by, custom_headers:custom_headers).value!
    end

    #
    # Gets a list of group application associations.
    #
    # @param group_id [Integer] The group identifier.
    # @param application_id [Integer] The application identifier.
    # @param acl [Integer] Gets or sets the access control level permissions.
    # @param page [Integer] Gets or sets the page number.
    # @param page_size [Integer] Gets or sets the size of the page.
    # @param sort_order [Enum] Gets or sets the order. Possible values include:
    # 'Unspecified', 'Ascending', 'Descending'
    # @param sort_by [Enum] Gets or sets the column to order by. Possible values
    # include: 'Unspecified', 'DrawerID', 'ApplicationID', 'GroupID', 'UserID',
    # 'QueueID', 'Acl'
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def get_group_application_associations_async(group_id, application_id:nil, acl:nil, page:nil, page_size:nil, sort_order:nil, sort_by:nil, custom_headers:nil)
      fail ArgumentError, 'group_id is nil' if group_id.nil?
      fail ArgumentError, "'page' should satisfy the constraint - 'InclusiveMaximum': '2147483647'" if !page.nil? && page > 2147483647
      fail ArgumentError, "'page' should satisfy the constraint - 'InclusiveMinimum': '1'" if !page.nil? && page < 1
      fail ArgumentError, "'page_size' should satisfy the constraint - 'InclusiveMaximum': '1000'" if !page_size.nil? && page_size > 1000
      fail ArgumentError, "'page_size' should satisfy the constraint - 'InclusiveMinimum': '1'" if !page_size.nil? && page_size < 1


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'
      path_template = 'v1/directory/groups/{groupID}/applications'

      request_url = @base_url || self.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          path_params: {'groupID' => group_id},
          query_params: {'applicationID' => application_id,'acl' => acl,'page' => page,'pageSize' => page_size,'sortOrder' => sort_order,'sortBy' => sort_by},
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:get, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200 || status_code == 403
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = {
              client_side_validation: true,
              required: false,
              serialized_name: 'parsed_response',
              type: {
                name: 'Sequence',
                element: {
                    client_side_validation: true,
                    required: false,
                    serialized_name: 'GroupApplicationModelElementType',
                    type: {
                      name: 'Composite',
                      class_name: 'GroupApplicationModel'
                    }
                }
              }
            }
            result.body = self.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # Inserts/Updates the application group association.
    #
    # @param group_id [Integer] The group identifier.
    # @param application_id [Integer] The application identifier.
    # @param model [GroupApplicationModel] The model.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [Object] operation results.
    #
    def create_or_update_application_group_association(group_id, application_id, model, custom_headers:nil)
      response = create_or_update_application_group_association_async(group_id, application_id, model, custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # Inserts/Updates the application group association.
    #
    # @param group_id [Integer] The group identifier.
    # @param application_id [Integer] The application identifier.
    # @param model [GroupApplicationModel] The model.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def create_or_update_application_group_association_with_http_info(group_id, application_id, model, custom_headers:nil)
      create_or_update_application_group_association_async(group_id, application_id, model, custom_headers:custom_headers).value!
    end

    #
    # Inserts/Updates the application group association.
    #
    # @param group_id [Integer] The group identifier.
    # @param application_id [Integer] The application identifier.
    # @param model [GroupApplicationModel] The model.
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def create_or_update_application_group_association_async(group_id, application_id, model, custom_headers:nil)
      fail ArgumentError, 'group_id is nil' if group_id.nil?
      fail ArgumentError, 'application_id is nil' if application_id.nil?
      fail ArgumentError, 'model is nil' if model.nil?


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'

      # Serialize Request
      request_mapper = Softheon.Enterprise.Api.Client::Models::GroupApplicationModel.mapper()
      request_content = self.serialize(request_mapper,  model)
      request_content = request_content != nil ? JSON.generate(request_content, quirks_mode: true) : nil

      path_template = 'v1/directory/applications/{applicationID}/groups/{groupID}'

      request_url = @base_url || self.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          path_params: {'groupID' => group_id,'applicationID' => application_id},
          body: request_content,
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:put, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 204 || status_code == 403
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end


        result
      end

      promise.execute
    end

    #
    # Deletes a application group association;
    #
    # @param group_id [Integer] The group identifier.
    # @param application_id [Integer] The application identifier.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [Object] operation results.
    #
    def delete_application_group_association(group_id, application_id, custom_headers:nil)
      response = delete_application_group_association_async(group_id, application_id, custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # Deletes a application group association;
    #
    # @param group_id [Integer] The group identifier.
    # @param application_id [Integer] The application identifier.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def delete_application_group_association_with_http_info(group_id, application_id, custom_headers:nil)
      delete_application_group_association_async(group_id, application_id, custom_headers:custom_headers).value!
    end

    #
    # Deletes a application group association;
    #
    # @param group_id [Integer] The group identifier.
    # @param application_id [Integer] The application identifier.
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def delete_application_group_association_async(group_id, application_id, custom_headers:nil)
      fail ArgumentError, 'group_id is nil' if group_id.nil?
      fail ArgumentError, 'application_id is nil' if application_id.nil?


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'
      path_template = 'v1/directory/applications/{applicationID}/groups/{groupID}'

      request_url = @base_url || self.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          path_params: {'groupID' => group_id,'applicationID' => application_id},
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:delete, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 204 || status_code == 403 || status_code == 404 || status_code == 500
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end


        result
      end

      promise.execute
    end

    #
    # Inserts/Updates the group application association.
    #
    # @param group_id [Integer] The group identifier.
    # @param application_id [Integer] The application identifier.
    # @param model [GroupApplicationModel] The model.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [Object] operation results.
    #
    def create_or_update_group_application_association(group_id, application_id, model, custom_headers:nil)
      response = create_or_update_group_application_association_async(group_id, application_id, model, custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # Inserts/Updates the group application association.
    #
    # @param group_id [Integer] The group identifier.
    # @param application_id [Integer] The application identifier.
    # @param model [GroupApplicationModel] The model.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def create_or_update_group_application_association_with_http_info(group_id, application_id, model, custom_headers:nil)
      create_or_update_group_application_association_async(group_id, application_id, model, custom_headers:custom_headers).value!
    end

    #
    # Inserts/Updates the group application association.
    #
    # @param group_id [Integer] The group identifier.
    # @param application_id [Integer] The application identifier.
    # @param model [GroupApplicationModel] The model.
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def create_or_update_group_application_association_async(group_id, application_id, model, custom_headers:nil)
      fail ArgumentError, 'group_id is nil' if group_id.nil?
      fail ArgumentError, 'application_id is nil' if application_id.nil?
      fail ArgumentError, 'model is nil' if model.nil?


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'

      # Serialize Request
      request_mapper = Softheon.Enterprise.Api.Client::Models::GroupApplicationModel.mapper()
      request_content = self.serialize(request_mapper,  model)
      request_content = request_content != nil ? JSON.generate(request_content, quirks_mode: true) : nil

      path_template = 'v1/directory/groups/{groupID}/applications/{applicationID}'

      request_url = @base_url || self.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          path_params: {'groupID' => group_id,'applicationID' => application_id},
          body: request_content,
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:put, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 204 || status_code == 403
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end


        result
      end

      promise.execute
    end

    #
    # Deletes a group application association;
    #
    # @param group_id [Integer] The group identifier.
    # @param application_id [Integer] The application identifier.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [Object] operation results.
    #
    def delete_group_application_association(group_id, application_id, custom_headers:nil)
      response = delete_group_application_association_async(group_id, application_id, custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # Deletes a group application association;
    #
    # @param group_id [Integer] The group identifier.
    # @param application_id [Integer] The application identifier.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def delete_group_application_association_with_http_info(group_id, application_id, custom_headers:nil)
      delete_group_application_association_async(group_id, application_id, custom_headers:custom_headers).value!
    end

    #
    # Deletes a group application association;
    #
    # @param group_id [Integer] The group identifier.
    # @param application_id [Integer] The application identifier.
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def delete_group_application_association_async(group_id, application_id, custom_headers:nil)
      fail ArgumentError, 'group_id is nil' if group_id.nil?
      fail ArgumentError, 'application_id is nil' if application_id.nil?


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'
      path_template = 'v1/directory/groups/{groupID}/applications/{applicationID}'

      request_url = @base_url || self.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          path_params: {'groupID' => group_id,'applicationID' => application_id},
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:delete, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 204 || status_code == 403 || status_code == 404 || status_code == 500
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end


        result
      end

      promise.execute
    end

    #
    # Gets a list of drawer user associations.
    #
    # @param drawer_id [Integer] The drawer identifier.
    # @param user_id [Integer] The user identifier.
    # @param acl [Integer] Gets or sets the access control level permissions.
    # @param page [Integer] Gets or sets the page number.
    # @param page_size [Integer] Gets or sets the size of the page.
    # @param sort_order [Enum] Gets or sets the order. Possible values include:
    # 'Unspecified', 'Ascending', 'Descending'
    # @param sort_by [Enum] Gets or sets the column to order by. Possible values
    # include: 'Unspecified', 'DrawerID', 'ApplicationID', 'GroupID', 'UserID',
    # 'QueueID', 'Acl'
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [Array] operation results.
    #
    def get_drawer_user_associations(drawer_id, user_id:nil, acl:nil, page:nil, page_size:nil, sort_order:nil, sort_by:nil, custom_headers:nil)
      response = get_drawer_user_associations_async(drawer_id, user_id:user_id, acl:acl, page:page, page_size:page_size, sort_order:sort_order, sort_by:sort_by, custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # Gets a list of drawer user associations.
    #
    # @param drawer_id [Integer] The drawer identifier.
    # @param user_id [Integer] The user identifier.
    # @param acl [Integer] Gets or sets the access control level permissions.
    # @param page [Integer] Gets or sets the page number.
    # @param page_size [Integer] Gets or sets the size of the page.
    # @param sort_order [Enum] Gets or sets the order. Possible values include:
    # 'Unspecified', 'Ascending', 'Descending'
    # @param sort_by [Enum] Gets or sets the column to order by. Possible values
    # include: 'Unspecified', 'DrawerID', 'ApplicationID', 'GroupID', 'UserID',
    # 'QueueID', 'Acl'
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def get_drawer_user_associations_with_http_info(drawer_id, user_id:nil, acl:nil, page:nil, page_size:nil, sort_order:nil, sort_by:nil, custom_headers:nil)
      get_drawer_user_associations_async(drawer_id, user_id:user_id, acl:acl, page:page, page_size:page_size, sort_order:sort_order, sort_by:sort_by, custom_headers:custom_headers).value!
    end

    #
    # Gets a list of drawer user associations.
    #
    # @param drawer_id [Integer] The drawer identifier.
    # @param user_id [Integer] The user identifier.
    # @param acl [Integer] Gets or sets the access control level permissions.
    # @param page [Integer] Gets or sets the page number.
    # @param page_size [Integer] Gets or sets the size of the page.
    # @param sort_order [Enum] Gets or sets the order. Possible values include:
    # 'Unspecified', 'Ascending', 'Descending'
    # @param sort_by [Enum] Gets or sets the column to order by. Possible values
    # include: 'Unspecified', 'DrawerID', 'ApplicationID', 'GroupID', 'UserID',
    # 'QueueID', 'Acl'
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def get_drawer_user_associations_async(drawer_id, user_id:nil, acl:nil, page:nil, page_size:nil, sort_order:nil, sort_by:nil, custom_headers:nil)
      fail ArgumentError, 'drawer_id is nil' if drawer_id.nil?
      fail ArgumentError, "'page' should satisfy the constraint - 'InclusiveMaximum': '2147483647'" if !page.nil? && page > 2147483647
      fail ArgumentError, "'page' should satisfy the constraint - 'InclusiveMinimum': '1'" if !page.nil? && page < 1
      fail ArgumentError, "'page_size' should satisfy the constraint - 'InclusiveMaximum': '1000'" if !page_size.nil? && page_size > 1000
      fail ArgumentError, "'page_size' should satisfy the constraint - 'InclusiveMinimum': '1'" if !page_size.nil? && page_size < 1


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'
      path_template = 'v1/directory/drawers/{drawerID}/users'

      request_url = @base_url || self.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          path_params: {'drawerID' => drawer_id},
          query_params: {'userID' => user_id,'acl' => acl,'page' => page,'pageSize' => page_size,'sortOrder' => sort_order,'sortBy' => sort_by},
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:get, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200 || status_code == 403
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = {
              client_side_validation: true,
              required: false,
              serialized_name: 'parsed_response',
              type: {
                name: 'Sequence',
                element: {
                    client_side_validation: true,
                    required: false,
                    serialized_name: 'UserDrawerModelElementType',
                    type: {
                      name: 'Composite',
                      class_name: 'UserDrawerModel'
                    }
                }
              }
            }
            result.body = self.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # Gets a list of user drawer associations.
    #
    # @param user_id [Integer] The user identifier.
    # @param drawer_id [Integer] The drawer identifier.
    # @param acl [Integer] Gets or sets the access control level permissions.
    # @param page [Integer] Gets or sets the page number.
    # @param page_size [Integer] Gets or sets the size of the page.
    # @param sort_order [Enum] Gets or sets the order. Possible values include:
    # 'Unspecified', 'Ascending', 'Descending'
    # @param sort_by [Enum] Gets or sets the column to order by. Possible values
    # include: 'Unspecified', 'DrawerID', 'ApplicationID', 'GroupID', 'UserID',
    # 'QueueID', 'Acl'
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [Array] operation results.
    #
    def get_user_drawer_associations(user_id, drawer_id:nil, acl:nil, page:nil, page_size:nil, sort_order:nil, sort_by:nil, custom_headers:nil)
      response = get_user_drawer_associations_async(user_id, drawer_id:drawer_id, acl:acl, page:page, page_size:page_size, sort_order:sort_order, sort_by:sort_by, custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # Gets a list of user drawer associations.
    #
    # @param user_id [Integer] The user identifier.
    # @param drawer_id [Integer] The drawer identifier.
    # @param acl [Integer] Gets or sets the access control level permissions.
    # @param page [Integer] Gets or sets the page number.
    # @param page_size [Integer] Gets or sets the size of the page.
    # @param sort_order [Enum] Gets or sets the order. Possible values include:
    # 'Unspecified', 'Ascending', 'Descending'
    # @param sort_by [Enum] Gets or sets the column to order by. Possible values
    # include: 'Unspecified', 'DrawerID', 'ApplicationID', 'GroupID', 'UserID',
    # 'QueueID', 'Acl'
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def get_user_drawer_associations_with_http_info(user_id, drawer_id:nil, acl:nil, page:nil, page_size:nil, sort_order:nil, sort_by:nil, custom_headers:nil)
      get_user_drawer_associations_async(user_id, drawer_id:drawer_id, acl:acl, page:page, page_size:page_size, sort_order:sort_order, sort_by:sort_by, custom_headers:custom_headers).value!
    end

    #
    # Gets a list of user drawer associations.
    #
    # @param user_id [Integer] The user identifier.
    # @param drawer_id [Integer] The drawer identifier.
    # @param acl [Integer] Gets or sets the access control level permissions.
    # @param page [Integer] Gets or sets the page number.
    # @param page_size [Integer] Gets or sets the size of the page.
    # @param sort_order [Enum] Gets or sets the order. Possible values include:
    # 'Unspecified', 'Ascending', 'Descending'
    # @param sort_by [Enum] Gets or sets the column to order by. Possible values
    # include: 'Unspecified', 'DrawerID', 'ApplicationID', 'GroupID', 'UserID',
    # 'QueueID', 'Acl'
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def get_user_drawer_associations_async(user_id, drawer_id:nil, acl:nil, page:nil, page_size:nil, sort_order:nil, sort_by:nil, custom_headers:nil)
      fail ArgumentError, 'user_id is nil' if user_id.nil?
      fail ArgumentError, "'page' should satisfy the constraint - 'InclusiveMaximum': '2147483647'" if !page.nil? && page > 2147483647
      fail ArgumentError, "'page' should satisfy the constraint - 'InclusiveMinimum': '1'" if !page.nil? && page < 1
      fail ArgumentError, "'page_size' should satisfy the constraint - 'InclusiveMaximum': '1000'" if !page_size.nil? && page_size > 1000
      fail ArgumentError, "'page_size' should satisfy the constraint - 'InclusiveMinimum': '1'" if !page_size.nil? && page_size < 1


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'
      path_template = 'v1/directory/users/{userID}/drawers'

      request_url = @base_url || self.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          path_params: {'userID' => user_id},
          query_params: {'drawerID' => drawer_id,'acl' => acl,'page' => page,'pageSize' => page_size,'sortOrder' => sort_order,'sortBy' => sort_by},
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:get, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200 || status_code == 403
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = {
              client_side_validation: true,
              required: false,
              serialized_name: 'parsed_response',
              type: {
                name: 'Sequence',
                element: {
                    client_side_validation: true,
                    required: false,
                    serialized_name: 'UserDrawerModelElementType',
                    type: {
                      name: 'Composite',
                      class_name: 'UserDrawerModel'
                    }
                }
              }
            }
            result.body = self.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # Inserts/Updates the drawer user association.
    #
    # @param user_id [Integer] The user identifier.
    # @param drawer_id [Integer] The drawer identifier.
    # @param model [UserDrawerModel] The model.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [Object] operation results.
    #
    def create_or_update_drawer_user_association(user_id, drawer_id, model, custom_headers:nil)
      response = create_or_update_drawer_user_association_async(user_id, drawer_id, model, custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # Inserts/Updates the drawer user association.
    #
    # @param user_id [Integer] The user identifier.
    # @param drawer_id [Integer] The drawer identifier.
    # @param model [UserDrawerModel] The model.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def create_or_update_drawer_user_association_with_http_info(user_id, drawer_id, model, custom_headers:nil)
      create_or_update_drawer_user_association_async(user_id, drawer_id, model, custom_headers:custom_headers).value!
    end

    #
    # Inserts/Updates the drawer user association.
    #
    # @param user_id [Integer] The user identifier.
    # @param drawer_id [Integer] The drawer identifier.
    # @param model [UserDrawerModel] The model.
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def create_or_update_drawer_user_association_async(user_id, drawer_id, model, custom_headers:nil)
      fail ArgumentError, 'user_id is nil' if user_id.nil?
      fail ArgumentError, 'drawer_id is nil' if drawer_id.nil?
      fail ArgumentError, 'model is nil' if model.nil?


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'

      # Serialize Request
      request_mapper = Softheon.Enterprise.Api.Client::Models::UserDrawerModel.mapper()
      request_content = self.serialize(request_mapper,  model)
      request_content = request_content != nil ? JSON.generate(request_content, quirks_mode: true) : nil

      path_template = 'v1/directory/drawers/{drawerID}/users/{userID}'

      request_url = @base_url || self.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          path_params: {'userID' => user_id,'drawerID' => drawer_id},
          body: request_content,
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:put, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 204 || status_code == 403
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end


        result
      end

      promise.execute
    end

    #
    # Deletes a drawer user association;
    #
    # @param user_id [Integer] The user identifier.
    # @param drawer_id [Integer] The drawer identifier.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [Object] operation results.
    #
    def delete_drawer_user_association(user_id, drawer_id, custom_headers:nil)
      response = delete_drawer_user_association_async(user_id, drawer_id, custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # Deletes a drawer user association;
    #
    # @param user_id [Integer] The user identifier.
    # @param drawer_id [Integer] The drawer identifier.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def delete_drawer_user_association_with_http_info(user_id, drawer_id, custom_headers:nil)
      delete_drawer_user_association_async(user_id, drawer_id, custom_headers:custom_headers).value!
    end

    #
    # Deletes a drawer user association;
    #
    # @param user_id [Integer] The user identifier.
    # @param drawer_id [Integer] The drawer identifier.
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def delete_drawer_user_association_async(user_id, drawer_id, custom_headers:nil)
      fail ArgumentError, 'user_id is nil' if user_id.nil?
      fail ArgumentError, 'drawer_id is nil' if drawer_id.nil?


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'
      path_template = 'v1/directory/drawers/{drawerID}/users/{userID}'

      request_url = @base_url || self.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          path_params: {'userID' => user_id,'drawerID' => drawer_id},
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:delete, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 204 || status_code == 403 || status_code == 404
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end


        result
      end

      promise.execute
    end

    #
    # Inserts/Updates the user drawer association.
    #
    # @param user_id [Integer] The user identifier.
    # @param drawer_id [Integer] The drawer identifier.
    # @param model [UserDrawerModel] The model.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [Object] operation results.
    #
    def create_or_update_user_drawer_association(user_id, drawer_id, model, custom_headers:nil)
      response = create_or_update_user_drawer_association_async(user_id, drawer_id, model, custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # Inserts/Updates the user drawer association.
    #
    # @param user_id [Integer] The user identifier.
    # @param drawer_id [Integer] The drawer identifier.
    # @param model [UserDrawerModel] The model.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def create_or_update_user_drawer_association_with_http_info(user_id, drawer_id, model, custom_headers:nil)
      create_or_update_user_drawer_association_async(user_id, drawer_id, model, custom_headers:custom_headers).value!
    end

    #
    # Inserts/Updates the user drawer association.
    #
    # @param user_id [Integer] The user identifier.
    # @param drawer_id [Integer] The drawer identifier.
    # @param model [UserDrawerModel] The model.
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def create_or_update_user_drawer_association_async(user_id, drawer_id, model, custom_headers:nil)
      fail ArgumentError, 'user_id is nil' if user_id.nil?
      fail ArgumentError, 'drawer_id is nil' if drawer_id.nil?
      fail ArgumentError, 'model is nil' if model.nil?


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'

      # Serialize Request
      request_mapper = Softheon.Enterprise.Api.Client::Models::UserDrawerModel.mapper()
      request_content = self.serialize(request_mapper,  model)
      request_content = request_content != nil ? JSON.generate(request_content, quirks_mode: true) : nil

      path_template = 'v1/directory/users/{userID}/drawers/{drawerID}'

      request_url = @base_url || self.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          path_params: {'userID' => user_id,'drawerID' => drawer_id},
          body: request_content,
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:put, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 204 || status_code == 403
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end


        result
      end

      promise.execute
    end

    #
    # Deletes a user drawer association;
    #
    # @param user_id [Integer] The user identifier.
    # @param drawer_id [Integer] The drawer identifier.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [Object] operation results.
    #
    def delete_user_drawer_association(user_id, drawer_id, custom_headers:nil)
      response = delete_user_drawer_association_async(user_id, drawer_id, custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # Deletes a user drawer association;
    #
    # @param user_id [Integer] The user identifier.
    # @param drawer_id [Integer] The drawer identifier.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def delete_user_drawer_association_with_http_info(user_id, drawer_id, custom_headers:nil)
      delete_user_drawer_association_async(user_id, drawer_id, custom_headers:custom_headers).value!
    end

    #
    # Deletes a user drawer association;
    #
    # @param user_id [Integer] The user identifier.
    # @param drawer_id [Integer] The drawer identifier.
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def delete_user_drawer_association_async(user_id, drawer_id, custom_headers:nil)
      fail ArgumentError, 'user_id is nil' if user_id.nil?
      fail ArgumentError, 'drawer_id is nil' if drawer_id.nil?


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'
      path_template = 'v1/directory/users/{userID}/drawers/{drawerID}'

      request_url = @base_url || self.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          path_params: {'userID' => user_id,'drawerID' => drawer_id},
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:delete, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 204 || status_code == 403 || status_code == 404
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end


        result
      end

      promise.execute
    end

    #
    # Gets a list of queue user associations.
    #
    # @param queue_id [Integer] The queue identifier.
    # @param user_id [Integer] The user identifier.
    # @param acl [Integer] Gets or sets the access control level permissions.
    # @param page [Integer] Gets or sets the page number.
    # @param page_size [Integer] Gets or sets the size of the page.
    # @param sort_order [Enum] Gets or sets the order. Possible values include:
    # 'Unspecified', 'Ascending', 'Descending'
    # @param sort_by [Enum] Gets or sets the column to order by. Possible values
    # include: 'Unspecified', 'DrawerID', 'ApplicationID', 'GroupID', 'UserID',
    # 'QueueID', 'Acl'
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [Array] operation results.
    #
    def get_queue_user_associations(queue_id, user_id:nil, acl:nil, page:nil, page_size:nil, sort_order:nil, sort_by:nil, custom_headers:nil)
      response = get_queue_user_associations_async(queue_id, user_id:user_id, acl:acl, page:page, page_size:page_size, sort_order:sort_order, sort_by:sort_by, custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # Gets a list of queue user associations.
    #
    # @param queue_id [Integer] The queue identifier.
    # @param user_id [Integer] The user identifier.
    # @param acl [Integer] Gets or sets the access control level permissions.
    # @param page [Integer] Gets or sets the page number.
    # @param page_size [Integer] Gets or sets the size of the page.
    # @param sort_order [Enum] Gets or sets the order. Possible values include:
    # 'Unspecified', 'Ascending', 'Descending'
    # @param sort_by [Enum] Gets or sets the column to order by. Possible values
    # include: 'Unspecified', 'DrawerID', 'ApplicationID', 'GroupID', 'UserID',
    # 'QueueID', 'Acl'
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def get_queue_user_associations_with_http_info(queue_id, user_id:nil, acl:nil, page:nil, page_size:nil, sort_order:nil, sort_by:nil, custom_headers:nil)
      get_queue_user_associations_async(queue_id, user_id:user_id, acl:acl, page:page, page_size:page_size, sort_order:sort_order, sort_by:sort_by, custom_headers:custom_headers).value!
    end

    #
    # Gets a list of queue user associations.
    #
    # @param queue_id [Integer] The queue identifier.
    # @param user_id [Integer] The user identifier.
    # @param acl [Integer] Gets or sets the access control level permissions.
    # @param page [Integer] Gets or sets the page number.
    # @param page_size [Integer] Gets or sets the size of the page.
    # @param sort_order [Enum] Gets or sets the order. Possible values include:
    # 'Unspecified', 'Ascending', 'Descending'
    # @param sort_by [Enum] Gets or sets the column to order by. Possible values
    # include: 'Unspecified', 'DrawerID', 'ApplicationID', 'GroupID', 'UserID',
    # 'QueueID', 'Acl'
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def get_queue_user_associations_async(queue_id, user_id:nil, acl:nil, page:nil, page_size:nil, sort_order:nil, sort_by:nil, custom_headers:nil)
      fail ArgumentError, 'queue_id is nil' if queue_id.nil?
      fail ArgumentError, "'page' should satisfy the constraint - 'InclusiveMaximum': '2147483647'" if !page.nil? && page > 2147483647
      fail ArgumentError, "'page' should satisfy the constraint - 'InclusiveMinimum': '1'" if !page.nil? && page < 1
      fail ArgumentError, "'page_size' should satisfy the constraint - 'InclusiveMaximum': '1000'" if !page_size.nil? && page_size > 1000
      fail ArgumentError, "'page_size' should satisfy the constraint - 'InclusiveMinimum': '1'" if !page_size.nil? && page_size < 1


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'
      path_template = 'v1/workflow/queues/{queueID}/users'

      request_url = @base_url || self.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          path_params: {'queueID' => queue_id},
          query_params: {'userID' => user_id,'acl' => acl,'page' => page,'pageSize' => page_size,'sortOrder' => sort_order,'sortBy' => sort_by},
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:get, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200 || status_code == 403
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = {
              client_side_validation: true,
              required: false,
              serialized_name: 'parsed_response',
              type: {
                name: 'Sequence',
                element: {
                    client_side_validation: true,
                    required: false,
                    serialized_name: 'UserQueueModelElementType',
                    type: {
                      name: 'Composite',
                      class_name: 'UserQueueModel'
                    }
                }
              }
            }
            result.body = self.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # Gets a list of user queue associations.
    #
    # @param user_id [Integer] The user identifier.
    # @param queue_id [Integer] The queue identifier.
    # @param acl [Integer] Gets or sets the access control level permissions.
    # @param page [Integer] Gets or sets the page number.
    # @param page_size [Integer] Gets or sets the size of the page.
    # @param sort_order [Enum] Gets or sets the order. Possible values include:
    # 'Unspecified', 'Ascending', 'Descending'
    # @param sort_by [Enum] Gets or sets the column to order by. Possible values
    # include: 'Unspecified', 'DrawerID', 'ApplicationID', 'GroupID', 'UserID',
    # 'QueueID', 'Acl'
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [Array] operation results.
    #
    def get_user_queue_associations(user_id, queue_id:nil, acl:nil, page:nil, page_size:nil, sort_order:nil, sort_by:nil, custom_headers:nil)
      response = get_user_queue_associations_async(user_id, queue_id:queue_id, acl:acl, page:page, page_size:page_size, sort_order:sort_order, sort_by:sort_by, custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # Gets a list of user queue associations.
    #
    # @param user_id [Integer] The user identifier.
    # @param queue_id [Integer] The queue identifier.
    # @param acl [Integer] Gets or sets the access control level permissions.
    # @param page [Integer] Gets or sets the page number.
    # @param page_size [Integer] Gets or sets the size of the page.
    # @param sort_order [Enum] Gets or sets the order. Possible values include:
    # 'Unspecified', 'Ascending', 'Descending'
    # @param sort_by [Enum] Gets or sets the column to order by. Possible values
    # include: 'Unspecified', 'DrawerID', 'ApplicationID', 'GroupID', 'UserID',
    # 'QueueID', 'Acl'
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def get_user_queue_associations_with_http_info(user_id, queue_id:nil, acl:nil, page:nil, page_size:nil, sort_order:nil, sort_by:nil, custom_headers:nil)
      get_user_queue_associations_async(user_id, queue_id:queue_id, acl:acl, page:page, page_size:page_size, sort_order:sort_order, sort_by:sort_by, custom_headers:custom_headers).value!
    end

    #
    # Gets a list of user queue associations.
    #
    # @param user_id [Integer] The user identifier.
    # @param queue_id [Integer] The queue identifier.
    # @param acl [Integer] Gets or sets the access control level permissions.
    # @param page [Integer] Gets or sets the page number.
    # @param page_size [Integer] Gets or sets the size of the page.
    # @param sort_order [Enum] Gets or sets the order. Possible values include:
    # 'Unspecified', 'Ascending', 'Descending'
    # @param sort_by [Enum] Gets or sets the column to order by. Possible values
    # include: 'Unspecified', 'DrawerID', 'ApplicationID', 'GroupID', 'UserID',
    # 'QueueID', 'Acl'
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def get_user_queue_associations_async(user_id, queue_id:nil, acl:nil, page:nil, page_size:nil, sort_order:nil, sort_by:nil, custom_headers:nil)
      fail ArgumentError, 'user_id is nil' if user_id.nil?
      fail ArgumentError, "'page' should satisfy the constraint - 'InclusiveMaximum': '2147483647'" if !page.nil? && page > 2147483647
      fail ArgumentError, "'page' should satisfy the constraint - 'InclusiveMinimum': '1'" if !page.nil? && page < 1
      fail ArgumentError, "'page_size' should satisfy the constraint - 'InclusiveMaximum': '1000'" if !page_size.nil? && page_size > 1000
      fail ArgumentError, "'page_size' should satisfy the constraint - 'InclusiveMinimum': '1'" if !page_size.nil? && page_size < 1


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'
      path_template = 'v1/directory/users/{userID}/queues'

      request_url = @base_url || self.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          path_params: {'userID' => user_id},
          query_params: {'queueID' => queue_id,'acl' => acl,'page' => page,'pageSize' => page_size,'sortOrder' => sort_order,'sortBy' => sort_by},
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:get, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200 || status_code == 403
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = {
              client_side_validation: true,
              required: false,
              serialized_name: 'parsed_response',
              type: {
                name: 'Sequence',
                element: {
                    client_side_validation: true,
                    required: false,
                    serialized_name: 'UserQueueModelElementType',
                    type: {
                      name: 'Composite',
                      class_name: 'UserQueueModel'
                    }
                }
              }
            }
            result.body = self.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # Inserts/Updates the queue user association.
    #
    # @param user_id [Integer] The user identifier.
    # @param queue_id [Integer] The queue identifier.
    # @param model [UserQueueModel] The model.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [Object] operation results.
    #
    def create_or_update_queue_user_association(user_id, queue_id, model, custom_headers:nil)
      response = create_or_update_queue_user_association_async(user_id, queue_id, model, custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # Inserts/Updates the queue user association.
    #
    # @param user_id [Integer] The user identifier.
    # @param queue_id [Integer] The queue identifier.
    # @param model [UserQueueModel] The model.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def create_or_update_queue_user_association_with_http_info(user_id, queue_id, model, custom_headers:nil)
      create_or_update_queue_user_association_async(user_id, queue_id, model, custom_headers:custom_headers).value!
    end

    #
    # Inserts/Updates the queue user association.
    #
    # @param user_id [Integer] The user identifier.
    # @param queue_id [Integer] The queue identifier.
    # @param model [UserQueueModel] The model.
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def create_or_update_queue_user_association_async(user_id, queue_id, model, custom_headers:nil)
      fail ArgumentError, 'user_id is nil' if user_id.nil?
      fail ArgumentError, 'queue_id is nil' if queue_id.nil?
      fail ArgumentError, 'model is nil' if model.nil?


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'

      # Serialize Request
      request_mapper = Softheon.Enterprise.Api.Client::Models::UserQueueModel.mapper()
      request_content = self.serialize(request_mapper,  model)
      request_content = request_content != nil ? JSON.generate(request_content, quirks_mode: true) : nil

      path_template = 'v1/workflow/queues/{queueID}/users/{userID}'

      request_url = @base_url || self.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          path_params: {'userID' => user_id,'queueID' => queue_id},
          body: request_content,
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:put, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 204 || status_code == 403
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end


        result
      end

      promise.execute
    end

    #
    # Deletes a queue user association;
    #
    # @param user_id [Integer] The user identifier.
    # @param queue_id [Integer] The queue identifier.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [Object] operation results.
    #
    def delete_queue_user_association(user_id, queue_id, custom_headers:nil)
      response = delete_queue_user_association_async(user_id, queue_id, custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # Deletes a queue user association;
    #
    # @param user_id [Integer] The user identifier.
    # @param queue_id [Integer] The queue identifier.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def delete_queue_user_association_with_http_info(user_id, queue_id, custom_headers:nil)
      delete_queue_user_association_async(user_id, queue_id, custom_headers:custom_headers).value!
    end

    #
    # Deletes a queue user association;
    #
    # @param user_id [Integer] The user identifier.
    # @param queue_id [Integer] The queue identifier.
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def delete_queue_user_association_async(user_id, queue_id, custom_headers:nil)
      fail ArgumentError, 'user_id is nil' if user_id.nil?
      fail ArgumentError, 'queue_id is nil' if queue_id.nil?


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'
      path_template = 'v1/workflow/queues/{queueID}/users/{userID}'

      request_url = @base_url || self.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          path_params: {'userID' => user_id,'queueID' => queue_id},
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:delete, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 204 || status_code == 403 || status_code == 404
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end


        result
      end

      promise.execute
    end

    #
    # Inserts/Updates the user queue association.
    #
    # @param user_id [Integer] The user identifier.
    # @param queue_id [Integer] The queue identifier.
    # @param model [UserQueueModel] The model.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [Object] operation results.
    #
    def create_or_update_user_queue_association(user_id, queue_id, model, custom_headers:nil)
      response = create_or_update_user_queue_association_async(user_id, queue_id, model, custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # Inserts/Updates the user queue association.
    #
    # @param user_id [Integer] The user identifier.
    # @param queue_id [Integer] The queue identifier.
    # @param model [UserQueueModel] The model.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def create_or_update_user_queue_association_with_http_info(user_id, queue_id, model, custom_headers:nil)
      create_or_update_user_queue_association_async(user_id, queue_id, model, custom_headers:custom_headers).value!
    end

    #
    # Inserts/Updates the user queue association.
    #
    # @param user_id [Integer] The user identifier.
    # @param queue_id [Integer] The queue identifier.
    # @param model [UserQueueModel] The model.
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def create_or_update_user_queue_association_async(user_id, queue_id, model, custom_headers:nil)
      fail ArgumentError, 'user_id is nil' if user_id.nil?
      fail ArgumentError, 'queue_id is nil' if queue_id.nil?
      fail ArgumentError, 'model is nil' if model.nil?


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'

      # Serialize Request
      request_mapper = Softheon.Enterprise.Api.Client::Models::UserQueueModel.mapper()
      request_content = self.serialize(request_mapper,  model)
      request_content = request_content != nil ? JSON.generate(request_content, quirks_mode: true) : nil

      path_template = 'v1/directory/users/{userID}/queues/{queueID}'

      request_url = @base_url || self.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          path_params: {'userID' => user_id,'queueID' => queue_id},
          body: request_content,
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:put, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 204 || status_code == 403
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end


        result
      end

      promise.execute
    end

    #
    # Deletes a user queue association;
    #
    # @param user_id [Integer] The user identifier.
    # @param queue_id [Integer] The queue identifier.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [Object] operation results.
    #
    def delete_user_queue_association(user_id, queue_id, custom_headers:nil)
      response = delete_user_queue_association_async(user_id, queue_id, custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # Deletes a user queue association;
    #
    # @param user_id [Integer] The user identifier.
    # @param queue_id [Integer] The queue identifier.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def delete_user_queue_association_with_http_info(user_id, queue_id, custom_headers:nil)
      delete_user_queue_association_async(user_id, queue_id, custom_headers:custom_headers).value!
    end

    #
    # Deletes a user queue association;
    #
    # @param user_id [Integer] The user identifier.
    # @param queue_id [Integer] The queue identifier.
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def delete_user_queue_association_async(user_id, queue_id, custom_headers:nil)
      fail ArgumentError, 'user_id is nil' if user_id.nil?
      fail ArgumentError, 'queue_id is nil' if queue_id.nil?


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'
      path_template = 'v1/directory/users/{userID}/queues/{queueID}'

      request_url = @base_url || self.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          path_params: {'userID' => user_id,'queueID' => queue_id},
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:delete, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 204 || status_code == 403 || status_code == 404
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end


        result
      end

      promise.execute
    end

    #
    # Gets a list of application user associations.
    #
    # @param application_id [Integer] The application identifier.
    # @param user_id [Integer] The user identifier.
    # @param acl [Integer] Gets or sets the access control level permissions.
    # @param page [Integer] Gets or sets the page number.
    # @param page_size [Integer] Gets or sets the size of the page.
    # @param sort_order [Enum] Gets or sets the order. Possible values include:
    # 'Unspecified', 'Ascending', 'Descending'
    # @param sort_by [Enum] Gets or sets the column to order by. Possible values
    # include: 'Unspecified', 'DrawerID', 'ApplicationID', 'GroupID', 'UserID',
    # 'QueueID', 'Acl'
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [Array] operation results.
    #
    def get_application_user_associations(application_id, user_id:nil, acl:nil, page:nil, page_size:nil, sort_order:nil, sort_by:nil, custom_headers:nil)
      response = get_application_user_associations_async(application_id, user_id:user_id, acl:acl, page:page, page_size:page_size, sort_order:sort_order, sort_by:sort_by, custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # Gets a list of application user associations.
    #
    # @param application_id [Integer] The application identifier.
    # @param user_id [Integer] The user identifier.
    # @param acl [Integer] Gets or sets the access control level permissions.
    # @param page [Integer] Gets or sets the page number.
    # @param page_size [Integer] Gets or sets the size of the page.
    # @param sort_order [Enum] Gets or sets the order. Possible values include:
    # 'Unspecified', 'Ascending', 'Descending'
    # @param sort_by [Enum] Gets or sets the column to order by. Possible values
    # include: 'Unspecified', 'DrawerID', 'ApplicationID', 'GroupID', 'UserID',
    # 'QueueID', 'Acl'
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def get_application_user_associations_with_http_info(application_id, user_id:nil, acl:nil, page:nil, page_size:nil, sort_order:nil, sort_by:nil, custom_headers:nil)
      get_application_user_associations_async(application_id, user_id:user_id, acl:acl, page:page, page_size:page_size, sort_order:sort_order, sort_by:sort_by, custom_headers:custom_headers).value!
    end

    #
    # Gets a list of application user associations.
    #
    # @param application_id [Integer] The application identifier.
    # @param user_id [Integer] The user identifier.
    # @param acl [Integer] Gets or sets the access control level permissions.
    # @param page [Integer] Gets or sets the page number.
    # @param page_size [Integer] Gets or sets the size of the page.
    # @param sort_order [Enum] Gets or sets the order. Possible values include:
    # 'Unspecified', 'Ascending', 'Descending'
    # @param sort_by [Enum] Gets or sets the column to order by. Possible values
    # include: 'Unspecified', 'DrawerID', 'ApplicationID', 'GroupID', 'UserID',
    # 'QueueID', 'Acl'
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def get_application_user_associations_async(application_id, user_id:nil, acl:nil, page:nil, page_size:nil, sort_order:nil, sort_by:nil, custom_headers:nil)
      fail ArgumentError, 'application_id is nil' if application_id.nil?
      fail ArgumentError, "'page' should satisfy the constraint - 'InclusiveMaximum': '2147483647'" if !page.nil? && page > 2147483647
      fail ArgumentError, "'page' should satisfy the constraint - 'InclusiveMinimum': '1'" if !page.nil? && page < 1
      fail ArgumentError, "'page_size' should satisfy the constraint - 'InclusiveMaximum': '1000'" if !page_size.nil? && page_size > 1000
      fail ArgumentError, "'page_size' should satisfy the constraint - 'InclusiveMinimum': '1'" if !page_size.nil? && page_size < 1


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'
      path_template = 'v1/directory/applications/{applicationID}/users'

      request_url = @base_url || self.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          path_params: {'applicationID' => application_id},
          query_params: {'userID' => user_id,'acl' => acl,'page' => page,'pageSize' => page_size,'sortOrder' => sort_order,'sortBy' => sort_by},
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:get, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200 || status_code == 403
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = {
              client_side_validation: true,
              required: false,
              serialized_name: 'parsed_response',
              type: {
                name: 'Sequence',
                element: {
                    client_side_validation: true,
                    required: false,
                    serialized_name: 'UserApplicationModelElementType',
                    type: {
                      name: 'Composite',
                      class_name: 'UserApplicationModel'
                    }
                }
              }
            }
            result.body = self.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # Gets a list of user application associations.
    #
    # @param user_id [Integer] The user identifier.
    # @param application_id [Integer] The application identifier.
    # @param acl [Integer] Gets or sets the access control level permissions.
    # @param page [Integer] Gets or sets the page number.
    # @param page_size [Integer] Gets or sets the size of the page.
    # @param sort_order [Enum] Gets or sets the order. Possible values include:
    # 'Unspecified', 'Ascending', 'Descending'
    # @param sort_by [Enum] Gets or sets the column to order by. Possible values
    # include: 'Unspecified', 'DrawerID', 'ApplicationID', 'GroupID', 'UserID',
    # 'QueueID', 'Acl'
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [Array] operation results.
    #
    def get_user_application_associations(user_id, application_id:nil, acl:nil, page:nil, page_size:nil, sort_order:nil, sort_by:nil, custom_headers:nil)
      response = get_user_application_associations_async(user_id, application_id:application_id, acl:acl, page:page, page_size:page_size, sort_order:sort_order, sort_by:sort_by, custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # Gets a list of user application associations.
    #
    # @param user_id [Integer] The user identifier.
    # @param application_id [Integer] The application identifier.
    # @param acl [Integer] Gets or sets the access control level permissions.
    # @param page [Integer] Gets or sets the page number.
    # @param page_size [Integer] Gets or sets the size of the page.
    # @param sort_order [Enum] Gets or sets the order. Possible values include:
    # 'Unspecified', 'Ascending', 'Descending'
    # @param sort_by [Enum] Gets or sets the column to order by. Possible values
    # include: 'Unspecified', 'DrawerID', 'ApplicationID', 'GroupID', 'UserID',
    # 'QueueID', 'Acl'
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def get_user_application_associations_with_http_info(user_id, application_id:nil, acl:nil, page:nil, page_size:nil, sort_order:nil, sort_by:nil, custom_headers:nil)
      get_user_application_associations_async(user_id, application_id:application_id, acl:acl, page:page, page_size:page_size, sort_order:sort_order, sort_by:sort_by, custom_headers:custom_headers).value!
    end

    #
    # Gets a list of user application associations.
    #
    # @param user_id [Integer] The user identifier.
    # @param application_id [Integer] The application identifier.
    # @param acl [Integer] Gets or sets the access control level permissions.
    # @param page [Integer] Gets or sets the page number.
    # @param page_size [Integer] Gets or sets the size of the page.
    # @param sort_order [Enum] Gets or sets the order. Possible values include:
    # 'Unspecified', 'Ascending', 'Descending'
    # @param sort_by [Enum] Gets or sets the column to order by. Possible values
    # include: 'Unspecified', 'DrawerID', 'ApplicationID', 'GroupID', 'UserID',
    # 'QueueID', 'Acl'
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def get_user_application_associations_async(user_id, application_id:nil, acl:nil, page:nil, page_size:nil, sort_order:nil, sort_by:nil, custom_headers:nil)
      fail ArgumentError, 'user_id is nil' if user_id.nil?
      fail ArgumentError, "'page' should satisfy the constraint - 'InclusiveMaximum': '2147483647'" if !page.nil? && page > 2147483647
      fail ArgumentError, "'page' should satisfy the constraint - 'InclusiveMinimum': '1'" if !page.nil? && page < 1
      fail ArgumentError, "'page_size' should satisfy the constraint - 'InclusiveMaximum': '1000'" if !page_size.nil? && page_size > 1000
      fail ArgumentError, "'page_size' should satisfy the constraint - 'InclusiveMinimum': '1'" if !page_size.nil? && page_size < 1


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'
      path_template = 'v1/directory/users/{userID}/applications'

      request_url = @base_url || self.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          path_params: {'userID' => user_id},
          query_params: {'applicationID' => application_id,'acl' => acl,'page' => page,'pageSize' => page_size,'sortOrder' => sort_order,'sortBy' => sort_by},
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:get, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200 || status_code == 403
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = {
              client_side_validation: true,
              required: false,
              serialized_name: 'parsed_response',
              type: {
                name: 'Sequence',
                element: {
                    client_side_validation: true,
                    required: false,
                    serialized_name: 'UserApplicationModelElementType',
                    type: {
                      name: 'Composite',
                      class_name: 'UserApplicationModel'
                    }
                }
              }
            }
            result.body = self.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # Inserts/Updates the application user association.
    #
    # @param user_id [Integer] The user identifier.
    # @param application_id [Integer] The application identifier.
    # @param model [UserApplicationModel] The model.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [Object] operation results.
    #
    def create_or_update_application_user_association(user_id, application_id, model, custom_headers:nil)
      response = create_or_update_application_user_association_async(user_id, application_id, model, custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # Inserts/Updates the application user association.
    #
    # @param user_id [Integer] The user identifier.
    # @param application_id [Integer] The application identifier.
    # @param model [UserApplicationModel] The model.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def create_or_update_application_user_association_with_http_info(user_id, application_id, model, custom_headers:nil)
      create_or_update_application_user_association_async(user_id, application_id, model, custom_headers:custom_headers).value!
    end

    #
    # Inserts/Updates the application user association.
    #
    # @param user_id [Integer] The user identifier.
    # @param application_id [Integer] The application identifier.
    # @param model [UserApplicationModel] The model.
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def create_or_update_application_user_association_async(user_id, application_id, model, custom_headers:nil)
      fail ArgumentError, 'user_id is nil' if user_id.nil?
      fail ArgumentError, 'application_id is nil' if application_id.nil?
      fail ArgumentError, 'model is nil' if model.nil?


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'

      # Serialize Request
      request_mapper = Softheon.Enterprise.Api.Client::Models::UserApplicationModel.mapper()
      request_content = self.serialize(request_mapper,  model)
      request_content = request_content != nil ? JSON.generate(request_content, quirks_mode: true) : nil

      path_template = 'v1/directory/applications/{applicationID}/users/{userID}'

      request_url = @base_url || self.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          path_params: {'userID' => user_id,'applicationID' => application_id},
          body: request_content,
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:put, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 204 || status_code == 403
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end


        result
      end

      promise.execute
    end

    #
    # Deletes an application user association;
    #
    # @param user_id [Integer] The user identifier.
    # @param application_id [Integer] The application identifier.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [Object] operation results.
    #
    def delete_application_user_association(user_id, application_id, custom_headers:nil)
      response = delete_application_user_association_async(user_id, application_id, custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # Deletes an application user association;
    #
    # @param user_id [Integer] The user identifier.
    # @param application_id [Integer] The application identifier.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def delete_application_user_association_with_http_info(user_id, application_id, custom_headers:nil)
      delete_application_user_association_async(user_id, application_id, custom_headers:custom_headers).value!
    end

    #
    # Deletes an application user association;
    #
    # @param user_id [Integer] The user identifier.
    # @param application_id [Integer] The application identifier.
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def delete_application_user_association_async(user_id, application_id, custom_headers:nil)
      fail ArgumentError, 'user_id is nil' if user_id.nil?
      fail ArgumentError, 'application_id is nil' if application_id.nil?


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'
      path_template = 'v1/directory/applications/{applicationID}/users/{userID}'

      request_url = @base_url || self.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          path_params: {'userID' => user_id,'applicationID' => application_id},
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:delete, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 204 || status_code == 403 || status_code == 404
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end


        result
      end

      promise.execute
    end

    #
    # Inserts/Updates the user application association.
    #
    # @param user_id [Integer] The user identifier.
    # @param application_id [Integer] The application identifier.
    # @param model [UserApplicationModel] The model.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [Object] operation results.
    #
    def create_or_update_user_application_association(user_id, application_id, model, custom_headers:nil)
      response = create_or_update_user_application_association_async(user_id, application_id, model, custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # Inserts/Updates the user application association.
    #
    # @param user_id [Integer] The user identifier.
    # @param application_id [Integer] The application identifier.
    # @param model [UserApplicationModel] The model.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def create_or_update_user_application_association_with_http_info(user_id, application_id, model, custom_headers:nil)
      create_or_update_user_application_association_async(user_id, application_id, model, custom_headers:custom_headers).value!
    end

    #
    # Inserts/Updates the user application association.
    #
    # @param user_id [Integer] The user identifier.
    # @param application_id [Integer] The application identifier.
    # @param model [UserApplicationModel] The model.
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def create_or_update_user_application_association_async(user_id, application_id, model, custom_headers:nil)
      fail ArgumentError, 'user_id is nil' if user_id.nil?
      fail ArgumentError, 'application_id is nil' if application_id.nil?
      fail ArgumentError, 'model is nil' if model.nil?


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'

      # Serialize Request
      request_mapper = Softheon.Enterprise.Api.Client::Models::UserApplicationModel.mapper()
      request_content = self.serialize(request_mapper,  model)
      request_content = request_content != nil ? JSON.generate(request_content, quirks_mode: true) : nil

      path_template = 'v1/directory/users/{userID}/applications/{applicationID}'

      request_url = @base_url || self.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          path_params: {'userID' => user_id,'applicationID' => application_id},
          body: request_content,
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:put, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 204 || status_code == 403
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end


        result
      end

      promise.execute
    end

    #
    # Deletes a user application association;
    #
    # @param user_id [Integer] The user identifier.
    # @param application_id [Integer] The application identifier.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [Object] operation results.
    #
    def delete_user_application_association(user_id, application_id, custom_headers:nil)
      response = delete_user_application_association_async(user_id, application_id, custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # Deletes a user application association;
    #
    # @param user_id [Integer] The user identifier.
    # @param application_id [Integer] The application identifier.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def delete_user_application_association_with_http_info(user_id, application_id, custom_headers:nil)
      delete_user_application_association_async(user_id, application_id, custom_headers:custom_headers).value!
    end

    #
    # Deletes a user application association;
    #
    # @param user_id [Integer] The user identifier.
    # @param application_id [Integer] The application identifier.
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def delete_user_application_association_async(user_id, application_id, custom_headers:nil)
      fail ArgumentError, 'user_id is nil' if user_id.nil?
      fail ArgumentError, 'application_id is nil' if application_id.nil?


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'
      path_template = 'v1/directory/users/{userID}/applications/{applicationID}'

      request_url = @base_url || self.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          path_params: {'userID' => user_id,'applicationID' => application_id},
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:delete, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 204 || status_code == 403 || status_code == 404
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end


        result
      end

      promise.execute
    end

    #
    # Gets a paged list of attachment metadata.
    #
    # @param type [Enum] Gets or sets the type. Possible values include:
    # 'Standard', 'EntityLink', 'WebLink'
    # @param extension [String] Gets or sets the extension.
    # @param min_size [Integer] Gets or sets the minimum size.
    # @param max_size [Integer] Gets or sets the maximum size.
    # @param acl [Integer] Gets or sets the access control list.
    # @param entity_id [Integer] Gets or sets the entity identifier.
    # @param drawer_id [Integer] Gets or sets the drawer identifier.
    # @param name [String] Gets or sets the name.
    # @param creator_user_id [Integer] Gets or sets the creator user identifier.
    # @param modifier_user_id [Integer] Gets or sets the modifier user identifier.
    # @param min_insertion_time [DateTime] Gets or sets the minimum insertion time.
    # @param max_insertion_time [DateTime] Gets or sets the maximum insertion time.
    # @param min_modification_time [DateTime] Gets or sets the minimum modification
    # time.
    # @param max_modification_time [DateTime] Gets or sets the maximum modification
    # time.
    # @param page [Integer] Gets or sets the page number.
    # @param page_size [Integer] Gets or sets the size of the page.
    # @param sort_order [Enum] Gets or sets the order. Possible values include:
    # 'Unspecified', 'Ascending', 'Descending'
    # @param sort_by [Enum] Gets or sets the column to order by. Possible values
    # include: 'PageNumber', 'ID', 'Type', 'InsertionTime', 'ModificationTime',
    # 'CrossReferenceID', 'SubType', 'Extension', 'Name'
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [Array] operation results.
    #
    def get_attachments_by_filter(type:nil, extension:nil, min_size:nil, max_size:nil, acl:nil, entity_id:nil, drawer_id:nil, name:nil, creator_user_id:nil, modifier_user_id:nil, min_insertion_time:nil, max_insertion_time:nil, min_modification_time:nil, max_modification_time:nil, page:nil, page_size:nil, sort_order:nil, sort_by:nil, custom_headers:nil)
      response = get_attachments_by_filter_async(type:type, extension:extension, min_size:min_size, max_size:max_size, acl:acl, entity_id:entity_id, drawer_id:drawer_id, name:name, creator_user_id:creator_user_id, modifier_user_id:modifier_user_id, min_insertion_time:min_insertion_time, max_insertion_time:max_insertion_time, min_modification_time:min_modification_time, max_modification_time:max_modification_time, page:page, page_size:page_size, sort_order:sort_order, sort_by:sort_by, custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # Gets a paged list of attachment metadata.
    #
    # @param type [Enum] Gets or sets the type. Possible values include:
    # 'Standard', 'EntityLink', 'WebLink'
    # @param extension [String] Gets or sets the extension.
    # @param min_size [Integer] Gets or sets the minimum size.
    # @param max_size [Integer] Gets or sets the maximum size.
    # @param acl [Integer] Gets or sets the access control list.
    # @param entity_id [Integer] Gets or sets the entity identifier.
    # @param drawer_id [Integer] Gets or sets the drawer identifier.
    # @param name [String] Gets or sets the name.
    # @param creator_user_id [Integer] Gets or sets the creator user identifier.
    # @param modifier_user_id [Integer] Gets or sets the modifier user identifier.
    # @param min_insertion_time [DateTime] Gets or sets the minimum insertion time.
    # @param max_insertion_time [DateTime] Gets or sets the maximum insertion time.
    # @param min_modification_time [DateTime] Gets or sets the minimum modification
    # time.
    # @param max_modification_time [DateTime] Gets or sets the maximum modification
    # time.
    # @param page [Integer] Gets or sets the page number.
    # @param page_size [Integer] Gets or sets the size of the page.
    # @param sort_order [Enum] Gets or sets the order. Possible values include:
    # 'Unspecified', 'Ascending', 'Descending'
    # @param sort_by [Enum] Gets or sets the column to order by. Possible values
    # include: 'PageNumber', 'ID', 'Type', 'InsertionTime', 'ModificationTime',
    # 'CrossReferenceID', 'SubType', 'Extension', 'Name'
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def get_attachments_by_filter_with_http_info(type:nil, extension:nil, min_size:nil, max_size:nil, acl:nil, entity_id:nil, drawer_id:nil, name:nil, creator_user_id:nil, modifier_user_id:nil, min_insertion_time:nil, max_insertion_time:nil, min_modification_time:nil, max_modification_time:nil, page:nil, page_size:nil, sort_order:nil, sort_by:nil, custom_headers:nil)
      get_attachments_by_filter_async(type:type, extension:extension, min_size:min_size, max_size:max_size, acl:acl, entity_id:entity_id, drawer_id:drawer_id, name:name, creator_user_id:creator_user_id, modifier_user_id:modifier_user_id, min_insertion_time:min_insertion_time, max_insertion_time:max_insertion_time, min_modification_time:min_modification_time, max_modification_time:max_modification_time, page:page, page_size:page_size, sort_order:sort_order, sort_by:sort_by, custom_headers:custom_headers).value!
    end

    #
    # Gets a paged list of attachment metadata.
    #
    # @param type [Enum] Gets or sets the type. Possible values include:
    # 'Standard', 'EntityLink', 'WebLink'
    # @param extension [String] Gets or sets the extension.
    # @param min_size [Integer] Gets or sets the minimum size.
    # @param max_size [Integer] Gets or sets the maximum size.
    # @param acl [Integer] Gets or sets the access control list.
    # @param entity_id [Integer] Gets or sets the entity identifier.
    # @param drawer_id [Integer] Gets or sets the drawer identifier.
    # @param name [String] Gets or sets the name.
    # @param creator_user_id [Integer] Gets or sets the creator user identifier.
    # @param modifier_user_id [Integer] Gets or sets the modifier user identifier.
    # @param min_insertion_time [DateTime] Gets or sets the minimum insertion time.
    # @param max_insertion_time [DateTime] Gets or sets the maximum insertion time.
    # @param min_modification_time [DateTime] Gets or sets the minimum modification
    # time.
    # @param max_modification_time [DateTime] Gets or sets the maximum modification
    # time.
    # @param page [Integer] Gets or sets the page number.
    # @param page_size [Integer] Gets or sets the size of the page.
    # @param sort_order [Enum] Gets or sets the order. Possible values include:
    # 'Unspecified', 'Ascending', 'Descending'
    # @param sort_by [Enum] Gets or sets the column to order by. Possible values
    # include: 'PageNumber', 'ID', 'Type', 'InsertionTime', 'ModificationTime',
    # 'CrossReferenceID', 'SubType', 'Extension', 'Name'
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def get_attachments_by_filter_async(type:nil, extension:nil, min_size:nil, max_size:nil, acl:nil, entity_id:nil, drawer_id:nil, name:nil, creator_user_id:nil, modifier_user_id:nil, min_insertion_time:nil, max_insertion_time:nil, min_modification_time:nil, max_modification_time:nil, page:nil, page_size:nil, sort_order:nil, sort_by:nil, custom_headers:nil)
      fail ArgumentError, "'extension' should satisfy the constraint - 'MaxLength': '255'" if !extension.nil? && extension.length > 255
      fail ArgumentError, "'extension' should satisfy the constraint - 'MinLength': '0'" if !extension.nil? && extension.length < 0
      fail ArgumentError, "'min_size' should satisfy the constraint - 'InclusiveMinimum': '0'" if !min_size.nil? && min_size < 0
      fail ArgumentError, "'max_size' should satisfy the constraint - 'InclusiveMinimum': '1'" if !max_size.nil? && max_size < 1
      fail ArgumentError, "'entity_id' should satisfy the constraint - 'InclusiveMaximum': '2147483647'" if !entity_id.nil? && entity_id > 2147483647
      fail ArgumentError, "'entity_id' should satisfy the constraint - 'InclusiveMinimum': '1'" if !entity_id.nil? && entity_id < 1
      fail ArgumentError, "'drawer_id' should satisfy the constraint - 'InclusiveMaximum': '2147483647'" if !drawer_id.nil? && drawer_id > 2147483647
      fail ArgumentError, "'drawer_id' should satisfy the constraint - 'InclusiveMinimum': '1'" if !drawer_id.nil? && drawer_id < 1
      fail ArgumentError, "'name' should satisfy the constraint - 'MaxLength': '255'" if !name.nil? && name.length > 255
      fail ArgumentError, "'name' should satisfy the constraint - 'MinLength': '0'" if !name.nil? && name.length < 0
      fail ArgumentError, "'creator_user_id' should satisfy the constraint - 'InclusiveMaximum': '2147483647'" if !creator_user_id.nil? && creator_user_id > 2147483647
      fail ArgumentError, "'creator_user_id' should satisfy the constraint - 'InclusiveMinimum': '1'" if !creator_user_id.nil? && creator_user_id < 1
      fail ArgumentError, "'modifier_user_id' should satisfy the constraint - 'InclusiveMaximum': '2147483647'" if !modifier_user_id.nil? && modifier_user_id > 2147483647
      fail ArgumentError, "'modifier_user_id' should satisfy the constraint - 'InclusiveMinimum': '1'" if !modifier_user_id.nil? && modifier_user_id < 1
      fail ArgumentError, "'page' should satisfy the constraint - 'InclusiveMaximum': '2147483647'" if !page.nil? && page > 2147483647
      fail ArgumentError, "'page' should satisfy the constraint - 'InclusiveMinimum': '1'" if !page.nil? && page < 1
      fail ArgumentError, "'page_size' should satisfy the constraint - 'InclusiveMaximum': '1000'" if !page_size.nil? && page_size > 1000
      fail ArgumentError, "'page_size' should satisfy the constraint - 'InclusiveMinimum': '1'" if !page_size.nil? && page_size < 1


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'
      path_template = 'v1/content/attachments'

      request_url = @base_url || self.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          query_params: {'type' => type,'extension' => extension,'minSize' => min_size,'maxSize' => max_size,'acl' => acl,'entityID' => entity_id,'drawerID' => drawer_id,'name' => name,'creatorUserID' => creator_user_id,'modifierUserID' => modifier_user_id,'minInsertionTime' => min_insertion_time,'maxInsertionTime' => max_insertion_time,'minModificationTime' => min_modification_time,'maxModificationTime' => max_modification_time,'page' => page,'pageSize' => page_size,'sortOrder' => sort_order,'sortBy' => sort_by},
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:get, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = {
              client_side_validation: true,
              required: false,
              serialized_name: 'parsed_response',
              type: {
                name: 'Sequence',
                element: {
                    client_side_validation: true,
                    required: false,
                    serialized_name: 'AttachmentModelElementType',
                    type: {
                      name: 'Composite',
                      class_name: 'AttachmentModel'
                    }
                }
              }
            }
            result.body = self.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # Gets a single attachment metadata based on its unique identifier.
    #
    # @param drawer [Integer] The drawer identifier.
    # @param id [Integer] The attachment identifier.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [AttachmentModel] operation results.
    #
    def get_attachment_by_id(drawer, id, custom_headers:nil)
      response = get_attachment_by_id_async(drawer, id, custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # Gets a single attachment metadata based on its unique identifier.
    #
    # @param drawer [Integer] The drawer identifier.
    # @param id [Integer] The attachment identifier.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def get_attachment_by_id_with_http_info(drawer, id, custom_headers:nil)
      get_attachment_by_id_async(drawer, id, custom_headers:custom_headers).value!
    end

    #
    # Gets a single attachment metadata based on its unique identifier.
    #
    # @param drawer [Integer] The drawer identifier.
    # @param id [Integer] The attachment identifier.
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def get_attachment_by_id_async(drawer, id, custom_headers:nil)
      fail ArgumentError, 'drawer is nil' if drawer.nil?
      fail ArgumentError, 'id is nil' if id.nil?


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'
      path_template = 'v1/content/attachments/{drawer}/{id}'

      request_url = @base_url || self.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          path_params: {'drawer' => drawer,'id' => id},
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:get, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200 || status_code == 404
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = Softheon.Enterprise.Api.Client::Models::AttachmentModel.mapper()
            result.body = self.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # Updates a specified attachment's metadata..
    #
    # @param drawer [Integer] The drawer identifier.
    # @param id [Integer] The attachment identifier.
    # @param model [UpdateAttachmentRequestModel] The model.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [Object] operation results.
    #
    def update_attachment(drawer, id, model, custom_headers:nil)
      response = update_attachment_async(drawer, id, model, custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # Updates a specified attachment's metadata..
    #
    # @param drawer [Integer] The drawer identifier.
    # @param id [Integer] The attachment identifier.
    # @param model [UpdateAttachmentRequestModel] The model.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def update_attachment_with_http_info(drawer, id, model, custom_headers:nil)
      update_attachment_async(drawer, id, model, custom_headers:custom_headers).value!
    end

    #
    # Updates a specified attachment's metadata..
    #
    # @param drawer [Integer] The drawer identifier.
    # @param id [Integer] The attachment identifier.
    # @param model [UpdateAttachmentRequestModel] The model.
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def update_attachment_async(drawer, id, model, custom_headers:nil)
      fail ArgumentError, 'drawer is nil' if drawer.nil?
      fail ArgumentError, 'id is nil' if id.nil?
      fail ArgumentError, 'model is nil' if model.nil?


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'

      # Serialize Request
      request_mapper = Softheon.Enterprise.Api.Client::Models::UpdateAttachmentRequestModel.mapper()
      request_content = self.serialize(request_mapper,  model)
      request_content = request_content != nil ? JSON.generate(request_content, quirks_mode: true) : nil

      path_template = 'v1/content/attachments/{drawer}/{id}'

      request_url = @base_url || self.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          path_params: {'drawer' => drawer,'id' => id},
          body: request_content,
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:put, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 204 || status_code == 403 || status_code == 404
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end


        result
      end

      promise.execute
    end

    #
    # Deletes an attachment
    #
    # @param drawer [Integer] The drawer identifier.
    # @param id [Integer] The attachment identifier.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [Object] operation results.
    #
    def delete_attachment(drawer, id, custom_headers:nil)
      response = delete_attachment_async(drawer, id, custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # Deletes an attachment
    #
    # @param drawer [Integer] The drawer identifier.
    # @param id [Integer] The attachment identifier.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def delete_attachment_with_http_info(drawer, id, custom_headers:nil)
      delete_attachment_async(drawer, id, custom_headers:custom_headers).value!
    end

    #
    # Deletes an attachment
    #
    # @param drawer [Integer] The drawer identifier.
    # @param id [Integer] The attachment identifier.
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def delete_attachment_async(drawer, id, custom_headers:nil)
      fail ArgumentError, 'drawer is nil' if drawer.nil?
      fail ArgumentError, 'id is nil' if id.nil?


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'
      path_template = 'v1/content/attachments/{drawer}/{id}'

      request_url = @base_url || self.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          path_params: {'drawer' => drawer,'id' => id},
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:delete, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 204 || status_code == 403 || status_code == 404
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end


        result
      end

      promise.execute
    end

    #
    # Gets an attachment's file content.
    #
    # @param drawer [Integer] The drawer identifier.
    # @param id [Integer] The attachment identifier.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [Object] operation results.
    #
    def get_attachment_file_content(drawer, id, custom_headers:nil)
      response = get_attachment_file_content_async(drawer, id, custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # Gets an attachment's file content.
    #
    # @param drawer [Integer] The drawer identifier.
    # @param id [Integer] The attachment identifier.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def get_attachment_file_content_with_http_info(drawer, id, custom_headers:nil)
      get_attachment_file_content_async(drawer, id, custom_headers:custom_headers).value!
    end

    #
    # Gets an attachment's file content.
    #
    # @param drawer [Integer] The drawer identifier.
    # @param id [Integer] The attachment identifier.
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def get_attachment_file_content_async(drawer, id, custom_headers:nil)
      fail ArgumentError, 'drawer is nil' if drawer.nil?
      fail ArgumentError, 'id is nil' if id.nil?


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'
      path_template = 'v1/content/attachments/{drawer}/{id}/file'

      request_url = @base_url || self.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          path_params: {'drawer' => drawer,'id' => id},
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:get, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200 || status_code == 403 || status_code == 404
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end


        result
      end

      promise.execute
    end

    #
    # Inserts a new file attachment.
    #
    # @param drawer [Integer] The drawer identifier.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [AttachmentModel] operation results.
    #
    def create_attachment(drawer, custom_headers:nil)
      response = create_attachment_async(drawer, custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # Inserts a new file attachment.
    #
    # @param drawer [Integer] The drawer identifier.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def create_attachment_with_http_info(drawer, custom_headers:nil)
      create_attachment_async(drawer, custom_headers:custom_headers).value!
    end

    #
    # Inserts a new file attachment.
    #
    # @param drawer [Integer] The drawer identifier.
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def create_attachment_async(drawer, custom_headers:nil)
      fail ArgumentError, 'drawer is nil' if drawer.nil?


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'
      path_template = 'v1/content/attachments/{drawer}'

      request_url = @base_url || self.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          path_params: {'drawer' => drawer},
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:post, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 201 || status_code == 400 || status_code == 403 || status_code == 404
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        # Deserialize Response
        if status_code == 201
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = Softheon.Enterprise.Api.Client::Models::AttachmentModel.mapper()
            result.body = self.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # Archives an attachment
    #
    # @param drawer [Integer] The drawer identifier.
    # @param id [Integer] The attachment identifier.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [Object] operation results.
    #
    def archive_attachment(drawer, id, custom_headers:nil)
      response = archive_attachment_async(drawer, id, custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # Archives an attachment
    #
    # @param drawer [Integer] The drawer identifier.
    # @param id [Integer] The attachment identifier.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def archive_attachment_with_http_info(drawer, id, custom_headers:nil)
      archive_attachment_async(drawer, id, custom_headers:custom_headers).value!
    end

    #
    # Archives an attachment
    #
    # @param drawer [Integer] The drawer identifier.
    # @param id [Integer] The attachment identifier.
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def archive_attachment_async(drawer, id, custom_headers:nil)
      fail ArgumentError, 'drawer is nil' if drawer.nil?
      fail ArgumentError, 'id is nil' if id.nil?


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'
      path_template = 'v1/content/attachments/{drawer}/{id}/archive'

      request_url = @base_url || self.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          path_params: {'drawer' => drawer,'id' => id},
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:put, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 204 || status_code == 400 || status_code == 403 || status_code == 404
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end


        result
      end

      promise.execute
    end

    #
    # Gets the paged list of attachment versions.
    #
    # @param drawer [Integer] The drawer identifier.
    # @param id [Integer] The attachment identifier.
    # @param version [Integer] Gets or sets the indexed version value.
    # @param creator_user_id [Integer] Gets or sets the creator identifier.
    # @param accessor_user_id [Integer] Gets or sets the identifier of the user who
    # accessed the attachment version.
    # @param min_access_time [DateTime] Gets or sets the min time the version was
    # last accessed.
    # @param max_access_time [DateTime] Gets or sets the max time the version was
    # last accessed.
    # @param min_creation_time [DateTime] Gets or sets the min creation time of the
    # attachment version.
    # @param max_creation_time [DateTime] Gets or sets the max creation time of the
    # attachment version.
    # @param min_modification_time [DateTime] Gets or sets the min modification
    # time of the attachment version.
    # @param max_modification_time [DateTime] Gets or sets the max modification
    # time of the attachment version.
    # @param page [Integer] Gets or sets the page number.
    # @param page_size [Integer] Gets or sets the size of the page.
    # @param sort_order [Enum] Gets or sets the order. Possible values include:
    # 'Unspecified', 'Ascending', 'Descending'
    # @param sort_by [Enum] Gets or sets the column to order by. Possible values
    # include: 'Version', 'CreatorUserID', 'AccessorUserID', 'AccessTime',
    # 'CreationTime', 'ModificationTime'
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [Array] operation results.
    #
    def get_attachment_versions_by_filter(drawer, id, version:nil, creator_user_id:nil, accessor_user_id:nil, min_access_time:nil, max_access_time:nil, min_creation_time:nil, max_creation_time:nil, min_modification_time:nil, max_modification_time:nil, page:nil, page_size:nil, sort_order:nil, sort_by:nil, custom_headers:nil)
      response = get_attachment_versions_by_filter_async(drawer, id, version:version, creator_user_id:creator_user_id, accessor_user_id:accessor_user_id, min_access_time:min_access_time, max_access_time:max_access_time, min_creation_time:min_creation_time, max_creation_time:max_creation_time, min_modification_time:min_modification_time, max_modification_time:max_modification_time, page:page, page_size:page_size, sort_order:sort_order, sort_by:sort_by, custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # Gets the paged list of attachment versions.
    #
    # @param drawer [Integer] The drawer identifier.
    # @param id [Integer] The attachment identifier.
    # @param version [Integer] Gets or sets the indexed version value.
    # @param creator_user_id [Integer] Gets or sets the creator identifier.
    # @param accessor_user_id [Integer] Gets or sets the identifier of the user who
    # accessed the attachment version.
    # @param min_access_time [DateTime] Gets or sets the min time the version was
    # last accessed.
    # @param max_access_time [DateTime] Gets or sets the max time the version was
    # last accessed.
    # @param min_creation_time [DateTime] Gets or sets the min creation time of the
    # attachment version.
    # @param max_creation_time [DateTime] Gets or sets the max creation time of the
    # attachment version.
    # @param min_modification_time [DateTime] Gets or sets the min modification
    # time of the attachment version.
    # @param max_modification_time [DateTime] Gets or sets the max modification
    # time of the attachment version.
    # @param page [Integer] Gets or sets the page number.
    # @param page_size [Integer] Gets or sets the size of the page.
    # @param sort_order [Enum] Gets or sets the order. Possible values include:
    # 'Unspecified', 'Ascending', 'Descending'
    # @param sort_by [Enum] Gets or sets the column to order by. Possible values
    # include: 'Version', 'CreatorUserID', 'AccessorUserID', 'AccessTime',
    # 'CreationTime', 'ModificationTime'
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def get_attachment_versions_by_filter_with_http_info(drawer, id, version:nil, creator_user_id:nil, accessor_user_id:nil, min_access_time:nil, max_access_time:nil, min_creation_time:nil, max_creation_time:nil, min_modification_time:nil, max_modification_time:nil, page:nil, page_size:nil, sort_order:nil, sort_by:nil, custom_headers:nil)
      get_attachment_versions_by_filter_async(drawer, id, version:version, creator_user_id:creator_user_id, accessor_user_id:accessor_user_id, min_access_time:min_access_time, max_access_time:max_access_time, min_creation_time:min_creation_time, max_creation_time:max_creation_time, min_modification_time:min_modification_time, max_modification_time:max_modification_time, page:page, page_size:page_size, sort_order:sort_order, sort_by:sort_by, custom_headers:custom_headers).value!
    end

    #
    # Gets the paged list of attachment versions.
    #
    # @param drawer [Integer] The drawer identifier.
    # @param id [Integer] The attachment identifier.
    # @param version [Integer] Gets or sets the indexed version value.
    # @param creator_user_id [Integer] Gets or sets the creator identifier.
    # @param accessor_user_id [Integer] Gets or sets the identifier of the user who
    # accessed the attachment version.
    # @param min_access_time [DateTime] Gets or sets the min time the version was
    # last accessed.
    # @param max_access_time [DateTime] Gets or sets the max time the version was
    # last accessed.
    # @param min_creation_time [DateTime] Gets or sets the min creation time of the
    # attachment version.
    # @param max_creation_time [DateTime] Gets or sets the max creation time of the
    # attachment version.
    # @param min_modification_time [DateTime] Gets or sets the min modification
    # time of the attachment version.
    # @param max_modification_time [DateTime] Gets or sets the max modification
    # time of the attachment version.
    # @param page [Integer] Gets or sets the page number.
    # @param page_size [Integer] Gets or sets the size of the page.
    # @param sort_order [Enum] Gets or sets the order. Possible values include:
    # 'Unspecified', 'Ascending', 'Descending'
    # @param sort_by [Enum] Gets or sets the column to order by. Possible values
    # include: 'Version', 'CreatorUserID', 'AccessorUserID', 'AccessTime',
    # 'CreationTime', 'ModificationTime'
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def get_attachment_versions_by_filter_async(drawer, id, version:nil, creator_user_id:nil, accessor_user_id:nil, min_access_time:nil, max_access_time:nil, min_creation_time:nil, max_creation_time:nil, min_modification_time:nil, max_modification_time:nil, page:nil, page_size:nil, sort_order:nil, sort_by:nil, custom_headers:nil)
      fail ArgumentError, 'drawer is nil' if drawer.nil?
      fail ArgumentError, 'id is nil' if id.nil?
      fail ArgumentError, "'version' should satisfy the constraint - 'InclusiveMaximum': '2147483647'" if !version.nil? && version > 2147483647
      fail ArgumentError, "'version' should satisfy the constraint - 'InclusiveMinimum': '1'" if !version.nil? && version < 1
      fail ArgumentError, "'creator_user_id' should satisfy the constraint - 'InclusiveMaximum': '2147483647'" if !creator_user_id.nil? && creator_user_id > 2147483647
      fail ArgumentError, "'creator_user_id' should satisfy the constraint - 'InclusiveMinimum': '1'" if !creator_user_id.nil? && creator_user_id < 1
      fail ArgumentError, "'accessor_user_id' should satisfy the constraint - 'InclusiveMaximum': '2147483647'" if !accessor_user_id.nil? && accessor_user_id > 2147483647
      fail ArgumentError, "'accessor_user_id' should satisfy the constraint - 'InclusiveMinimum': '1'" if !accessor_user_id.nil? && accessor_user_id < 1
      fail ArgumentError, "'page' should satisfy the constraint - 'InclusiveMaximum': '2147483647'" if !page.nil? && page > 2147483647
      fail ArgumentError, "'page' should satisfy the constraint - 'InclusiveMinimum': '1'" if !page.nil? && page < 1
      fail ArgumentError, "'page_size' should satisfy the constraint - 'InclusiveMaximum': '1000'" if !page_size.nil? && page_size > 1000
      fail ArgumentError, "'page_size' should satisfy the constraint - 'InclusiveMinimum': '1'" if !page_size.nil? && page_size < 1


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'
      path_template = 'v1/content/attachments/{drawer}/{id}/versions'

      request_url = @base_url || self.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          path_params: {'drawer' => drawer,'id' => id},
          query_params: {'version' => version,'creatorUserID' => creator_user_id,'accessorUserID' => accessor_user_id,'minAccessTime' => min_access_time,'maxAccessTime' => max_access_time,'minCreationTime' => min_creation_time,'maxCreationTime' => max_creation_time,'minModificationTime' => min_modification_time,'maxModificationTime' => max_modification_time,'page' => page,'pageSize' => page_size,'sortOrder' => sort_order,'sortBy' => sort_by},
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:get, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200 || status_code == 404
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = {
              client_side_validation: true,
              required: false,
              serialized_name: 'parsed_response',
              type: {
                name: 'Sequence',
                element: {
                    client_side_validation: true,
                    required: false,
                    serialized_name: 'AttachmentVersionModelElementType',
                    type: {
                      name: 'Composite',
                      class_name: 'AttachmentVersionModel'
                    }
                }
              }
            }
            result.body = self.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # Gets a file for a specified attachment version.
    #
    # @param drawer [Integer] The drawer identifier.
    # @param id [Integer] The attachment identifier.
    # @param version_id [Integer] The version identifier.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [Object] operation results.
    #
    def get_attachment_version_file_content(drawer, id, version_id, custom_headers:nil)
      response = get_attachment_version_file_content_async(drawer, id, version_id, custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # Gets a file for a specified attachment version.
    #
    # @param drawer [Integer] The drawer identifier.
    # @param id [Integer] The attachment identifier.
    # @param version_id [Integer] The version identifier.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def get_attachment_version_file_content_with_http_info(drawer, id, version_id, custom_headers:nil)
      get_attachment_version_file_content_async(drawer, id, version_id, custom_headers:custom_headers).value!
    end

    #
    # Gets a file for a specified attachment version.
    #
    # @param drawer [Integer] The drawer identifier.
    # @param id [Integer] The attachment identifier.
    # @param version_id [Integer] The version identifier.
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def get_attachment_version_file_content_async(drawer, id, version_id, custom_headers:nil)
      fail ArgumentError, 'drawer is nil' if drawer.nil?
      fail ArgumentError, 'id is nil' if id.nil?
      fail ArgumentError, 'version_id is nil' if version_id.nil?


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'
      path_template = 'v1/content/attachments/{drawer}/{id}/versions/{versionID}'

      request_url = @base_url || self.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          path_params: {'drawer' => drawer,'id' => id,'versionID' => version_id},
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:get, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200 || status_code == 403 || status_code == 404
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end


        result
      end

      promise.execute
    end

    #
    # Checks out the attachment file.
    #
    # @param drawer [Integer] The drawer identifier.
    # @param id [Integer] The attachment identifier.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [Object] operation results.
    #
    def check_out_attachment(drawer, id, custom_headers:nil)
      response = check_out_attachment_async(drawer, id, custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # Checks out the attachment file.
    #
    # @param drawer [Integer] The drawer identifier.
    # @param id [Integer] The attachment identifier.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def check_out_attachment_with_http_info(drawer, id, custom_headers:nil)
      check_out_attachment_async(drawer, id, custom_headers:custom_headers).value!
    end

    #
    # Checks out the attachment file.
    #
    # @param drawer [Integer] The drawer identifier.
    # @param id [Integer] The attachment identifier.
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def check_out_attachment_async(drawer, id, custom_headers:nil)
      fail ArgumentError, 'drawer is nil' if drawer.nil?
      fail ArgumentError, 'id is nil' if id.nil?


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'
      path_template = 'v1/content/attachments/{drawer}/{id}/checkout'

      request_url = @base_url || self.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          path_params: {'drawer' => drawer,'id' => id},
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:put, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 204 || status_code == 400 || status_code == 403 || status_code == 404
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end


        result
      end

      promise.execute
    end

    #
    # Undoes the attachment check out of the attachment file.
    #
    # @param drawer [Integer] The drawer identifier.
    # @param id [Integer] The attachment identifier.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [Object] operation results.
    #
    def undo_check_out_attachment(drawer, id, custom_headers:nil)
      response = undo_check_out_attachment_async(drawer, id, custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # Undoes the attachment check out of the attachment file.
    #
    # @param drawer [Integer] The drawer identifier.
    # @param id [Integer] The attachment identifier.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def undo_check_out_attachment_with_http_info(drawer, id, custom_headers:nil)
      undo_check_out_attachment_async(drawer, id, custom_headers:custom_headers).value!
    end

    #
    # Undoes the attachment check out of the attachment file.
    #
    # @param drawer [Integer] The drawer identifier.
    # @param id [Integer] The attachment identifier.
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def undo_check_out_attachment_async(drawer, id, custom_headers:nil)
      fail ArgumentError, 'drawer is nil' if drawer.nil?
      fail ArgumentError, 'id is nil' if id.nil?


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'
      path_template = 'v1/content/attachments/{drawer}/{id}/checkout'

      request_url = @base_url || self.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          path_params: {'drawer' => drawer,'id' => id},
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:delete, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 204 || status_code == 400 || status_code == 403 || status_code == 404
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end


        result
      end

      promise.execute
    end

    #
    # Checks in the new version of attachment file.
    #
    # @param drawer [Integer] The drawer identifier.
    # @param id [Integer] The attachment identifier.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [Object] operation results.
    #
    def check_in_attachment(drawer, id, custom_headers:nil)
      response = check_in_attachment_async(drawer, id, custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # Checks in the new version of attachment file.
    #
    # @param drawer [Integer] The drawer identifier.
    # @param id [Integer] The attachment identifier.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def check_in_attachment_with_http_info(drawer, id, custom_headers:nil)
      check_in_attachment_async(drawer, id, custom_headers:custom_headers).value!
    end

    #
    # Checks in the new version of attachment file.
    #
    # @param drawer [Integer] The drawer identifier.
    # @param id [Integer] The attachment identifier.
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def check_in_attachment_async(drawer, id, custom_headers:nil)
      fail ArgumentError, 'drawer is nil' if drawer.nil?
      fail ArgumentError, 'id is nil' if id.nil?


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'
      path_template = 'v1/content/attachments/{drawer}/{id}/checkin'

      request_url = @base_url || self.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          path_params: {'drawer' => drawer,'id' => id},
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:put, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 204 || status_code == 400 || status_code == 403 || status_code == 404
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end


        result
      end

      promise.execute
    end

    #
    # Rolls back to a specified version the attachment file.
    #
    # @param drawer [Integer] The drawer identifier.
    # @param id [Integer] The attachment identifier.
    # @param version_id [Integer] The version identifier.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [Object] operation results.
    #
    def rollback_attachment_version(drawer, id, version_id, custom_headers:nil)
      response = rollback_attachment_version_async(drawer, id, version_id, custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # Rolls back to a specified version the attachment file.
    #
    # @param drawer [Integer] The drawer identifier.
    # @param id [Integer] The attachment identifier.
    # @param version_id [Integer] The version identifier.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def rollback_attachment_version_with_http_info(drawer, id, version_id, custom_headers:nil)
      rollback_attachment_version_async(drawer, id, version_id, custom_headers:custom_headers).value!
    end

    #
    # Rolls back to a specified version the attachment file.
    #
    # @param drawer [Integer] The drawer identifier.
    # @param id [Integer] The attachment identifier.
    # @param version_id [Integer] The version identifier.
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def rollback_attachment_version_async(drawer, id, version_id, custom_headers:nil)
      fail ArgumentError, 'drawer is nil' if drawer.nil?
      fail ArgumentError, 'id is nil' if id.nil?
      fail ArgumentError, 'version_id is nil' if version_id.nil?


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'
      path_template = 'v1/content/attachments/{drawer}/{id}/rollback/{versionID}'

      request_url = @base_url || self.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          path_params: {'drawer' => drawer,'id' => id,'versionID' => version_id},
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:put, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 204 || status_code == 400 || status_code == 403 || status_code == 404
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end


        result
      end

      promise.execute
    end

    #
    # Gets a list of all available drawers.
    #
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [Array] operation results.
    #
    def get_all_drawers(custom_headers:nil)
      response = get_all_drawers_async(custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # Gets a list of all available drawers.
    #
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def get_all_drawers_with_http_info(custom_headers:nil)
      get_all_drawers_async(custom_headers:custom_headers).value!
    end

    #
    # Gets a list of all available drawers.
    #
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def get_all_drawers_async(custom_headers:nil)


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'
      path_template = 'v1/directory/drawers'

      request_url = @base_url || self.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:get, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = {
              client_side_validation: true,
              required: false,
              serialized_name: 'parsed_response',
              type: {
                name: 'Sequence',
                element: {
                    client_side_validation: true,
                    required: false,
                    serialized_name: 'DrawerModelElementType',
                    type: {
                      name: 'Composite',
                      class_name: 'DrawerModel'
                    }
                }
              }
            }
            result.body = self.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # Gets a single drawer by its unique identifier.
    #
    # @param id [Integer] The drawer identifier.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [DrawerModel] operation results.
    #
    def get_drawer_by_id(id, custom_headers:nil)
      response = get_drawer_by_id_async(id, custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # Gets a single drawer by its unique identifier.
    #
    # @param id [Integer] The drawer identifier.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def get_drawer_by_id_with_http_info(id, custom_headers:nil)
      get_drawer_by_id_async(id, custom_headers:custom_headers).value!
    end

    #
    # Gets a single drawer by its unique identifier.
    #
    # @param id [Integer] The drawer identifier.
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def get_drawer_by_id_async(id, custom_headers:nil)
      fail ArgumentError, 'id is nil' if id.nil?


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'
      path_template = 'v1/directory/drawers/{id}'

      request_url = @base_url || self.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          path_params: {'id' => id},
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:get, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200 || status_code == 404
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = Softheon.Enterprise.Api.Client::Models::DrawerModel.mapper()
            result.body = self.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # Updates a specified drawer.
    #
    # @param id [Integer] The drawer identifier.
    # @param model [DrawerBase] The model.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [Object] operation results.
    #
    def update_drawer(id, model, custom_headers:nil)
      response = update_drawer_async(id, model, custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # Updates a specified drawer.
    #
    # @param id [Integer] The drawer identifier.
    # @param model [DrawerBase] The model.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def update_drawer_with_http_info(id, model, custom_headers:nil)
      update_drawer_async(id, model, custom_headers:custom_headers).value!
    end

    #
    # Updates a specified drawer.
    #
    # @param id [Integer] The drawer identifier.
    # @param model [DrawerBase] The model.
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def update_drawer_async(id, model, custom_headers:nil)
      fail ArgumentError, 'id is nil' if id.nil?
      fail ArgumentError, 'model is nil' if model.nil?


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'

      # Serialize Request
      request_mapper = Softheon.Enterprise.Api.Client::Models::DrawerBase.mapper()
      request_content = self.serialize(request_mapper,  model)
      request_content = request_content != nil ? JSON.generate(request_content, quirks_mode: true) : nil

      path_template = 'v1/directory/drawers/{id}'

      request_url = @base_url || self.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          path_params: {'id' => id},
          body: request_content,
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:put, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 204 || status_code == 403 || status_code == 404
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end


        result
      end

      promise.execute
    end

    #
    # Gets a single drawer by its name.
    #
    # @param name [String] The drawer name.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [DrawerModel] operation results.
    #
    def get_drawer_by_name(name, custom_headers:nil)
      response = get_drawer_by_name_async(name, custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # Gets a single drawer by its name.
    #
    # @param name [String] The drawer name.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def get_drawer_by_name_with_http_info(name, custom_headers:nil)
      get_drawer_by_name_async(name, custom_headers:custom_headers).value!
    end

    #
    # Gets a single drawer by its name.
    #
    # @param name [String] The drawer name.
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def get_drawer_by_name_async(name, custom_headers:nil)
      fail ArgumentError, 'name is nil' if name.nil?


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'
      path_template = 'v1/directory/drawers/{name}'

      request_url = @base_url || self.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          path_params: {'name' => name},
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:get, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200 || status_code == 404
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = Softheon.Enterprise.Api.Client::Models::DrawerModel.mapper()
            result.body = self.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # Gets a paged list of entity summaries.
    #
    # @param drawer_id [Integer] Gets or sets the drawer identifier.
    # @param acl [Integer] Gets or sets the access control list.
    # @param type [Integer] Gets or sets the type of the entity.
    # @param name [String] Gets or sets the name.
    # @param state [Enum] Gets or sets the state. Possible values include:
    # 'Undefined', 'Available', 'Locked', 'Suspended', 'Archived', 'Deleted',
    # 'Canceled', 'Complete', 'Reviewed', 'ReviewedSuspended', 'ReviewedComplete',
    # 'Rejected', 'RoutingSlipOpen', 'ReviewedRoutingSlipOpen'
    # @param reference_count [Integer] Gets or sets the reference count.
    # @param attach_count [Integer] Gets or sets the attach count.
    # @param note_count [Integer] Gets or sets the note count.
    # @param owner_user_id [Integer] Gets or sets the owner user identifier.
    # @param owner_group_id [Integer] Gets or sets the owner group identifier.
    # @param creator_user_id [Integer] Gets or sets the creator user identifier.
    # @param creator_group_id [Integer] Gets or sets the creator group identifier.
    # @param modifier_user_id [Integer] Gets or sets the modifier user identifier.
    # @param modifier_group_id [Integer] Gets or sets the modifier group
    # identifier.
    # @param min_creation_time [DateTime] Gets or sets the minimum creation time.
    # @param max_creation_time [DateTime] Gets or sets the maximum creation time.
    # @param min_modification_time [DateTime] Gets or sets the minimum modification
    # time.
    # @param max_modification_time [DateTime] Gets or sets the maximum modification
    # time.
    # @param page [Integer] Gets or sets the page number.
    # @param page_size [Integer] Gets or sets the size of the page.
    # @param sort_order [Enum] Gets or sets the order. Possible values include:
    # 'Unspecified', 'Ascending', 'Descending'
    # @param sort_by [Enum] Gets or sets the column to order by. Possible values
    # include: 'ID', 'Type', 'CreationTime', 'ModificationTime', 'State', 'Name'
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [Array] operation results.
    #
    def get_entities_by_filter(drawer_id, acl:nil, type:nil, name:nil, state:nil, reference_count:nil, attach_count:nil, note_count:nil, owner_user_id:nil, owner_group_id:nil, creator_user_id:nil, creator_group_id:nil, modifier_user_id:nil, modifier_group_id:nil, min_creation_time:nil, max_creation_time:nil, min_modification_time:nil, max_modification_time:nil, page:nil, page_size:nil, sort_order:nil, sort_by:nil, custom_headers:nil)
      response = get_entities_by_filter_async(drawer_id, acl:acl, type:type, name:name, state:state, reference_count:reference_count, attach_count:attach_count, note_count:note_count, owner_user_id:owner_user_id, owner_group_id:owner_group_id, creator_user_id:creator_user_id, creator_group_id:creator_group_id, modifier_user_id:modifier_user_id, modifier_group_id:modifier_group_id, min_creation_time:min_creation_time, max_creation_time:max_creation_time, min_modification_time:min_modification_time, max_modification_time:max_modification_time, page:page, page_size:page_size, sort_order:sort_order, sort_by:sort_by, custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # Gets a paged list of entity summaries.
    #
    # @param drawer_id [Integer] Gets or sets the drawer identifier.
    # @param acl [Integer] Gets or sets the access control list.
    # @param type [Integer] Gets or sets the type of the entity.
    # @param name [String] Gets or sets the name.
    # @param state [Enum] Gets or sets the state. Possible values include:
    # 'Undefined', 'Available', 'Locked', 'Suspended', 'Archived', 'Deleted',
    # 'Canceled', 'Complete', 'Reviewed', 'ReviewedSuspended', 'ReviewedComplete',
    # 'Rejected', 'RoutingSlipOpen', 'ReviewedRoutingSlipOpen'
    # @param reference_count [Integer] Gets or sets the reference count.
    # @param attach_count [Integer] Gets or sets the attach count.
    # @param note_count [Integer] Gets or sets the note count.
    # @param owner_user_id [Integer] Gets or sets the owner user identifier.
    # @param owner_group_id [Integer] Gets or sets the owner group identifier.
    # @param creator_user_id [Integer] Gets or sets the creator user identifier.
    # @param creator_group_id [Integer] Gets or sets the creator group identifier.
    # @param modifier_user_id [Integer] Gets or sets the modifier user identifier.
    # @param modifier_group_id [Integer] Gets or sets the modifier group
    # identifier.
    # @param min_creation_time [DateTime] Gets or sets the minimum creation time.
    # @param max_creation_time [DateTime] Gets or sets the maximum creation time.
    # @param min_modification_time [DateTime] Gets or sets the minimum modification
    # time.
    # @param max_modification_time [DateTime] Gets or sets the maximum modification
    # time.
    # @param page [Integer] Gets or sets the page number.
    # @param page_size [Integer] Gets or sets the size of the page.
    # @param sort_order [Enum] Gets or sets the order. Possible values include:
    # 'Unspecified', 'Ascending', 'Descending'
    # @param sort_by [Enum] Gets or sets the column to order by. Possible values
    # include: 'ID', 'Type', 'CreationTime', 'ModificationTime', 'State', 'Name'
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def get_entities_by_filter_with_http_info(drawer_id, acl:nil, type:nil, name:nil, state:nil, reference_count:nil, attach_count:nil, note_count:nil, owner_user_id:nil, owner_group_id:nil, creator_user_id:nil, creator_group_id:nil, modifier_user_id:nil, modifier_group_id:nil, min_creation_time:nil, max_creation_time:nil, min_modification_time:nil, max_modification_time:nil, page:nil, page_size:nil, sort_order:nil, sort_by:nil, custom_headers:nil)
      get_entities_by_filter_async(drawer_id, acl:acl, type:type, name:name, state:state, reference_count:reference_count, attach_count:attach_count, note_count:note_count, owner_user_id:owner_user_id, owner_group_id:owner_group_id, creator_user_id:creator_user_id, creator_group_id:creator_group_id, modifier_user_id:modifier_user_id, modifier_group_id:modifier_group_id, min_creation_time:min_creation_time, max_creation_time:max_creation_time, min_modification_time:min_modification_time, max_modification_time:max_modification_time, page:page, page_size:page_size, sort_order:sort_order, sort_by:sort_by, custom_headers:custom_headers).value!
    end

    #
    # Gets a paged list of entity summaries.
    #
    # @param drawer_id [Integer] Gets or sets the drawer identifier.
    # @param acl [Integer] Gets or sets the access control list.
    # @param type [Integer] Gets or sets the type of the entity.
    # @param name [String] Gets or sets the name.
    # @param state [Enum] Gets or sets the state. Possible values include:
    # 'Undefined', 'Available', 'Locked', 'Suspended', 'Archived', 'Deleted',
    # 'Canceled', 'Complete', 'Reviewed', 'ReviewedSuspended', 'ReviewedComplete',
    # 'Rejected', 'RoutingSlipOpen', 'ReviewedRoutingSlipOpen'
    # @param reference_count [Integer] Gets or sets the reference count.
    # @param attach_count [Integer] Gets or sets the attach count.
    # @param note_count [Integer] Gets or sets the note count.
    # @param owner_user_id [Integer] Gets or sets the owner user identifier.
    # @param owner_group_id [Integer] Gets or sets the owner group identifier.
    # @param creator_user_id [Integer] Gets or sets the creator user identifier.
    # @param creator_group_id [Integer] Gets or sets the creator group identifier.
    # @param modifier_user_id [Integer] Gets or sets the modifier user identifier.
    # @param modifier_group_id [Integer] Gets or sets the modifier group
    # identifier.
    # @param min_creation_time [DateTime] Gets or sets the minimum creation time.
    # @param max_creation_time [DateTime] Gets or sets the maximum creation time.
    # @param min_modification_time [DateTime] Gets or sets the minimum modification
    # time.
    # @param max_modification_time [DateTime] Gets or sets the maximum modification
    # time.
    # @param page [Integer] Gets or sets the page number.
    # @param page_size [Integer] Gets or sets the size of the page.
    # @param sort_order [Enum] Gets or sets the order. Possible values include:
    # 'Unspecified', 'Ascending', 'Descending'
    # @param sort_by [Enum] Gets or sets the column to order by. Possible values
    # include: 'ID', 'Type', 'CreationTime', 'ModificationTime', 'State', 'Name'
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def get_entities_by_filter_async(drawer_id, acl:nil, type:nil, name:nil, state:nil, reference_count:nil, attach_count:nil, note_count:nil, owner_user_id:nil, owner_group_id:nil, creator_user_id:nil, creator_group_id:nil, modifier_user_id:nil, modifier_group_id:nil, min_creation_time:nil, max_creation_time:nil, min_modification_time:nil, max_modification_time:nil, page:nil, page_size:nil, sort_order:nil, sort_by:nil, custom_headers:nil)
      fail ArgumentError, 'drawer_id is nil' if drawer_id.nil?
      fail ArgumentError, "'drawer_id' should satisfy the constraint - 'InclusiveMaximum': '2147483647'" if !drawer_id.nil? && drawer_id > 2147483647
      fail ArgumentError, "'drawer_id' should satisfy the constraint - 'InclusiveMinimum': '1'" if !drawer_id.nil? && drawer_id < 1
      fail ArgumentError, "'type' should satisfy the constraint - 'InclusiveMaximum': '2147483647'" if !type.nil? && type > 2147483647
      fail ArgumentError, "'type' should satisfy the constraint - 'InclusiveMinimum': '1'" if !type.nil? && type < 1
      fail ArgumentError, "'name' should satisfy the constraint - 'MaxLength': '255'" if !name.nil? && name.length > 255
      fail ArgumentError, "'name' should satisfy the constraint - 'MinLength': '0'" if !name.nil? && name.length < 0
      fail ArgumentError, "'reference_count' should satisfy the constraint - 'InclusiveMaximum': '2147483647'" if !reference_count.nil? && reference_count > 2147483647
      fail ArgumentError, "'reference_count' should satisfy the constraint - 'InclusiveMinimum': '0'" if !reference_count.nil? && reference_count < 0
      fail ArgumentError, "'attach_count' should satisfy the constraint - 'InclusiveMaximum': '2147483647'" if !attach_count.nil? && attach_count > 2147483647
      fail ArgumentError, "'attach_count' should satisfy the constraint - 'InclusiveMinimum': '0'" if !attach_count.nil? && attach_count < 0
      fail ArgumentError, "'note_count' should satisfy the constraint - 'InclusiveMaximum': '2147483647'" if !note_count.nil? && note_count > 2147483647
      fail ArgumentError, "'note_count' should satisfy the constraint - 'InclusiveMinimum': '0'" if !note_count.nil? && note_count < 0
      fail ArgumentError, "'owner_user_id' should satisfy the constraint - 'InclusiveMaximum': '2147483647'" if !owner_user_id.nil? && owner_user_id > 2147483647
      fail ArgumentError, "'owner_user_id' should satisfy the constraint - 'InclusiveMinimum': '1'" if !owner_user_id.nil? && owner_user_id < 1
      fail ArgumentError, "'owner_group_id' should satisfy the constraint - 'InclusiveMaximum': '2147483647'" if !owner_group_id.nil? && owner_group_id > 2147483647
      fail ArgumentError, "'owner_group_id' should satisfy the constraint - 'InclusiveMinimum': '0'" if !owner_group_id.nil? && owner_group_id < 0
      fail ArgumentError, "'creator_user_id' should satisfy the constraint - 'InclusiveMaximum': '2147483647'" if !creator_user_id.nil? && creator_user_id > 2147483647
      fail ArgumentError, "'creator_user_id' should satisfy the constraint - 'InclusiveMinimum': '1'" if !creator_user_id.nil? && creator_user_id < 1
      fail ArgumentError, "'creator_group_id' should satisfy the constraint - 'InclusiveMaximum': '2147483647'" if !creator_group_id.nil? && creator_group_id > 2147483647
      fail ArgumentError, "'creator_group_id' should satisfy the constraint - 'InclusiveMinimum': '0'" if !creator_group_id.nil? && creator_group_id < 0
      fail ArgumentError, "'modifier_user_id' should satisfy the constraint - 'InclusiveMaximum': '2147483647'" if !modifier_user_id.nil? && modifier_user_id > 2147483647
      fail ArgumentError, "'modifier_user_id' should satisfy the constraint - 'InclusiveMinimum': '1'" if !modifier_user_id.nil? && modifier_user_id < 1
      fail ArgumentError, "'modifier_group_id' should satisfy the constraint - 'InclusiveMaximum': '2147483647'" if !modifier_group_id.nil? && modifier_group_id > 2147483647
      fail ArgumentError, "'modifier_group_id' should satisfy the constraint - 'InclusiveMinimum': '0'" if !modifier_group_id.nil? && modifier_group_id < 0
      fail ArgumentError, "'page' should satisfy the constraint - 'InclusiveMaximum': '2147483647'" if !page.nil? && page > 2147483647
      fail ArgumentError, "'page' should satisfy the constraint - 'InclusiveMinimum': '1'" if !page.nil? && page < 1
      fail ArgumentError, "'page_size' should satisfy the constraint - 'InclusiveMaximum': '1000'" if !page_size.nil? && page_size > 1000
      fail ArgumentError, "'page_size' should satisfy the constraint - 'InclusiveMinimum': '1'" if !page_size.nil? && page_size < 1


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'
      path_template = 'v1/content/entities'

      request_url = @base_url || self.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          query_params: {'drawerID' => drawer_id,'acl' => acl,'type' => type,'name' => name,'state' => state,'referenceCount' => reference_count,'attachCount' => attach_count,'noteCount' => note_count,'ownerUserID' => owner_user_id,'ownerGroupID' => owner_group_id,'creatorUserID' => creator_user_id,'creatorGroupID' => creator_group_id,'modifierUserID' => modifier_user_id,'modifierGroupID' => modifier_group_id,'minCreationTime' => min_creation_time,'maxCreationTime' => max_creation_time,'minModificationTime' => min_modification_time,'maxModificationTime' => max_modification_time,'page' => page,'pageSize' => page_size,'sortOrder' => sort_order,'sortBy' => sort_by},
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:get, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = {
              client_side_validation: true,
              required: false,
              serialized_name: 'parsed_response',
              type: {
                name: 'Sequence',
                element: {
                    client_side_validation: true,
                    required: false,
                    serialized_name: 'GetEntityBaseResponseElementType',
                    type: {
                      name: 'Composite',
                      class_name: 'GetEntityBaseResponse'
                    }
                }
              }
            }
            result.body = self.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # Gets a single entity complete with all profile metadata.
    #
    # @param drawer [Integer] The drawer identifier.
    # @param id [Integer] The entity identifier.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [EntityModel] operation results.
    #
    def get_entity_by_id(drawer, id, custom_headers:nil)
      response = get_entity_by_id_async(drawer, id, custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # Gets a single entity complete with all profile metadata.
    #
    # @param drawer [Integer] The drawer identifier.
    # @param id [Integer] The entity identifier.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def get_entity_by_id_with_http_info(drawer, id, custom_headers:nil)
      get_entity_by_id_async(drawer, id, custom_headers:custom_headers).value!
    end

    #
    # Gets a single entity complete with all profile metadata.
    #
    # @param drawer [Integer] The drawer identifier.
    # @param id [Integer] The entity identifier.
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def get_entity_by_id_async(drawer, id, custom_headers:nil)
      fail ArgumentError, 'drawer is nil' if drawer.nil?
      fail ArgumentError, 'id is nil' if id.nil?


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'
      path_template = 'v1/content/entities/{drawer}/{id}'

      request_url = @base_url || self.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          path_params: {'drawer' => drawer,'id' => id},
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:get, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200 || status_code == 403 || status_code == 404
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = Softheon.Enterprise.Api.Client::Models::EntityModel.mapper()
            result.body = self.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # Updates a specified entity.
    #
    # @param drawer [Integer] The drawer identifier.
    # @param id [Integer] The entity identifier.
    # @param model [UpdateEntityRequestModel] The entity model.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [Object] operation results.
    #
    def update_entity(drawer, id, model, custom_headers:nil)
      response = update_entity_async(drawer, id, model, custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # Updates a specified entity.
    #
    # @param drawer [Integer] The drawer identifier.
    # @param id [Integer] The entity identifier.
    # @param model [UpdateEntityRequestModel] The entity model.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def update_entity_with_http_info(drawer, id, model, custom_headers:nil)
      update_entity_async(drawer, id, model, custom_headers:custom_headers).value!
    end

    #
    # Updates a specified entity.
    #
    # @param drawer [Integer] The drawer identifier.
    # @param id [Integer] The entity identifier.
    # @param model [UpdateEntityRequestModel] The entity model.
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def update_entity_async(drawer, id, model, custom_headers:nil)
      fail ArgumentError, 'drawer is nil' if drawer.nil?
      fail ArgumentError, 'id is nil' if id.nil?
      fail ArgumentError, 'model is nil' if model.nil?


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'

      # Serialize Request
      request_mapper = Softheon.Enterprise.Api.Client::Models::UpdateEntityRequestModel.mapper()
      request_content = self.serialize(request_mapper,  model)
      request_content = request_content != nil ? JSON.generate(request_content, quirks_mode: true) : nil

      path_template = 'v1/content/entities/{drawer}/{id}'

      request_url = @base_url || self.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          path_params: {'drawer' => drawer,'id' => id},
          body: request_content,
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:put, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 204 || status_code == 403 || status_code == 404
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end


        result
      end

      promise.execute
    end

    #
    # Deletes a specified entity.
    #
    # @param drawer [Integer] The drawer identifier.
    # @param id [Integer] The entity identifier.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [Object] operation results.
    #
    def delete_entity(drawer, id, custom_headers:nil)
      response = delete_entity_async(drawer, id, custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # Deletes a specified entity.
    #
    # @param drawer [Integer] The drawer identifier.
    # @param id [Integer] The entity identifier.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def delete_entity_with_http_info(drawer, id, custom_headers:nil)
      delete_entity_async(drawer, id, custom_headers:custom_headers).value!
    end

    #
    # Deletes a specified entity.
    #
    # @param drawer [Integer] The drawer identifier.
    # @param id [Integer] The entity identifier.
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def delete_entity_async(drawer, id, custom_headers:nil)
      fail ArgumentError, 'drawer is nil' if drawer.nil?
      fail ArgumentError, 'id is nil' if id.nil?


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'
      path_template = 'v1/content/entities/{drawer}/{id}'

      request_url = @base_url || self.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          path_params: {'drawer' => drawer,'id' => id},
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:delete, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 204 || status_code == 403 || status_code == 404
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end


        result
      end

      promise.execute
    end

    #
    # Creates a new entity.
    #
    # @param drawer [Integer] The drawer identifier.
    # @param model [InsertEntityRequestModel] The entity model.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [EntityModel] operation results.
    #
    def create_entity(drawer, model, custom_headers:nil)
      response = create_entity_async(drawer, model, custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # Creates a new entity.
    #
    # @param drawer [Integer] The drawer identifier.
    # @param model [InsertEntityRequestModel] The entity model.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def create_entity_with_http_info(drawer, model, custom_headers:nil)
      create_entity_async(drawer, model, custom_headers:custom_headers).value!
    end

    #
    # Creates a new entity.
    #
    # @param drawer [Integer] The drawer identifier.
    # @param model [InsertEntityRequestModel] The entity model.
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def create_entity_async(drawer, model, custom_headers:nil)
      fail ArgumentError, 'drawer is nil' if drawer.nil?
      fail ArgumentError, 'model is nil' if model.nil?


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'

      # Serialize Request
      request_mapper = Softheon.Enterprise.Api.Client::Models::InsertEntityRequestModel.mapper()
      request_content = self.serialize(request_mapper,  model)
      request_content = request_content != nil ? JSON.generate(request_content, quirks_mode: true) : nil

      path_template = 'v1/content/entities/{drawer}'

      request_url = @base_url || self.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          path_params: {'drawer' => drawer},
          body: request_content,
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:post, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 201 || status_code == 404
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        # Deserialize Response
        if status_code == 201
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = Softheon.Enterprise.Api.Client::Models::EntityModel.mapper()
            result.body = self.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # Copies the contents of an entity.
    #
    # @param drawer [Integer] The drawer.
    # @param id [Integer] The entity identifier.
    # @param model [EntityContentModel] The model.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [EntityModel] operation results.
    #
    def copy_entity(drawer, id, model, custom_headers:nil)
      response = copy_entity_async(drawer, id, model, custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # Copies the contents of an entity.
    #
    # @param drawer [Integer] The drawer.
    # @param id [Integer] The entity identifier.
    # @param model [EntityContentModel] The model.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def copy_entity_with_http_info(drawer, id, model, custom_headers:nil)
      copy_entity_async(drawer, id, model, custom_headers:custom_headers).value!
    end

    #
    # Copies the contents of an entity.
    #
    # @param drawer [Integer] The drawer.
    # @param id [Integer] The entity identifier.
    # @param model [EntityContentModel] The model.
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def copy_entity_async(drawer, id, model, custom_headers:nil)
      fail ArgumentError, 'drawer is nil' if drawer.nil?
      fail ArgumentError, 'id is nil' if id.nil?
      fail ArgumentError, 'model is nil' if model.nil?


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'

      # Serialize Request
      request_mapper = Softheon.Enterprise.Api.Client::Models::EntityContentModel.mapper()
      request_content = self.serialize(request_mapper,  model)
      request_content = request_content != nil ? JSON.generate(request_content, quirks_mode: true) : nil

      path_template = 'v1/content/entities/{drawer}/{id}/copy'

      request_url = @base_url || self.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          path_params: {'drawer' => drawer,'id' => id},
          body: request_content,
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:post, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 201 || status_code == 404
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        # Deserialize Response
        if status_code == 201
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = Softheon.Enterprise.Api.Client::Models::EntityModel.mapper()
            result.body = self.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # Gets a paged list of events.
    #
    # @param drawer_id [Integer] Gets or sets the drawer identifier.
    # @param entity_id [Integer] Gets or sets the entity identifier.
    # @param type [Enum] Gets or sets the type. Possible values include:
    # 'Undefined', 'Fatal', 'Warning', 'Info', 'Debug', 'Process', 'RPC', 'SQL',
    # 'DDE'
    # @param min_event_time [DateTime] Gets or sets the minimum event time.
    # @param max_event_time [DateTime] Gets or sets the maximum event time.
    # @param event_user_id [Integer] Gets or sets the event user identifier.
    # @param event_group_id [Integer] Gets or sets the event group identifier.
    # @param category [Enum] Gets or sets the category. Possible values include:
    # 'Undefined', 'Entity', 'Profile', 'Attachment', 'Discussion', 'Field',
    # 'Workflow'
    # @param class_parameter [Enum] Gets or sets the class. Possible values
    # include: 'Undefined', 'Application', 'Security', 'System'
    # @param operation [Enum] Gets or sets the operation. Possible values include:
    # 'Undefined', 'Insert', 'Update', 'Delete', 'Copy', 'Lock', 'Unlock', 'Open',
    # 'Close', 'Checkout', 'Checkin', 'View', 'Merge', 'Split', 'Classify', 'Null',
    # 'OpenWF', 'Remove', 'ReturnToTop', 'ReturnToBottom', 'Accept', 'Suspend',
    # 'Reject', 'Route', 'Forward', 'Reply', 'Reassign', 'Reset', 'Override',
    # 'Rollback', 'Archive'
    # @param min_processing_time [Integer] Gets or sets the minimum processing
    # time.
    # @param max_processing_time [Integer] Gets or sets the maximum processing
    # time.
    # @param page [Integer] Gets or sets the page number.
    # @param page_size [Integer] Gets or sets the size of the page.
    # @param sort_order [Enum] Gets or sets the order. Possible values include:
    # 'Unspecified', 'Ascending', 'Descending'
    # @param sort_by [Enum] Gets or sets the column to order by. Possible values
    # include: 'ID', 'Type', 'EventTime'
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [Array] operation results.
    #
    def get_events_by_filter(drawer_id, entity_id, type:nil, min_event_time:nil, max_event_time:nil, event_user_id:nil, event_group_id:nil, category:nil, class_parameter:nil, operation:nil, min_processing_time:nil, max_processing_time:nil, page:nil, page_size:nil, sort_order:nil, sort_by:nil, custom_headers:nil)
      response = get_events_by_filter_async(drawer_id, entity_id, type:type, min_event_time:min_event_time, max_event_time:max_event_time, event_user_id:event_user_id, event_group_id:event_group_id, category:category, class_parameter:class_parameter, operation:operation, min_processing_time:min_processing_time, max_processing_time:max_processing_time, page:page, page_size:page_size, sort_order:sort_order, sort_by:sort_by, custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # Gets a paged list of events.
    #
    # @param drawer_id [Integer] Gets or sets the drawer identifier.
    # @param entity_id [Integer] Gets or sets the entity identifier.
    # @param type [Enum] Gets or sets the type. Possible values include:
    # 'Undefined', 'Fatal', 'Warning', 'Info', 'Debug', 'Process', 'RPC', 'SQL',
    # 'DDE'
    # @param min_event_time [DateTime] Gets or sets the minimum event time.
    # @param max_event_time [DateTime] Gets or sets the maximum event time.
    # @param event_user_id [Integer] Gets or sets the event user identifier.
    # @param event_group_id [Integer] Gets or sets the event group identifier.
    # @param category [Enum] Gets or sets the category. Possible values include:
    # 'Undefined', 'Entity', 'Profile', 'Attachment', 'Discussion', 'Field',
    # 'Workflow'
    # @param class_parameter [Enum] Gets or sets the class. Possible values
    # include: 'Undefined', 'Application', 'Security', 'System'
    # @param operation [Enum] Gets or sets the operation. Possible values include:
    # 'Undefined', 'Insert', 'Update', 'Delete', 'Copy', 'Lock', 'Unlock', 'Open',
    # 'Close', 'Checkout', 'Checkin', 'View', 'Merge', 'Split', 'Classify', 'Null',
    # 'OpenWF', 'Remove', 'ReturnToTop', 'ReturnToBottom', 'Accept', 'Suspend',
    # 'Reject', 'Route', 'Forward', 'Reply', 'Reassign', 'Reset', 'Override',
    # 'Rollback', 'Archive'
    # @param min_processing_time [Integer] Gets or sets the minimum processing
    # time.
    # @param max_processing_time [Integer] Gets or sets the maximum processing
    # time.
    # @param page [Integer] Gets or sets the page number.
    # @param page_size [Integer] Gets or sets the size of the page.
    # @param sort_order [Enum] Gets or sets the order. Possible values include:
    # 'Unspecified', 'Ascending', 'Descending'
    # @param sort_by [Enum] Gets or sets the column to order by. Possible values
    # include: 'ID', 'Type', 'EventTime'
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def get_events_by_filter_with_http_info(drawer_id, entity_id, type:nil, min_event_time:nil, max_event_time:nil, event_user_id:nil, event_group_id:nil, category:nil, class_parameter:nil, operation:nil, min_processing_time:nil, max_processing_time:nil, page:nil, page_size:nil, sort_order:nil, sort_by:nil, custom_headers:nil)
      get_events_by_filter_async(drawer_id, entity_id, type:type, min_event_time:min_event_time, max_event_time:max_event_time, event_user_id:event_user_id, event_group_id:event_group_id, category:category, class_parameter:class_parameter, operation:operation, min_processing_time:min_processing_time, max_processing_time:max_processing_time, page:page, page_size:page_size, sort_order:sort_order, sort_by:sort_by, custom_headers:custom_headers).value!
    end

    #
    # Gets a paged list of events.
    #
    # @param drawer_id [Integer] Gets or sets the drawer identifier.
    # @param entity_id [Integer] Gets or sets the entity identifier.
    # @param type [Enum] Gets or sets the type. Possible values include:
    # 'Undefined', 'Fatal', 'Warning', 'Info', 'Debug', 'Process', 'RPC', 'SQL',
    # 'DDE'
    # @param min_event_time [DateTime] Gets or sets the minimum event time.
    # @param max_event_time [DateTime] Gets or sets the maximum event time.
    # @param event_user_id [Integer] Gets or sets the event user identifier.
    # @param event_group_id [Integer] Gets or sets the event group identifier.
    # @param category [Enum] Gets or sets the category. Possible values include:
    # 'Undefined', 'Entity', 'Profile', 'Attachment', 'Discussion', 'Field',
    # 'Workflow'
    # @param class_parameter [Enum] Gets or sets the class. Possible values
    # include: 'Undefined', 'Application', 'Security', 'System'
    # @param operation [Enum] Gets or sets the operation. Possible values include:
    # 'Undefined', 'Insert', 'Update', 'Delete', 'Copy', 'Lock', 'Unlock', 'Open',
    # 'Close', 'Checkout', 'Checkin', 'View', 'Merge', 'Split', 'Classify', 'Null',
    # 'OpenWF', 'Remove', 'ReturnToTop', 'ReturnToBottom', 'Accept', 'Suspend',
    # 'Reject', 'Route', 'Forward', 'Reply', 'Reassign', 'Reset', 'Override',
    # 'Rollback', 'Archive'
    # @param min_processing_time [Integer] Gets or sets the minimum processing
    # time.
    # @param max_processing_time [Integer] Gets or sets the maximum processing
    # time.
    # @param page [Integer] Gets or sets the page number.
    # @param page_size [Integer] Gets or sets the size of the page.
    # @param sort_order [Enum] Gets or sets the order. Possible values include:
    # 'Unspecified', 'Ascending', 'Descending'
    # @param sort_by [Enum] Gets or sets the column to order by. Possible values
    # include: 'ID', 'Type', 'EventTime'
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def get_events_by_filter_async(drawer_id, entity_id, type:nil, min_event_time:nil, max_event_time:nil, event_user_id:nil, event_group_id:nil, category:nil, class_parameter:nil, operation:nil, min_processing_time:nil, max_processing_time:nil, page:nil, page_size:nil, sort_order:nil, sort_by:nil, custom_headers:nil)
      fail ArgumentError, 'drawer_id is nil' if drawer_id.nil?
      fail ArgumentError, "'drawer_id' should satisfy the constraint - 'InclusiveMaximum': '2147483647'" if !drawer_id.nil? && drawer_id > 2147483647
      fail ArgumentError, "'drawer_id' should satisfy the constraint - 'InclusiveMinimum': '1'" if !drawer_id.nil? && drawer_id < 1
      fail ArgumentError, 'entity_id is nil' if entity_id.nil?
      fail ArgumentError, "'entity_id' should satisfy the constraint - 'InclusiveMaximum': '2147483647'" if !entity_id.nil? && entity_id > 2147483647
      fail ArgumentError, "'entity_id' should satisfy the constraint - 'InclusiveMinimum': '1'" if !entity_id.nil? && entity_id < 1
      fail ArgumentError, "'event_user_id' should satisfy the constraint - 'InclusiveMaximum': '2147483647'" if !event_user_id.nil? && event_user_id > 2147483647
      fail ArgumentError, "'event_user_id' should satisfy the constraint - 'InclusiveMinimum': '1'" if !event_user_id.nil? && event_user_id < 1
      fail ArgumentError, "'event_group_id' should satisfy the constraint - 'InclusiveMaximum': '2147483647'" if !event_group_id.nil? && event_group_id > 2147483647
      fail ArgumentError, "'event_group_id' should satisfy the constraint - 'InclusiveMinimum': '1'" if !event_group_id.nil? && event_group_id < 1
      fail ArgumentError, "'page' should satisfy the constraint - 'InclusiveMaximum': '2147483647'" if !page.nil? && page > 2147483647
      fail ArgumentError, "'page' should satisfy the constraint - 'InclusiveMinimum': '1'" if !page.nil? && page < 1
      fail ArgumentError, "'page_size' should satisfy the constraint - 'InclusiveMaximum': '1000'" if !page_size.nil? && page_size > 1000
      fail ArgumentError, "'page_size' should satisfy the constraint - 'InclusiveMinimum': '1'" if !page_size.nil? && page_size < 1


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'
      path_template = 'v1/content/events'

      request_url = @base_url || self.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          query_params: {'drawerID' => drawer_id,'entityID' => entity_id,'type' => type,'minEventTime' => min_event_time,'maxEventTime' => max_event_time,'eventUserID' => event_user_id,'eventGroupID' => event_group_id,'category' => category,'class' => class_parameter,'operation' => operation,'minProcessingTime' => min_processing_time,'maxProcessingTime' => max_processing_time,'page' => page,'pageSize' => page_size,'sortOrder' => sort_order,'sortBy' => sort_by},
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:get, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = {
              client_side_validation: true,
              required: false,
              serialized_name: 'parsed_response',
              type: {
                name: 'Sequence',
                element: {
                    client_side_validation: true,
                    required: false,
                    serialized_name: 'EventModelElementType',
                    type: {
                      name: 'Composite',
                      class_name: 'EventModel'
                    }
                }
              }
            }
            result.body = self.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # Retrieves a single event based on its unique identifier.
    #
    # @param drawer [Integer] The drawer identifier.
    # @param id [Integer] The event identifier.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [EventModel] operation results.
    #
    def get_event_by_id(drawer, id, custom_headers:nil)
      response = get_event_by_id_async(drawer, id, custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # Retrieves a single event based on its unique identifier.
    #
    # @param drawer [Integer] The drawer identifier.
    # @param id [Integer] The event identifier.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def get_event_by_id_with_http_info(drawer, id, custom_headers:nil)
      get_event_by_id_async(drawer, id, custom_headers:custom_headers).value!
    end

    #
    # Retrieves a single event based on its unique identifier.
    #
    # @param drawer [Integer] The drawer identifier.
    # @param id [Integer] The event identifier.
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def get_event_by_id_async(drawer, id, custom_headers:nil)
      fail ArgumentError, 'drawer is nil' if drawer.nil?
      fail ArgumentError, 'id is nil' if id.nil?


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'
      path_template = 'v1/content/events/{drawer}/{id}'

      request_url = @base_url || self.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          path_params: {'drawer' => drawer,'id' => id},
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:get, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200 || status_code == 404
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = Softheon.Enterprise.Api.Client::Models::EventModel.mapper()
            result.body = self.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # Creates a new event.
    #
    # @param drawer [Integer] The drawer identifier.
    # @param model [EventModel] The event model.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [EventModel] operation results.
    #
    def create_event(drawer, model, custom_headers:nil)
      response = create_event_async(drawer, model, custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # Creates a new event.
    #
    # @param drawer [Integer] The drawer identifier.
    # @param model [EventModel] The event model.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def create_event_with_http_info(drawer, model, custom_headers:nil)
      create_event_async(drawer, model, custom_headers:custom_headers).value!
    end

    #
    # Creates a new event.
    #
    # @param drawer [Integer] The drawer identifier.
    # @param model [EventModel] The event model.
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def create_event_async(drawer, model, custom_headers:nil)
      fail ArgumentError, 'drawer is nil' if drawer.nil?
      fail ArgumentError, 'model is nil' if model.nil?


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'

      # Serialize Request
      request_mapper = Softheon.Enterprise.Api.Client::Models::EventModel.mapper()
      request_content = self.serialize(request_mapper,  model)
      request_content = request_content != nil ? JSON.generate(request_content, quirks_mode: true) : nil

      path_template = 'v1/content/events/{drawer}'

      request_url = @base_url || self.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          path_params: {'drawer' => drawer},
          body: request_content,
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:post, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 201 || status_code == 404
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        # Deserialize Response
        if status_code == 201
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = Softheon.Enterprise.Api.Client::Models::EventModel.mapper()
            result.body = self.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # Gets a paged list of extension rows
    #
    # @param drawer_id [Integer] Gets or sets the drawer identifier.
    # @param entity_id [Integer] Gets or sets the entity identifier.
    # @param profile_id [Integer] Gets or sets the profile identifier.
    # @param i_d [Integer] Gets or sets the extension identifier.
    # @param type [Integer] Gets or sets the type of the extension.
    # @param page [Integer] Gets or sets the page number.
    # @param page_size [Integer] Gets or sets the size of the page.
    # @param sort_order [Enum] Gets or sets the order. Possible values include:
    # 'Unspecified', 'Ascending', 'Descending'
    # @param sort_by [Enum] Gets or sets the column to order by. Possible values
    # include: 'RowNumber', 'ID', 'Type', 'String', 'Integer', 'Double', 'Date'
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [Array] operation results.
    #
    def get_extensions_by_filter(drawer_id, entity_id, profile_id, i_d:nil, type:nil, page:nil, page_size:nil, sort_order:nil, sort_by:nil, custom_headers:nil)
      response = get_extensions_by_filter_async(drawer_id, entity_id, profile_id, i_d:i_d, type:type, page:page, page_size:page_size, sort_order:sort_order, sort_by:sort_by, custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # Gets a paged list of extension rows
    #
    # @param drawer_id [Integer] Gets or sets the drawer identifier.
    # @param entity_id [Integer] Gets or sets the entity identifier.
    # @param profile_id [Integer] Gets or sets the profile identifier.
    # @param i_d [Integer] Gets or sets the extension identifier.
    # @param type [Integer] Gets or sets the type of the extension.
    # @param page [Integer] Gets or sets the page number.
    # @param page_size [Integer] Gets or sets the size of the page.
    # @param sort_order [Enum] Gets or sets the order. Possible values include:
    # 'Unspecified', 'Ascending', 'Descending'
    # @param sort_by [Enum] Gets or sets the column to order by. Possible values
    # include: 'RowNumber', 'ID', 'Type', 'String', 'Integer', 'Double', 'Date'
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def get_extensions_by_filter_with_http_info(drawer_id, entity_id, profile_id, i_d:nil, type:nil, page:nil, page_size:nil, sort_order:nil, sort_by:nil, custom_headers:nil)
      get_extensions_by_filter_async(drawer_id, entity_id, profile_id, i_d:i_d, type:type, page:page, page_size:page_size, sort_order:sort_order, sort_by:sort_by, custom_headers:custom_headers).value!
    end

    #
    # Gets a paged list of extension rows
    #
    # @param drawer_id [Integer] Gets or sets the drawer identifier.
    # @param entity_id [Integer] Gets or sets the entity identifier.
    # @param profile_id [Integer] Gets or sets the profile identifier.
    # @param i_d [Integer] Gets or sets the extension identifier.
    # @param type [Integer] Gets or sets the type of the extension.
    # @param page [Integer] Gets or sets the page number.
    # @param page_size [Integer] Gets or sets the size of the page.
    # @param sort_order [Enum] Gets or sets the order. Possible values include:
    # 'Unspecified', 'Ascending', 'Descending'
    # @param sort_by [Enum] Gets or sets the column to order by. Possible values
    # include: 'RowNumber', 'ID', 'Type', 'String', 'Integer', 'Double', 'Date'
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def get_extensions_by_filter_async(drawer_id, entity_id, profile_id, i_d:nil, type:nil, page:nil, page_size:nil, sort_order:nil, sort_by:nil, custom_headers:nil)
      fail ArgumentError, 'drawer_id is nil' if drawer_id.nil?
      fail ArgumentError, "'drawer_id' should satisfy the constraint - 'InclusiveMaximum': '2147483647'" if !drawer_id.nil? && drawer_id > 2147483647
      fail ArgumentError, "'drawer_id' should satisfy the constraint - 'InclusiveMinimum': '1'" if !drawer_id.nil? && drawer_id < 1
      fail ArgumentError, 'entity_id is nil' if entity_id.nil?
      fail ArgumentError, "'entity_id' should satisfy the constraint - 'InclusiveMaximum': '2147483647'" if !entity_id.nil? && entity_id > 2147483647
      fail ArgumentError, "'entity_id' should satisfy the constraint - 'InclusiveMinimum': '1'" if !entity_id.nil? && entity_id < 1
      fail ArgumentError, 'profile_id is nil' if profile_id.nil?
      fail ArgumentError, "'profile_id' should satisfy the constraint - 'InclusiveMaximum': '2147483647'" if !profile_id.nil? && profile_id > 2147483647
      fail ArgumentError, "'profile_id' should satisfy the constraint - 'InclusiveMinimum': '1'" if !profile_id.nil? && profile_id < 1
      fail ArgumentError, "'i_d' should satisfy the constraint - 'InclusiveMaximum': '2147483647'" if !i_d.nil? && i_d > 2147483647
      fail ArgumentError, "'i_d' should satisfy the constraint - 'InclusiveMinimum': '1'" if !i_d.nil? && i_d < 1
      fail ArgumentError, "'type' should satisfy the constraint - 'InclusiveMaximum': '2147483647'" if !type.nil? && type > 2147483647
      fail ArgumentError, "'type' should satisfy the constraint - 'InclusiveMinimum': '0'" if !type.nil? && type < 0
      fail ArgumentError, "'page' should satisfy the constraint - 'InclusiveMaximum': '2147483647'" if !page.nil? && page > 2147483647
      fail ArgumentError, "'page' should satisfy the constraint - 'InclusiveMinimum': '1'" if !page.nil? && page < 1
      fail ArgumentError, "'page_size' should satisfy the constraint - 'InclusiveMaximum': '1000'" if !page_size.nil? && page_size > 1000
      fail ArgumentError, "'page_size' should satisfy the constraint - 'InclusiveMinimum': '1'" if !page_size.nil? && page_size < 1


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'
      path_template = 'v1/content/extensions'

      request_url = @base_url || self.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          query_params: {'drawerID' => drawer_id,'entityID' => entity_id,'profileID' => profile_id,'iD' => i_d,'type' => type,'page' => page,'pageSize' => page_size,'sortOrder' => sort_order,'sortBy' => sort_by},
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:get, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = {
              client_side_validation: true,
              required: false,
              serialized_name: 'parsed_response',
              type: {
                name: 'Sequence',
                element: {
                    client_side_validation: true,
                    required: false,
                    serialized_name: 'ExtensionModelElementType',
                    type: {
                      name: 'Composite',
                      class_name: 'ExtensionModel'
                    }
                }
              }
            }
            result.body = self.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # Gets a paged list of flows.
    #
    # @param drawer_id [Integer] Gets or sets the drawer identifier.
    # @param entity_id [Integer] Gets or sets the entity identifier.
    # @param type [Enum] Gets or sets the type. Possible values include: 'None',
    # 'Workflow', 'Fatal', 'Warning', 'Info', 'Debug', 'Process', 'Rpc', 'Sql',
    # 'Dde'
    # @param queue_id [Integer] Gets or sets the queue identifier.
    # @param min_workflow_time [DateTime] Gets or sets the minimum workflow time.
    # @param max_workflow_time [DateTime] Gets or sets the maximum workflow time.
    # @param min_insertion_time [DateTime] Gets or sets the minimum insertion time.
    # @param max_insertion_time [DateTime] Gets or sets the maximum insertion time.
    # @param workflow_user_id [Integer] Gets or sets the workflow user identifier.
    # @param workflow_group_id [Integer] Gets or sets the workflow group
    # identifier.
    # @param operation [Enum] Gets or sets the operation. Possible values include:
    # 'None', 'Update', 'Reset', 'Override', 'Null'
    # @param category [Enum] Gets or sets the category. Possible values include:
    # 'None', 'Direct', 'AdHoc', 'Production', 'Review', 'Reset', 'RoutingSlip',
    # 'ReviewRoutingSlip', 'Override'
    # @param status [Enum] Gets or sets the status. Possible values include:
    # 'None', 'Approved', 'Rejected', 'Suspended', 'ApprovedR', 'NoneR'
    # @param state [Enum] Gets or sets the state. Possible values include: 'None',
    # 'Processed', 'Pending', 'Waiting', 'ProcessedR', 'Override', 'OverrideR',
    # 'WaitingR'
    # @param min_index1 [Integer] Gets or sets the minimum index 1.
    # @param max_index1 [Integer] Gets or sets the maximum index 1.
    # @param min_index2 [Integer] Gets or sets the minimum index 2.
    # @param max_index2 [Integer] Gets or sets the maximum index 2.
    # @param page [Integer] Gets or sets the page number.
    # @param page_size [Integer] Gets or sets the size of the page.
    # @param sort_order [Enum] Gets or sets the order. Possible values include:
    # 'Unspecified', 'Ascending', 'Descending'
    # @param sort_by [Enum] Gets or sets the column to order by. Possible values
    # include: 'ID', 'Type', 'QueueID', 'WorkflowTime', 'InsertionTime', 'Index'
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [Array] operation results.
    #
    def get_flows_by_filter(drawer_id, entity_id, type:nil, queue_id:nil, min_workflow_time:nil, max_workflow_time:nil, min_insertion_time:nil, max_insertion_time:nil, workflow_user_id:nil, workflow_group_id:nil, operation:nil, category:nil, status:nil, state:nil, min_index1:nil, max_index1:nil, min_index2:nil, max_index2:nil, page:nil, page_size:nil, sort_order:nil, sort_by:nil, custom_headers:nil)
      response = get_flows_by_filter_async(drawer_id, entity_id, type:type, queue_id:queue_id, min_workflow_time:min_workflow_time, max_workflow_time:max_workflow_time, min_insertion_time:min_insertion_time, max_insertion_time:max_insertion_time, workflow_user_id:workflow_user_id, workflow_group_id:workflow_group_id, operation:operation, category:category, status:status, state:state, min_index1:min_index1, max_index1:max_index1, min_index2:min_index2, max_index2:max_index2, page:page, page_size:page_size, sort_order:sort_order, sort_by:sort_by, custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # Gets a paged list of flows.
    #
    # @param drawer_id [Integer] Gets or sets the drawer identifier.
    # @param entity_id [Integer] Gets or sets the entity identifier.
    # @param type [Enum] Gets or sets the type. Possible values include: 'None',
    # 'Workflow', 'Fatal', 'Warning', 'Info', 'Debug', 'Process', 'Rpc', 'Sql',
    # 'Dde'
    # @param queue_id [Integer] Gets or sets the queue identifier.
    # @param min_workflow_time [DateTime] Gets or sets the minimum workflow time.
    # @param max_workflow_time [DateTime] Gets or sets the maximum workflow time.
    # @param min_insertion_time [DateTime] Gets or sets the minimum insertion time.
    # @param max_insertion_time [DateTime] Gets or sets the maximum insertion time.
    # @param workflow_user_id [Integer] Gets or sets the workflow user identifier.
    # @param workflow_group_id [Integer] Gets or sets the workflow group
    # identifier.
    # @param operation [Enum] Gets or sets the operation. Possible values include:
    # 'None', 'Update', 'Reset', 'Override', 'Null'
    # @param category [Enum] Gets or sets the category. Possible values include:
    # 'None', 'Direct', 'AdHoc', 'Production', 'Review', 'Reset', 'RoutingSlip',
    # 'ReviewRoutingSlip', 'Override'
    # @param status [Enum] Gets or sets the status. Possible values include:
    # 'None', 'Approved', 'Rejected', 'Suspended', 'ApprovedR', 'NoneR'
    # @param state [Enum] Gets or sets the state. Possible values include: 'None',
    # 'Processed', 'Pending', 'Waiting', 'ProcessedR', 'Override', 'OverrideR',
    # 'WaitingR'
    # @param min_index1 [Integer] Gets or sets the minimum index 1.
    # @param max_index1 [Integer] Gets or sets the maximum index 1.
    # @param min_index2 [Integer] Gets or sets the minimum index 2.
    # @param max_index2 [Integer] Gets or sets the maximum index 2.
    # @param page [Integer] Gets or sets the page number.
    # @param page_size [Integer] Gets or sets the size of the page.
    # @param sort_order [Enum] Gets or sets the order. Possible values include:
    # 'Unspecified', 'Ascending', 'Descending'
    # @param sort_by [Enum] Gets or sets the column to order by. Possible values
    # include: 'ID', 'Type', 'QueueID', 'WorkflowTime', 'InsertionTime', 'Index'
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def get_flows_by_filter_with_http_info(drawer_id, entity_id, type:nil, queue_id:nil, min_workflow_time:nil, max_workflow_time:nil, min_insertion_time:nil, max_insertion_time:nil, workflow_user_id:nil, workflow_group_id:nil, operation:nil, category:nil, status:nil, state:nil, min_index1:nil, max_index1:nil, min_index2:nil, max_index2:nil, page:nil, page_size:nil, sort_order:nil, sort_by:nil, custom_headers:nil)
      get_flows_by_filter_async(drawer_id, entity_id, type:type, queue_id:queue_id, min_workflow_time:min_workflow_time, max_workflow_time:max_workflow_time, min_insertion_time:min_insertion_time, max_insertion_time:max_insertion_time, workflow_user_id:workflow_user_id, workflow_group_id:workflow_group_id, operation:operation, category:category, status:status, state:state, min_index1:min_index1, max_index1:max_index1, min_index2:min_index2, max_index2:max_index2, page:page, page_size:page_size, sort_order:sort_order, sort_by:sort_by, custom_headers:custom_headers).value!
    end

    #
    # Gets a paged list of flows.
    #
    # @param drawer_id [Integer] Gets or sets the drawer identifier.
    # @param entity_id [Integer] Gets or sets the entity identifier.
    # @param type [Enum] Gets or sets the type. Possible values include: 'None',
    # 'Workflow', 'Fatal', 'Warning', 'Info', 'Debug', 'Process', 'Rpc', 'Sql',
    # 'Dde'
    # @param queue_id [Integer] Gets or sets the queue identifier.
    # @param min_workflow_time [DateTime] Gets or sets the minimum workflow time.
    # @param max_workflow_time [DateTime] Gets or sets the maximum workflow time.
    # @param min_insertion_time [DateTime] Gets or sets the minimum insertion time.
    # @param max_insertion_time [DateTime] Gets or sets the maximum insertion time.
    # @param workflow_user_id [Integer] Gets or sets the workflow user identifier.
    # @param workflow_group_id [Integer] Gets or sets the workflow group
    # identifier.
    # @param operation [Enum] Gets or sets the operation. Possible values include:
    # 'None', 'Update', 'Reset', 'Override', 'Null'
    # @param category [Enum] Gets or sets the category. Possible values include:
    # 'None', 'Direct', 'AdHoc', 'Production', 'Review', 'Reset', 'RoutingSlip',
    # 'ReviewRoutingSlip', 'Override'
    # @param status [Enum] Gets or sets the status. Possible values include:
    # 'None', 'Approved', 'Rejected', 'Suspended', 'ApprovedR', 'NoneR'
    # @param state [Enum] Gets or sets the state. Possible values include: 'None',
    # 'Processed', 'Pending', 'Waiting', 'ProcessedR', 'Override', 'OverrideR',
    # 'WaitingR'
    # @param min_index1 [Integer] Gets or sets the minimum index 1.
    # @param max_index1 [Integer] Gets or sets the maximum index 1.
    # @param min_index2 [Integer] Gets or sets the minimum index 2.
    # @param max_index2 [Integer] Gets or sets the maximum index 2.
    # @param page [Integer] Gets or sets the page number.
    # @param page_size [Integer] Gets or sets the size of the page.
    # @param sort_order [Enum] Gets or sets the order. Possible values include:
    # 'Unspecified', 'Ascending', 'Descending'
    # @param sort_by [Enum] Gets or sets the column to order by. Possible values
    # include: 'ID', 'Type', 'QueueID', 'WorkflowTime', 'InsertionTime', 'Index'
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def get_flows_by_filter_async(drawer_id, entity_id, type:nil, queue_id:nil, min_workflow_time:nil, max_workflow_time:nil, min_insertion_time:nil, max_insertion_time:nil, workflow_user_id:nil, workflow_group_id:nil, operation:nil, category:nil, status:nil, state:nil, min_index1:nil, max_index1:nil, min_index2:nil, max_index2:nil, page:nil, page_size:nil, sort_order:nil, sort_by:nil, custom_headers:nil)
      fail ArgumentError, 'drawer_id is nil' if drawer_id.nil?
      fail ArgumentError, "'drawer_id' should satisfy the constraint - 'InclusiveMaximum': '2147483647'" if !drawer_id.nil? && drawer_id > 2147483647
      fail ArgumentError, "'drawer_id' should satisfy the constraint - 'InclusiveMinimum': '1'" if !drawer_id.nil? && drawer_id < 1
      fail ArgumentError, 'entity_id is nil' if entity_id.nil?
      fail ArgumentError, "'entity_id' should satisfy the constraint - 'InclusiveMaximum': '2147483647'" if !entity_id.nil? && entity_id > 2147483647
      fail ArgumentError, "'entity_id' should satisfy the constraint - 'InclusiveMinimum': '1'" if !entity_id.nil? && entity_id < 1
      fail ArgumentError, "'queue_id' should satisfy the constraint - 'InclusiveMaximum': '2147483647'" if !queue_id.nil? && queue_id > 2147483647
      fail ArgumentError, "'queue_id' should satisfy the constraint - 'InclusiveMinimum': '1'" if !queue_id.nil? && queue_id < 1
      fail ArgumentError, "'workflow_user_id' should satisfy the constraint - 'InclusiveMaximum': '2147483647'" if !workflow_user_id.nil? && workflow_user_id > 2147483647
      fail ArgumentError, "'workflow_user_id' should satisfy the constraint - 'InclusiveMinimum': '1'" if !workflow_user_id.nil? && workflow_user_id < 1
      fail ArgumentError, "'workflow_group_id' should satisfy the constraint - 'InclusiveMaximum': '2147483647'" if !workflow_group_id.nil? && workflow_group_id > 2147483647
      fail ArgumentError, "'workflow_group_id' should satisfy the constraint - 'InclusiveMinimum': '1'" if !workflow_group_id.nil? && workflow_group_id < 1
      fail ArgumentError, "'page' should satisfy the constraint - 'InclusiveMaximum': '2147483647'" if !page.nil? && page > 2147483647
      fail ArgumentError, "'page' should satisfy the constraint - 'InclusiveMinimum': '1'" if !page.nil? && page < 1
      fail ArgumentError, "'page_size' should satisfy the constraint - 'InclusiveMaximum': '1000'" if !page_size.nil? && page_size > 1000
      fail ArgumentError, "'page_size' should satisfy the constraint - 'InclusiveMinimum': '1'" if !page_size.nil? && page_size < 1


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'
      path_template = 'v1/content/flows'

      request_url = @base_url || self.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          query_params: {'drawerID' => drawer_id,'entityID' => entity_id,'type' => type,'queueID' => queue_id,'minWorkflowTime' => min_workflow_time,'maxWorkflowTime' => max_workflow_time,'minInsertionTime' => min_insertion_time,'maxInsertionTime' => max_insertion_time,'workflowUserID' => workflow_user_id,'workflowGroupID' => workflow_group_id,'operation' => operation,'category' => category,'status' => status,'state' => state,'minIndex1' => min_index1,'maxIndex1' => max_index1,'minIndex2' => min_index2,'maxIndex2' => max_index2,'page' => page,'pageSize' => page_size,'sortOrder' => sort_order,'sortBy' => sort_by},
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:get, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = {
              client_side_validation: true,
              required: false,
              serialized_name: 'parsed_response',
              type: {
                name: 'Sequence',
                element: {
                    client_side_validation: true,
                    required: false,
                    serialized_name: 'FlowModelElementType',
                    type: {
                      name: 'Composite',
                      class_name: 'FlowModel'
                    }
                }
              }
            }
            result.body = self.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # Gets a single flow based on its unique identifier.
    #
    # @param drawer [Integer] The drawer identifier.
    # @param id [Integer] The flow identifier.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [FlowModel] operation results.
    #
    def get_flow_by_id(drawer, id, custom_headers:nil)
      response = get_flow_by_id_async(drawer, id, custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # Gets a single flow based on its unique identifier.
    #
    # @param drawer [Integer] The drawer identifier.
    # @param id [Integer] The flow identifier.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def get_flow_by_id_with_http_info(drawer, id, custom_headers:nil)
      get_flow_by_id_async(drawer, id, custom_headers:custom_headers).value!
    end

    #
    # Gets a single flow based on its unique identifier.
    #
    # @param drawer [Integer] The drawer identifier.
    # @param id [Integer] The flow identifier.
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def get_flow_by_id_async(drawer, id, custom_headers:nil)
      fail ArgumentError, 'drawer is nil' if drawer.nil?
      fail ArgumentError, 'id is nil' if id.nil?


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'
      path_template = 'v1/content/flows/{drawer}/{id}'

      request_url = @base_url || self.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          path_params: {'drawer' => drawer,'id' => id},
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:get, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200 || status_code == 404
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = Softheon.Enterprise.Api.Client::Models::FlowModel.mapper()
            result.body = self.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # Gets a paged list of entity template definitions.
    #
    # @param drawer_id [Integer] Gets or sets the drawer identifier.
    # @param name [String] Gets or sets the name.
    # @param category [String] Gets or sets the category.
    # @param page [Integer] Gets or sets the page number.
    # @param page_size [Integer] Gets or sets the size of the page.
    # @param sort_order [Enum] Gets or sets the order. Possible values include:
    # 'Unspecified', 'Ascending', 'Descending'
    # @param sort_by [Integer] Gets or sets the column to order by.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [Array] operation results.
    #
    def get_templates_by_filter(drawer_id:nil, name:nil, category:nil, page:nil, page_size:nil, sort_order:nil, sort_by:nil, custom_headers:nil)
      response = get_templates_by_filter_async(drawer_id:drawer_id, name:name, category:category, page:page, page_size:page_size, sort_order:sort_order, sort_by:sort_by, custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # Gets a paged list of entity template definitions.
    #
    # @param drawer_id [Integer] Gets or sets the drawer identifier.
    # @param name [String] Gets or sets the name.
    # @param category [String] Gets or sets the category.
    # @param page [Integer] Gets or sets the page number.
    # @param page_size [Integer] Gets or sets the size of the page.
    # @param sort_order [Enum] Gets or sets the order. Possible values include:
    # 'Unspecified', 'Ascending', 'Descending'
    # @param sort_by [Integer] Gets or sets the column to order by.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def get_templates_by_filter_with_http_info(drawer_id:nil, name:nil, category:nil, page:nil, page_size:nil, sort_order:nil, sort_by:nil, custom_headers:nil)
      get_templates_by_filter_async(drawer_id:drawer_id, name:name, category:category, page:page, page_size:page_size, sort_order:sort_order, sort_by:sort_by, custom_headers:custom_headers).value!
    end

    #
    # Gets a paged list of entity template definitions.
    #
    # @param drawer_id [Integer] Gets or sets the drawer identifier.
    # @param name [String] Gets or sets the name.
    # @param category [String] Gets or sets the category.
    # @param page [Integer] Gets or sets the page number.
    # @param page_size [Integer] Gets or sets the size of the page.
    # @param sort_order [Enum] Gets or sets the order. Possible values include:
    # 'Unspecified', 'Ascending', 'Descending'
    # @param sort_by [Integer] Gets or sets the column to order by.
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def get_templates_by_filter_async(drawer_id:nil, name:nil, category:nil, page:nil, page_size:nil, sort_order:nil, sort_by:nil, custom_headers:nil)
      fail ArgumentError, "'drawer_id' should satisfy the constraint - 'InclusiveMaximum': '2147483647'" if !drawer_id.nil? && drawer_id > 2147483647
      fail ArgumentError, "'drawer_id' should satisfy the constraint - 'InclusiveMinimum': '1'" if !drawer_id.nil? && drawer_id < 1
      fail ArgumentError, "'name' should satisfy the constraint - 'MaxLength': '255'" if !name.nil? && name.length > 255
      fail ArgumentError, "'name' should satisfy the constraint - 'MinLength': '0'" if !name.nil? && name.length < 0
      fail ArgumentError, "'category' should satisfy the constraint - 'MaxLength': '255'" if !category.nil? && category.length > 255
      fail ArgumentError, "'category' should satisfy the constraint - 'MinLength': '0'" if !category.nil? && category.length < 0
      fail ArgumentError, "'page' should satisfy the constraint - 'InclusiveMaximum': '2147483647'" if !page.nil? && page > 2147483647
      fail ArgumentError, "'page' should satisfy the constraint - 'InclusiveMinimum': '1'" if !page.nil? && page < 1
      fail ArgumentError, "'page_size' should satisfy the constraint - 'InclusiveMaximum': '1000'" if !page_size.nil? && page_size > 1000
      fail ArgumentError, "'page_size' should satisfy the constraint - 'InclusiveMinimum': '1'" if !page_size.nil? && page_size < 1


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'
      path_template = 'v1/template/ftl'

      request_url = @base_url || self.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          query_params: {'drawerID' => drawer_id,'name' => name,'category' => category,'page' => page,'pageSize' => page_size,'sortOrder' => sort_order,'sortBy' => sort_by},
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:get, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = {
              client_side_validation: true,
              required: false,
              serialized_name: 'parsed_response',
              type: {
                name: 'Sequence',
                element: {
                    client_side_validation: true,
                    required: false,
                    serialized_name: 'EntityDefinitionModelElementType',
                    type: {
                      name: 'Composite',
                      class_name: 'EntityDefinitionModel'
                    }
                }
              }
            }
            result.body = self.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # Creates a new entity template definition.
    #
    # @param model [EntityDefinitionBase] The entity template model.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [EntityDefinitionModel] operation results.
    #
    def create_template(model, custom_headers:nil)
      response = create_template_async(model, custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # Creates a new entity template definition.
    #
    # @param model [EntityDefinitionBase] The entity template model.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def create_template_with_http_info(model, custom_headers:nil)
      create_template_async(model, custom_headers:custom_headers).value!
    end

    #
    # Creates a new entity template definition.
    #
    # @param model [EntityDefinitionBase] The entity template model.
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def create_template_async(model, custom_headers:nil)
      fail ArgumentError, 'model is nil' if model.nil?


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'

      # Serialize Request
      request_mapper = Softheon.Enterprise.Api.Client::Models::EntityDefinitionBase.mapper()
      request_content = self.serialize(request_mapper,  model)
      request_content = request_content != nil ? JSON.generate(request_content, quirks_mode: true) : nil

      path_template = 'v1/template/ftl'

      request_url = @base_url || self.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          body: request_content,
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:post, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 201 || status_code == 403 || status_code == 404 || status_code == 409
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        # Deserialize Response
        if status_code == 201
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = Softheon.Enterprise.Api.Client::Models::EntityDefinitionModel.mapper()
            result.body = self.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # Gets a single entity template definition by its type.
    #
    # @param type [Integer] The unique template type.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [EntityDefinitionModel] operation results.
    #
    def get_template_by_type(type, custom_headers:nil)
      response = get_template_by_type_async(type, custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # Gets a single entity template definition by its type.
    #
    # @param type [Integer] The unique template type.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def get_template_by_type_with_http_info(type, custom_headers:nil)
      get_template_by_type_async(type, custom_headers:custom_headers).value!
    end

    #
    # Gets a single entity template definition by its type.
    #
    # @param type [Integer] The unique template type.
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def get_template_by_type_async(type, custom_headers:nil)
      fail ArgumentError, 'type is nil' if type.nil?


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'
      path_template = 'v1/template/ftl/{type}'

      request_url = @base_url || self.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          path_params: {'type' => type},
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:get, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200 || status_code == 404
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = Softheon.Enterprise.Api.Client::Models::EntityDefinitionModel.mapper()
            result.body = self.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # Updates a specified entity template definition by type.
    #
    # @param type [Integer] The unique template type.
    # @param model [UpdateEntityDefinitionRequestModel] The entity template model.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [Object] operation results.
    #
    def update_template_by_type(type, model, custom_headers:nil)
      response = update_template_by_type_async(type, model, custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # Updates a specified entity template definition by type.
    #
    # @param type [Integer] The unique template type.
    # @param model [UpdateEntityDefinitionRequestModel] The entity template model.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def update_template_by_type_with_http_info(type, model, custom_headers:nil)
      update_template_by_type_async(type, model, custom_headers:custom_headers).value!
    end

    #
    # Updates a specified entity template definition by type.
    #
    # @param type [Integer] The unique template type.
    # @param model [UpdateEntityDefinitionRequestModel] The entity template model.
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def update_template_by_type_async(type, model, custom_headers:nil)
      fail ArgumentError, 'type is nil' if type.nil?
      fail ArgumentError, 'model is nil' if model.nil?


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'

      # Serialize Request
      request_mapper = Softheon.Enterprise.Api.Client::Models::UpdateEntityDefinitionRequestModel.mapper()
      request_content = self.serialize(request_mapper,  model)
      request_content = request_content != nil ? JSON.generate(request_content, quirks_mode: true) : nil

      path_template = 'v1/template/ftl/{type}'

      request_url = @base_url || self.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          path_params: {'type' => type},
          body: request_content,
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:put, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 204 || status_code == 403 || status_code == 404
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end


        result
      end

      promise.execute
    end

    #
    # Deletes a specified entity template definition by type.
    #
    # @param type [Integer] The unique template type.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [Object] operation results.
    #
    def delete_template_by_type(type, custom_headers:nil)
      response = delete_template_by_type_async(type, custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # Deletes a specified entity template definition by type.
    #
    # @param type [Integer] The unique template type.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def delete_template_by_type_with_http_info(type, custom_headers:nil)
      delete_template_by_type_async(type, custom_headers:custom_headers).value!
    end

    #
    # Deletes a specified entity template definition by type.
    #
    # @param type [Integer] The unique template type.
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def delete_template_by_type_async(type, custom_headers:nil)
      fail ArgumentError, 'type is nil' if type.nil?


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'
      path_template = 'v1/template/ftl/{type}'

      request_url = @base_url || self.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          path_params: {'type' => type},
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:delete, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 204 || status_code == 403 || status_code == 404
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end


        result
      end

      promise.execute
    end

    #
    # Gets a single entity template definition by its unique identifier.
    #
    # @param id [String] The template identifier.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [EntityDefinitionModel] operation results.
    #
    def get_template_by_id(id, custom_headers:nil)
      response = get_template_by_id_async(id, custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # Gets a single entity template definition by its unique identifier.
    #
    # @param id [String] The template identifier.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def get_template_by_id_with_http_info(id, custom_headers:nil)
      get_template_by_id_async(id, custom_headers:custom_headers).value!
    end

    #
    # Gets a single entity template definition by its unique identifier.
    #
    # @param id [String] The template identifier.
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def get_template_by_id_async(id, custom_headers:nil)
      fail ArgumentError, 'id is nil' if id.nil?


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'
      path_template = 'v1/template/ftl/{id}'

      request_url = @base_url || self.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          path_params: {'id' => id},
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:get, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200 || status_code == 404
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = Softheon.Enterprise.Api.Client::Models::EntityDefinitionModel.mapper()
            result.body = self.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # Updates a specified entity template definition by identifier.
    #
    # @param id [String] The unique template identifier.
    # @param model [UpdateEntityDefinitionRequestModel] The entity template model.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [Object] operation results.
    #
    def update_template_by_id(id, model, custom_headers:nil)
      response = update_template_by_id_async(id, model, custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # Updates a specified entity template definition by identifier.
    #
    # @param id [String] The unique template identifier.
    # @param model [UpdateEntityDefinitionRequestModel] The entity template model.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def update_template_by_id_with_http_info(id, model, custom_headers:nil)
      update_template_by_id_async(id, model, custom_headers:custom_headers).value!
    end

    #
    # Updates a specified entity template definition by identifier.
    #
    # @param id [String] The unique template identifier.
    # @param model [UpdateEntityDefinitionRequestModel] The entity template model.
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def update_template_by_id_async(id, model, custom_headers:nil)
      fail ArgumentError, 'id is nil' if id.nil?
      fail ArgumentError, 'model is nil' if model.nil?


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'

      # Serialize Request
      request_mapper = Softheon.Enterprise.Api.Client::Models::UpdateEntityDefinitionRequestModel.mapper()
      request_content = self.serialize(request_mapper,  model)
      request_content = request_content != nil ? JSON.generate(request_content, quirks_mode: true) : nil

      path_template = 'v1/template/ftl/{id}'

      request_url = @base_url || self.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          path_params: {'id' => id},
          body: request_content,
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:put, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 204 || status_code == 403 || status_code == 404
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end


        result
      end

      promise.execute
    end

    #
    # Deletes a specified entity template definition by identifier.
    #
    # @param id [String] The unique template identifier.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [Object] operation results.
    #
    def delete_template_by_id(id, custom_headers:nil)
      response = delete_template_by_id_async(id, custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # Deletes a specified entity template definition by identifier.
    #
    # @param id [String] The unique template identifier.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def delete_template_by_id_with_http_info(id, custom_headers:nil)
      delete_template_by_id_async(id, custom_headers:custom_headers).value!
    end

    #
    # Deletes a specified entity template definition by identifier.
    #
    # @param id [String] The unique template identifier.
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def delete_template_by_id_async(id, custom_headers:nil)
      fail ArgumentError, 'id is nil' if id.nil?


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'
      path_template = 'v1/template/ftl/{id}'

      request_url = @base_url || self.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          path_params: {'id' => id},
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:delete, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 204 || status_code == 403 || status_code == 404
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end


        result
      end

      promise.execute
    end

    #
    # Validates the specified template field.
    #
    # @param type [Integer] The template type.
    # @param field_id [String] The field name.
    # @param sort_column [String] Gets or sets the sort column.
    # @param page [Integer] Gets or sets the page number.
    # @param page_size [Integer] Gets or sets the size of the page.
    # @param sort_order [Enum] Gets or sets the order. Possible values include:
    # 'Unspecified', 'Ascending', 'Descending'
    # @param sort_by [Integer] Gets or sets the column to order by.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [FieldValidationModel] operation results.
    #
    def validate_template_field(type, field_id, sort_column:nil, page:nil, page_size:nil, sort_order:nil, sort_by:nil, custom_headers:nil)
      response = validate_template_field_async(type, field_id, sort_column:sort_column, page:page, page_size:page_size, sort_order:sort_order, sort_by:sort_by, custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # Validates the specified template field.
    #
    # @param type [Integer] The template type.
    # @param field_id [String] The field name.
    # @param sort_column [String] Gets or sets the sort column.
    # @param page [Integer] Gets or sets the page number.
    # @param page_size [Integer] Gets or sets the size of the page.
    # @param sort_order [Enum] Gets or sets the order. Possible values include:
    # 'Unspecified', 'Ascending', 'Descending'
    # @param sort_by [Integer] Gets or sets the column to order by.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def validate_template_field_with_http_info(type, field_id, sort_column:nil, page:nil, page_size:nil, sort_order:nil, sort_by:nil, custom_headers:nil)
      validate_template_field_async(type, field_id, sort_column:sort_column, page:page, page_size:page_size, sort_order:sort_order, sort_by:sort_by, custom_headers:custom_headers).value!
    end

    #
    # Validates the specified template field.
    #
    # @param type [Integer] The template type.
    # @param field_id [String] The field name.
    # @param sort_column [String] Gets or sets the sort column.
    # @param page [Integer] Gets or sets the page number.
    # @param page_size [Integer] Gets or sets the size of the page.
    # @param sort_order [Enum] Gets or sets the order. Possible values include:
    # 'Unspecified', 'Ascending', 'Descending'
    # @param sort_by [Integer] Gets or sets the column to order by.
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def validate_template_field_async(type, field_id, sort_column:nil, page:nil, page_size:nil, sort_order:nil, sort_by:nil, custom_headers:nil)
      fail ArgumentError, 'type is nil' if type.nil?
      fail ArgumentError, 'field_id is nil' if field_id.nil?
      fail ArgumentError, "'page' should satisfy the constraint - 'InclusiveMaximum': '2147483647'" if !page.nil? && page > 2147483647
      fail ArgumentError, "'page' should satisfy the constraint - 'InclusiveMinimum': '1'" if !page.nil? && page < 1
      fail ArgumentError, "'page_size' should satisfy the constraint - 'InclusiveMaximum': '1000'" if !page_size.nil? && page_size > 1000
      fail ArgumentError, "'page_size' should satisfy the constraint - 'InclusiveMinimum': '1'" if !page_size.nil? && page_size < 1


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'
      path_template = 'v1/template/ftl/{type}/validate/{fieldID}'

      request_url = @base_url || self.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          path_params: {'type' => type,'fieldID' => field_id},
          query_params: {'sortColumn' => sort_column,'page' => page,'pageSize' => page_size,'sortOrder' => sort_order,'sortBy' => sort_by},
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:get, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200 || status_code == 404
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = Softheon.Enterprise.Api.Client::Models::FieldValidationModel.mapper()
            result.body = self.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # Gets a paged list of groups.
    #
    # @param i_d [Integer] Gets or sets the group identifier.
    # @param user_id [Integer] Gets or sets the user identifier.
    # @param name [String] Gets or sets the name.
    # @param type [Enum] Gets or sets the type. Possible values include: 'Generic',
    # 'Access', 'Role'
    # @param state [Enum] Gets or sets the state. Possible values include:
    # 'Inactive', 'Active'
    # @param page [Integer] Gets or sets the page number.
    # @param page_size [Integer] Gets or sets the size of the page.
    # @param sort_order [Enum] Gets or sets the order. Possible values include:
    # 'Unspecified', 'Ascending', 'Descending'
    # @param sort_by [Enum] Gets or sets the column to order by. Possible values
    # include: 'ID', 'Name', 'Type', 'State'
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [Array] operation results.
    #
    def get_groups_by_filter(i_d:nil, user_id:nil, name:nil, type:nil, state:nil, page:nil, page_size:nil, sort_order:nil, sort_by:nil, custom_headers:nil)
      response = get_groups_by_filter_async(i_d:i_d, user_id:user_id, name:name, type:type, state:state, page:page, page_size:page_size, sort_order:sort_order, sort_by:sort_by, custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # Gets a paged list of groups.
    #
    # @param i_d [Integer] Gets or sets the group identifier.
    # @param user_id [Integer] Gets or sets the user identifier.
    # @param name [String] Gets or sets the name.
    # @param type [Enum] Gets or sets the type. Possible values include: 'Generic',
    # 'Access', 'Role'
    # @param state [Enum] Gets or sets the state. Possible values include:
    # 'Inactive', 'Active'
    # @param page [Integer] Gets or sets the page number.
    # @param page_size [Integer] Gets or sets the size of the page.
    # @param sort_order [Enum] Gets or sets the order. Possible values include:
    # 'Unspecified', 'Ascending', 'Descending'
    # @param sort_by [Enum] Gets or sets the column to order by. Possible values
    # include: 'ID', 'Name', 'Type', 'State'
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def get_groups_by_filter_with_http_info(i_d:nil, user_id:nil, name:nil, type:nil, state:nil, page:nil, page_size:nil, sort_order:nil, sort_by:nil, custom_headers:nil)
      get_groups_by_filter_async(i_d:i_d, user_id:user_id, name:name, type:type, state:state, page:page, page_size:page_size, sort_order:sort_order, sort_by:sort_by, custom_headers:custom_headers).value!
    end

    #
    # Gets a paged list of groups.
    #
    # @param i_d [Integer] Gets or sets the group identifier.
    # @param user_id [Integer] Gets or sets the user identifier.
    # @param name [String] Gets or sets the name.
    # @param type [Enum] Gets or sets the type. Possible values include: 'Generic',
    # 'Access', 'Role'
    # @param state [Enum] Gets or sets the state. Possible values include:
    # 'Inactive', 'Active'
    # @param page [Integer] Gets or sets the page number.
    # @param page_size [Integer] Gets or sets the size of the page.
    # @param sort_order [Enum] Gets or sets the order. Possible values include:
    # 'Unspecified', 'Ascending', 'Descending'
    # @param sort_by [Enum] Gets or sets the column to order by. Possible values
    # include: 'ID', 'Name', 'Type', 'State'
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def get_groups_by_filter_async(i_d:nil, user_id:nil, name:nil, type:nil, state:nil, page:nil, page_size:nil, sort_order:nil, sort_by:nil, custom_headers:nil)
      fail ArgumentError, "'i_d' should satisfy the constraint - 'InclusiveMaximum': '2147483647'" if !i_d.nil? && i_d > 2147483647
      fail ArgumentError, "'i_d' should satisfy the constraint - 'InclusiveMinimum': '1'" if !i_d.nil? && i_d < 1
      fail ArgumentError, "'user_id' should satisfy the constraint - 'InclusiveMaximum': '2147483647'" if !user_id.nil? && user_id > 2147483647
      fail ArgumentError, "'user_id' should satisfy the constraint - 'InclusiveMinimum': '1'" if !user_id.nil? && user_id < 1
      fail ArgumentError, "'name' should satisfy the constraint - 'MaxLength': '255'" if !name.nil? && name.length > 255
      fail ArgumentError, "'name' should satisfy the constraint - 'MinLength': '0'" if !name.nil? && name.length < 0
      fail ArgumentError, "'page' should satisfy the constraint - 'InclusiveMaximum': '2147483647'" if !page.nil? && page > 2147483647
      fail ArgumentError, "'page' should satisfy the constraint - 'InclusiveMinimum': '1'" if !page.nil? && page < 1
      fail ArgumentError, "'page_size' should satisfy the constraint - 'InclusiveMaximum': '1000'" if !page_size.nil? && page_size > 1000
      fail ArgumentError, "'page_size' should satisfy the constraint - 'InclusiveMinimum': '1'" if !page_size.nil? && page_size < 1


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'
      path_template = 'v1/directory/groups'

      request_url = @base_url || self.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          query_params: {'iD' => i_d,'userID' => user_id,'name' => name,'type' => type,'state' => state,'page' => page,'pageSize' => page_size,'sortOrder' => sort_order,'sortBy' => sort_by},
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:get, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200 || status_code == 403
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = {
              client_side_validation: true,
              required: false,
              serialized_name: 'parsed_response',
              type: {
                name: 'Sequence',
                element: {
                    client_side_validation: true,
                    required: false,
                    serialized_name: 'GroupModelElementType',
                    type: {
                      name: 'Composite',
                      class_name: 'GroupModel'
                    }
                }
              }
            }
            result.body = self.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # Creates a new group.
    #
    # @param model [InsertGroupRequestModel] The group model.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [GroupModel] operation results.
    #
    def create_group(model, custom_headers:nil)
      response = create_group_async(model, custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # Creates a new group.
    #
    # @param model [InsertGroupRequestModel] The group model.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def create_group_with_http_info(model, custom_headers:nil)
      create_group_async(model, custom_headers:custom_headers).value!
    end

    #
    # Creates a new group.
    #
    # @param model [InsertGroupRequestModel] The group model.
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def create_group_async(model, custom_headers:nil)
      fail ArgumentError, 'model is nil' if model.nil?


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'

      # Serialize Request
      request_mapper = Softheon.Enterprise.Api.Client::Models::InsertGroupRequestModel.mapper()
      request_content = self.serialize(request_mapper,  model)
      request_content = request_content != nil ? JSON.generate(request_content, quirks_mode: true) : nil

      path_template = 'v1/directory/groups'

      request_url = @base_url || self.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          body: request_content,
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:post, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 201 || status_code == 403 || status_code == 409
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        # Deserialize Response
        if status_code == 201
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = Softheon.Enterprise.Api.Client::Models::GroupModel.mapper()
            result.body = self.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # Gets a single group by its unique identifier.
    #
    # @param id [Integer] The group identifier.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [GroupModel] operation results.
    #
    def get_group_by_id(id, custom_headers:nil)
      response = get_group_by_id_async(id, custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # Gets a single group by its unique identifier.
    #
    # @param id [Integer] The group identifier.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def get_group_by_id_with_http_info(id, custom_headers:nil)
      get_group_by_id_async(id, custom_headers:custom_headers).value!
    end

    #
    # Gets a single group by its unique identifier.
    #
    # @param id [Integer] The group identifier.
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def get_group_by_id_async(id, custom_headers:nil)
      fail ArgumentError, 'id is nil' if id.nil?


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'
      path_template = 'v1/directory/groups/{id}'

      request_url = @base_url || self.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          path_params: {'id' => id},
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:get, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200 || status_code == 403 || status_code == 404
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = Softheon.Enterprise.Api.Client::Models::GroupModel.mapper()
            result.body = self.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # Updates a specified group.
    #
    # @param id [Integer] The group identifier.
    # @param model [GroupBase] The group model.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [Object] operation results.
    #
    def update_group(id, model, custom_headers:nil)
      response = update_group_async(id, model, custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # Updates a specified group.
    #
    # @param id [Integer] The group identifier.
    # @param model [GroupBase] The group model.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def update_group_with_http_info(id, model, custom_headers:nil)
      update_group_async(id, model, custom_headers:custom_headers).value!
    end

    #
    # Updates a specified group.
    #
    # @param id [Integer] The group identifier.
    # @param model [GroupBase] The group model.
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def update_group_async(id, model, custom_headers:nil)
      fail ArgumentError, 'id is nil' if id.nil?
      fail ArgumentError, 'model is nil' if model.nil?


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'

      # Serialize Request
      request_mapper = Softheon.Enterprise.Api.Client::Models::GroupBase.mapper()
      request_content = self.serialize(request_mapper,  model)
      request_content = request_content != nil ? JSON.generate(request_content, quirks_mode: true) : nil

      path_template = 'v1/directory/groups/{id}'

      request_url = @base_url || self.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          path_params: {'id' => id},
          body: request_content,
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:put, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 204 || status_code == 403 || status_code == 404 || status_code == 500
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end


        result
      end

      promise.execute
    end

    #
    # Deactivates a group and removes all group associations.
    #
    # @param id [Integer] The group identifier.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [Object] operation results.
    #
    def delete_group(id, custom_headers:nil)
      response = delete_group_async(id, custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # Deactivates a group and removes all group associations.
    #
    # @param id [Integer] The group identifier.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def delete_group_with_http_info(id, custom_headers:nil)
      delete_group_async(id, custom_headers:custom_headers).value!
    end

    #
    # Deactivates a group and removes all group associations.
    #
    # @param id [Integer] The group identifier.
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def delete_group_async(id, custom_headers:nil)
      fail ArgumentError, 'id is nil' if id.nil?


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'
      path_template = 'v1/directory/groups/{id}'

      request_url = @base_url || self.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          path_params: {'id' => id},
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:delete, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 204 || status_code == 403 || status_code == 404 || status_code == 500
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end


        result
      end

      promise.execute
    end

    #
    # Gets a paged list of entity links
    #
    # @param child_entity_id [Integer] Gets or sets the child entity identifier.
    # @param child_drawer_id [Integer] Gets or sets the child drawer identifier.
    # @param child_type [Integer] Gets or sets the type of the child.
    # @param acl [Integer] Gets or sets the access control list.
    # @param entity_id [Integer] Gets or sets the entity identifier.
    # @param drawer_id [Integer] Gets or sets the drawer identifier.
    # @param name [String] Gets or sets the name.
    # @param creator_user_id [Integer] Gets or sets the creator user identifier.
    # @param modifier_user_id [Integer] Gets or sets the modifier user identifier.
    # @param min_insertion_time [DateTime] Gets or sets the minimum insertion time.
    # @param max_insertion_time [DateTime] Gets or sets the maximum insertion time.
    # @param min_modification_time [DateTime] Gets or sets the minimum modification
    # time.
    # @param max_modification_time [DateTime] Gets or sets the maximum modification
    # time.
    # @param page [Integer] Gets or sets the page number.
    # @param page_size [Integer] Gets or sets the size of the page.
    # @param sort_order [Enum] Gets or sets the order. Possible values include:
    # 'Unspecified', 'Ascending', 'Descending'
    # @param sort_by [Enum] Gets or sets the column to order by. Possible values
    # include: 'PageNumber', 'ID', 'Type', 'InsertionTime', 'ModificationTime',
    # 'CrossReferenceID', 'SubType', 'Extension', 'Name'
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [Array] operation results.
    #
    def get_links_by_filter(child_entity_id:nil, child_drawer_id:nil, child_type:nil, acl:nil, entity_id:nil, drawer_id:nil, name:nil, creator_user_id:nil, modifier_user_id:nil, min_insertion_time:nil, max_insertion_time:nil, min_modification_time:nil, max_modification_time:nil, page:nil, page_size:nil, sort_order:nil, sort_by:nil, custom_headers:nil)
      response = get_links_by_filter_async(child_entity_id:child_entity_id, child_drawer_id:child_drawer_id, child_type:child_type, acl:acl, entity_id:entity_id, drawer_id:drawer_id, name:name, creator_user_id:creator_user_id, modifier_user_id:modifier_user_id, min_insertion_time:min_insertion_time, max_insertion_time:max_insertion_time, min_modification_time:min_modification_time, max_modification_time:max_modification_time, page:page, page_size:page_size, sort_order:sort_order, sort_by:sort_by, custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # Gets a paged list of entity links
    #
    # @param child_entity_id [Integer] Gets or sets the child entity identifier.
    # @param child_drawer_id [Integer] Gets or sets the child drawer identifier.
    # @param child_type [Integer] Gets or sets the type of the child.
    # @param acl [Integer] Gets or sets the access control list.
    # @param entity_id [Integer] Gets or sets the entity identifier.
    # @param drawer_id [Integer] Gets or sets the drawer identifier.
    # @param name [String] Gets or sets the name.
    # @param creator_user_id [Integer] Gets or sets the creator user identifier.
    # @param modifier_user_id [Integer] Gets or sets the modifier user identifier.
    # @param min_insertion_time [DateTime] Gets or sets the minimum insertion time.
    # @param max_insertion_time [DateTime] Gets or sets the maximum insertion time.
    # @param min_modification_time [DateTime] Gets or sets the minimum modification
    # time.
    # @param max_modification_time [DateTime] Gets or sets the maximum modification
    # time.
    # @param page [Integer] Gets or sets the page number.
    # @param page_size [Integer] Gets or sets the size of the page.
    # @param sort_order [Enum] Gets or sets the order. Possible values include:
    # 'Unspecified', 'Ascending', 'Descending'
    # @param sort_by [Enum] Gets or sets the column to order by. Possible values
    # include: 'PageNumber', 'ID', 'Type', 'InsertionTime', 'ModificationTime',
    # 'CrossReferenceID', 'SubType', 'Extension', 'Name'
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def get_links_by_filter_with_http_info(child_entity_id:nil, child_drawer_id:nil, child_type:nil, acl:nil, entity_id:nil, drawer_id:nil, name:nil, creator_user_id:nil, modifier_user_id:nil, min_insertion_time:nil, max_insertion_time:nil, min_modification_time:nil, max_modification_time:nil, page:nil, page_size:nil, sort_order:nil, sort_by:nil, custom_headers:nil)
      get_links_by_filter_async(child_entity_id:child_entity_id, child_drawer_id:child_drawer_id, child_type:child_type, acl:acl, entity_id:entity_id, drawer_id:drawer_id, name:name, creator_user_id:creator_user_id, modifier_user_id:modifier_user_id, min_insertion_time:min_insertion_time, max_insertion_time:max_insertion_time, min_modification_time:min_modification_time, max_modification_time:max_modification_time, page:page, page_size:page_size, sort_order:sort_order, sort_by:sort_by, custom_headers:custom_headers).value!
    end

    #
    # Gets a paged list of entity links
    #
    # @param child_entity_id [Integer] Gets or sets the child entity identifier.
    # @param child_drawer_id [Integer] Gets or sets the child drawer identifier.
    # @param child_type [Integer] Gets or sets the type of the child.
    # @param acl [Integer] Gets or sets the access control list.
    # @param entity_id [Integer] Gets or sets the entity identifier.
    # @param drawer_id [Integer] Gets or sets the drawer identifier.
    # @param name [String] Gets or sets the name.
    # @param creator_user_id [Integer] Gets or sets the creator user identifier.
    # @param modifier_user_id [Integer] Gets or sets the modifier user identifier.
    # @param min_insertion_time [DateTime] Gets or sets the minimum insertion time.
    # @param max_insertion_time [DateTime] Gets or sets the maximum insertion time.
    # @param min_modification_time [DateTime] Gets or sets the minimum modification
    # time.
    # @param max_modification_time [DateTime] Gets or sets the maximum modification
    # time.
    # @param page [Integer] Gets or sets the page number.
    # @param page_size [Integer] Gets or sets the size of the page.
    # @param sort_order [Enum] Gets or sets the order. Possible values include:
    # 'Unspecified', 'Ascending', 'Descending'
    # @param sort_by [Enum] Gets or sets the column to order by. Possible values
    # include: 'PageNumber', 'ID', 'Type', 'InsertionTime', 'ModificationTime',
    # 'CrossReferenceID', 'SubType', 'Extension', 'Name'
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def get_links_by_filter_async(child_entity_id:nil, child_drawer_id:nil, child_type:nil, acl:nil, entity_id:nil, drawer_id:nil, name:nil, creator_user_id:nil, modifier_user_id:nil, min_insertion_time:nil, max_insertion_time:nil, min_modification_time:nil, max_modification_time:nil, page:nil, page_size:nil, sort_order:nil, sort_by:nil, custom_headers:nil)
      fail ArgumentError, "'child_entity_id' should satisfy the constraint - 'InclusiveMaximum': '2147483647'" if !child_entity_id.nil? && child_entity_id > 2147483647
      fail ArgumentError, "'child_entity_id' should satisfy the constraint - 'InclusiveMinimum': '1'" if !child_entity_id.nil? && child_entity_id < 1
      fail ArgumentError, "'child_drawer_id' should satisfy the constraint - 'InclusiveMaximum': '2147483647'" if !child_drawer_id.nil? && child_drawer_id > 2147483647
      fail ArgumentError, "'child_drawer_id' should satisfy the constraint - 'InclusiveMinimum': '1'" if !child_drawer_id.nil? && child_drawer_id < 1
      fail ArgumentError, "'child_type' should satisfy the constraint - 'InclusiveMaximum': '2147483647'" if !child_type.nil? && child_type > 2147483647
      fail ArgumentError, "'child_type' should satisfy the constraint - 'InclusiveMinimum': '1'" if !child_type.nil? && child_type < 1
      fail ArgumentError, "'entity_id' should satisfy the constraint - 'InclusiveMaximum': '2147483647'" if !entity_id.nil? && entity_id > 2147483647
      fail ArgumentError, "'entity_id' should satisfy the constraint - 'InclusiveMinimum': '1'" if !entity_id.nil? && entity_id < 1
      fail ArgumentError, "'drawer_id' should satisfy the constraint - 'InclusiveMaximum': '2147483647'" if !drawer_id.nil? && drawer_id > 2147483647
      fail ArgumentError, "'drawer_id' should satisfy the constraint - 'InclusiveMinimum': '1'" if !drawer_id.nil? && drawer_id < 1
      fail ArgumentError, "'name' should satisfy the constraint - 'MaxLength': '255'" if !name.nil? && name.length > 255
      fail ArgumentError, "'name' should satisfy the constraint - 'MinLength': '0'" if !name.nil? && name.length < 0
      fail ArgumentError, "'creator_user_id' should satisfy the constraint - 'InclusiveMaximum': '2147483647'" if !creator_user_id.nil? && creator_user_id > 2147483647
      fail ArgumentError, "'creator_user_id' should satisfy the constraint - 'InclusiveMinimum': '1'" if !creator_user_id.nil? && creator_user_id < 1
      fail ArgumentError, "'modifier_user_id' should satisfy the constraint - 'InclusiveMaximum': '2147483647'" if !modifier_user_id.nil? && modifier_user_id > 2147483647
      fail ArgumentError, "'modifier_user_id' should satisfy the constraint - 'InclusiveMinimum': '1'" if !modifier_user_id.nil? && modifier_user_id < 1
      fail ArgumentError, "'page' should satisfy the constraint - 'InclusiveMaximum': '2147483647'" if !page.nil? && page > 2147483647
      fail ArgumentError, "'page' should satisfy the constraint - 'InclusiveMinimum': '1'" if !page.nil? && page < 1
      fail ArgumentError, "'page_size' should satisfy the constraint - 'InclusiveMaximum': '1000'" if !page_size.nil? && page_size > 1000
      fail ArgumentError, "'page_size' should satisfy the constraint - 'InclusiveMinimum': '1'" if !page_size.nil? && page_size < 1


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'
      path_template = 'v1/content/links'

      request_url = @base_url || self.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          query_params: {'childEntityID' => child_entity_id,'childDrawerID' => child_drawer_id,'childType' => child_type,'acl' => acl,'entityID' => entity_id,'drawerID' => drawer_id,'name' => name,'creatorUserID' => creator_user_id,'modifierUserID' => modifier_user_id,'minInsertionTime' => min_insertion_time,'maxInsertionTime' => max_insertion_time,'minModificationTime' => min_modification_time,'maxModificationTime' => max_modification_time,'page' => page,'pageSize' => page_size,'sortOrder' => sort_order,'sortBy' => sort_by},
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:get, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = {
              client_side_validation: true,
              required: false,
              serialized_name: 'parsed_response',
              type: {
                name: 'Sequence',
                element: {
                    client_side_validation: true,
                    required: false,
                    serialized_name: 'EntityLinkModelElementType',
                    type: {
                      name: 'Composite',
                      class_name: 'EntityLinkModel'
                    }
                }
              }
            }
            result.body = self.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # Gets a link based on its unique identifier.
    #
    # @param drawer [Integer] The drawer identifier.
    # @param id [Integer] The link identifier.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [EntityLinkModel] operation results.
    #
    def get_link_by_id(drawer, id, custom_headers:nil)
      response = get_link_by_id_async(drawer, id, custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # Gets a link based on its unique identifier.
    #
    # @param drawer [Integer] The drawer identifier.
    # @param id [Integer] The link identifier.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def get_link_by_id_with_http_info(drawer, id, custom_headers:nil)
      get_link_by_id_async(drawer, id, custom_headers:custom_headers).value!
    end

    #
    # Gets a link based on its unique identifier.
    #
    # @param drawer [Integer] The drawer identifier.
    # @param id [Integer] The link identifier.
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def get_link_by_id_async(drawer, id, custom_headers:nil)
      fail ArgumentError, 'drawer is nil' if drawer.nil?
      fail ArgumentError, 'id is nil' if id.nil?


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'
      path_template = 'v1/content/links/{drawer}/{id}'

      request_url = @base_url || self.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          path_params: {'drawer' => drawer,'id' => id},
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:get, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200 || status_code == 403 || status_code == 404
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = Softheon.Enterprise.Api.Client::Models::EntityLinkModel.mapper()
            result.body = self.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # Updates a specified link.
    #
    # @param drawer [Integer] The drawer identifier.
    # @param id [Integer] The link identifier.
    # @param model [UpdateEntityLinkRequestModel] The model.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [Object] operation results.
    #
    def update_link(drawer, id, model, custom_headers:nil)
      response = update_link_async(drawer, id, model, custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # Updates a specified link.
    #
    # @param drawer [Integer] The drawer identifier.
    # @param id [Integer] The link identifier.
    # @param model [UpdateEntityLinkRequestModel] The model.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def update_link_with_http_info(drawer, id, model, custom_headers:nil)
      update_link_async(drawer, id, model, custom_headers:custom_headers).value!
    end

    #
    # Updates a specified link.
    #
    # @param drawer [Integer] The drawer identifier.
    # @param id [Integer] The link identifier.
    # @param model [UpdateEntityLinkRequestModel] The model.
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def update_link_async(drawer, id, model, custom_headers:nil)
      fail ArgumentError, 'drawer is nil' if drawer.nil?
      fail ArgumentError, 'id is nil' if id.nil?
      fail ArgumentError, 'model is nil' if model.nil?


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'

      # Serialize Request
      request_mapper = Softheon.Enterprise.Api.Client::Models::UpdateEntityLinkRequestModel.mapper()
      request_content = self.serialize(request_mapper,  model)
      request_content = request_content != nil ? JSON.generate(request_content, quirks_mode: true) : nil

      path_template = 'v1/content/links/{drawer}/{id}'

      request_url = @base_url || self.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          path_params: {'drawer' => drawer,'id' => id},
          body: request_content,
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:put, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 204 || status_code == 403 || status_code == 404
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end


        result
      end

      promise.execute
    end

    #
    # Deletes a specified link.
    #
    # @param drawer [Integer] The drawer identifier.
    # @param id [Integer] The link identifier.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [Object] operation results.
    #
    def delete_link(drawer, id, custom_headers:nil)
      response = delete_link_async(drawer, id, custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # Deletes a specified link.
    #
    # @param drawer [Integer] The drawer identifier.
    # @param id [Integer] The link identifier.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def delete_link_with_http_info(drawer, id, custom_headers:nil)
      delete_link_async(drawer, id, custom_headers:custom_headers).value!
    end

    #
    # Deletes a specified link.
    #
    # @param drawer [Integer] The drawer identifier.
    # @param id [Integer] The link identifier.
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def delete_link_async(drawer, id, custom_headers:nil)
      fail ArgumentError, 'drawer is nil' if drawer.nil?
      fail ArgumentError, 'id is nil' if id.nil?


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'
      path_template = 'v1/content/links/{drawer}/{id}'

      request_url = @base_url || self.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          path_params: {'drawer' => drawer,'id' => id},
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:delete, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 204 || status_code == 403 || status_code == 404
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end


        result
      end

      promise.execute
    end

    #
    # Creates a new link.
    #
    # @param drawer [Integer] The drawer identifier.
    # @param model [InsertEntityLinkRequestModel] The link model.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [EntityLinkModel] operation results.
    #
    def create_link(drawer, model, custom_headers:nil)
      response = create_link_async(drawer, model, custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # Creates a new link.
    #
    # @param drawer [Integer] The drawer identifier.
    # @param model [InsertEntityLinkRequestModel] The link model.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def create_link_with_http_info(drawer, model, custom_headers:nil)
      create_link_async(drawer, model, custom_headers:custom_headers).value!
    end

    #
    # Creates a new link.
    #
    # @param drawer [Integer] The drawer identifier.
    # @param model [InsertEntityLinkRequestModel] The link model.
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def create_link_async(drawer, model, custom_headers:nil)
      fail ArgumentError, 'drawer is nil' if drawer.nil?
      fail ArgumentError, 'model is nil' if model.nil?


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'

      # Serialize Request
      request_mapper = Softheon.Enterprise.Api.Client::Models::InsertEntityLinkRequestModel.mapper()
      request_content = self.serialize(request_mapper,  model)
      request_content = request_content != nil ? JSON.generate(request_content, quirks_mode: true) : nil

      path_template = 'v1/content/links/{drawer}'

      request_url = @base_url || self.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          path_params: {'drawer' => drawer},
          body: request_content,
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:post, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 201 || status_code == 403 || status_code == 404 || status_code == 409
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        # Deserialize Response
        if status_code == 201
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = Softheon.Enterprise.Api.Client::Models::EntityLinkModel.mapper()
            result.body = self.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # Gets a lock for a single entity based on its unique identifier.
    #
    # @param drawer [Integer] The drawer identifier.
    # @param id [Integer] The entity identifier.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [LockModel] operation results.
    #
    def get_locks_by_filter(drawer, id, custom_headers:nil)
      response = get_locks_by_filter_async(drawer, id, custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # Gets a lock for a single entity based on its unique identifier.
    #
    # @param drawer [Integer] The drawer identifier.
    # @param id [Integer] The entity identifier.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def get_locks_by_filter_with_http_info(drawer, id, custom_headers:nil)
      get_locks_by_filter_async(drawer, id, custom_headers:custom_headers).value!
    end

    #
    # Gets a lock for a single entity based on its unique identifier.
    #
    # @param drawer [Integer] The drawer identifier.
    # @param id [Integer] The entity identifier.
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def get_locks_by_filter_async(drawer, id, custom_headers:nil)
      fail ArgumentError, 'drawer is nil' if drawer.nil?
      fail ArgumentError, 'id is nil' if id.nil?


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'
      path_template = 'v1/content/entities/{drawer}/{id}/locks'

      request_url = @base_url || self.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          path_params: {'drawer' => drawer,'id' => id},
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:get, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200 || status_code == 404
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = Softheon.Enterprise.Api.Client::Models::LockModel.mapper()
            result.body = self.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # Inserts or updates lock on a specified entity.
    #
    # @param drawer [Integer] The drawer identifier.
    # @param id [Integer] The entity identifier.
    # @param model [UpdateLockRequestModel] The lock model.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [Object] operation results.
    #
    def create_or_update_lock(drawer, id, model, custom_headers:nil)
      response = create_or_update_lock_async(drawer, id, model, custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # Inserts or updates lock on a specified entity.
    #
    # @param drawer [Integer] The drawer identifier.
    # @param id [Integer] The entity identifier.
    # @param model [UpdateLockRequestModel] The lock model.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def create_or_update_lock_with_http_info(drawer, id, model, custom_headers:nil)
      create_or_update_lock_async(drawer, id, model, custom_headers:custom_headers).value!
    end

    #
    # Inserts or updates lock on a specified entity.
    #
    # @param drawer [Integer] The drawer identifier.
    # @param id [Integer] The entity identifier.
    # @param model [UpdateLockRequestModel] The lock model.
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def create_or_update_lock_async(drawer, id, model, custom_headers:nil)
      fail ArgumentError, 'drawer is nil' if drawer.nil?
      fail ArgumentError, 'id is nil' if id.nil?
      fail ArgumentError, 'model is nil' if model.nil?


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'

      # Serialize Request
      request_mapper = Softheon.Enterprise.Api.Client::Models::UpdateLockRequestModel.mapper()
      request_content = self.serialize(request_mapper,  model)
      request_content = request_content != nil ? JSON.generate(request_content, quirks_mode: true) : nil

      path_template = 'v1/content/entities/{drawer}/{id}/locks'

      request_url = @base_url || self.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          path_params: {'drawer' => drawer,'id' => id},
          body: request_content,
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:put, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 201 || status_code == 403 || status_code == 404
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end


        result
      end

      promise.execute
    end

    #
    # Deletes a lock on a specified entity.
    #
    # @param drawer [Integer] The drawer identifier.
    # @param id [Integer] The entity identifier.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [Object] operation results.
    #
    def delete_lock(drawer, id, custom_headers:nil)
      response = delete_lock_async(drawer, id, custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # Deletes a lock on a specified entity.
    #
    # @param drawer [Integer] The drawer identifier.
    # @param id [Integer] The entity identifier.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def delete_lock_with_http_info(drawer, id, custom_headers:nil)
      delete_lock_async(drawer, id, custom_headers:custom_headers).value!
    end

    #
    # Deletes a lock on a specified entity.
    #
    # @param drawer [Integer] The drawer identifier.
    # @param id [Integer] The entity identifier.
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def delete_lock_async(drawer, id, custom_headers:nil)
      fail ArgumentError, 'drawer is nil' if drawer.nil?
      fail ArgumentError, 'id is nil' if id.nil?


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'
      path_template = 'v1/content/entities/{drawer}/{id}/locks'

      request_url = @base_url || self.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          path_params: {'drawer' => drawer,'id' => id},
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:delete, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 204 || status_code == 403 || status_code == 404
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end


        result
      end

      promise.execute
    end

    #
    # Gets a paged list of notes.
    #
    # @param drawer_id [Integer] Gets or sets the drawer identifier.
    # @param entity_id [Integer] Gets or sets the entity identifier.
    # @param name [String] Gets or sets the name.
    # @param creator_user_id [Integer] Gets or sets the creator user identifier.
    # @param modifier_user_id [Integer] Gets or sets the modifier user identifier.
    # @param min_creation_time [DateTime] Gets or sets the minimum creation time.
    # @param max_creation_time [DateTime] Gets or sets the maximum creation time.
    # @param min_modification_time [DateTime] Gets or sets the minimum modification
    # time.
    # @param max_modification_time [DateTime] Gets or sets the maximum modification
    # time.
    # @param parent_id [Integer] Gets or sets the parent note identifier.
    # @param page [Integer] Gets or sets the page number.
    # @param page_size [Integer] Gets or sets the size of the page.
    # @param sort_order [Enum] Gets or sets the order. Possible values include:
    # 'Unspecified', 'Ascending', 'Descending'
    # @param sort_by [Enum] Gets or sets the column to order by. Possible values
    # include: 'ID', 'EntityID', 'Name', 'CreationTime', 'ModificationTime'
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [Array] operation results.
    #
    def get_notes_by_filter(drawer_id, entity_id:nil, name:nil, creator_user_id:nil, modifier_user_id:nil, min_creation_time:nil, max_creation_time:nil, min_modification_time:nil, max_modification_time:nil, parent_id:nil, page:nil, page_size:nil, sort_order:nil, sort_by:nil, custom_headers:nil)
      response = get_notes_by_filter_async(drawer_id, entity_id:entity_id, name:name, creator_user_id:creator_user_id, modifier_user_id:modifier_user_id, min_creation_time:min_creation_time, max_creation_time:max_creation_time, min_modification_time:min_modification_time, max_modification_time:max_modification_time, parent_id:parent_id, page:page, page_size:page_size, sort_order:sort_order, sort_by:sort_by, custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # Gets a paged list of notes.
    #
    # @param drawer_id [Integer] Gets or sets the drawer identifier.
    # @param entity_id [Integer] Gets or sets the entity identifier.
    # @param name [String] Gets or sets the name.
    # @param creator_user_id [Integer] Gets or sets the creator user identifier.
    # @param modifier_user_id [Integer] Gets or sets the modifier user identifier.
    # @param min_creation_time [DateTime] Gets or sets the minimum creation time.
    # @param max_creation_time [DateTime] Gets or sets the maximum creation time.
    # @param min_modification_time [DateTime] Gets or sets the minimum modification
    # time.
    # @param max_modification_time [DateTime] Gets or sets the maximum modification
    # time.
    # @param parent_id [Integer] Gets or sets the parent note identifier.
    # @param page [Integer] Gets or sets the page number.
    # @param page_size [Integer] Gets or sets the size of the page.
    # @param sort_order [Enum] Gets or sets the order. Possible values include:
    # 'Unspecified', 'Ascending', 'Descending'
    # @param sort_by [Enum] Gets or sets the column to order by. Possible values
    # include: 'ID', 'EntityID', 'Name', 'CreationTime', 'ModificationTime'
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def get_notes_by_filter_with_http_info(drawer_id, entity_id:nil, name:nil, creator_user_id:nil, modifier_user_id:nil, min_creation_time:nil, max_creation_time:nil, min_modification_time:nil, max_modification_time:nil, parent_id:nil, page:nil, page_size:nil, sort_order:nil, sort_by:nil, custom_headers:nil)
      get_notes_by_filter_async(drawer_id, entity_id:entity_id, name:name, creator_user_id:creator_user_id, modifier_user_id:modifier_user_id, min_creation_time:min_creation_time, max_creation_time:max_creation_time, min_modification_time:min_modification_time, max_modification_time:max_modification_time, parent_id:parent_id, page:page, page_size:page_size, sort_order:sort_order, sort_by:sort_by, custom_headers:custom_headers).value!
    end

    #
    # Gets a paged list of notes.
    #
    # @param drawer_id [Integer] Gets or sets the drawer identifier.
    # @param entity_id [Integer] Gets or sets the entity identifier.
    # @param name [String] Gets or sets the name.
    # @param creator_user_id [Integer] Gets or sets the creator user identifier.
    # @param modifier_user_id [Integer] Gets or sets the modifier user identifier.
    # @param min_creation_time [DateTime] Gets or sets the minimum creation time.
    # @param max_creation_time [DateTime] Gets or sets the maximum creation time.
    # @param min_modification_time [DateTime] Gets or sets the minimum modification
    # time.
    # @param max_modification_time [DateTime] Gets or sets the maximum modification
    # time.
    # @param parent_id [Integer] Gets or sets the parent note identifier.
    # @param page [Integer] Gets or sets the page number.
    # @param page_size [Integer] Gets or sets the size of the page.
    # @param sort_order [Enum] Gets or sets the order. Possible values include:
    # 'Unspecified', 'Ascending', 'Descending'
    # @param sort_by [Enum] Gets or sets the column to order by. Possible values
    # include: 'ID', 'EntityID', 'Name', 'CreationTime', 'ModificationTime'
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def get_notes_by_filter_async(drawer_id, entity_id:nil, name:nil, creator_user_id:nil, modifier_user_id:nil, min_creation_time:nil, max_creation_time:nil, min_modification_time:nil, max_modification_time:nil, parent_id:nil, page:nil, page_size:nil, sort_order:nil, sort_by:nil, custom_headers:nil)
      fail ArgumentError, 'drawer_id is nil' if drawer_id.nil?
      fail ArgumentError, "'drawer_id' should satisfy the constraint - 'InclusiveMaximum': '2147483647'" if !drawer_id.nil? && drawer_id > 2147483647
      fail ArgumentError, "'drawer_id' should satisfy the constraint - 'InclusiveMinimum': '1'" if !drawer_id.nil? && drawer_id < 1
      fail ArgumentError, "'entity_id' should satisfy the constraint - 'InclusiveMaximum': '2147483647'" if !entity_id.nil? && entity_id > 2147483647
      fail ArgumentError, "'entity_id' should satisfy the constraint - 'InclusiveMinimum': '1'" if !entity_id.nil? && entity_id < 1
      fail ArgumentError, "'name' should satisfy the constraint - 'MaxLength': '255'" if !name.nil? && name.length > 255
      fail ArgumentError, "'name' should satisfy the constraint - 'MinLength': '0'" if !name.nil? && name.length < 0
      fail ArgumentError, "'creator_user_id' should satisfy the constraint - 'InclusiveMaximum': '2147483647'" if !creator_user_id.nil? && creator_user_id > 2147483647
      fail ArgumentError, "'creator_user_id' should satisfy the constraint - 'InclusiveMinimum': '1'" if !creator_user_id.nil? && creator_user_id < 1
      fail ArgumentError, "'modifier_user_id' should satisfy the constraint - 'InclusiveMaximum': '2147483647'" if !modifier_user_id.nil? && modifier_user_id > 2147483647
      fail ArgumentError, "'modifier_user_id' should satisfy the constraint - 'InclusiveMinimum': '1'" if !modifier_user_id.nil? && modifier_user_id < 1
      fail ArgumentError, "'parent_id' should satisfy the constraint - 'InclusiveMaximum': '2147483647'" if !parent_id.nil? && parent_id > 2147483647
      fail ArgumentError, "'parent_id' should satisfy the constraint - 'InclusiveMinimum': '1'" if !parent_id.nil? && parent_id < 1
      fail ArgumentError, "'page' should satisfy the constraint - 'InclusiveMaximum': '2147483647'" if !page.nil? && page > 2147483647
      fail ArgumentError, "'page' should satisfy the constraint - 'InclusiveMinimum': '1'" if !page.nil? && page < 1
      fail ArgumentError, "'page_size' should satisfy the constraint - 'InclusiveMaximum': '1000'" if !page_size.nil? && page_size > 1000
      fail ArgumentError, "'page_size' should satisfy the constraint - 'InclusiveMinimum': '1'" if !page_size.nil? && page_size < 1


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'
      path_template = 'v1/content/notes'

      request_url = @base_url || self.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          query_params: {'drawerID' => drawer_id,'entityID' => entity_id,'name' => name,'creatorUserID' => creator_user_id,'modifierUserID' => modifier_user_id,'minCreationTime' => min_creation_time,'maxCreationTime' => max_creation_time,'minModificationTime' => min_modification_time,'maxModificationTime' => max_modification_time,'parentID' => parent_id,'page' => page,'pageSize' => page_size,'sortOrder' => sort_order,'sortBy' => sort_by},
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:get, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = {
              client_side_validation: true,
              required: false,
              serialized_name: 'parsed_response',
              type: {
                name: 'Sequence',
                element: {
                    client_side_validation: true,
                    required: false,
                    serialized_name: 'NoteModelElementType',
                    type: {
                      name: 'Composite',
                      class_name: 'NoteModel'
                    }
                }
              }
            }
            result.body = self.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # Gets a note by its unique identifier.
    #
    # @param drawer [Integer] The drawer identifier.
    # @param id [Integer] The note identifier.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [NoteModel] operation results.
    #
    def get_note_by_id(drawer, id, custom_headers:nil)
      response = get_note_by_id_async(drawer, id, custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # Gets a note by its unique identifier.
    #
    # @param drawer [Integer] The drawer identifier.
    # @param id [Integer] The note identifier.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def get_note_by_id_with_http_info(drawer, id, custom_headers:nil)
      get_note_by_id_async(drawer, id, custom_headers:custom_headers).value!
    end

    #
    # Gets a note by its unique identifier.
    #
    # @param drawer [Integer] The drawer identifier.
    # @param id [Integer] The note identifier.
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def get_note_by_id_async(drawer, id, custom_headers:nil)
      fail ArgumentError, 'drawer is nil' if drawer.nil?
      fail ArgumentError, 'id is nil' if id.nil?


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'
      path_template = 'v1/content/notes/{drawer}/{id}'

      request_url = @base_url || self.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          path_params: {'drawer' => drawer,'id' => id},
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:get, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200 || status_code == 403 || status_code == 404
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = Softheon.Enterprise.Api.Client::Models::NoteModel.mapper()
            result.body = self.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # Updates a specified note.
    #
    # @param drawer [Integer] The drawer identifier.
    # @param id [Integer] The note identifier.
    # @param model [NoteBase] The note model.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [Object] operation results.
    #
    def update_note(drawer, id, model, custom_headers:nil)
      response = update_note_async(drawer, id, model, custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # Updates a specified note.
    #
    # @param drawer [Integer] The drawer identifier.
    # @param id [Integer] The note identifier.
    # @param model [NoteBase] The note model.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def update_note_with_http_info(drawer, id, model, custom_headers:nil)
      update_note_async(drawer, id, model, custom_headers:custom_headers).value!
    end

    #
    # Updates a specified note.
    #
    # @param drawer [Integer] The drawer identifier.
    # @param id [Integer] The note identifier.
    # @param model [NoteBase] The note model.
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def update_note_async(drawer, id, model, custom_headers:nil)
      fail ArgumentError, 'drawer is nil' if drawer.nil?
      fail ArgumentError, 'id is nil' if id.nil?
      fail ArgumentError, 'model is nil' if model.nil?


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'

      # Serialize Request
      request_mapper = Softheon.Enterprise.Api.Client::Models::NoteBase.mapper()
      request_content = self.serialize(request_mapper,  model)
      request_content = request_content != nil ? JSON.generate(request_content, quirks_mode: true) : nil

      path_template = 'v1/content/notes/{drawer}/{id}'

      request_url = @base_url || self.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          path_params: {'drawer' => drawer,'id' => id},
          body: request_content,
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:put, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 204 || status_code == 403 || status_code == 404
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end


        result
      end

      promise.execute
    end

    #
    # Deletes a specified note.
    #
    # @param drawer [Integer] The drawer identifier.
    # @param id [Integer] The note identifier.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [Object] operation results.
    #
    def delete_note(drawer, id, custom_headers:nil)
      response = delete_note_async(drawer, id, custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # Deletes a specified note.
    #
    # @param drawer [Integer] The drawer identifier.
    # @param id [Integer] The note identifier.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def delete_note_with_http_info(drawer, id, custom_headers:nil)
      delete_note_async(drawer, id, custom_headers:custom_headers).value!
    end

    #
    # Deletes a specified note.
    #
    # @param drawer [Integer] The drawer identifier.
    # @param id [Integer] The note identifier.
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def delete_note_async(drawer, id, custom_headers:nil)
      fail ArgumentError, 'drawer is nil' if drawer.nil?
      fail ArgumentError, 'id is nil' if id.nil?


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'
      path_template = 'v1/content/notes/{drawer}/{id}'

      request_url = @base_url || self.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          path_params: {'drawer' => drawer,'id' => id},
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:delete, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 204 || status_code == 403 || status_code == 404
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end


        result
      end

      promise.execute
    end

    #
    # Creates a new note.
    #
    # @param drawer [Integer] The drawer identifier.
    # @param model [InsertNoteRequestModel] The note model.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [NoteModel] operation results.
    #
    def create_note(drawer, model, custom_headers:nil)
      response = create_note_async(drawer, model, custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # Creates a new note.
    #
    # @param drawer [Integer] The drawer identifier.
    # @param model [InsertNoteRequestModel] The note model.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def create_note_with_http_info(drawer, model, custom_headers:nil)
      create_note_async(drawer, model, custom_headers:custom_headers).value!
    end

    #
    # Creates a new note.
    #
    # @param drawer [Integer] The drawer identifier.
    # @param model [InsertNoteRequestModel] The note model.
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def create_note_async(drawer, model, custom_headers:nil)
      fail ArgumentError, 'drawer is nil' if drawer.nil?
      fail ArgumentError, 'model is nil' if model.nil?


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'

      # Serialize Request
      request_mapper = Softheon.Enterprise.Api.Client::Models::InsertNoteRequestModel.mapper()
      request_content = self.serialize(request_mapper,  model)
      request_content = request_content != nil ? JSON.generate(request_content, quirks_mode: true) : nil

      path_template = 'v1/content/notes/{drawer}'

      request_url = @base_url || self.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          path_params: {'drawer' => drawer},
          body: request_content,
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:post, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 201 || status_code == 403 || status_code == 404
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        # Deserialize Response
        if status_code == 201
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = Softheon.Enterprise.Api.Client::Models::NoteModel.mapper()
            result.body = self.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # Gets a paged list of queue assignments.
    #
    # @param queue_id [Integer] Gets or sets the unique queue identifier.
    # @param user_id [Integer] Gets or sets the user identifier.
    # @param group_id [Integer] Gets or sets the group identifier.
    # @param type [Enum] Gets or sets the queue assignment type. Possible values
    # include: 'Unspecified', 'Primary', 'Secondary'
    # @param order [Integer] Gets or sets the sort order.
    # @param task_sort_column [Enum] Gets or sets the task sort column. Possible
    # values include: 'TaskID', 'QueueID', 'DrawerID', 'AddressID', 'ObjectID',
    # 'ObjectType', 'State', 'Priority', 'Description', 'Message1', 'Message2',
    # 'Message3', 'Message4', 'Message5', 'OwnerUserID', 'OwnerGroupID',
    # 'EffectiveUserID', 'EffectiveGroupID', 'PreviousQueueID', 'NextQueueID',
    # 'InsertionTime', 'ResolutionTime', 'TaskFileAttachment', 'ReservedInt1',
    # 'ReservedString1'
    # @param state [Enum] Gets or sets the state. Possible values include:
    # 'Unspecified', 'Inactive', 'Active'
    # @param fetch_type [Enum] Gets or sets the type of the fetch. Possible values
    # include: 'Unspecified', 'Manual', 'Push'
    # @param page [Integer] Gets or sets the page number.
    # @param page_size [Integer] Gets or sets the size of the page.
    # @param sort_order [Enum] Gets or sets the order. Possible values include:
    # 'Unspecified', 'Ascending', 'Descending'
    # @param sort_by [Enum] Gets or sets the column to order by. Possible values
    # include: 'QueueID', 'UserID', 'GroupID', 'Type', 'State', 'Order',
    # 'FetchType'
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [Array] operation results.
    #
    def get_queue_assignments_by_filter(queue_id:nil, user_id:nil, group_id:nil, type:nil, order:nil, task_sort_column:nil, state:nil, fetch_type:nil, page:nil, page_size:nil, sort_order:nil, sort_by:nil, custom_headers:nil)
      response = get_queue_assignments_by_filter_async(queue_id:queue_id, user_id:user_id, group_id:group_id, type:type, order:order, task_sort_column:task_sort_column, state:state, fetch_type:fetch_type, page:page, page_size:page_size, sort_order:sort_order, sort_by:sort_by, custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # Gets a paged list of queue assignments.
    #
    # @param queue_id [Integer] Gets or sets the unique queue identifier.
    # @param user_id [Integer] Gets or sets the user identifier.
    # @param group_id [Integer] Gets or sets the group identifier.
    # @param type [Enum] Gets or sets the queue assignment type. Possible values
    # include: 'Unspecified', 'Primary', 'Secondary'
    # @param order [Integer] Gets or sets the sort order.
    # @param task_sort_column [Enum] Gets or sets the task sort column. Possible
    # values include: 'TaskID', 'QueueID', 'DrawerID', 'AddressID', 'ObjectID',
    # 'ObjectType', 'State', 'Priority', 'Description', 'Message1', 'Message2',
    # 'Message3', 'Message4', 'Message5', 'OwnerUserID', 'OwnerGroupID',
    # 'EffectiveUserID', 'EffectiveGroupID', 'PreviousQueueID', 'NextQueueID',
    # 'InsertionTime', 'ResolutionTime', 'TaskFileAttachment', 'ReservedInt1',
    # 'ReservedString1'
    # @param state [Enum] Gets or sets the state. Possible values include:
    # 'Unspecified', 'Inactive', 'Active'
    # @param fetch_type [Enum] Gets or sets the type of the fetch. Possible values
    # include: 'Unspecified', 'Manual', 'Push'
    # @param page [Integer] Gets or sets the page number.
    # @param page_size [Integer] Gets or sets the size of the page.
    # @param sort_order [Enum] Gets or sets the order. Possible values include:
    # 'Unspecified', 'Ascending', 'Descending'
    # @param sort_by [Enum] Gets or sets the column to order by. Possible values
    # include: 'QueueID', 'UserID', 'GroupID', 'Type', 'State', 'Order',
    # 'FetchType'
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def get_queue_assignments_by_filter_with_http_info(queue_id:nil, user_id:nil, group_id:nil, type:nil, order:nil, task_sort_column:nil, state:nil, fetch_type:nil, page:nil, page_size:nil, sort_order:nil, sort_by:nil, custom_headers:nil)
      get_queue_assignments_by_filter_async(queue_id:queue_id, user_id:user_id, group_id:group_id, type:type, order:order, task_sort_column:task_sort_column, state:state, fetch_type:fetch_type, page:page, page_size:page_size, sort_order:sort_order, sort_by:sort_by, custom_headers:custom_headers).value!
    end

    #
    # Gets a paged list of queue assignments.
    #
    # @param queue_id [Integer] Gets or sets the unique queue identifier.
    # @param user_id [Integer] Gets or sets the user identifier.
    # @param group_id [Integer] Gets or sets the group identifier.
    # @param type [Enum] Gets or sets the queue assignment type. Possible values
    # include: 'Unspecified', 'Primary', 'Secondary'
    # @param order [Integer] Gets or sets the sort order.
    # @param task_sort_column [Enum] Gets or sets the task sort column. Possible
    # values include: 'TaskID', 'QueueID', 'DrawerID', 'AddressID', 'ObjectID',
    # 'ObjectType', 'State', 'Priority', 'Description', 'Message1', 'Message2',
    # 'Message3', 'Message4', 'Message5', 'OwnerUserID', 'OwnerGroupID',
    # 'EffectiveUserID', 'EffectiveGroupID', 'PreviousQueueID', 'NextQueueID',
    # 'InsertionTime', 'ResolutionTime', 'TaskFileAttachment', 'ReservedInt1',
    # 'ReservedString1'
    # @param state [Enum] Gets or sets the state. Possible values include:
    # 'Unspecified', 'Inactive', 'Active'
    # @param fetch_type [Enum] Gets or sets the type of the fetch. Possible values
    # include: 'Unspecified', 'Manual', 'Push'
    # @param page [Integer] Gets or sets the page number.
    # @param page_size [Integer] Gets or sets the size of the page.
    # @param sort_order [Enum] Gets or sets the order. Possible values include:
    # 'Unspecified', 'Ascending', 'Descending'
    # @param sort_by [Enum] Gets or sets the column to order by. Possible values
    # include: 'QueueID', 'UserID', 'GroupID', 'Type', 'State', 'Order',
    # 'FetchType'
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def get_queue_assignments_by_filter_async(queue_id:nil, user_id:nil, group_id:nil, type:nil, order:nil, task_sort_column:nil, state:nil, fetch_type:nil, page:nil, page_size:nil, sort_order:nil, sort_by:nil, custom_headers:nil)
      fail ArgumentError, "'queue_id' should satisfy the constraint - 'InclusiveMaximum': '2147483647'" if !queue_id.nil? && queue_id > 2147483647
      fail ArgumentError, "'queue_id' should satisfy the constraint - 'InclusiveMinimum': '1'" if !queue_id.nil? && queue_id < 1
      fail ArgumentError, "'user_id' should satisfy the constraint - 'InclusiveMaximum': '2147483647'" if !user_id.nil? && user_id > 2147483647
      fail ArgumentError, "'user_id' should satisfy the constraint - 'InclusiveMinimum': '1'" if !user_id.nil? && user_id < 1
      fail ArgumentError, "'group_id' should satisfy the constraint - 'InclusiveMaximum': '2147483647'" if !group_id.nil? && group_id > 2147483647
      fail ArgumentError, "'group_id' should satisfy the constraint - 'InclusiveMinimum': '1'" if !group_id.nil? && group_id < 1
      fail ArgumentError, "'order' should satisfy the constraint - 'InclusiveMaximum': '2147483647'" if !order.nil? && order > 2147483647
      fail ArgumentError, "'order' should satisfy the constraint - 'InclusiveMinimum': '1'" if !order.nil? && order < 1
      fail ArgumentError, "'page' should satisfy the constraint - 'InclusiveMaximum': '2147483647'" if !page.nil? && page > 2147483647
      fail ArgumentError, "'page' should satisfy the constraint - 'InclusiveMinimum': '1'" if !page.nil? && page < 1
      fail ArgumentError, "'page_size' should satisfy the constraint - 'InclusiveMaximum': '1000'" if !page_size.nil? && page_size > 1000
      fail ArgumentError, "'page_size' should satisfy the constraint - 'InclusiveMinimum': '1'" if !page_size.nil? && page_size < 1


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'
      path_template = 'v1/workflow/assignments'

      request_url = @base_url || self.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          query_params: {'queueID' => queue_id,'userID' => user_id,'groupID' => group_id,'type' => type,'order' => order,'taskSortColumn' => task_sort_column,'state' => state,'fetchType' => fetch_type,'page' => page,'pageSize' => page_size,'sortOrder' => sort_order,'sortBy' => sort_by},
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:get, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200 || status_code == 403
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = {
              client_side_validation: true,
              required: false,
              serialized_name: 'parsed_response',
              type: {
                name: 'Sequence',
                element: {
                    client_side_validation: true,
                    required: false,
                    serialized_name: 'QueueAssignmentModelElementType',
                    type: {
                      name: 'Composite',
                      class_name: 'QueueAssignmentModel'
                    }
                }
              }
            }
            result.body = self.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # Updates the specified queue assignment.
    #
    # @param model [QueueAssignmentModel] The model.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [Object] operation results.
    #
    def update_queue_assignemnt(model, custom_headers:nil)
      response = update_queue_assignemnt_async(model, custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # Updates the specified queue assignment.
    #
    # @param model [QueueAssignmentModel] The model.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def update_queue_assignemnt_with_http_info(model, custom_headers:nil)
      update_queue_assignemnt_async(model, custom_headers:custom_headers).value!
    end

    #
    # Updates the specified queue assignment.
    #
    # @param model [QueueAssignmentModel] The model.
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def update_queue_assignemnt_async(model, custom_headers:nil)
      fail ArgumentError, 'model is nil' if model.nil?


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'

      # Serialize Request
      request_mapper = Softheon.Enterprise.Api.Client::Models::QueueAssignmentModel.mapper()
      request_content = self.serialize(request_mapper,  model)
      request_content = request_content != nil ? JSON.generate(request_content, quirks_mode: true) : nil

      path_template = 'v1/workflow/assignments'

      request_url = @base_url || self.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          body: request_content,
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:put, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 204 || status_code == 403 || status_code == 404
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end


        result
      end

      promise.execute
    end

    #
    # Creates a new queue assignment.
    #
    # @param model [InsertQueueAssignmentRequestModel] The model.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [QueueAssignmentModel] operation results.
    #
    def create_queue_assignment(model, custom_headers:nil)
      response = create_queue_assignment_async(model, custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # Creates a new queue assignment.
    #
    # @param model [InsertQueueAssignmentRequestModel] The model.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def create_queue_assignment_with_http_info(model, custom_headers:nil)
      create_queue_assignment_async(model, custom_headers:custom_headers).value!
    end

    #
    # Creates a new queue assignment.
    #
    # @param model [InsertQueueAssignmentRequestModel] The model.
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def create_queue_assignment_async(model, custom_headers:nil)
      fail ArgumentError, 'model is nil' if model.nil?


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'

      # Serialize Request
      request_mapper = Softheon.Enterprise.Api.Client::Models::InsertQueueAssignmentRequestModel.mapper()
      request_content = self.serialize(request_mapper,  model)
      request_content = request_content != nil ? JSON.generate(request_content, quirks_mode: true) : nil

      path_template = 'v1/workflow/assignments'

      request_url = @base_url || self.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          body: request_content,
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:post, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 201 || status_code == 403 || status_code == 404 || status_code == 409
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        # Deserialize Response
        if status_code == 201
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = Softheon.Enterprise.Api.Client::Models::QueueAssignmentModel.mapper()
            result.body = self.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # Gets a single queue assignment based on user and queue identifiers.
    #
    # @param user_id [Integer] The user identifier.
    # @param queue_id [Integer] The queue identifier.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [QueueAssignmentModel] operation results.
    #
    def get_queue_assignments_by_id(user_id, queue_id, custom_headers:nil)
      response = get_queue_assignments_by_id_async(user_id, queue_id, custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # Gets a single queue assignment based on user and queue identifiers.
    #
    # @param user_id [Integer] The user identifier.
    # @param queue_id [Integer] The queue identifier.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def get_queue_assignments_by_id_with_http_info(user_id, queue_id, custom_headers:nil)
      get_queue_assignments_by_id_async(user_id, queue_id, custom_headers:custom_headers).value!
    end

    #
    # Gets a single queue assignment based on user and queue identifiers.
    #
    # @param user_id [Integer] The user identifier.
    # @param queue_id [Integer] The queue identifier.
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def get_queue_assignments_by_id_async(user_id, queue_id, custom_headers:nil)
      fail ArgumentError, 'user_id is nil' if user_id.nil?
      fail ArgumentError, 'queue_id is nil' if queue_id.nil?


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'
      path_template = 'v1/workflow/assignments/users/{userId}/queues/{queueId}'

      request_url = @base_url || self.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          path_params: {'userId' => user_id,'queueId' => queue_id},
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:get, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200 || status_code == 403 || status_code == 404
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = Softheon.Enterprise.Api.Client::Models::QueueAssignmentModel.mapper()
            result.body = self.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # Deletes the specified queue assignment.
    #
    # @param user_id [Integer] The user identifier.
    # @param queue_id [Integer] The queue identifier.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [Object] operation results.
    #
    def delete_queue_assignment(user_id, queue_id, custom_headers:nil)
      response = delete_queue_assignment_async(user_id, queue_id, custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # Deletes the specified queue assignment.
    #
    # @param user_id [Integer] The user identifier.
    # @param queue_id [Integer] The queue identifier.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def delete_queue_assignment_with_http_info(user_id, queue_id, custom_headers:nil)
      delete_queue_assignment_async(user_id, queue_id, custom_headers:custom_headers).value!
    end

    #
    # Deletes the specified queue assignment.
    #
    # @param user_id [Integer] The user identifier.
    # @param queue_id [Integer] The queue identifier.
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def delete_queue_assignment_async(user_id, queue_id, custom_headers:nil)
      fail ArgumentError, 'user_id is nil' if user_id.nil?
      fail ArgumentError, 'queue_id is nil' if queue_id.nil?


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'
      path_template = 'v1/workflow/assignments/users/{userId}/queues/{queueId}'

      request_url = @base_url || self.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          path_params: {'userId' => user_id,'queueId' => queue_id},
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:delete, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 204 || status_code == 403 || status_code == 404
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end


        result
      end

      promise.execute
    end

    #
    # Gets a paged list of queues.
    #
    # @param i_d [Integer] Gets or sets the queue identifier.
    # @param name [String] Gets or sets the name.
    # @param alias_parameter [String] Gets or sets the alias.
    # @param type [Enum] Gets or sets the type. Possible values include: 'Inbound',
    # 'Outbound', 'Access', 'Any', 'Shared', 'Public', 'Recycle', 'Fax', 'Print',
    # 'Scan', 'Ocr', 'Workflow', 'Schedule', 'System', 'Other', 'CdoInfostore',
    # 'CdoFolder'
    # @param access [Integer] Gets or sets the access level.
    # @param bypass_security [Boolean] Gets or sets a value indicating whether to
    # bypass security checks.
    # @param page [Integer] Gets or sets the page number.
    # @param page_size [Integer] Gets or sets the size of the page.
    # @param sort_order [Enum] Gets or sets the order. Possible values include:
    # 'Unspecified', 'Ascending', 'Descending'
    # @param sort_by [Enum] Gets or sets the column to order by. Possible values
    # include: 'ID', 'Type', 'Name', 'Alias'
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [Array] operation results.
    #
    def get_queues_by_filter(i_d:nil, name:nil, alias_parameter:nil, type:nil, access:nil, bypass_security:nil, page:nil, page_size:nil, sort_order:nil, sort_by:nil, custom_headers:nil)
      response = get_queues_by_filter_async(i_d:i_d, name:name, alias_parameter:alias_parameter, type:type, access:access, bypass_security:bypass_security, page:page, page_size:page_size, sort_order:sort_order, sort_by:sort_by, custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # Gets a paged list of queues.
    #
    # @param i_d [Integer] Gets or sets the queue identifier.
    # @param name [String] Gets or sets the name.
    # @param alias_parameter [String] Gets or sets the alias.
    # @param type [Enum] Gets or sets the type. Possible values include: 'Inbound',
    # 'Outbound', 'Access', 'Any', 'Shared', 'Public', 'Recycle', 'Fax', 'Print',
    # 'Scan', 'Ocr', 'Workflow', 'Schedule', 'System', 'Other', 'CdoInfostore',
    # 'CdoFolder'
    # @param access [Integer] Gets or sets the access level.
    # @param bypass_security [Boolean] Gets or sets a value indicating whether to
    # bypass security checks.
    # @param page [Integer] Gets or sets the page number.
    # @param page_size [Integer] Gets or sets the size of the page.
    # @param sort_order [Enum] Gets or sets the order. Possible values include:
    # 'Unspecified', 'Ascending', 'Descending'
    # @param sort_by [Enum] Gets or sets the column to order by. Possible values
    # include: 'ID', 'Type', 'Name', 'Alias'
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def get_queues_by_filter_with_http_info(i_d:nil, name:nil, alias_parameter:nil, type:nil, access:nil, bypass_security:nil, page:nil, page_size:nil, sort_order:nil, sort_by:nil, custom_headers:nil)
      get_queues_by_filter_async(i_d:i_d, name:name, alias_parameter:alias_parameter, type:type, access:access, bypass_security:bypass_security, page:page, page_size:page_size, sort_order:sort_order, sort_by:sort_by, custom_headers:custom_headers).value!
    end

    #
    # Gets a paged list of queues.
    #
    # @param i_d [Integer] Gets or sets the queue identifier.
    # @param name [String] Gets or sets the name.
    # @param alias_parameter [String] Gets or sets the alias.
    # @param type [Enum] Gets or sets the type. Possible values include: 'Inbound',
    # 'Outbound', 'Access', 'Any', 'Shared', 'Public', 'Recycle', 'Fax', 'Print',
    # 'Scan', 'Ocr', 'Workflow', 'Schedule', 'System', 'Other', 'CdoInfostore',
    # 'CdoFolder'
    # @param access [Integer] Gets or sets the access level.
    # @param bypass_security [Boolean] Gets or sets a value indicating whether to
    # bypass security checks.
    # @param page [Integer] Gets or sets the page number.
    # @param page_size [Integer] Gets or sets the size of the page.
    # @param sort_order [Enum] Gets or sets the order. Possible values include:
    # 'Unspecified', 'Ascending', 'Descending'
    # @param sort_by [Enum] Gets or sets the column to order by. Possible values
    # include: 'ID', 'Type', 'Name', 'Alias'
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def get_queues_by_filter_async(i_d:nil, name:nil, alias_parameter:nil, type:nil, access:nil, bypass_security:nil, page:nil, page_size:nil, sort_order:nil, sort_by:nil, custom_headers:nil)
      fail ArgumentError, "'i_d' should satisfy the constraint - 'InclusiveMaximum': '2147483647'" if !i_d.nil? && i_d > 2147483647
      fail ArgumentError, "'i_d' should satisfy the constraint - 'InclusiveMinimum': '1'" if !i_d.nil? && i_d < 1
      fail ArgumentError, "'name' should satisfy the constraint - 'MaxLength': '255'" if !name.nil? && name.length > 255
      fail ArgumentError, "'name' should satisfy the constraint - 'MinLength': '0'" if !name.nil? && name.length < 0
      fail ArgumentError, "'alias_parameter' should satisfy the constraint - 'MaxLength': '255'" if !alias_parameter.nil? && alias_parameter.length > 255
      fail ArgumentError, "'alias_parameter' should satisfy the constraint - 'MinLength': '0'" if !alias_parameter.nil? && alias_parameter.length < 0
      fail ArgumentError, "'page' should satisfy the constraint - 'InclusiveMaximum': '2147483647'" if !page.nil? && page > 2147483647
      fail ArgumentError, "'page' should satisfy the constraint - 'InclusiveMinimum': '1'" if !page.nil? && page < 1
      fail ArgumentError, "'page_size' should satisfy the constraint - 'InclusiveMaximum': '1000'" if !page_size.nil? && page_size > 1000
      fail ArgumentError, "'page_size' should satisfy the constraint - 'InclusiveMinimum': '1'" if !page_size.nil? && page_size < 1


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'
      path_template = 'v1/workflow/queues'

      request_url = @base_url || self.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          query_params: {'iD' => i_d,'name' => name,'alias' => alias_parameter,'type' => type,'access' => access,'bypassSecurity' => bypass_security,'page' => page,'pageSize' => page_size,'sortOrder' => sort_order,'sortBy' => sort_by},
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:get, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = {
              client_side_validation: true,
              required: false,
              serialized_name: 'parsed_response',
              type: {
                name: 'Sequence',
                element: {
                    client_side_validation: true,
                    required: false,
                    serialized_name: 'QueueModelElementType',
                    type: {
                      name: 'Composite',
                      class_name: 'QueueModel'
                    }
                }
              }
            }
            result.body = self.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # Creates a new queue.
    #
    # @param model [InsertQueueRequestModel] The queue model.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [QueueModel] operation results.
    #
    def create_queue(model, custom_headers:nil)
      response = create_queue_async(model, custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # Creates a new queue.
    #
    # @param model [InsertQueueRequestModel] The queue model.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def create_queue_with_http_info(model, custom_headers:nil)
      create_queue_async(model, custom_headers:custom_headers).value!
    end

    #
    # Creates a new queue.
    #
    # @param model [InsertQueueRequestModel] The queue model.
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def create_queue_async(model, custom_headers:nil)
      fail ArgumentError, 'model is nil' if model.nil?


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'

      # Serialize Request
      request_mapper = Softheon.Enterprise.Api.Client::Models::InsertQueueRequestModel.mapper()
      request_content = self.serialize(request_mapper,  model)
      request_content = request_content != nil ? JSON.generate(request_content, quirks_mode: true) : nil

      path_template = 'v1/workflow/queues'

      request_url = @base_url || self.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          body: request_content,
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:post, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 201 || status_code == 403
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        # Deserialize Response
        if status_code == 201
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = Softheon.Enterprise.Api.Client::Models::QueueModel.mapper()
            result.body = self.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # Gets a single queue by its unique identifier.
    #
    # @param id [Integer] The queue identifier.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [QueueModel] operation results.
    #
    def get_queue_by_id(id, custom_headers:nil)
      response = get_queue_by_id_async(id, custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # Gets a single queue by its unique identifier.
    #
    # @param id [Integer] The queue identifier.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def get_queue_by_id_with_http_info(id, custom_headers:nil)
      get_queue_by_id_async(id, custom_headers:custom_headers).value!
    end

    #
    # Gets a single queue by its unique identifier.
    #
    # @param id [Integer] The queue identifier.
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def get_queue_by_id_async(id, custom_headers:nil)
      fail ArgumentError, 'id is nil' if id.nil?


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'
      path_template = 'v1/workflow/queues/{id}'

      request_url = @base_url || self.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          path_params: {'id' => id},
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:get, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200 || status_code == 404
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = Softheon.Enterprise.Api.Client::Models::QueueModel.mapper()
            result.body = self.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # Updates a specified queue.
    #
    # @param id [Integer] The unique queue identifier.
    # @param model [QueueBase] The queue model.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [Object] operation results.
    #
    def update_queue(id, model, custom_headers:nil)
      response = update_queue_async(id, model, custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # Updates a specified queue.
    #
    # @param id [Integer] The unique queue identifier.
    # @param model [QueueBase] The queue model.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def update_queue_with_http_info(id, model, custom_headers:nil)
      update_queue_async(id, model, custom_headers:custom_headers).value!
    end

    #
    # Updates a specified queue.
    #
    # @param id [Integer] The unique queue identifier.
    # @param model [QueueBase] The queue model.
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def update_queue_async(id, model, custom_headers:nil)
      fail ArgumentError, 'id is nil' if id.nil?
      fail ArgumentError, 'model is nil' if model.nil?


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'

      # Serialize Request
      request_mapper = Softheon.Enterprise.Api.Client::Models::QueueBase.mapper()
      request_content = self.serialize(request_mapper,  model)
      request_content = request_content != nil ? JSON.generate(request_content, quirks_mode: true) : nil

      path_template = 'v1/workflow/queues/{id}'

      request_url = @base_url || self.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          path_params: {'id' => id},
          body: request_content,
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:put, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200 || status_code == 403 || status_code == 404
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end


        result
      end

      promise.execute
    end

    #
    # Deletes a specified queue.
    #
    # @param id [Integer] The queue identifier.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [Object] operation results.
    #
    def delete_queue(id, custom_headers:nil)
      response = delete_queue_async(id, custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # Deletes a specified queue.
    #
    # @param id [Integer] The queue identifier.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def delete_queue_with_http_info(id, custom_headers:nil)
      delete_queue_async(id, custom_headers:custom_headers).value!
    end

    #
    # Deletes a specified queue.
    #
    # @param id [Integer] The queue identifier.
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def delete_queue_async(id, custom_headers:nil)
      fail ArgumentError, 'id is nil' if id.nil?


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'
      path_template = 'v1/workflow/queues/{id}'

      request_url = @base_url || self.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          path_params: {'id' => id},
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:delete, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 204 || status_code == 403 || status_code == 404
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end


        result
      end

      promise.execute
    end

    #
    # Gets a single queue by its name.
    #
    # @param name [String] The queue name.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [QueueModel] operation results.
    #
    def get_queue_by_name(name, custom_headers:nil)
      response = get_queue_by_name_async(name, custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # Gets a single queue by its name.
    #
    # @param name [String] The queue name.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def get_queue_by_name_with_http_info(name, custom_headers:nil)
      get_queue_by_name_async(name, custom_headers:custom_headers).value!
    end

    #
    # Gets a single queue by its name.
    #
    # @param name [String] The queue name.
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def get_queue_by_name_async(name, custom_headers:nil)
      fail ArgumentError, 'name is nil' if name.nil?


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'
      path_template = 'v1/workflow/queues/{name}'

      request_url = @base_url || self.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          path_params: {'name' => name},
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:get, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200 || status_code == 404
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = Softheon.Enterprise.Api.Client::Models::QueueModel.mapper()
            result.body = self.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # Gets a paged list of tasks.
    #
    # @param last_task_id [Integer] Gets or sets the last task identifier.
    # @param i_d [Integer] Gets or sets the entity identifier.
    # @param type [Integer] Gets or sets the type of the entity.
    # @param queue_id [Integer] Gets or sets the queue identifier.
    # @param queue_type [Integer] Gets or sets the type of the queue.
    # @param drawer_id [Integer] Gets or sets the drawer identifier.
    # @param description [String] Gets or sets the task description.
    # @param task_id [Integer] Gets or sets the task identifier.
    # @param page [Integer] Gets or sets the page number.
    # @param page_size [Integer] Gets or sets the size of the page.
    # @param sort_order [Enum] Gets or sets the order. Possible values include:
    # 'Unspecified', 'Ascending', 'Descending'
    # @param sort_by [Enum] Gets or sets the column to order by. Possible values
    # include: 'TaskID', 'QueueID', 'ObjectID', 'Priority', 'Description',
    # 'InsertionTime', 'ResolutionTime', 'ReservedInt1'
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [Array] operation results.
    #
    def get_tasks_by_filter(last_task_id:nil, i_d:nil, type:nil, queue_id:nil, queue_type:nil, drawer_id:nil, description:nil, task_id:nil, page:nil, page_size:nil, sort_order:nil, sort_by:nil, custom_headers:nil)
      response = get_tasks_by_filter_async(last_task_id:last_task_id, i_d:i_d, type:type, queue_id:queue_id, queue_type:queue_type, drawer_id:drawer_id, description:description, task_id:task_id, page:page, page_size:page_size, sort_order:sort_order, sort_by:sort_by, custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # Gets a paged list of tasks.
    #
    # @param last_task_id [Integer] Gets or sets the last task identifier.
    # @param i_d [Integer] Gets or sets the entity identifier.
    # @param type [Integer] Gets or sets the type of the entity.
    # @param queue_id [Integer] Gets or sets the queue identifier.
    # @param queue_type [Integer] Gets or sets the type of the queue.
    # @param drawer_id [Integer] Gets or sets the drawer identifier.
    # @param description [String] Gets or sets the task description.
    # @param task_id [Integer] Gets or sets the task identifier.
    # @param page [Integer] Gets or sets the page number.
    # @param page_size [Integer] Gets or sets the size of the page.
    # @param sort_order [Enum] Gets or sets the order. Possible values include:
    # 'Unspecified', 'Ascending', 'Descending'
    # @param sort_by [Enum] Gets or sets the column to order by. Possible values
    # include: 'TaskID', 'QueueID', 'ObjectID', 'Priority', 'Description',
    # 'InsertionTime', 'ResolutionTime', 'ReservedInt1'
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def get_tasks_by_filter_with_http_info(last_task_id:nil, i_d:nil, type:nil, queue_id:nil, queue_type:nil, drawer_id:nil, description:nil, task_id:nil, page:nil, page_size:nil, sort_order:nil, sort_by:nil, custom_headers:nil)
      get_tasks_by_filter_async(last_task_id:last_task_id, i_d:i_d, type:type, queue_id:queue_id, queue_type:queue_type, drawer_id:drawer_id, description:description, task_id:task_id, page:page, page_size:page_size, sort_order:sort_order, sort_by:sort_by, custom_headers:custom_headers).value!
    end

    #
    # Gets a paged list of tasks.
    #
    # @param last_task_id [Integer] Gets or sets the last task identifier.
    # @param i_d [Integer] Gets or sets the entity identifier.
    # @param type [Integer] Gets or sets the type of the entity.
    # @param queue_id [Integer] Gets or sets the queue identifier.
    # @param queue_type [Integer] Gets or sets the type of the queue.
    # @param drawer_id [Integer] Gets or sets the drawer identifier.
    # @param description [String] Gets or sets the task description.
    # @param task_id [Integer] Gets or sets the task identifier.
    # @param page [Integer] Gets or sets the page number.
    # @param page_size [Integer] Gets or sets the size of the page.
    # @param sort_order [Enum] Gets or sets the order. Possible values include:
    # 'Unspecified', 'Ascending', 'Descending'
    # @param sort_by [Enum] Gets or sets the column to order by. Possible values
    # include: 'TaskID', 'QueueID', 'ObjectID', 'Priority', 'Description',
    # 'InsertionTime', 'ResolutionTime', 'ReservedInt1'
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def get_tasks_by_filter_async(last_task_id:nil, i_d:nil, type:nil, queue_id:nil, queue_type:nil, drawer_id:nil, description:nil, task_id:nil, page:nil, page_size:nil, sort_order:nil, sort_by:nil, custom_headers:nil)
      fail ArgumentError, "'last_task_id' should satisfy the constraint - 'InclusiveMaximum': '2147483647'" if !last_task_id.nil? && last_task_id > 2147483647
      fail ArgumentError, "'last_task_id' should satisfy the constraint - 'InclusiveMinimum': '0'" if !last_task_id.nil? && last_task_id < 0
      fail ArgumentError, "'i_d' should satisfy the constraint - 'InclusiveMaximum': '2147483647'" if !i_d.nil? && i_d > 2147483647
      fail ArgumentError, "'i_d' should satisfy the constraint - 'InclusiveMinimum': '1'" if !i_d.nil? && i_d < 1
      fail ArgumentError, "'queue_type' should satisfy the constraint - 'InclusiveMaximum': '2147483647'" if !queue_type.nil? && queue_type > 2147483647
      fail ArgumentError, "'queue_type' should satisfy the constraint - 'InclusiveMinimum': '1'" if !queue_type.nil? && queue_type < 1
      fail ArgumentError, "'drawer_id' should satisfy the constraint - 'InclusiveMaximum': '2147483647'" if !drawer_id.nil? && drawer_id > 2147483647
      fail ArgumentError, "'drawer_id' should satisfy the constraint - 'InclusiveMinimum': '1'" if !drawer_id.nil? && drawer_id < 1
      fail ArgumentError, "'description' should satisfy the constraint - 'MaxLength': '255'" if !description.nil? && description.length > 255
      fail ArgumentError, "'description' should satisfy the constraint - 'MinLength': '0'" if !description.nil? && description.length < 0
      fail ArgumentError, "'page' should satisfy the constraint - 'InclusiveMaximum': '2147483647'" if !page.nil? && page > 2147483647
      fail ArgumentError, "'page' should satisfy the constraint - 'InclusiveMinimum': '1'" if !page.nil? && page < 1
      fail ArgumentError, "'page_size' should satisfy the constraint - 'InclusiveMaximum': '1000'" if !page_size.nil? && page_size > 1000
      fail ArgumentError, "'page_size' should satisfy the constraint - 'InclusiveMinimum': '1'" if !page_size.nil? && page_size < 1


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'
      path_template = 'v1/workflow/tasks'

      request_url = @base_url || self.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          query_params: {'lastTaskID' => last_task_id,'iD' => i_d,'type' => type,'queueID' => queue_id,'queueType' => queue_type,'drawerID' => drawer_id,'description' => description,'taskID' => task_id,'page' => page,'pageSize' => page_size,'sortOrder' => sort_order,'sortBy' => sort_by},
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:get, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = {
              client_side_validation: true,
              required: false,
              serialized_name: 'parsed_response',
              type: {
                name: 'Sequence',
                element: {
                    client_side_validation: true,
                    required: false,
                    serialized_name: 'TaskModelElementType',
                    type: {
                      name: 'Composite',
                      class_name: 'TaskModel'
                    }
                }
              }
            }
            result.body = self.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # Creates a new task.
    #
    # @param model [InsertTaskRequestModel] The task model.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [Object] operation results.
    #
    def create_task(model, custom_headers:nil)
      response = create_task_async(model, custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # Creates a new task.
    #
    # @param model [InsertTaskRequestModel] The task model.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def create_task_with_http_info(model, custom_headers:nil)
      create_task_async(model, custom_headers:custom_headers).value!
    end

    #
    # Creates a new task.
    #
    # @param model [InsertTaskRequestModel] The task model.
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def create_task_async(model, custom_headers:nil)
      fail ArgumentError, 'model is nil' if model.nil?


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'

      # Serialize Request
      request_mapper = Softheon.Enterprise.Api.Client::Models::InsertTaskRequestModel.mapper()
      request_content = self.serialize(request_mapper,  model)
      request_content = request_content != nil ? JSON.generate(request_content, quirks_mode: true) : nil

      path_template = 'v1/workflow/tasks'

      request_url = @base_url || self.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          body: request_content,
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:post, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 201 || status_code == 403 || status_code == 404 || status_code == 409
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end


        result
      end

      promise.execute
    end

    #
    # Gets a single task based on its unique identifier.
    #
    # @param id [Integer] The identifier.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [TaskModel] operation results.
    #
    def get_task_by_id(id, custom_headers:nil)
      response = get_task_by_id_async(id, custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # Gets a single task based on its unique identifier.
    #
    # @param id [Integer] The identifier.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def get_task_by_id_with_http_info(id, custom_headers:nil)
      get_task_by_id_async(id, custom_headers:custom_headers).value!
    end

    #
    # Gets a single task based on its unique identifier.
    #
    # @param id [Integer] The identifier.
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def get_task_by_id_async(id, custom_headers:nil)
      fail ArgumentError, 'id is nil' if id.nil?


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'
      path_template = 'v1/workflow/tasks/{id}'

      request_url = @base_url || self.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          path_params: {'id' => id},
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:get, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200 || status_code == 404
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = Softheon.Enterprise.Api.Client::Models::TaskModel.mapper()
            result.body = self.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # Updates a specified task.
    #
    # @param id [Integer] The identifier.
    # @param model [TaskBase] The task model.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [Object] operation results.
    #
    def update_task(id, model, custom_headers:nil)
      response = update_task_async(id, model, custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # Updates a specified task.
    #
    # @param id [Integer] The identifier.
    # @param model [TaskBase] The task model.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def update_task_with_http_info(id, model, custom_headers:nil)
      update_task_async(id, model, custom_headers:custom_headers).value!
    end

    #
    # Updates a specified task.
    #
    # @param id [Integer] The identifier.
    # @param model [TaskBase] The task model.
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def update_task_async(id, model, custom_headers:nil)
      fail ArgumentError, 'id is nil' if id.nil?
      fail ArgumentError, 'model is nil' if model.nil?


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'

      # Serialize Request
      request_mapper = Softheon.Enterprise.Api.Client::Models::TaskBase.mapper()
      request_content = self.serialize(request_mapper,  model)
      request_content = request_content != nil ? JSON.generate(request_content, quirks_mode: true) : nil

      path_template = 'v1/workflow/tasks/{id}'

      request_url = @base_url || self.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          path_params: {'id' => id},
          body: request_content,
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:put, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 204 || status_code == 403 || status_code == 404
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end


        result
      end

      promise.execute
    end

    #
    # Deletes a specified task.
    #
    # @param id [Integer] The identifier.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [Object] operation results.
    #
    def delete_task(id, custom_headers:nil)
      response = delete_task_async(id, custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # Deletes a specified task.
    #
    # @param id [Integer] The identifier.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def delete_task_with_http_info(id, custom_headers:nil)
      delete_task_async(id, custom_headers:custom_headers).value!
    end

    #
    # Deletes a specified task.
    #
    # @param id [Integer] The identifier.
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def delete_task_async(id, custom_headers:nil)
      fail ArgumentError, 'id is nil' if id.nil?


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'
      path_template = 'v1/workflow/tasks/{id}'

      request_url = @base_url || self.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          path_params: {'id' => id},
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:delete, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 204 || status_code == 403 || status_code == 404
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end


        result
      end

      promise.execute
    end

    #
    # Gets a single task based on user predefined queue assignment criteria.
    #
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [TaskModel] operation results.
    #
    def fetch_task_from_queue_assignment(custom_headers:nil)
      response = fetch_task_from_queue_assignment_async(custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # Gets a single task based on user predefined queue assignment criteria.
    #
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def fetch_task_from_queue_assignment_with_http_info(custom_headers:nil)
      fetch_task_from_queue_assignment_async(custom_headers:custom_headers).value!
    end

    #
    # Gets a single task based on user predefined queue assignment criteria.
    #
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def fetch_task_from_queue_assignment_async(custom_headers:nil)


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'
      path_template = 'v1/workflow/tasks/fetch'

      request_url = @base_url || self.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:get, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200 || status_code == 404
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = Softheon.Enterprise.Api.Client::Models::TaskModel.mapper()
            result.body = self.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # Gets a paged list of users.Gets a paged list of users.
    #
    # @param i_d [Integer] Gets or sets the identifier.
    # @param primary_group_id [Integer] Gets or sets the primary group identifier.
    # @param group_id [Integer] Gets or sets the group identifier.
    # @param group_name [String] Gets or sets the name of the group.
    # @param username [String] Gets or sets the username.
    # @param type [Enum] Gets or sets the type. Possible values include:
    # 'ImageDesk', 'PublishDesk', 'FaxDesk', 'CaptureDesk', 'RecognitionDesk',
    # 'PortalUser', 'AdminDesk', 'WorkflowDesk', 'Benchmark', 'ReportDesk',
    # 'ColdDesk', 'PortalDesk', 'WorkflowArchitect', 'DocumentDesk', 'Poweruser'
    # @param state [Enum] Gets or sets the state. Possible values include:
    # 'Active', 'Inactive'
    # @param full_name [String] Gets or sets the full name.
    # @param page [Integer] Gets or sets the page number.
    # @param page_size [Integer] Gets or sets the size of the page.
    # @param sort_order [Enum] Gets or sets the order. Possible values include:
    # 'Unspecified', 'Ascending', 'Descending'
    # @param sort_by [Enum] Gets or sets the column to order by. Possible values
    # include: 'ID', 'PrimaryGroupID', 'Username', 'UserFullName', 'Type', 'State'
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [Array] operation results.
    #
    def get_users_by_filter(i_d:nil, primary_group_id:nil, group_id:nil, group_name:nil, username:nil, type:nil, state:nil, full_name:nil, page:nil, page_size:nil, sort_order:nil, sort_by:nil, custom_headers:nil)
      response = get_users_by_filter_async(i_d:i_d, primary_group_id:primary_group_id, group_id:group_id, group_name:group_name, username:username, type:type, state:state, full_name:full_name, page:page, page_size:page_size, sort_order:sort_order, sort_by:sort_by, custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # Gets a paged list of users.Gets a paged list of users.
    #
    # @param i_d [Integer] Gets or sets the identifier.
    # @param primary_group_id [Integer] Gets or sets the primary group identifier.
    # @param group_id [Integer] Gets or sets the group identifier.
    # @param group_name [String] Gets or sets the name of the group.
    # @param username [String] Gets or sets the username.
    # @param type [Enum] Gets or sets the type. Possible values include:
    # 'ImageDesk', 'PublishDesk', 'FaxDesk', 'CaptureDesk', 'RecognitionDesk',
    # 'PortalUser', 'AdminDesk', 'WorkflowDesk', 'Benchmark', 'ReportDesk',
    # 'ColdDesk', 'PortalDesk', 'WorkflowArchitect', 'DocumentDesk', 'Poweruser'
    # @param state [Enum] Gets or sets the state. Possible values include:
    # 'Active', 'Inactive'
    # @param full_name [String] Gets or sets the full name.
    # @param page [Integer] Gets or sets the page number.
    # @param page_size [Integer] Gets or sets the size of the page.
    # @param sort_order [Enum] Gets or sets the order. Possible values include:
    # 'Unspecified', 'Ascending', 'Descending'
    # @param sort_by [Enum] Gets or sets the column to order by. Possible values
    # include: 'ID', 'PrimaryGroupID', 'Username', 'UserFullName', 'Type', 'State'
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def get_users_by_filter_with_http_info(i_d:nil, primary_group_id:nil, group_id:nil, group_name:nil, username:nil, type:nil, state:nil, full_name:nil, page:nil, page_size:nil, sort_order:nil, sort_by:nil, custom_headers:nil)
      get_users_by_filter_async(i_d:i_d, primary_group_id:primary_group_id, group_id:group_id, group_name:group_name, username:username, type:type, state:state, full_name:full_name, page:page, page_size:page_size, sort_order:sort_order, sort_by:sort_by, custom_headers:custom_headers).value!
    end

    #
    # Gets a paged list of users.Gets a paged list of users.
    #
    # @param i_d [Integer] Gets or sets the identifier.
    # @param primary_group_id [Integer] Gets or sets the primary group identifier.
    # @param group_id [Integer] Gets or sets the group identifier.
    # @param group_name [String] Gets or sets the name of the group.
    # @param username [String] Gets or sets the username.
    # @param type [Enum] Gets or sets the type. Possible values include:
    # 'ImageDesk', 'PublishDesk', 'FaxDesk', 'CaptureDesk', 'RecognitionDesk',
    # 'PortalUser', 'AdminDesk', 'WorkflowDesk', 'Benchmark', 'ReportDesk',
    # 'ColdDesk', 'PortalDesk', 'WorkflowArchitect', 'DocumentDesk', 'Poweruser'
    # @param state [Enum] Gets or sets the state. Possible values include:
    # 'Active', 'Inactive'
    # @param full_name [String] Gets or sets the full name.
    # @param page [Integer] Gets or sets the page number.
    # @param page_size [Integer] Gets or sets the size of the page.
    # @param sort_order [Enum] Gets or sets the order. Possible values include:
    # 'Unspecified', 'Ascending', 'Descending'
    # @param sort_by [Enum] Gets or sets the column to order by. Possible values
    # include: 'ID', 'PrimaryGroupID', 'Username', 'UserFullName', 'Type', 'State'
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def get_users_by_filter_async(i_d:nil, primary_group_id:nil, group_id:nil, group_name:nil, username:nil, type:nil, state:nil, full_name:nil, page:nil, page_size:nil, sort_order:nil, sort_by:nil, custom_headers:nil)
      fail ArgumentError, "'page' should satisfy the constraint - 'InclusiveMaximum': '2147483647'" if !page.nil? && page > 2147483647
      fail ArgumentError, "'page' should satisfy the constraint - 'InclusiveMinimum': '1'" if !page.nil? && page < 1
      fail ArgumentError, "'page_size' should satisfy the constraint - 'InclusiveMaximum': '1000'" if !page_size.nil? && page_size > 1000
      fail ArgumentError, "'page_size' should satisfy the constraint - 'InclusiveMinimum': '1'" if !page_size.nil? && page_size < 1


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'
      path_template = 'v1/directory/users'

      request_url = @base_url || self.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          query_params: {'iD' => i_d,'primaryGroupID' => primary_group_id,'groupID' => group_id,'groupName' => group_name,'username' => username,'type' => type,'state' => state,'fullName' => full_name,'page' => page,'pageSize' => page_size,'sortOrder' => sort_order,'sortBy' => sort_by},
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:get, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200 || status_code == 403
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = {
              client_side_validation: true,
              required: false,
              serialized_name: 'parsed_response',
              type: {
                name: 'Sequence',
                element: {
                    client_side_validation: true,
                    required: false,
                    serialized_name: 'UserModelElementType',
                    type: {
                      name: 'Composite',
                      class_name: 'UserModel'
                    }
                }
              }
            }
            result.body = self.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # Creates a new user.
    #
    # @param model [InsertUserRequestModel] The user model.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [UserModel] operation results.
    #
    def create_user(model, custom_headers:nil)
      response = create_user_async(model, custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # Creates a new user.
    #
    # @param model [InsertUserRequestModel] The user model.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def create_user_with_http_info(model, custom_headers:nil)
      create_user_async(model, custom_headers:custom_headers).value!
    end

    #
    # Creates a new user.
    #
    # @param model [InsertUserRequestModel] The user model.
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def create_user_async(model, custom_headers:nil)
      fail ArgumentError, 'model is nil' if model.nil?


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'

      # Serialize Request
      request_mapper = Softheon.Enterprise.Api.Client::Models::InsertUserRequestModel.mapper()
      request_content = self.serialize(request_mapper,  model)
      request_content = request_content != nil ? JSON.generate(request_content, quirks_mode: true) : nil

      path_template = 'v1/directory/users'

      request_url = @base_url || self.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          body: request_content,
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:post, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 201 || status_code == 403 || status_code == 409
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        # Deserialize Response
        if status_code == 201
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = Softheon.Enterprise.Api.Client::Models::UserModel.mapper()
            result.body = self.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # Gets a single user by its unique identifier.
    #
    # @param id [Integer] The user identifier.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [UserModel] operation results.
    #
    def get_user_by_id(id, custom_headers:nil)
      response = get_user_by_id_async(id, custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # Gets a single user by its unique identifier.
    #
    # @param id [Integer] The user identifier.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def get_user_by_id_with_http_info(id, custom_headers:nil)
      get_user_by_id_async(id, custom_headers:custom_headers).value!
    end

    #
    # Gets a single user by its unique identifier.
    #
    # @param id [Integer] The user identifier.
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def get_user_by_id_async(id, custom_headers:nil)
      fail ArgumentError, 'id is nil' if id.nil?


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'
      path_template = 'v1/directory/users/{id}'

      request_url = @base_url || self.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          path_params: {'id' => id},
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:get, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200 || status_code == 403 || status_code == 404
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = Softheon.Enterprise.Api.Client::Models::UserModel.mapper()
            result.body = self.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # Updates a specified user.
    #
    # @param id [Integer] The user identifier.
    # @param model [UserBase] The user model.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [Object] operation results.
    #
    def update_user(id, model, custom_headers:nil)
      response = update_user_async(id, model, custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # Updates a specified user.
    #
    # @param id [Integer] The user identifier.
    # @param model [UserBase] The user model.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def update_user_with_http_info(id, model, custom_headers:nil)
      update_user_async(id, model, custom_headers:custom_headers).value!
    end

    #
    # Updates a specified user.
    #
    # @param id [Integer] The user identifier.
    # @param model [UserBase] The user model.
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def update_user_async(id, model, custom_headers:nil)
      fail ArgumentError, 'id is nil' if id.nil?
      fail ArgumentError, 'model is nil' if model.nil?


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'

      # Serialize Request
      request_mapper = Softheon.Enterprise.Api.Client::Models::UserBase.mapper()
      request_content = self.serialize(request_mapper,  model)
      request_content = request_content != nil ? JSON.generate(request_content, quirks_mode: true) : nil

      path_template = 'v1/directory/users/{id}'

      request_url = @base_url || self.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          path_params: {'id' => id},
          body: request_content,
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:put, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 204 || status_code == 403 || status_code == 404
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end


        result
      end

      promise.execute
    end

    #
    # Deactivates a specified user and removes all user associations.
    #
    # @param id [Integer] The user identifier.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [Object] operation results.
    #
    def delete_user(id, custom_headers:nil)
      response = delete_user_async(id, custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # Deactivates a specified user and removes all user associations.
    #
    # @param id [Integer] The user identifier.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def delete_user_with_http_info(id, custom_headers:nil)
      delete_user_async(id, custom_headers:custom_headers).value!
    end

    #
    # Deactivates a specified user and removes all user associations.
    #
    # @param id [Integer] The user identifier.
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def delete_user_async(id, custom_headers:nil)
      fail ArgumentError, 'id is nil' if id.nil?


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'
      path_template = 'v1/directory/users/{id}'

      request_url = @base_url || self.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          path_params: {'id' => id},
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:delete, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 204 || status_code == 403 || status_code == 404
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end


        result
      end

      promise.execute
    end

    #
    # Gets a paged list of workflows.
    #
    # @param application_id [Integer] Gets or sets the application identifier.
    # @param entity_type [Integer] Gets or sets the type of the entity.
    # @param name [String] Gets or sets the name.
    # @param page [Integer] Gets or sets the page number.
    # @param page_size [Integer] Gets or sets the size of the page.
    # @param sort_order [Enum] Gets or sets the order. Possible values include:
    # 'Unspecified', 'Ascending', 'Descending'
    # @param sort_by [Integer] Gets or sets the column to order by.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [Array] operation results.
    #
    def get_workflows_by_filter(application_id:nil, entity_type:nil, name:nil, page:nil, page_size:nil, sort_order:nil, sort_by:nil, custom_headers:nil)
      response = get_workflows_by_filter_async(application_id:application_id, entity_type:entity_type, name:name, page:page, page_size:page_size, sort_order:sort_order, sort_by:sort_by, custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # Gets a paged list of workflows.
    #
    # @param application_id [Integer] Gets or sets the application identifier.
    # @param entity_type [Integer] Gets or sets the type of the entity.
    # @param name [String] Gets or sets the name.
    # @param page [Integer] Gets or sets the page number.
    # @param page_size [Integer] Gets or sets the size of the page.
    # @param sort_order [Enum] Gets or sets the order. Possible values include:
    # 'Unspecified', 'Ascending', 'Descending'
    # @param sort_by [Integer] Gets or sets the column to order by.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def get_workflows_by_filter_with_http_info(application_id:nil, entity_type:nil, name:nil, page:nil, page_size:nil, sort_order:nil, sort_by:nil, custom_headers:nil)
      get_workflows_by_filter_async(application_id:application_id, entity_type:entity_type, name:name, page:page, page_size:page_size, sort_order:sort_order, sort_by:sort_by, custom_headers:custom_headers).value!
    end

    #
    # Gets a paged list of workflows.
    #
    # @param application_id [Integer] Gets or sets the application identifier.
    # @param entity_type [Integer] Gets or sets the type of the entity.
    # @param name [String] Gets or sets the name.
    # @param page [Integer] Gets or sets the page number.
    # @param page_size [Integer] Gets or sets the size of the page.
    # @param sort_order [Enum] Gets or sets the order. Possible values include:
    # 'Unspecified', 'Ascending', 'Descending'
    # @param sort_by [Integer] Gets or sets the column to order by.
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def get_workflows_by_filter_async(application_id:nil, entity_type:nil, name:nil, page:nil, page_size:nil, sort_order:nil, sort_by:nil, custom_headers:nil)
      fail ArgumentError, "'application_id' should satisfy the constraint - 'InclusiveMaximum': '2147483647'" if !application_id.nil? && application_id > 2147483647
      fail ArgumentError, "'application_id' should satisfy the constraint - 'InclusiveMinimum': '1'" if !application_id.nil? && application_id < 1
      fail ArgumentError, "'entity_type' should satisfy the constraint - 'InclusiveMaximum': '2147483647'" if !entity_type.nil? && entity_type > 2147483647
      fail ArgumentError, "'entity_type' should satisfy the constraint - 'InclusiveMinimum': '1'" if !entity_type.nil? && entity_type < 1
      fail ArgumentError, "'name' should satisfy the constraint - 'MaxLength': '255'" if !name.nil? && name.length > 255
      fail ArgumentError, "'name' should satisfy the constraint - 'MinLength': '0'" if !name.nil? && name.length < 0
      fail ArgumentError, "'page' should satisfy the constraint - 'InclusiveMaximum': '2147483647'" if !page.nil? && page > 2147483647
      fail ArgumentError, "'page' should satisfy the constraint - 'InclusiveMinimum': '1'" if !page.nil? && page < 1
      fail ArgumentError, "'page_size' should satisfy the constraint - 'InclusiveMaximum': '1000'" if !page_size.nil? && page_size > 1000
      fail ArgumentError, "'page_size' should satisfy the constraint - 'InclusiveMinimum': '1'" if !page_size.nil? && page_size < 1


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'
      path_template = 'v1/workflow/workflows'

      request_url = @base_url || self.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          query_params: {'applicationID' => application_id,'entityType' => entity_type,'name' => name,'page' => page,'pageSize' => page_size,'sortOrder' => sort_order,'sortBy' => sort_by},
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:get, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = {
              client_side_validation: true,
              required: false,
              serialized_name: 'parsed_response',
              type: {
                name: 'Sequence',
                element: {
                    client_side_validation: true,
                    required: false,
                    serialized_name: 'WorkflowModelElementType',
                    type: {
                      name: 'Composite',
                      class_name: 'WorkflowModel'
                    }
                }
              }
            }
            result.body = self.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # Gets a single workflow based on its unique identifier.
    #
    # @param id [Integer] The workflow identifier.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [WorkflowModel] operation results.
    #
    def get_workflow_by_id(id, custom_headers:nil)
      response = get_workflow_by_id_async(id, custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # Gets a single workflow based on its unique identifier.
    #
    # @param id [Integer] The workflow identifier.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def get_workflow_by_id_with_http_info(id, custom_headers:nil)
      get_workflow_by_id_async(id, custom_headers:custom_headers).value!
    end

    #
    # Gets a single workflow based on its unique identifier.
    #
    # @param id [Integer] The workflow identifier.
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def get_workflow_by_id_async(id, custom_headers:nil)
      fail ArgumentError, 'id is nil' if id.nil?


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'
      path_template = 'v1/workflow/workflows/{id}'

      request_url = @base_url || self.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          path_params: {'id' => id},
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:get, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200 || status_code == 404
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = Softheon.Enterprise.Api.Client::Models::WorkflowModel.mapper()
            result.body = self.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # Gets queues for a specific workflow.
    #
    # @param id [Integer] The workflow identifier.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [Array] operation results.
    #
    def get_workflow_queues_by_id(id, custom_headers:nil)
      response = get_workflow_queues_by_id_async(id, custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # Gets queues for a specific workflow.
    #
    # @param id [Integer] The workflow identifier.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def get_workflow_queues_by_id_with_http_info(id, custom_headers:nil)
      get_workflow_queues_by_id_async(id, custom_headers:custom_headers).value!
    end

    #
    # Gets queues for a specific workflow.
    #
    # @param id [Integer] The workflow identifier.
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def get_workflow_queues_by_id_async(id, custom_headers:nil)
      fail ArgumentError, 'id is nil' if id.nil?


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'
      path_template = 'v1/workflow/workflows/{id}/queue'

      request_url = @base_url || self.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          path_params: {'id' => id},
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:get, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200 || status_code == 404
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = {
              client_side_validation: true,
              required: false,
              serialized_name: 'parsed_response',
              type: {
                name: 'Sequence',
                element: {
                    client_side_validation: true,
                    required: false,
                    serialized_name: 'WorkflowQueueModelElementType',
                    type: {
                      name: 'Composite',
                      class_name: 'WorkflowQueueModel'
                    }
                }
              }
            }
            result.body = self.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # Gets a single entity template definition completed with all profiles
    # definitions as XML entity definition.
    #
    # @param type [Integer] The unique template type.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [String] operation results.
    #
    def get_xmltemplate_by_type(type, custom_headers:nil)
      response = get_xmltemplate_by_type_async(type, custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # Gets a single entity template definition completed with all profiles
    # definitions as XML entity definition.
    #
    # @param type [Integer] The unique template type.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def get_xmltemplate_by_type_with_http_info(type, custom_headers:nil)
      get_xmltemplate_by_type_async(type, custom_headers:custom_headers).value!
    end

    #
    # Gets a single entity template definition completed with all profiles
    # definitions as XML entity definition.
    #
    # @param type [Integer] The unique template type.
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def get_xmltemplate_by_type_async(type, custom_headers:nil)
      fail ArgumentError, 'type is nil' if type.nil?


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'
      path_template = 'v1/template/xml/{type}'

      request_url = @base_url || self.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          path_params: {'type' => type},
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:get, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200 || status_code == 404
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = {
              client_side_validation: true,
              required: false,
              serialized_name: 'parsed_response',
              type: {
                name: 'String'
              }
            }
            result.body = self.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # Creates a new entity template definition.
    #
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [String] operation results.
    #
    def create_xmltemplate(custom_headers:nil)
      response = create_xmltemplate_async(custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # Creates a new entity template definition.
    #
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def create_xmltemplate_with_http_info(custom_headers:nil)
      create_xmltemplate_async(custom_headers:custom_headers).value!
    end

    #
    # Creates a new entity template definition.
    #
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def create_xmltemplate_async(custom_headers:nil)


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'
      path_template = 'v1/template/xml'

      request_url = @base_url || self.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:post, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 201 || status_code == 409 || status_code == 400 || status_code == 403
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        # Deserialize Response
        if status_code == 201
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = {
              client_side_validation: true,
              required: false,
              serialized_name: 'parsed_response',
              type: {
                name: 'String'
              }
            }
            result.body = self.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end


    private
    #
    # Adds telemetry information.
    #
    def add_telemetry
        sdk_information = 'Softheon.Enterprise.Api.Client'
        add_user_agent_information(sdk_information)
    end
  end
end
